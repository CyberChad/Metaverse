# Settings
watch 0
warnings --off
epmem --off
smem --set database memory
smem --set learning on
smem --set initial-variable-id 999000
chunk only
chunk bottom-only off
chunk add-osk off
chunk lhs-repair on
chunk rhs-repair on
chunk allow-local-negations on
chunk add-ltm-links off
chunk max-chunks 1000
chunk max-dupes 3
soar max-elaborations 500
soar max-goal-depth 100
soar wait-snc off

# Procedural Memory

sp {evaluate-operator*elaborate*state*look-ahead-operator*merge*copy
    :default
    (state <s> ^name evaluate-operator ^id-mapping <im> ^superstate <s*1>)
    (<s*1> ^operator <so>)
    (<so> ^name evaluate-operator ^superoperator <o>)
    (<o> ^name merge ^assigner <assigner> ^receiver <receiver>)
    (<im> ^<receiver> <ri> ^<assigner> <ni>)
    -->
    (<s> ^look-ahead-operator <copy-o> + ^untried-tied-operator <copy-o> +)
    (<copy-o> ^name merge + ^receiver <ri> + ^assigner <ni> +)
}

sp {selection*elaborate*comprehend
    :default
    (state <s> ^choices multiple ^superstate <ss>)
    (<ss> ^name comprehension)
    -->
    (<s> ^problem-space <p*1> +)
    (<p*1> ^use-selection-space true +)
}

sp {selection*elaborate*name
    :default
    (state <s> ^choices multiple ^problem-space <p*1>)
    (<p*1> ^use-selection-space true)
    -->
    (<s> ^name selection +)
}

sp {evaluate-operator*elaborate*symbolic-evaluation*from-subgoal
    :default
    (state <ss> ^superstate <s>
          ^{ << required-success success partial-success indifferent partial-failure failure prohibit-failure >> <svalue> } <eb>)
    (<s> ^operator <so> ^evaluation <e>)
    (<so> ^name evaluate-operator ^evaluation <e> ^evaluation <e*1>)
    (<e*1> ^desired <eb>)
    -->
    (<e> ^symbolic-value <svalue> +)
}

sp {evaluate-operator*elaborate*symbolic-evaluation*from-subgoal*depth-exceeded*duplicate-desired
    :default
    (state <ss> ^depth-exceeded <eb> ^superstate <s>)
    (<eb> ^duplicate-of <des>)
    (<s> ^operator <so> ^evaluation <e>)
    (<so> ^name evaluate-operator ^evaluation <e*1> ^evaluation <e>)
    (<e*1> ^desired <des>)
    -->
    (<e> ^symbolic-value depth-exceeded +)
}

sp {evaluate-operator*elaborate*symbolic-evaluation*from-subgoal*depth-exceeded
    :default
    (state <ss> ^depth-exceeded <eb> ^superstate <s>)
    (<s> ^operator <so> ^evaluation <e>)
    (<so> ^name evaluate-operator ^evaluation <e*1> ^evaluation <e>)
    (<e*1> ^desired <eb>)
    -->
    (<e> ^symbolic-value depth-exceeded +)
}

sp {selection*elaborate*evaluate-operator*remaining-operators*current-evaluation-depth
    :default
    (state <s> ^name selection ^operator <o> ^evaluation <e>
          ^remaining-operators <ro> ^current-evaluation-depth <ced>)
    (<o> ^name evaluate-operator ^evaluation <e>)
    -->
    (<e> ^remaining-operators <ro> + ^current-evaluation-depth <ced> +)
}

sp {selection*apply*evaluate-operator*depth
    :default
    (state <s> ^operator <o> + ^current-evaluation-depth <ced>
          ^superstate <s*1>)
    (<o> ^name evaluate-operator ^superoperator <i>)
   -{ (state <s> ^evaluation <e>)
      (<e> ^current-evaluation-depth <ced> ^superoperator <i> ^value true)}
    (<s*1> ^problem-space <p*1>)
    (<p*1> ^learning <l*1>)
    (<l*1> ^type exploration)
    -->
    (<o> ^current-evaluation-depth <ced> +)
}

sp {selection*propose*evaluate-operator
    :default
    (state <s> ^name selection ^item <i>)
   -{ (state <s> ^evaluation <e>)
      (<e> ^superoperator <i> ^value true)}
    -->
    (<s> ^operator <o> +)
    (<o> ^name evaluate-operator + ^superoperator <i> +)
}

sp {selection*select*failure-evaluation-becomes-reject-preference
    :default
    (state <s> ^name selection ^quiescence t ^evaluation <e1> ^superstate <ss>)
    (<e1> ^symbolic-value { << lose failure >> <s*1> } ^superoperator <o1>
          ^desired <e>)
    (<ss> ^desired <e>)
    -->
    (<ss> ^operator <o1> < ^operator <o1> = -1.000000)
}

sp {evaluate-operator*failure
    :default
    (state <s> ^quiescence t ^impasse no-change ^attribute state
          ^superstate <ss>)
    (<ss> ^name evaluate-operator ^desired <d>)
    -->
    (<ss> ^exhaustion-failure <d> + ^failure <d> +)
}

sp {evaluate-operator*elaborate*return*current-waypoint
    :default
    (state <s> ^name evaluate-operator ^tried-tied-operator <t*1>
          ^current-waypoint <wp> ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^evaluation <e>)
    (<e> -^current-waypoint <c*1>)
    -->
    (<e> ^current-waypoint <wp> +)
}

sp {evaluate-operator*elaborate*return*visited
    :default
    :o-support
    (state <s> ^name evaluate-operator ^tried-tied-operator <t*1>
          ^current-waypoint <wp> ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^evaluation <e>)
    -->
    (<s> ^visited <wp> +)
}

sp {selection*apply*state*evaluation*path-current
    :default
    (state <s> ^name selection ^operator <o> ^path-cost <pc>
          ^current-waypoint <wp>)
    (<o> ^name evaluate-operator ^evaluation <e>)
   -{ (<e> ^path-cost <p*1> ^current-waypoint <c*1>)}
    -->
    (<e> ^path-cost <pc> + ^current-waypoint <wp> +)
}

sp {selection*apply*state*evaluation
    :default
    (state <s> ^name selection ^operator <o>)
    (<o> ^name evaluate-operator ^superoperator <ob>)
   -{ (<s> ^evaluation <e*1>)
      (<e*1> ^superoperator <ob>)}
    -->
    (<s> ^evaluation <e> +)
    (<e> ^superoperator <ob> +)
}

sp {apply*compute-best-total-estimate*pass-back-super
    :default
    (state <s> ^operator <op> ^evaluation <e> ^superstate <s*1>)
    (<op> ^name compute-best-total-estimate)
    (<e> ^total-estimated-cost <tes> ^superoperator <so>)
   -{ (<s> ^evaluation <e*1>)
      (<e*1> ^total-estimated-cost { < <tes> <t*1> })}
    (<s*1> ^superstate <s*2>)
    (<s*2> ^operator <o*1>)
    (<o*1> ^evaluation <se>)
    (<se> ^estimated-cost { < <tes> <sec> })
    -->
    (<se> ^estimated-cost <sec> - ^estimated-cost <tes> +
           ^updated-estimate true +)
}

sp {apply*compute-best-total-estimate*remove-old
    :default
    (state <s> ^operator <op> ^best-total-estimate <bte> ^evaluation <e>)
    (<op> ^name compute-best-total-estimate)
    (<e> ^total-estimated-cost { <> <bte> <tes> })
   -{ (<s> ^evaluation <e*1>)
      (<e*1> ^total-estimated-cost { < <tes> <t*1> })}
    -->
    (<s> ^best-total-estimate <bte> -)
}

sp {apply*compute-best-total-estimate
    :default
    (state <s> ^operator <op> ^evaluation <e>)
    (<op> ^name compute-best-total-estimate)
    (<e> ^total-estimated-cost <tes>)
   -{ (<s> ^evaluation <e*1>)
      (<e*1> ^total-estimated-cost { < <tes> <t*1> })}
    -->
    (<s> ^best-total-estimate <tes> +)
}

sp {selection*propose*compute-best-total-estimate2
    :default
    (state <s> ^name selection -^not-all-operators-total-estimated-cost true
          ^best-total-estimate <bte> ^superstate <s*1>)
   -{ (<s> ^evaluation <e*2>)
      (<e*2> ^total-estimated-cost { <= <bte> <t*1> })}
    (<s*1> ^superstate <s*2>)
    (<s*2> ^operator <o*1>)
    (<o*1> ^evaluation <e*1>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name compute-best-total-estimate +)
}

sp {selection*propose*compute-best-total-estimate
    :default
    (state <s> ^name selection -^best-total-estimate <bte>
          -^not-all-operators-total-estimated-cost true ^superstate <s*1>)
   -{ (<s> ^problem-space <p*1>)
      (<p*1> ^learning <l*1>)
      (<l*1> ^type exploration)}
    (<s*1> ^superstate <s*2>)
    (<s*2> ^operator <o*1>)
    (<o*1> ^evaluation <e*1>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name compute-best-total-estimate +)
}

sp {Impasse__Operator_Tie*compare*selection*equal*estimated-cost
    :default
    (state <s> ^name selection ^operator <op2> +
          ^operator { <> <op2> <op1> } +)
    (<op2> ^name evaluate-operator ^evaluation <e*2>)
    (<op1> ^name evaluate-operator ^evaluation <e*1>)
    (<e*2> ^total-estimated-cost <ec>)
    (<e*1> ^total-estimated-cost <ec>)
    -->
    (<s> ^operator <op1> = <op2>)
}

sp {Impasse__Operator_Tie*compare*selection*prefer*lower*estimated-cost
    :default
    (state <s> ^name selection ^operator <op2> + ^operator <op1> +
          ^evaluation <e2> ^evaluation <e1>)
    (<op2> ^name evaluate-operator ^superoperator <sop2>)
    (<op1> ^name evaluate-operator ^superoperator <sop1>)
    (<e2> ^superoperator <sop2> ^total-estimated-cost <t*1>)
    (<e1> ^superoperator <sop1> ^total-estimated-cost { < <t*1> <ec> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {Impasse__Operator_Tie*compare*selection*prefer*no*estimated-cost
    :default
    (state <s> ^name selection ^operator <op2> + ^operator <op1> +
          ^evaluation <e2>)
    (<op2> ^name evaluate-operator ^superoperator <sop2>)
    (<op1> ^name evaluate-operator ^superoperator <sop>)
   -{ (<s> ^evaluation <e>)
      (<e> ^superoperator <sop> ^path-cost <p*1> ^estimated-cost <e*1>)}
    (<e2> ^superoperator <sop2> ^estimated-cost <e*2>)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {selection*elaborate*superstate*preferences*indifferent*better*final-cost
    :default
    (state <s> ^name selection ^evaluation <e2> ^evaluation { <> <e2> <e1> }
          ^superstate <ss>)
    (<e2> ^symbolic-value indifferent ^superoperator <so2>)
    (<e1> ^final-cost <fc> ^superoperator <so1>)
    -->
    (<ss> ^operator <so1> > <so2>)
}

sp {selection*elaborate*superstate*preferences*final-cost*equal
    :default
    (state <s> ^name selection ^evaluation <e2> ^evaluation { <> <e2> <e1> }
          ^superstate <ss>)
    (<e2> ^final-cost <fc> ^superoperator <so2>)
    (<e1> ^final-cost <fc> ^superoperator <so1>)
    -->
    (<ss> ^operator <so1> = <so2>)
}

sp {selection*elaborate*evaluation*final-cost
    :default
    (state <s> ^name selection ^evaluation <e>)
    (<e> ^estimated-cost 0 ^path-cost <pc>)
    -->
    (<e> ^final-cost <pc> + ^value true +)
}

sp {selection*elaborate*evaluation*total-estimated-cost
    :default
    (state <s> ^name selection ^evaluation <e>)
    (<e> ^path-cost <pc> ^estimated-cost { <> 0 <ec> })
    -->
    (<e> ^total-estimated-cost (+ <ec> <pc>) +)
}

sp {selection*elaborate*evaluation*estimated-cost
    :default
    (state <s> ^name selection ^evaluation <e> -^current-waypoint <cur-wp>
          ^desired-waypoint <des-wp>)
    (<e> -^updated-estimate true ^current-waypoint <cur-wp>)
    (<des-wp> ^y <dy> ^x <dx>)
    (<cur-wp> ^y <cy> ^x <cx>)
    -->
    (<e> ^estimated-cost (compute-range <cx> <cy> <dx> <dy>) +)
}

sp {selection*elaborate*state*all-objects-total-estimated-cost
    :default
    (state <s> ^name selection ^operator <o> +)
   -{ (<o> ^evaluation <e*1>)
      (<e*1> ^total-estimated-cost <t*1>)}
    (<o> ^name evaluate-operator)
    -->
    (<s> ^not-all-operators-total-estimated-cost true +)
}

sp {evaluate-operator*elaborate*visited*current-location
    :default
    (state <s> ^name selection ^operator <op> ^current-waypoint <wp>)
    (<op> ^name evaluate-operator ^evaluation <e>)
    -->
    (<e> ^visited <wp> +)
}

sp {evaluate-operator*elaborate*forward*visited
    :default
    (state <s> ^name selection ^operator <op> ^superstate <s*1>)
    (<op> ^name evaluate-operator ^evaluation <e>)
    (<s*1> ^superstate <s*2>)
    (<s*2> ^operator <o*1>)
    (<o*1> ^evaluation <e*1>)
    (<e*1> ^visited <ewp>)
    -->
    (<e> ^visited <ewp> +)
}

sp {elaborate*state*top-state
    :default
    (state <s> ^superstate <s*1> -^name evaluate-operator)
    (<s*1> ^top-state <ts>)
    -->
    (<s> ^top-state <ts> +)
}

sp {default*select*reject*conflict
    "Reject an object if it leads to a conflict that can not be resolved."
    :default
    (state <s3> ^quiescence t ^choices none ^attribute state ^superstate <s2>)
    (<s2> ^quiescence t ^impasse conflict ^attribute operator ^item <o>
          ^superstate <s1>)
    (<s1> ^operator <o> +)
    -->
    (<s1> ^operator <o> -)
}

sp {default*select*indifferent-and-worst*tied
    "Indifferent an object if it leads to a tie that can not be resolved."
    :default
    (state <s3> ^quiescence t ^choices none ^attribute state ^superstate <s2>)
    (<s2> ^quiescence t ^superstate <s1> ^item <o>)
    (<s1> -^ntype heuristic ^operator <o> +)
    -->
    (<s1> ^operator <o> = ^operator <o> <)
}

sp {default*top-goal*halt*operator*failure
    "Halt if no operator can be selected for the top goal."
    :default
    (state <ss> ^impasse constraint-failure ^superstate <s>)
    (<s> ^superstate nil)
    -->
    (interrupt)
}

sp {top-ps*propose*wait
    "Propose wait if there is a state no-change."
    :default
    (state <s> ^quiescence t ^choices none ^attribute state)
   -{ (<s> ^operator <o*1>)
      (<o*1> ^name wait)}
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name wait +)
}

sp {evaluate-operator*elaborate*state*remove*untried-tied-operator2
    :default
    (state <s> ^untried-tied-operator <o> ^look-ahead-operator <o>
          ^operator <o>)
   -{ (<s> ^problem-space <p*1>)
      (<p*1> ^name action)}
    -->
    (<s> ^untried-tied-operator <o> -)
}

sp {evaluate-operator*elaborate*state*tried-tied-operator
    :default
    (state <s> ^look-ahead-operator <o> ^operator <o>)
   -{ (<s> ^problem-space <p*1>)
      (<p*1> ^name action)}
    -->
    (<s> ^tried-tied-operator <o> +)
}

sp {evaluate-operator*elaborate*state*remove*untried-tied-operator
    :default
    (state <s> ^untried-tied-operator <o> ^look-ahead-operator <o>
          ^operator <o> ^problem-space <p*1>)
    (<p*1> ^name action)
    -->
    (<s> ^untried-tied-operator <o> -)
}

sp {evaluate-operator*elaborate*state*tried-tied-operator*primitive-action
    :default
    (state <s> ^look-ahead-operator <o> ^operator <o> ^problem-space <p*1>)
    (<p*1> ^name action)
    -->
    (<s> ^tried-tied-operator <o> +)
}

sp {evaluate-operator*propose*look-ahead*reject-all-others
    :default
    (state <s> ^untried-tied-operator <o> ^look-ahead-operator <o>
          ^operator { <> <o> <o1> } +)
    -->
    (<s> ^operator <o1> -)
}

sp {evaluate-operator*propose*look-ahead
    :default
    (state <s> ^untried-tied-operator <o> ^look-ahead-operator <o>)
    -->
    (<s> ^operator <o> +)
}

sp {evaluate-operator*elaborate*evaluation*failure*no-operators
    :default
    (state <goal-nc> ^quiescence t ^impasse no-change ^attribute state
          ^superstate <state-nc>)
    (<state-nc> ^quiescence t ^impasse no-change ^attribute state
          ^superstate <eval-g>)
    (<eval-g> ^quiescence t ^superstate <select-g>)
    (<select-g> ^operator <o2> ^evaluation <e2>)
    (<o2> ^name evaluate-operator ^evaluation <e2>)
    -->
    (<e2> ^symbolic-value failure +)
}

sp {selection*elaborate*evaluate-operator*all-operators-novalue
    :default
    (state <s> ^quiescence t -^found-value <f*1>
          -^not-all-operators-evaluated <n*1> ^choices multiple
          ^superstate <s*1> ^operator <o>)
    (<s*1> ^superstate <sss>)
    (<sss> ^name selection ^operator <sso>)
    (<sso> ^name evaluate-operator ^evaluation <e>)
    -->
    (<e> ^numeric-value novalue +)
}

sp {selection*pass-back-success
    :default
    (state <s> ^evaluation <e*1> ^superstate <s*1>)
    (<e*1> ^symbolic-value { << required-success >> <s*3> })
    (<s*1> ^superstate <s*2>)
    (<s*2> ^operator <sso>)
    (<sso> ^name evaluate-operator ^evaluation <e2> ^superoperator <s*4>)
    (<s*4> ^name <n*1>)
    -->
    (<e2> ^symbolic-value partial-success +)
}

sp {evaluate-operator*elaborate*evaluation*failure*constraint-failure
    :default
    (state <rej-state-imp> ^impasse constraint-failure ^attribute operator
          ^superstate <eval-g>)
    (<eval-g> ^superstate <select-g>)
    (<select-g> ^operator <o2> ^evaluation <e2>)
    (<o2> ^name evaluate-operator ^evaluation <e2>)
    -->
    (<e2> ^symbolic-value failure +)
}

sp {evaluate-operator*elaborate*operator*add-attribute-to-duplicate-operator*nln
    :default
    (state <s> ^look-ahead-operator <o-copy> ^problem-space <p>)
    (<o-copy> ^duplicate-of <o>)
    (<p> ^no-local-negations <nln>)
    (<o> ^{ <> duplicate-of <att> } <val>)
    -->
    (<o-copy> ^<att> <val> +)
}

sp {evaluate-operator*elaborate*operator*add-duplicated-attribute-to-duplicate-operator
    :default
    (state <s> ^problem-space <p> ^duplicates <d>
          ^look-ahead-operator <o-copy>)
    (<p> -^no-local-negations <nln> -^dont-copy <att>)
    (<o-copy> ^duplicate-of <o>)
    (<o> ^{ <> duplicate-of <att> } <id>)
    (<d> ^<id> <copy-id>)
    -->
    (<o-copy> ^<att> <copy-id> +)
}

sp {evaluate-operator*elaborate*operator*add-attribute-to-duplicate-operator
    :default
    (state <s> ^problem-space <p> ^duplicates <d>
          ^look-ahead-operator <o-copy>)
    (<p> -^no-local-negations <nln> -^dont-copy <att>)
    (<o-copy> ^duplicate-of <o>)
    (<o> ^{ <> duplicate-of <> desired <att> } <val>)
    (<d> -^<val> <v*1>)
    -->
    (<o-copy> ^<att> <val> +)
}

sp {evaluate-operator*elaborate*state*create-duplicates-table-for-operator-only
    :default
    (state <s> ^default-operator-copy yes -^default-state-copy yes
          ^impasse no-change ^attribute operator)
    -->
    (<s> ^duplicates <d> +)
}

sp {evaluate-operator*elaborate*operator*copy-default-operator-copy-from-problem-space
    :default
    (state <s> ^superstate <s*1> ^problem-space <p*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^name evaluate-operator)
    (<p*1> ^default-operator-copy <yes-or-no>)
    -->
    (<s> ^default-operator-copy <yes-or-no> +)
}

sp {evaluate-operator*elaborate*operator*default-operator-copy-is-yes
    :default
    (state <s> ^problem-space <ps> ^superstate <s*1>)
    (<ps> -^default-operator-copy no)
    (<s*1> ^operator <o*1>)
    (<o*1> ^name evaluate-operator)
    -->
    (<s> ^default-operator-copy yes +)
}

sp {duplicate-desired*replace-old-value
    :default
    (state <s> ^duplicates <d*1> ^desired <o-copy> ^problem-space <p>)
    (<o-copy> ^duplicate-of <o>)
    (<o> ^{ <> duplicate-of <att> } <id>)
    (<p> -^dont-copy <att>)
    (<d*1> ^<id> <copy-id>)
    -->
    (<o-copy> ^<att> <copy-id> +)
}

sp {duplicate-desired*copy-old-value
    :default
    (state <s> ^duplicates <d> ^desired <o-copy> ^superstate <s*1>
          ^problem-space <p>)
    (<o-copy> ^duplicate-of <o>)
    (<s*1> ^operator <so>)
    (<so> ^name evaluate-operator ^evaluation <e*1>)
    (<e*1> ^desired <o>)
    (<o> ^{ <> duplicate-of <att> } <val>)
    (<d> -^<val> <v*1>)
    (<p> -^dont-copy <att>)
    -->
    (<o-copy> ^<att> <val> +)
}

sp {evaluate-operator*elaborate*state*eval*desired
    :default
    (state <s> ^superstate <ss>)
    (<ss> ^operator <so>)
    (<so> ^default-desired-copy yes ^name evaluate-operator ^evaluation <e*1>)
    (<e*1> ^desired <d>)
    -->
    (<s> ^desired <d-copy> +)
    (<d-copy> ^duplicate-of <d> +)
}

sp {evaluate-operator*elaborate*state*add-duplicates-for-all-attributes
    :default
    (state <s> ^default-state-copy yes ^problem-space <p> ^duplicates <d*1>
          ^duplicate-of <d*2>)
    (<p> -^dont-copy-anything <d*3> ^all-attributes-at-level two
          -^one-level-attributes <att> -^dont-copy <att>)
    (<d*2> ^{ <> tried-tied-operator <att> } <id>)
    (<d*1> ^<id> <new-id>)
    -->
    (<s> ^<att> <new-id> +)
}

sp {evaluate-operator*elaborate*state*add-duplicate-to-state
    :default
    (state <s> ^default-state-copy yes ^duplicates <d*1> ^duplicate-of <d*2>
          ^problem-space <p*1>)
    (<p*1> ^two-level-attributes <att>)
    (<d*2> ^<att> <id>)
    (<d*1> ^<id> <new-id>)
    -->
    (<s> ^<att> <new-id> +)
}

sp {evaluate-operator*elaborate*add-duplicated-attribute-to-duplicate
    :default
    (state <s> ^default-state-copy yes ^duplicates <d>)
    (<d> ^<id> <new-id> ^<sub-val> <new-val>)
    (<id> ^{ <> tried-tied-operator <sub-att> } <sub-val>)
    -->
    (<new-id> ^<sub-att> <new-val> +)
}

sp {evaluate-operator*elaborate*add-attribute-to-duplicate*nln
    :default
    (state <s> ^default-state-copy yes ^duplicates <d> ^problem-space <p*1>)
    (<p*1> ^no-local-negations <nln>)
    (<d> ^<id> <new-id>)
    (<id> ^{ <> tried-tied-operator <sub-att> } <sub-val>)
    -->
    (<new-id> ^<sub-att> <sub-val> +)
}

sp {evaluate-operator*elaborate*add-attribute-to-duplicate
    :default
    (state <s> ^default-state-copy yes ^duplicates <d>)
   -{ (<s> ^problem-space <p*1>)
      (<p*1> ^no-local-negations <nln>)}
    (<d> ^<id> <new-id> -^<sub-val> <s*1>)
    (<id> ^{ <> tried-tied-operator <sub-att> } <sub-val>)
   -{ (<s> ^problem-space <p*2>)
      (<p*2> ^dont-copy <sub-att>)}
    -->
    (<new-id> ^<sub-att> <sub-val> +)
}

sp {evaluate-operator*elaborate*state*duplicate-id-for-all-attributes
    :default
    (state <s> ^default-state-copy yes ^problem-space <p> ^duplicates <d>
          ^duplicate-of <ss>)
    (<p> -^dont-copy-anything <d*1> ^all-attributes-at-level two
          -^one-level-attributes <att> -^dont-copy <att>)
    (<ss>
          ^{ <> duplicate-of <> tried-tied-operator <> problem-space <> impasse <> attribute <> choices <> quiescence <> operator <> superstate <att> } <id>)
    -->
    (<d> ^<id> <new-id> +)
}

sp {evaluate-operator*elaborate*state*duplicate-id-for-attribute
    :default
    (state <s> ^default-state-copy yes ^duplicates <d> ^duplicate-of <d*1>
          ^problem-space <p*1>)
    (<p*1> ^two-level-attributes <att>)
    (<d*1> ^<att> <id>)
    -->
    (<d> ^<id> <new-id> +)
}

sp {evaluate-operator*elaborate*state*change-all-attributes-at-level-one-to-duplicate
    :default
    (state <s> ^all-attributes-at-level one ^default-state-copy yes
          ^duplicates <d*1> ^duplicate-of <d*2>)
    (<d*2> ^{ <> tried-tied-operator <att> } <id>)
   -{ (<s> ^problem-space <p*1>)
      (<p*1> ^dont-copy <att>)}
    (<d*1> ^<id> <new-id>)
    -->
    (<s> ^<att> <id> - ^<att> <new-id> +)
}

sp {evaluate-operator*elaborate*state*change-one-level-attribute-to-duplicate
    :default
    (state <s> ^default-state-copy yes ^duplicates <d*1> ^duplicate-of <d*2>
          ^problem-space <p*1>)
    (<p*1> ^one-level-attributes <att>)
    (<d*2> ^<att> <id>)
    (<d*1> ^<id> <new-id>)
    -->
    (<s> ^<att> <id> - ^<att> <new-id> +)
}

sp {evaluate-operator*elaborate*state*add-all-attributes-at-level-one
    :default
    (state <s> ^all-attributes-at-level one ^default-state-copy yes
          ^problem-space <p> ^duplicate-of <ss>)
    (<p> -^dont-copy-anything <d*1> -^dont-copy <att>)
    (<ss>
          ^{ <> duplicate-of <> tried-tied-operator <> problem-space <> impasse <> attribute <> choices <> quiescence <> operator <> superstate <> type <> name <> look-ahead-operator <> smem <> epmem <> svs <> reward-link <att> } <val>)
    -->
    (<s> ^<att> <val> +)
}

sp {evaluate-operator*elaborate*state*add-one-level-attributes
    :default
    (state <s> ^default-state-copy yes ^duplicate-of <d*1>
          ^problem-space <p*1>)
    (<p*1> ^one-level-attributes <att>)
    (<d*1> ^<att> <val>)
    -->
    (<s> ^<att> <val> +)
}

sp {evaluate-operator*elaborate*state*create-duplicates-table
    :default
    (state <s> ^default-state-copy yes ^impasse no-change ^attribute operator
          ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^name evaluate-operator)
    -->
    (<s> ^duplicates <d> +)
}

sp {evaluate-operator*elaborate*state*copy-all-attributes-at-level-one-from-problem-space
    :default
    (state <s> ^default-state-copy yes ^problem-space <p*1>)
    (<p*1> ^all-attributes-at-level one)
    -->
    (<s> ^all-attributes-at-level one +)
}

sp {evaluate-operator*elaborate*state*default-copy-is-all-attributes-at-level-one*no-problem-space
    :default
    (state <s> ^impasse no-change -^problem-space <p*1> ^attribute operator
          ^superstate <s*1>)
    (<s*1> ^operator <so>)
    (<so> -^superproblem-space <p> ^name evaluate-operator)
    -->
    (<s> ^all-attributes-at-level one +)
}

sp {evaluate-operator*elaborate*state*default-copy-is-all-attributes-at-level-one
    :default
    (state <s> ^impasse no-change ^attribute operator ^problem-space <p>
          ^superstate <s*1>)
    (<p> -^dont-copy-anything <d*2> -^dont-copy <d*1>
          -^two-level-attributes <t*1> -^one-level-attributes <o*2>
          -^all-attributes-at-level two)
    (<s*1> ^operator <o*1>)
    (<o*1> ^name evaluate-operator)
    -->
    (<s> ^all-attributes-at-level one +)
}

sp {evaluate-operator*elaborate*default-state-copy-from-problem-space
    :default
    (state <s> ^superstate <s*1> ^problem-space <p*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^name evaluate-operator)
    (<p*1> ^default-state-copy <yes-or-no>)
    -->
    (<s> ^default-state-copy <yes-or-no> +)
}

sp {evaluate-operator*elaborate*default-for-default-state-copy-is-yes
    :default
    (state <s> ^problem-space <p> ^superstate <s*1>)
    (<p> -^default-state-copy no)
    (<s*1> ^operator <o*1>)
    (<o*1> ^name evaluate-operator)
    -->
    (<s> ^default-state-copy yes +)
}

sp {evaluate-operator*elaborate*numeric-evaluation*from-subgoal
    :default
    (state <ss> ^numeric-value <v> ^desired <eb> ^superstate <s>)
    (<s> ^operator <so> ^evaluation <e>)
    (<so> ^name evaluate-operator ^evaluation <e*1> ^evaluation <e>)
    (<e*1> ^desired <eb>)
    -->
    (<e> ^numeric-value <v> +)
}

sp {evaluate-operator*elaborate*evaluation*from-subgoal*duplicate-desired
    :default
    (state <s> ^superstate <ss>
          ^{ << required-success success partial-success indifferent partial-failure failure prohibit-failure >> <svalue> } <deb>)
    (<ss> ^operator <so> ^evaluation <e>)
    (<so> ^name evaluate-operator ^evaluation <e> ^evaluation <e*1>)
    (<e*1> ^desired <eb>)
    (<deb> ^duplicate-of <eb>)
    -->
    (<e> ^symbolic-value <svalue> +)
}

sp {evaluate-operator*elaborate*state*look-ahead-operator*copy
    :default
    (state <s> ^default-operator-copy yes ^superstate <s*1>
          ^problem-space <p*1>)
    (<s*1> ^operator <so>)
    (<so> ^name evaluate-operator ^superproblem-space <s*2> ^superoperator <o>)
    (<s*2> ^name <n>)
    (<p*1> ^name <n>)
    -->
    (<s> ^look-ahead-operator <copy-o> + ^untried-tied-operator <copy-o> +)
    (<copy-o> ^duplicate-of <o> +)
}

sp {evaluate-operator*elaborate*state*duplicate-of
    :default
    (state <s> ^default-state-copy yes ^superstate <ss>)
    (<ss> ^operator <so>)
    (<so> ^name evaluate-operator ^superstate <sss>)
    -->
    (<s> ^duplicate-of <sss> +)
}

sp {evaluate-operator*elaborate*state*name
    :default
    (state <s> ^impasse no-change ^attribute operator ^superstate <s*1>)
    (<s*1> ^operator <so>)
    (<so> ^name evaluate-operator ^superstate <s*2>)
    (<s*2> ^name { <> evaluate-operator <name> })
    -->
    (<s> ^name <name> +)
}

sp {evaluate-operator*elaborate*state*desired*nln
    :default
    (state <s> ^impasse no-change ^attribute operator ^superstate <s*1>
          ^problem-space <p*1>)
    (<s*1> ^operator <so>)
    (<so> ^name evaluate-operator ^evaluation <e*1>)
    (<e*1> ^desired <d>)
    (<p*1> ^no-local-negations <nln>)
    -->
    (<s> ^desired <d> +)
}

sp {evaluate-operator*elaborate*state*desired
    :default
    (state <s> ^impasse no-change ^attribute operator ^superstate <s*1>)
   -{ (<s> ^problem-space <p*1>)
      (<p*1> ^no-local-negations <nln>)}
    (<s*1> ^operator <so>)
    (<so> -^default-desired-copy yes ^name evaluate-operator ^evaluation <e*1>)
    (<e*1> ^desired <d>)
    -->
    (<s> ^desired <d> +)
}

sp {selection*elaborate*evaluate-operator*superstate
    :default
    (state <s> ^name selection ^operator <o> ^superstate <ss>)
    (<o> ^name evaluate-operator)
    -->
    (<o> ^superstate <ss> +)
}

sp {selection*elaborate*evaluate-operator*superproblem-space
    :default
    (state <s> ^name selection ^operator <o> ^superstate <s*1>)
    (<o> ^name evaluate-operator)
    (<s*1> ^problem-space <p2>)
    -->
    (<o> ^superproblem-space <p2> +)
}

sp {selection*elaborate*evaluate-operator*evaluation
    :default
    (state <s> ^name selection ^operator <o> ^evaluation <e>)
    (<o> ^name evaluate-operator ^superoperator <ob>)
    (<e> ^superoperator <ob>)
    -->
    (<o> ^evaluation <e> +)
}

sp {selection*select*evaluate-operator*indifferent
    :default
    (state <s> ^name selection -^operator-selection not-indifferent
          ^operator <o> +)
    (<o> ^name evaluate-operator)
    -->
    (<s> ^operator <o> =)
}

sp {selection*compare*novalue-evaluation-always-worse
    :default
    (state <s> ^name selection ^evaluation <e1> ^evaluation { <> <e1> <e2> }
          ^superstate <ss>)
    (<e1> ^numeric-value novalue ^desired <d> ^superoperator <o1>)
    (<e2> ^desired <d> ^numeric-value { <> novalue <n*1> } ^superoperator <o2>)
    (<ss> ^desired <d>)
    -->
    (<ss> ^operator <o2> > <o1>)
}

sp {selection*elaborate*state*found-value-true
    :default
    (state <s> ^name selection ^evaluation <e>)
    (<e> ^{ << numeric-value symbolic-value >> <a*1> } { <> novalue <v*1> })
    -->
    (<s> ^found-value true +)
}

sp {selection*elaborate*state*all-objects-evaluated
    :default
    (state <s> ^name selection ^operator <o> +)
   -{ (<o> ^name evaluate-operator ^evaluation <e*1>)
      (<e*1> ^value true)}
    -->
    (<s> ^not-all-operators-evaluated true +)
}

sp {selection*select*partial-failure-evaluation-becomes-worst-preference
    :default
    (state <s> ^name selection ^evaluation <e1> ^superstate <ss>)
    (<e1> ^symbolic-value partial-failure ^superoperator <o1> ^desired <e>)
    (<ss> ^desired <e>)
    -->
    (<ss> ^operator <o1> <)
}

sp {selection*select*prohibit-failure-evaluation-becomes-prohibit-preference
    :default
    (state <s> ^name selection ^evaluation <e1> ^superstate <ss>)
    (<e1> ^symbolic-value prohibit-failure ^superoperator <o1> ^desired <e>)
    (<ss> ^desired <e>)
    -->
    (<ss> ^operator <o1> ~)
}

sp {selection*select*success-evaluation-becomes-best-preference
    :default
    (state <s> ^name selection ^evaluation <e1> ^superstate <ss>)
    (<e1> ^symbolic-value { << partial-success success >> <s*1> }
          ^superoperator <o1> ^desired <eb>)
    (<ss> ^desired <eb>)
    -->
    (<ss> ^operator <o1> > ^operator <o1> = 0.900000)
}

sp {selection*select*required-success-evaluation-becomes-required-preference
    :default
    (state <s> ^name selection ^evaluation <e1> ^superstate <ss>)
    (<e1> ^symbolic-value required-success ^superoperator <o1> ^desired <eb>)
    (<ss> ^desired <eb>)
    -->
    (<ss> ^operator <o1> !)
}

sp {selection*compare*partial-failure-evaluation-better-than-failure
    :default
    (state <s> ^name selection ^evaluation <e2> ^evaluation { <> <e2> <e1> }
          ^superstate <ss>)
    (<e2> ^symbolic-value failure ^desired <d> ^superoperator <y>)
    (<e1> ^symbolic-value partial-failure ^desired <d>
          ^superoperator { <> <y> <x> })
    (<ss> ^desired <d>)
    -->
    (<ss> ^operator <x> > <y>)
}

sp {selection*compare*success-evaluation-better-than-partial-success
    :default
    (state <s> ^name selection ^evaluation <e2> ^evaluation { <> <e2> <e1> }
          ^superstate <ss>)
    (<e2> ^symbolic-value partial-success ^desired <d> ^superoperator <y>)
    (<e1> ^symbolic-value success ^desired <d> ^superoperator { <> <y> <x> })
    (<ss> ^desired <d>)
    -->
    (<ss> ^operator <x> > <y>)
}

sp {selection*compare*prefer-lower-evaluation
    :default
    (state <s> ^name selection ^evaluation <e2> ^evaluation { <> <e2> <e1> }
          ^superstate <ss>)
    (<e2> ^desired <d> ^numeric-value <n*1> ^superoperator <o2>)
    (<d> ^better lower)
    (<e1> ^desired <d> ^numeric-value { < <n*1> <v> } ^superoperator <o1>)
    (<ss> ^desired <d> ^problem-space <p2>)
    -->
    (<ss> ^operator <o2> < <o1>)
}

sp {selection*compare*higher-evaluation-better
    :default
    (state <s> ^name selection ^evaluation <e2> ^evaluation { <> <e2> <e1> }
          ^superstate <ss>)
    (<e2> ^desired <d> ^numeric-value <n*1> ^superoperator <o2>)
    (<d> ^better higher)
    (<e1> ^desired <d> ^numeric-value { > <n*1> <v> } ^superoperator <o1>)
    (<ss> ^desired <d> ^problem-space <p2>)
    -->
    (<ss> ^operator <o2> < <o1>)
}

sp {selection*elaborate*evaluation*desired
    :default
    (state <s> ^evaluation <e> ^superstate <s*1>)
    (<s*1> ^desired <d>)
    -->
    (<e> ^desired <d> +)
}

sp {selection*elaborate*evaluation*value
    :default
    (state <s> ^evaluation <e>)
    (<e> ^{ << numeric-value symbolic-value >> <a*1> } <v*1>)
    -->
    (<e> ^value true +)
}

sp {selection*elaborate*name*selection*action
    :default
    (state <s> ^choices multiple -^io <i*1> ^problemspace <p*1>)
   -{ (<s> ^operator <o> +)
      (<o> ^name learn-action-result)}
    (<p*1> ^name action)
    -->
    (<s> ^name selection +)
}

sp {selection*elaborate*name*selection*game-heuristics
    :default
    (state <s> ^problemspace game-heuristics ^choices multiple)
   -{ (<s> ^operator <o> +)
      (<o> ^name learn-action-result)}
    -->
    (<s> ^name selection +)
}

sp {selection*elaborate*name*selection
    :default
    (state <s> ^problemspace games ^choices multiple)
   -{ (<s> ^operator <o> +)
      (<o> ^name learn-action-result)}
    -->
    (<s> ^name selection +)
}

sp {top-state*elaborate*action-stack*task-object*mark*object
    (state <s> ^superstate nil ^action-stack <a*1>)
    (<a*1> ^task-objects <t*1>)
    (<t*1> ^object <obj>)
    -->
    (<obj> ^task-object true +)
}

sp {top-state*elaborate*action-stack*task-objects
    (state <s> ^superstate nil ^action-stack <stack>)
    -->
    (<stack> ^task-objects <objs> +)
}

sp {top-state*elaborate*action-stack*bottom*prev
    (state <s> ^superstate nil ^action-stack <a*1>)
    (<a*1> ^bottom <bot>)
    -->
    (<bot> ^prev none +)
}

sp {top-state*elaborate*action-stack*prev*links
    (state <s> ^superstate nil ^action-stack <a*1>)
    (<a*1> ^actions <a*2>)
    (<a*2> ^action <a>)
    (<a> ^next { <> none <next> })
    -->
    (<next> ^prev <a> +)
}

sp {top-state*elaborate*actions*next*action
    (state <s> ^superstate nil ^action-stack <a*1>)
    (<a*1> ^actions <a>)
    (<a> ^action <action>)
    (<action> ^next { <> none <next> })
    -->
    (<a> ^action <next> +)
}

sp {top-state*elaborate*actions*bottom*action
    (state <s> ^superstate nil ^action-stack <stack>)
    (<stack> ^actions <a> ^bottom { <> none <action> })
    -->
    (<a> ^action <action> +)
}

sp {pop-action*elaborate*action-to-pop
    (state <s> ^name pop-action ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^action <action>)
    -->
    (<s> ^action-to-pop <action> +)
}

sp {pop-action*elaborate*action-stack
    (state <s> ^name pop-action ^superstate <s*1>)
    (<s*1> ^action-stack <stack>)
    -->
    (<s> ^action-stack <stack> +)
}

sp {pop-action*apply*complete-pop-action*delete*dialog*info
    (state <s> ^name pop-action ^operator <o*1> ^action-to-pop <bottom>
          ^action-stack <a*1> ^top-state <top>)
    (<o*1> ^name complete-pop-action)
    (<a*1> ^bottom <bottom>)
    (<top> ^dialog-world <w> ^dialog-object-list <list>)
    -->
    (<top> ^dialog-object-list <list> - ^dialog-world <w> -
           ^dialog-object-list nil + ^dialog-object-list-saved nil +
           ^dialog-world <new> +)
    (<new> ^objects <objs> + ^predicates <preds> +)
}

sp {pop-action*apply*complete-pop-action*delete*non-confirmed*task*object
    (state <s> ^name pop-action ^operator <o*1> ^action-to-pop <action>
          ^action-stack <a*1> ^action-stack <a*2> ^top-state <t*2>)
    (<o*1> ^name complete-pop-action)
    (<a*1> ^bottom <action>)
    (<a*2> ^task-objects <t*1>)
    (<t*2> ^perception-monitor <p*1>)
    (<p*1> ^object-monitor <o*2>)
    (<o*2> ^object-info <obj-info>)
    (<obj-info> ^wm-obj <obj>)
   -{ (<obj> ^predicates <p*3>)
      (<p*3> ^arm-status grabbed)}
   -{ (<obj> ^predicates <p*2>)
      (<p*2> ^object-status confirmed)}
    (<t*1> ^object <obj>)
    -->
    (<obj-info> ^delete-object true +)
}

sp {pop-action*apply*complete-pop-action*bottom*clear*task-objects
    (state <s> ^name pop-action ^operator <o*1> ^action-to-pop <action>
          ^action-stack <a*1> ^action-stack <stack>)
    (<o*1> ^name complete-pop-action)
    (<a*1> ^bottom <action>)
    (<stack> ^task-objects <objs>)
    -->
    (<stack> ^task-objects <objs> - ^task-objects <new> +)
}

sp {pop-action*apply*complete-pop-action*mark*performed*once*subaction
    (state <s> ^name pop-action ^operator <o*1> ^action-to-pop <a*2>
          ^action-to-pop <a*1>)
    (<o*1> ^name complete-pop-action)
    (<a*1> ^execution-operator <op>)
    (<op> ^perform once ^subaction-handle <sub-handle>)
    (<a*2> ^prev <p*1>)
    (<p*1> ^execution-operator <parent-op>)
    -->
    (<parent-op> ^performed <sub-handle> +)
}

sp {pop-action*apply*complete-pop-action*remove*robot-status
    (state <s> ^name pop-action ^operator <o*1> ^action-to-pop <bottom>
          ^action-stack <a*1> ^top-state <t*1>)
    (<o*1> ^name complete-pop-action)
    (<a*1> ^bottom <bottom>)
    (<t*1> ^world <w*1>)
    (<w*1> ^objects <o*2>)
    (<o*2> ^object <o*3>)
    (<o*3> ^predicates <preds>)
    (<preds> ^robot-status <status>)
    -->
    (<preds> ^robot-status <status> -)
}

sp {pop-action*apply*complete-pop-action*remove*answers
    (state <s> ^name pop-action ^operator <o*1> ^action-to-pop <bottom>
          ^action-stack <a*1> ^top-state <t*1>)
    (<o*1> ^name complete-pop-action)
    (<a*1> ^bottom <bottom>)
    (<t*1> ^world <w*1>)
    (<w*1> ^objects <objs>)
    (<objs> ^object <obj>)
    (<obj> ^predicates <preds>)
    (<preds> ^modifier1 answer1)
    -->
    (<preds> ^modifier1 answer1 -)
}

sp {pop-action*apply*complete-pop-action*remove*remembered*things
    (state <s> ^name pop-action ^operator <o*1> ^action-to-pop <a*1>)
    (<o*1> ^name complete-pop-action)
    (<a*1> ^remembered <rem>)
    (<rem> ^value <val> ^attribute <att> ^object <o*2>)
    (<o*2> ^predicates <preds>)
    (<preds> ^<att> <val>)
    -->
    (<preds> ^<att> <val> -)
}

sp {pop-action*apply*complete-pop-action*push*learning*segment
    (state <s> ^name pop-action ^action-to-pop <action> ^operator <o*1>
          ^top-state <t*1>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^change-name clear-action-stack)}
    (<action> ^policy-learning-needed true ^status success
          ^execution-operator <e*1>)
    (<o*1> ^name complete-pop-action)
    (<e*1> ^action-handle { <> find1 <a*1> })
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <changes>)
    -->
    (<changes> ^new-segment-info <info> +)
    (<info> ^purpose <p> + ^originator agent +)
    (<p> ^type retrospective-learning + ^parameters <params> +
           ^satisfaction <s*2> +)
    (<s*2> ^learning-event <l*1> +)
    (<l*1> ^type retrospective +)
    (<params> ^action <action> +)
}

sp {pop-action*apply*complete-pop-action*report*execution*failure*not*bottom
    (state <s> ^name pop-action ^action-to-pop <action> ^operator <o*1>
          ^action-stack <a*1> ^top-state <t*1>)
    (<action> ^status failure ^failure-info <info> ^execution-failure <type>)
    (<o*1> ^name complete-pop-action)
    (<a*1> ^bottom { <> <action> <b*1> })
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^failure <f> +)
    (<f> ^type execution-failure + ^failure-type <type> +
           ^failure-info <info> + ^bottom-action false +)
}

sp {pop-action*apply*complete-pop-action*report*execution*failure*bottom
    (state <s> ^name pop-action ^action-to-pop <action> ^action-stack <a*1>
          ^operator <o*1> ^top-state <t*1>)
    (<action> ^status failure ^failure-info <info> ^execution-failure <type>)
    (<a*1> ^bottom <action>)
    (<o*1> ^name complete-pop-action)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^failure <f> +)
    (<f> ^type execution-failure + ^failure-type <type> +
           ^failure-info <info> + ^bottom-action true +)
}

sp {pop-action*apply*complete-pop-action*report*find-failure
    (state <s> ^name pop-action ^action-to-pop <action> ^operator <o*1>
          ^top-state <t*1>)
    (<action> -^status success ^execution-operator <e*1>)
    (<e*1> ^action-handle find1)
    (<o*1> ^name complete-pop-action)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <chgs>)
    -->
    (<chgs> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type find-failure +)
}

sp {pop-action*apply*complete-pop-action*report*find-success
    (state <s> ^name pop-action ^action-to-pop <action> ^operator <o*1>
          ^top-state <t*1>)
    (<action> ^status success ^execution-operator <e*1>)
    (<e*1> ^action-handle find1)
    (<o*1> ^name complete-pop-action)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <chgs>)
    -->
    (<chgs> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type find-success +)
}

sp {pop-action*apply*complete-pop-action*report*performed*action-event
    (state <s> ^name pop-action ^action-to-pop <action> ^operator <o*1>
          ^top-state <t*1>)
    (<action> ^status success ^execution-operator <e*1>)
    (<o*1> ^name complete-pop-action)
    (<e*1> ^action-handle <action-handle>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^performed <p*1> +)
    (<p*1> ^action-event <a*1> +)
    (<a*1> ^type <action-handle> +)
}

sp {pop-action*apply*complete-pop-action*pop*segment
    (state <s> ^name pop-action ^operator <o*1> ^action-to-pop <a*1>
          ^top-state <t*2> ^top-state <t*1>)
    (<o*1> ^name complete-pop-action)
    (<a*1> ^execution-operator <op>)
    (<t*2> ^interaction <i*2>)
    (<i*2> ^changes <chgs>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <s*2>)
    (<s*2> ^purpose <p>)
    (<p> ^type execute-action ^parameters <p*1>)
    (<p*1> ^action-operator <op>)
    -->
    (<chgs> ^terminate-segment true +)
}

sp {pop-action*apply*complete-pop-action*clear*changes
    (state <s> ^name pop-action ^operator <o*1> ^action-to-pop <action>
          ^action-stack <a*1>)
    (<o*1> ^name complete-pop-action)
    (<a*1> ^changes <changes>)
    (<changes> ^pop <action>)
    -->
    (<changes> ^pop <action> -)
}

sp {pop-action*apply*complete-pop-action*change*bottom
    (state <s> ^name pop-action ^operator <o*1> ^action-to-pop <action>
          ^action-stack <stack>)
    (<o*1> ^name complete-pop-action)
    (<stack> ^bottom <action>)
    -->
    (<stack> ^bottom <action> - ^bottom none +)
}

sp {pop-action*apply*complete-pop-action*pop
    (state <s> ^name pop-action ^operator <o*1> ^action-to-pop <action>
          ^action-stack <stack>)
    (<o*1> ^name complete-pop-action)
    (<stack> ^top <action>)
    (<action> ^prev <prev>)
    -->
    (<stack> ^top <action> - ^top <prev> +)
    (<action> ^next none -)
    (<prev> ^next <action> - ^next none +)
}

sp {pop-action*propose*complete-pop-action
    (state <s> ^name pop-action)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete-pop-action +)
}

sp {push-action*apply*add-task-objects*copy*object
    (state <s> ^name push-action ^operator <o> ^action-stack <a*1>)
    (<o> ^name add-task-objects ^object <obj>)
    (<a*1> ^task-objects <objs>)
    -->
    (<objs> ^object <obj> +)
}

sp {push-action*apply*add-task-objects*no*objects
    (state <s> ^name push-action ^operator <o*1> ^action-to-push <action>)
    (<o*1> ^name add-task-objects)
    -->
    (<s> ^added-objects true +)
}

sp {push-action*elaborate*add-taks-objects*object*from*until-clause
    (state <s> ^name push-action ^operator <o> + ^action-to-push <a*1>)
    (<o> ^name add-task-objects)
    (<a*1> ^execution-operator <e*1>)
    (<e*1> ^until-clause <until>)
    (<until> ^{ << 1 2 >> <num> } <obj>)
    -->
    (<o> ^object <obj> +)
}

sp {push-action*elaborate*add-task-objects*object*from*predicate
    (state <s> ^name push-action ^operator <o> + ^action-to-push <a*1>)
    (<o> ^name add-task-objects)
    (<a*1> ^execution-operator <e*1>)
    (<e*1> ^<arg-name> <arg>)
    (<arg> ^arg-type predicate ^2 <obj>)
    -->
    (<o> ^object <obj> +)
}

sp {push-action*elaborate*add-task-objects*object
    (state <s> ^name push-action ^operator <o> + ^action-to-push <a*1>)
    (<o> ^name add-task-objects)
    (<a*1> ^execution-operator <e*1>)
    (<e*1> ^<arg-name> <arg>)
    (<arg> ^arg-type object ^id <obj>)
    -->
    (<o> ^object <obj> +)
}

sp {push-action*propose*add-task-objects
    (state <s> ^name push-action -^added-objects <a*1>
          ^action-to-push <action>)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name add-task-objects +)
}

sp {push-action*elaborate*action-to-push
    (state <s> ^name push-action ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^action <action>)
    -->
    (<s> ^action-to-push <action> +)
}

sp {push-action*elaborate*action-stack
    (state <s> ^name push-action ^superstate <s*1>)
    (<s*1> ^action-stack <stack>)
    -->
    (<s> ^action-stack <stack> +)
}

sp {push-action*apply*complete-push-action*print*action*segment
    (state <s> ^name push-action ^agent-params <a*1> ^operator <o*1>
          ^action-to-push <a>)
    (<a*1> ^debug-actions true)
    (<o*1> ^name complete-push-action)
    (<a> ^execution-operator <exop>)
    -->
    (write |Pushing a new action segment: | (crlf))
    (write (cmd print <a> |-d| 1) (crlf))
    (write |Action Operator: | (crlf))
    (write (cmd print <exop> |-d| 5) (crlf))
}

sp {push-action*apply*complete-push-action*ask*remove*previous*answer
    (state <s> ^name push-action ^operator <o*1> ^action-to-push <a*1>
          ^top-state <t*1>)
    (<o*1> ^name complete-push-action)
    (<a*1> ^execution-operator <e*1>)
    (<e*1> ^action-handle ask1)
    (<t*1> ^world <w*1>)
    (<w*1> ^objects <o*2>)
    (<o*2> ^object <obj>)
    (<obj> ^predicates <preds>)
    (<preds> ^modifier1 answer1)
    -->
    (<preds> ^modifier1 answer1 -)
}

sp {push-action*apply*complete-push-action*clear*changes
    (state <s> ^name push-action ^operator <o*1> ^action-to-push <action>
          ^action-stack <a*1>)
    (<o*1> ^name complete-push-action)
    (<a*1> ^changes <changes>)
    (<changes> ^push <action>)
    -->
    (<changes> ^push <action> -)
}

sp {push-action*apply*complete-push-action*change*bottom
    (state <s> ^name push-action ^action-stack <stack> ^operator <o*1>
          ^action-to-push <action>)
    (<stack> ^bottom none)
    (<o*1> ^name complete-push-action)
    -->
    (<stack> ^bottom none - ^bottom <action> +)
}

sp {push-action*apply*complete-push-action*push
    (state <s> ^name push-action ^operator <o*1> ^action-to-push <action>
          ^action-stack <stack>)
    (<o*1> ^name complete-push-action)
    (<stack> ^top <top>)
    -->
    (<stack> ^top <top> - ^top <action> +)
    (<action> ^next none +)
    (<top> ^next none - ^next <action> +)
}

sp {push-action*apply*complete-push-action*add*start-of-execution*flag
    (state <s> ^name push-action ^operator <o*1> ^action-to-push <a>)
    (<o*1> ^name complete-push-action)
    -->
    (<a> ^start-of-execution true +)
}

sp {push-action*propose*complete-push-action
    (state <s> ^name push-action)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete-push-action +)
}

sp {manage-action-stack*elaborate*change-info
    (state <s> ^name manage-action-stack ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^change-info <info>)
    -->
    (<s> ^change-info <info> +)
}

sp {manage-action-stack*elaborate*change-name
    (state <s> ^name manage-action-stack ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^change-name <name>)
    -->
    (<s> ^change-name <name> +)
}

sp {manage-action-stack*elaborate*action-stack
    (state <s> ^name manage-action-stack ^superstate <s*1>)
    (<s*1> ^action-stack <stack>)
    -->
    (<s> ^action-stack <stack> +)
}

sp {manage-action-stack*apply*complete-clear-action-stack
    (state <s> ^name manage-action-stack ^operator <o*1> ^action-stack <a*1>)
    (<o*1> ^name complete-clear-action-stack)
    (<a*1> ^changes <changes>)
    (<changes> ^clear-action-stack true)
    -->
    (<changes> ^clear-action-stack true -)
}

sp {manage-action-stack*propose*complete-clear-action-stack
    (state <s> ^change-name clear-action-stack ^name manage-action-stack
          ^action-stack <a*1>)
    (<a*1> ^top none)
    -->
    (<s> ^operator <o> +)
    (<o> ^name complete-clear-action-stack +)
}

sp {manage-action-stack*clear-stack*propose*pop-action
    (state <s> ^change-name clear-action-stack ^name manage-action-stack
          ^action-stack <a*1>)
    (<a*1> ^top { <> none <action> })
    -->
    (<s> ^operator <o> +)
    (<o> ^name pop-action + ^action <action> +)
}

sp {manage-action-stack*propose*pop-action
    (state <s> ^change-name pop ^name manage-action-stack
          ^change-info <action>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name pop-action + ^action <action> +)
}

sp {manage-action-stack*propose*push-action
    (state <s> ^change-name push ^name manage-action-stack
          ^change-info <action>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name push-action + ^action <action> +)
}

sp {top-state*apply*init-agent*create*action-stack
    (state <s> ^superstate nil ^operator <o*1>)
    (<o*1> ^name init-agent)
    -->
    (<s> ^action-stack <action> +)
    (<action> ^top none + ^bottom none + ^changes <c> + ^actions <a> +
           ^object-set <objs> +)
}

sp {generate-action-operator*apply*mark-argument-missing*mark*missing
    (state <s> ^name generate-action-operator ^operator <o>
          ^action-operator <aop>)
    (<o> ^name mark-argument-missing ^arg-name <arg-name>)
    -->
    (<aop> ^missing-argument <arg-name> +)
}

sp {generate-action-operator*propose*mark-argument-missing*new*procedural*arg
    (state <s> ^name generate-action-operator ^action-id <a*1>
          ^action-operator <aop>)
    (<a*1> ^procedural <p*1>)
    (<p*1> ^<arg-name> <a*2>)
    (<aop> -^missing-argument <arg-name>)
   -{ (<s> ^argument-info <a*3>)
      (<a*3> ^arg-name <arg-name>)}
    (<a*2> ^importance required)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name mark-argument-missing + ^arg-name <arg-name> +)
}

sp {generate-action-operator*propose*attend-to-scene-change*new-object
    (state <s> ^name generate-action-operator ^top-state <t*1>)
    (<t*1> ^perception-monitor <p*1>)
    (<p*1> ^changes <c*1>)
    (<c*1> ^change <change>)
    -->
    (<s> ^operator <o> + ^operator <o> = ^operator <o> >)
    (<o> ^name attend-to-scene-change + ^change <change> +)
}

sp {generate-action-operator*apply*add-argument-to-world*predicate
    (state <s> ^name generate-action-operator ^operator <o> ^top-state <t*1>)
    (<o> ^arg-type predicate ^name add-argument-to-world ^2 <obj2>
          ^handle <pred-handle> ^1 <obj1>)
    (<t*1> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <ts-pred>)
    (<ts-pred> ^handle <pred-handle>)
    -->
    (<ts-pred> ^instance <i> +)
    (<i> ^1 <obj1> + ^2 <obj2> +)
}

sp {generate-action-operator*apply*add-argument-to-world*create*add-object*change
    (state <s> ^name generate-action-operator ^operator <o> ^top-state <t*1>)
    (<o> ^arg-type object ^name add-argument-to-world ^source-obj <obj>
          ^source-type <type>)
    (<t*1> ^perception-monitor <p*1>)
    (<p*1> ^changes <chgs>)
    -->
    (<chgs> ^change <c> +)
    (<c> ^type new-object + ^<type> <obj> +)
}

sp {generate-action-operator*propose*add-argument-to-world*predicate*with*spatial-relation
    (state <s> ^name generate-action-operator ^argument-info <arg2-info>
          ^argument-info <arg1-info> ^predicate-lti <pred-lti>
          ^top-state <t*1>)
    (<arg2-info> ^arg-status existing ^arg-type predicate
          ^handle <pred-handle> ^2 <obj2>)
    (<arg1-info> ^arg-status real ^arg-type object ^id <obj1>)
    (<pred-lti> ^handle <pred-handle> ^spatial-relation <s*1>)
    (<s*1> ^handle <sr-handle>)
    (<t*1> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <ts-pred>)
    (<ts-pred> ^handle <sr-handle>)
   -{ (<ts-pred> ^instance <i>)
      (<i> ^2 <obj2> ^1 <obj1>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name add-argument-to-world + ^arg-type predicate +
           ^handle <sr-handle> + ^1 <obj1> + ^2 <obj2> +)
}

sp {generate-action-operator*propose*add-argument-to-world*predicate
    (state <s> ^name generate-action-operator ^predicate-lti <pred-lti>
          ^argument-info <arg2-info> ^argument-info <arg1-info>
          ^top-state <t*1>)
    (<pred-lti> -^spatial-relation <s*1> ^handle <pred-handle>)
    (<arg2-info> ^arg-status existing ^arg-type predicate
          ^handle <pred-handle> ^2 <obj2>)
    (<arg1-info> ^arg-status real ^arg-type object ^id <obj1>)
    (<t*1> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <ts-pred>)
    (<ts-pred> ^handle <pred-handle>)
   -{ (<ts-pred> ^instance <i>)
      (<i> ^2 <obj2> ^1 <obj1>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name add-argument-to-world + ^arg-type predicate +
           ^handle <pred-handle> + ^1 <obj1> + ^2 <obj2> +)
}

sp {generate-action-operator*propose*add-argument-to-world*object*smem*until-clause
    (state <s> ^name generate-action-operator ^argument-info <arg-info>)
    (<arg-info> ^arg-type until-clause ^predicate <pred>)
    (<pred> ^obj-source <o*1> -^<name> <obj>)
    (<o*1> ^<name> <src>)
    (<src> ^object-instance true)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name add-argument-to-world + ^arg-type object +
           ^source-type smem-obj + ^source-obj <src> +)
}

sp {generate-action-operator*propose*add-argument-to-world*object*smem
    (state <s> ^name generate-action-operator ^argument-info <arg-info>)
    (<arg-info> ^obj-source <o*1> ^arg-status <any> -^<name> <obj>)
    (<o*1> ^<name> <src>)
    (<src> ^object-instance true)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name add-argument-to-world + ^arg-type object +
           ^source-type smem-obj + ^source-obj <src> +)
}

sp {generate-action-operator*propose*add-argument-to-world*object*imagined*until-clause
    (state <s> ^name generate-action-operator ^argument-info <arg-info>)
    (<arg-info> ^arg-type until-clause ^predicate <pred>)
    (<pred> ^obj-source <o*1> -^<name> <obj>)
    (<o*1> ^<name> <src>)
    (<src> -^object-instance true)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name add-argument-to-world + ^arg-type object +
           ^source-type imagined-obj + ^source-obj <src> +)
}

sp {generate-action-operator*propose*add-argument-to-world*object*imagined
    (state <s> ^name generate-action-operator ^argument-info <arg-info>)
    (<arg-info> -^arg-status abstract ^obj-source <o*1> -^<name> <obj>)
    (<o*1> ^<name> <src>)
    (<src> -^object-instance true)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name add-argument-to-world + ^arg-type object +
           ^source-type imagined-obj + ^source-obj <src> +)
}

sp {generate-action-operator*apply*complete-generate-action-operator*add*action-operator*to*segment
    (state <s> ^name generate-action-operator ^operator <o*1>
          ^action-operator <op> ^top-state <t*1>)
    (<o*1> ^name complete-generate-action-operator)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <s*2>)
    (<s*2> ^purpose <p*1>)
    (<p*1> ^parameters <params>)
    -->
    (<params> ^action-operator <op> +)
}

sp {generate-action-operator*apply*complete-generate-action-operator*task-subaction
    (state <s> ^name generate-action-operator ^command-message <msg>
          ^operator <o*1> ^action-operator <op> ^top-state <t*1>)
    (<msg> ^task-subaction true)
    (<o*1> ^name complete-generate-action-operator)
    (<t*1> ^action-stack <a*1>)
    (<a*1> ^changes <c>)
    -->
    (<c> ^push <action> +)
    (<action> ^task-subaction true + ^execution-operator <op> +)
    (<msg> ^pushed true +)
}

sp {generate-action-operator*apply*complete-generate-action-operator
    (state <s> ^name generate-action-operator ^command-message <msg>
          ^operator <o*1> ^action-operator <op> ^top-state <t*1>)
    (<msg> -^task-subaction true)
    (<o*1> ^name complete-generate-action-operator)
    (<t*1> ^action-stack <a*1>)
    (<a*1> ^changes <c>)
    -->
    (<c> ^push <action> +)
    (<action> ^execution-operator <op> +)
    (<msg> ^pushed true +)
}

sp {generate-action-operator*propose*complete-generate-action-operator
    (state <s> ^name generate-action-operator ^action-operator <op>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name complete-generate-action-operator +)
}

sp {generate-action-operator*apply*store-concepts*remove*retrieve
    (state <s> ^name generate-action-operator ^operator <o*1> ^smem <s*1>)
    (<o*1> ^name store-concepts)
    (<s*1> ^command <cmd>)
    (<cmd> ^retrieve <ret>)
    -->
    (<cmd> ^retrieve <ret> -)
}

sp {generate-action-operator*apply*store-concepts*store
    (state <s> ^name generate-action-operator ^operator <o*1> ^to-store <lti>
          ^smem <s*1>)
    (<o*1> ^name store-concepts)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^store <lti> +)
    (<s> ^stored-concepts true +)
}

sp {generate-action-operator*propose*store-concepts
    (state <s> ^concepts-to-store true -^stored-concepts <s*1>
          ^name generate-action-operator)
    -->
    (<s> ^operator <o> +)
    (<o> ^name store-concepts +)
}

sp {generate-action-operator*elaborate*concepts-to-store
    (state <s> ^name generate-action-operator ^to-store <lti>)
    -->
    (<s> ^concepts-to-store true +)
}

sp {generate-action-operator*apply*mark-argument-optional*remove*unknown
    (state <s> ^name generate-action-operator ^operator <o>)
    (<o> ^name mark-argument-optional ^argument <parg>)
    (<parg> ^importance unknown)
    -->
    (<parg> ^importance unknown -)
    (<s> ^to-store <parg> +)
}

sp {generate-action-operator*apply*mark-argument-optional*mark*optional
    (state <s> ^name generate-action-operator ^operator <o>)
    (<o> ^name mark-argument-optional ^argument <parg>)
    -->
    (<parg> ^importance optional +)
    (<s> ^to-store <parg> +)
}

sp {generate-action-operator*propose*mark-argument-optional*predicate
    (state <s> ^name generate-action-operator ^action-id <a*1>)
    (<a*1> ^procedural <p*1>)
    (<p*1> ^<arg-name> <parg>)
   -{ (<s> ^argument-info <a*2>)
      (<a*2> ^arg-name <arg-name>)}
    (<parg> ^importance unknown ^arg-type predicate)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name mark-argument-optional + ^argument <parg> +)
}

sp {generate-action-operator*propose*mark-argument-optional*simple
    (state <s> ^name generate-action-operator ^action-id <a*1>)
    (<a*1> ^procedural <p*1>)
    (<p*1> ^<arg-name> <parg>)
   -{ (<s> ^argument-info <a*2>)
      (<a*2> ^arg-name <arg-name>)}
    (<parg> ^importance unknown ^arg-type { << object concept >> <a*3> })
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name mark-argument-optional + ^argument <parg> +)
}

sp {generate-action-operator*propose*mark-argument-optional*new*procedural*arg
    (state <s> ^name generate-action-operator -^new-action true
          ^argument-info <arg-info>)
    (<arg-info> ^created-procedural-argument true ^procedural <parg>)
    (<parg> ^importance unknown)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name mark-argument-optional + ^argument <parg> +)
}

sp {generate-action-operator*apply*create-operator-argument*arg-type*until-clause*state*predicate*visible
    (state <s> ^name generate-action-operator ^operator <o>
          ^action-operator <op>)
    (<o> ^name create-operator-argument ^argument-info <arg-info>)
    (<arg-info> ^arg-type until-clause ^predicate <pred>)
    (<pred> ^handle visible1 ^type state ^1 <obj1>)
    -->
    (<op> ^until-clause <new-clause> +)
    (<new-clause> ^arg-type until-clause + ^predicate <new-pred> +)
    (<new-pred> ^type state + ^handle visible1 + ^1 <obj1> +)
    (<arg-info> ^created <new-clause> +)
}

sp {generate-action-operator*apply*create-operator-argument*arg-type*until-clause*state*predicate
    (state <s> ^name generate-action-operator ^operator <o>
          ^action-operator <op>)
    (<o> ^name create-operator-argument ^argument-info <arg-info>)
    (<arg-info> ^arg-type until-clause ^predicate <pred>)
    (<pred> ^type state ^handle { <> visible1 <handle> } ^1 <obj1>)
    -->
    (<op> ^until-clause <new-clause> +)
    (<new-clause> ^arg-type until-clause + ^predicate <new-pred> +)
    (<new-pred> ^type state + ^handle <handle> + ^1 <obj1> +)
    (<arg-info> ^created <new-clause> +)
}

sp {generate-action-operator*apply*create-operator-argument*predicate
    (state <s> ^name generate-action-operator ^operator <o>
          ^action-operator <op>)
    (<o> ^name create-operator-argument ^argument-info <arg-info>)
    (<arg-info> ^arg-type predicate ^arg-name <arg-name> ^2 <obj2>
          ^handle <pred-handle>)
    -->
    (<op> ^<arg-name> <arg> +)
    (<arg> ^arg-type predicate + ^handle <pred-handle> + ^2 <obj2> +)
    (<arg-info> ^created <arg> +)
}

sp {generate-action-operator*apply*create-operator-argument*copy*concept*arg
    (state <s> ^name generate-action-operator ^operator <o>
          ^action-operator <op>)
    (<o> ^name create-operator-argument ^argument-info <arg-info>)
    (<arg-info> ^arg-type concept ^arg-name <arg-name>
          ^handle <concept-handle>)
    -->
    (<op> ^<arg-name> <arg> +)
    (<arg> ^arg-type concept + ^handle <concept-handle> +)
    (<arg-info> ^created <arg> +)
}

sp {generate-action-operator*apply*create-operator-argument*copy*object*arg
    (state <s> ^name generate-action-operator ^operator <o>
          ^action-operator <op>)
    (<o> ^name create-operator-argument ^argument-info <arg-info>)
    (<arg-info> ^arg-type object ^arg-name <arg-name> ^id <obj>)
    -->
    (<op> ^<arg-name> <arg> +)
    (<arg> ^arg-type object + ^id <obj> +)
    (<arg-info> ^created <arg> +)
}

sp {generate-action-operator*propose*create-operator-argument
    (state <s> ^name generate-action-operator ^argument-info <arg-info>
          ^action-operator <op>)
    (<arg-info> -^created <arg> ^arg-name <arg-name>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name create-operator-argument + ^argument-info <arg-info> +)
}

sp {generate-action-operator*apply*create-action-operator*mark*learn-proposal
    (state <s> ^name generate-action-operator ^operator <o>
          ^action-operator <op>)
    (<o> ^name create-action-operator ^action-id <a*1>)
    (<a*1> ^learn-proposal <bool>)
    -->
    (<op> ^learn-proposal <bool> +)
}

sp {generate-action-operator*apply*create-action-operator*copy*operator*name
    (state <s> ^name generate-action-operator ^operator <o>
          ^action-operator <op>)
    (<o> ^name create-action-operator ^action-id <a*1>)
    (<a*1> ^procedural <p*1>)
    (<p*1> ^op_name <name>)
    -->
    (<op> ^name <name> +)
}

sp {generate-action-operator*apply*create-action-operator
    (state <s> ^name generate-action-operator ^operator <o>)
    (<o> ^name create-action-operator ^action-id <id>)
    (<id> ^handle <action-handle>)
    -->
    (<s> ^action-operator <op> +)
    (<op> ^action-handle <action-handle> +)
}

sp {generate-action-operator*propose*create-action-operator
    (state <s> ^name generate-action-operator ^action-id <id>)
   -{ (<s> ^action-operator <a*1>)
      (<a*1> ^name <n*1>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name create-action-operator + ^action-id <id> +)
}

sp {generate-action-operator*apply*create-procedural-argument*predicate
    (state <s> ^name generate-action-operator ^operator <o> ^action-id <a*1>)
    (<o> ^name create-procedural-argument ^argument-info <arg-info>)
    (<arg-info> ^arg-type predicate ^arg-status <status> ^arg-name <arg-name>)
    (<a*1> ^procedural <proc>)
    -->
    (<proc> ^<arg-name> <parg> +)
    (<parg> ^arg-type predicate + ^arg-status <status> + ^importance unknown +
           ^id <new-pred-slot> + ^2 <new-obj-slot> +)
    (<arg-info> ^created-procedural-argument true +)
    (<s> ^to-store <proc> + ^to-store <parg> +)
}

sp {generate-action-operator*apply*create-procedural-argument*concept
    (state <s> ^name generate-action-operator ^operator <o> ^action-id <a*1>)
    (<o> ^name create-procedural-argument ^argument-info <arg-info>)
    (<arg-info> ^arg-type concept ^arg-status <status> ^arg-name <arg-name>)
    (<a*1> ^procedural <proc>)
    -->
    (<proc> ^<arg-name> <parg> +)
    (<parg> ^arg-type concept + ^arg-status <status> + ^importance unknown +
           ^id <new-conc-slot> +)
    (<arg-info> ^created-procedural-argument true +)
    (<s> ^to-store <proc> + ^to-store <parg> +)
}

sp {generate-action-operator*apply*create-procedural-argument*object
    (state <s> ^name generate-action-operator ^operator <o> ^action-id <a*1>)
    (<o> ^name create-procedural-argument ^argument-info <arg-info>)
    (<arg-info> ^arg-type object ^arg-status <status> ^arg-name <arg-name>)
    (<a*1> ^procedural <proc>)
    -->
    (<proc> ^<arg-name> <parg> +)
    (<parg> ^arg-type object + ^arg-status <status> + ^importance unknown +
           ^id <new-obj-slot> +)
    (<arg-info> ^created-procedural-argument true +)
    (<s> ^to-store <proc> + ^to-store <parg> +)
}

sp {generate-action-operator*propose*create-procedural-argument
    (state <s> ^name generate-action-operator ^action-id <a*1>
          ^argument-info <arg-info>)
    (<a*1> ^procedural <proc>)
    (<arg-info> ^arg-name <arg-name>
          ^arg-type { << object concept predicate >> <a*2> })
    (<proc> -^<arg-name> <a*3>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name create-procedural-argument + ^argument-info <arg-info> +)
}

sp {generate-action-operator*apply*create-semantic-structure
    (state <s> ^name generate-action-operator ^operator <o*1>
          ^action-id <action-id>)
    (<o*1> ^name create-semantic-structure)
    (<action-id> ^handle <handle>)
    -->
    (<action-id> ^item-type action + ^procedural <proc> +)
    (<proc> ^op_name (make-constant-symbol (concat |op_| <handle>)) +)
    (<s> ^to-store <action-id> + ^to-store <proc> + ^new-action true +)
}

sp {generate-action-operator*propose*create-semantic-structure
    (state <s> ^name generate-action-operator ^action-id <action-id>)
    (<action-id> -^procedural <p*1>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-semantic-structure +)
}

sp {generate-action-operator*worst*preference*complete-generate-action-operator
    (state <s> ^name generate-action-operator ^operator <o> +)
    (<o> ^name complete-generate-action-operator)
    -->
    (<s> ^operator <o> <)
}

sp {generate-action-operator*prefer*mark*arguments*over*others
    (state <s> ^name generate-action-operator ^operator <o2> +
          ^operator <o1> +)
    (<o2> ^name { << store-concepts >> <n*2> })
    (<o1> ^name { << mark-argument-optional mark-argument-missing >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {generate-action-operator*prefer*create*operator*structures*over*others
    (state <s> ^name generate-action-operator ^operator <o2> +
          ^operator <o1> +)
    (<o2>
          ^name { << mark-argument-optional mark-argument-missing store-concepts >> <n*2> })
    (<o1>
          ^name { << create-action-operator create-operator-argument >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {generate-action-operator*prefer*add-argument-to-world*over*others
    (state <s> ^name generate-action-operator ^operator <o2> +
          ^operator <o1> +)
    (<o2>
          ^name { << create-action-operator create-operator-argument mark-argument-optional store-concepts >> <n*2> })
    (<o1> ^name { << add-argument-to-world >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {generate-action-operator*prefer*add-argument-to-world*object*over*predicate
    (state <s> ^name generate-action-operator ^operator <o2> +
          ^operator <o1> +)
    (<o2> ^arg-type predicate ^name add-argument-to-world)
    (<o1> ^arg-type object ^name add-argument-to-world)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {generate-action-operator*prefer*create*semantic*structures*over*others
    (state <s> ^name generate-action-operator ^operator <o2> +
          ^operator <o1> +)
    (<o2>
          ^name { << add-argument-to-world create-action-operator create-operator-argument mark-argument-optional store-concepts >> <n*2> })
    (<o1>
          ^name { << create-semantic-structure create-procedural-argument >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {generate-action-operator*elaborate*argument-info*predicate*arg-status*desired
    (state <s> ^name generate-action-operator ^predicate-lti <pred-info>
          ^argument-info <arg-info>)
    (<pred-info> ^relation-type desired ^handle <pred-handle>)
   -{ (<arg-info> ^procedural <p*1>)
      (<p*1> ^arg-status <a*1>)}
    (<arg-info> ^arg-type predicate ^handle <pred-handle>)
    -->
    (<arg-info> ^arg-status desired +)
}

sp {generate-action-operator*elaborate*argument-info*predicate*arg-status*existing
    (state <s> ^name generate-action-operator ^predicate-lti <pred-info>
          ^argument-info <arg-info>)
    (<pred-info> ^relation-type existing ^handle <pred-handle>)
   -{ (<arg-info> ^procedural <p*1>)
      (<p*1> ^arg-status <a*1>)}
    (<arg-info> ^arg-type predicate ^handle <pred-handle>)
    -->
    (<arg-info> ^arg-status existing +)
}

sp {generate-action-operator*elaborate*argument-info*concept*arg-status*default*real
    (state <s> ^name generate-action-operator ^argument-info <arg-info>)
   -{ (<arg-info> ^procedural <p*1>)
      (<p*1> ^arg-status <a*1>)}
    (<arg-info> ^arg-type concept)
    -->
    (<arg-info> ^arg-status abstract +)
}

sp {generate-action-operator*elaborate*argument-info*object*arg-status*default*real
    (state <s> ^name generate-action-operator ^argument-info <arg-info>)
   -{ (<arg-info> ^procedural <p*1>)
      (<p*1> ^arg-status <a*1>)}
    (<arg-info> ^arg-type object)
    -->
    (<arg-info> ^arg-status real +)
}

sp {generate-action-operator*elaborate*argument-info*object*arg-status*from*procedural
    (state <s> ^name generate-action-operator ^argument-info <arg-info>)
    (<arg-info> ^procedural <p*1> ^arg-type <any>)
    (<p*1> ^arg-status <status>)
    -->
    (<arg-info> ^arg-status <status> +)
}

sp {generate-action-operator*elaborate*object*from*world*matches*source*handle*abstract
    (state <s> ^name generate-action-operator ^argument-info <arg-info>)
    (<arg-info> ^arg-status abstract ^obj-source <o*3>)
    (<o*3> ^<name> <src>)
    (<src> -^object-instance <o*4> ^handle <handle>)
   -{ (<s> ^world <w*1>)
      (<w*1> ^objects <o*1>)
      (<o*1> ^object <o*2>)
      (<o*2> ^handle <handle>)}
    -->
    (<arg-info> ^<name> <src> +)
}

sp {generate-action-operator*elaborate*object*from*world*matches*source*handle*until-clause
    (state <s> ^name generate-action-operator ^argument-info <arg-info>
          ^world <w*1>)
    (<arg-info> ^arg-type until-clause ^predicate <pred>)
    (<pred> ^obj-source <o*2>)
    (<w*1> ^objects <o*1>)
    (<o*2> ^<name> <n*1>)
    (<n*1> ^handle <handle>)
    (<o*1> ^object <wobj>)
    (<wobj> ^handle <handle>)
    -->
    (<pred> ^<name> <wobj> +)
}

sp {generate-action-operator*elaborate*object*from*world*matches*source*handle
    (state <s> ^name generate-action-operator ^argument-info <arg-info>
          ^world <w*1>)
    (<arg-info> ^obj-source <o*2>)
    (<w*1> ^objects <o*1>)
    (<o*2> ^<name> <n*1>)
    (<n*1> ^handle <handle>)
    (<o*1> ^object <wobj>)
    (<wobj> ^handle <handle>)
    -->
    (<arg-info> ^<name> <wobj> +)
}

sp {generate-action-operator*elaborate*argument-info*procedural
    (state <s> ^name generate-action-operator ^action-id <a*1>
          ^argument-info <arg-info>)
    (<a*1> ^procedural <p*1>)
    (<arg-info> ^arg-name <arg-name>)
    (<p*1> ^<arg-name> <parg>)
    -->
    (<arg-info> ^procedural <parg> +)
}

sp {generate-action-operator*elaborate*argument-info*until-clause*predicate*visible
    (state <s> ^name generate-action-operator ^command-message <c*1>)
    (<c*1> ^<arg-name> <a*1>)
    (<a*1> ^until-clause <until>)
    (<until> ^agent <a*3> ^action <a*2> ^arg1 <obj>)
    (<a*3> ^handle rosie)
    (<a*2> ^handle sense1)
    -->
    (<s> ^argument-info <arg-info> +)
    (<arg-info> ^arg-name until-clause + ^arg-type until-clause +
           ^predicate <pred> +)
    (<pred> ^type state + ^handle visible1 + ^obj-source <o*1> +)
    (<o*1> ^1 <obj> +)
}

sp {generate-action-operator*elaborate*argument-info*predicate*arg2*relation*arg1
    (state <s> ^name generate-action-operator ^command-message <msg>)
    (<msg> ^arg2 <a*1>)
    (<a*1> ^2 <v*1>)
    (<v*1> ^relations <arg1>)
    (<arg1> ^2 <obj1> ^handle <handle>)
    -->
    (<s> ^argument-info <arg-info> +)
    (<arg-info> ^arg-name arg1 + ^arg-type predicate + ^handle <handle> +
           ^obj-source <o*1> +)
    (<o*1> ^2 <obj1> +)
}

sp {generate-action-operator*elaborate*argument-info*predicate*pred*rel*arg2
    (state <s> ^name generate-action-operator ^command-message <msg>)
    (<msg> ^{ << predicate relation >> <a*1> } <arg>)
    (<arg> -^until-clause <u*1> ^item-type predicate ^2 <obj2>
          ^handle <handle>)
    -->
    (<s> ^argument-info <arg-info> +)
    (<arg-info> ^arg-name arg2 + ^arg-type predicate + ^handle <handle> +
           ^obj-source <o*1> +)
    (<o*1> ^2 <obj2> +)
}

sp {generate-action-operator*elaborate*argument-info*predicate*arg
    (state <s> ^name generate-action-operator ^command-message <msg>)
    (<msg> ^{ << arg1 arg2 arg3 arg4 arg5 >> <arg-name> } <arg>)
    (<arg> -^until-clause <u*1> ^item-type predicate ^2 <obj2>
          ^handle <handle>)
    -->
    (<s> ^argument-info <arg-info> +)
    (<arg-info> ^arg-name <arg-name> + ^arg-type predicate +
           ^handle <handle> + ^obj-source <o*1> +)
    (<o*1> ^2 <obj2> +)
}

sp {generate-action-operator*elaborate*argument-info*concept
    (state <s> ^name generate-action-operator ^command-message <msg>)
    (<msg> ^<arg-name> <arg>)
    (<arg> ^item-type concept ^handle <handle>)
    -->
    (<s> ^argument-info <arg-info> +)
    (<arg-info> ^arg-name <arg-name> + ^arg-type concept + ^handle <handle> +)
}

sp {generate-action-operator*elaborate*argument-info*object*linked
    (state <s> ^name generate-action-operator ^command-message <msg>)
    (<msg> ^<arg-name> <arg>)
    (<arg> ^item-type object ^linked-to <other>)
    -->
    (<s> ^argument-info <arg-info> +)
    (<arg-info> ^arg-name <arg-name> + ^arg-type object + ^obj-source <o*1> +)
    (<o*1> ^id <other> +)
}

sp {generate-action-operator*elaborate*argument-info*object
    (state <s> ^name generate-action-operator ^command-message <msg>)
    (<msg> ^<arg-name> <arg>)
    (<arg> -^linked-to <l*1> ^item-type object)
    -->
    (<s> ^argument-info <arg-info> +)
    (<arg-info> ^arg-name <arg-name> + ^arg-type object + ^obj-source <o*1> +)
    (<o*1> ^id <arg> +)
}

sp {generate-action-operator*elaborate*argument-info*message
    (state <s> ^name generate-action-operator ^command-message <msg>)
    (<msg> ^arg1 <a*2> ^action <a*1>)
    (<a*2> ^sentence <sentence>)
    (<a*1> ^handle { << say1 ask1 >> <h*1> })
    -->
    (<s> ^argument-info <arg-info> +)
    (<arg-info> ^arg-name arg1 + ^arg-type object + ^id <new-obj> +)
    (<new-obj> ^handle (make-constant-symbol obj-hand) +
           ^predicates <obj-preds> +)
    (<obj-preds> ^category message + ^sentence <sentence> +)
}

sp {generate-action-operator*elaborate*smem-query*result*predicate-lti
    (state <s> ^name generate-action-operator ^smem-query <q>
          ^command-message <c*1>)
    (<q> ^cue <c*2> ^result <pred-lti>)
    (<c*2> ^handle <pred-handle>)
    (<c*1> ^<any> <arg>)
    (<arg> ^handle <pred-handle>
          ^item-type { << concept predicate property >> <i*1> })
    -->
    (<s> ^predicate-lti <pred-lti> +)
}

sp {generate-action-operator*elaborate*smem-query*predicate
    (state <s> ^name generate-action-operator ^command-message <c*1>)
    (<c*1> ^<any> <arg>)
    (<arg> ^item-type { << concept predicate property >> <i*1> }
          ^handle <pred-handle>)
    -->
    (<s> ^smem-query <q> +)
    (<q> ^cue <c*2> + ^depth 4 +)
    (<c*2> ^handle <pred-handle> +)
}

sp {generate-action-operator*elaborate*smem-query*result*action-id
    (state <s> ^name generate-action-operator ^smem-query <q>
          ^command-message <c*1>)
    (<c*1> ^action <a*1>)
    (<a*1> ^handle <action-handle>)
    (<q> ^cue <c*2> ^result <action-lti>)
    (<c*2> ^handle <action-handle>)
    -->
    (<s> ^action-id <action-lti> +)
}

sp {generate-action-operator*elaborate*smem-query*action
    (state <s> ^name generate-action-operator ^command-message <c*1>)
    (<c*1> ^action <a*1>)
    (<a*1> ^handle <action-handle>)
    -->
    (<s> ^smem-query <q> +)
    (<q> ^cue <c*2> + ^depth 8 +)
    (<c*2> ^handle <action-handle> +)
}

sp {generate-action-operator*elaborate*message*from*superoperator
    (state <s> ^name generate-action-operator ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^command-message <msg>)
    -->
    (<s> ^command-message <msg> +)
}

sp {generate-action-operator*elaborate*world*from*superstate
    (state <s> ^name generate-action-operator ^superstate <s*1>)
    (<s*1> ^world <world>)
    -->
    (<s> ^world <world> +)
}

sp {execute-action*apply*remove-start-of-execution-flag
    (state <s> ^name execute-action ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name remove-start-of-execution-flag)
    (<t*1> ^action-stack <a*1>)
    (<a*1> ^top <top>)
    (<top> ^start-of-execution <flag>)
    -->
    (<top> ^start-of-execution <flag> -)
}

sp {execute-action*propose*remove-start-of-execution-flag
    (state <s> ^name execute-action ^top-state <t*1>)
    (<t*1> ^action-stack <a*1>)
    (<a*1> ^top <top>)
    (<top> ^start-of-execution <flag>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name remove-start-of-execution-flag +)
}

sp {execute-action*elaborate*problem-space
    (state <s> ^name execute-action)
    -->
    (<s> ^problem-space <ps> +)
    (<ps> ^name action + ^action <action> + ^world <world> +
           ^learning <learn> +)
    (<world> ^copy-type shallow +)
    (<action> ^type execute +)
    (<learn> ^type exploration +)
}

sp {execute-action*prefer*remove-start-of-execution-flag*over*others
    (state <s> ^name execute-action ^operator <o2> + ^operator <o1> +)
    (<o2> -^name remove-start-of-execution-flag)
    (<o1> ^name remove-start-of-execution-flag)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {execute-action*elaborate*child-action*superoperator
    (state <s> ^name execute-action ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^action <a>)
    -->
    (<s> ^child-action <a> +)
}

sp {problem-space*action*apply*report-failure-unmatched-action*add*interaction*status
    (state <s> ^operator <o*1> ^problem-space <p*1> ^top-state <t*1>)
    (<o*1> ^name report-failure-unmatched-action)
    (<p*1> ^name action)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^failure <f> +)
    (<f> ^type no-proposed-action +)
}

sp {problem-space*action*apply*report-failure-missing-argument*report-failure
    (state <s> ^operator <o> ^problem-space <p*1> ^top-state <t*1>)
    (<o> ^name report-failure-missing-argument ^arg-name <arg-name>
          ^action-operator <aop>)
    (<p*1> ^name action)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^failure <f> +)
    (<f> ^type missing-argument + ^arg-name <arg-name> +
           ^action-operator <aop> +)
}

sp {problem-space*action*propose*report-failure-missing-argument*missing*required*arg
    (state <s> ^problem-space <p*1> ^action-id <a*1> ^action-operator <aop>)
    (<p*1> ^name action)
    (<a*1> ^procedural <p*2>)
    (<p*2> ^<arg-name> <parg>)
    (<aop> -^<arg-name> <a*2>)
    (<parg> ^importance required ^arg-type <any>)
    -->
    (<s> ^operator <o> + ^operator <o> > ^operator <o> =)
    (<o> ^name report-failure-missing-argument + ^action-operator <aop> +
           ^arg-name <arg-name> +)
}

sp {problem-space*action*apply*report-failure-multiple-arguments*report-failure
    (state <s> ^failure <f> ^operator <o*1> ^problem-space <p*1>
          ^top-state <t*1>)
    (<f> ^copied-preds true)
    (<o*1> ^name report-failure-multiple-arguments)
    (<p*1> ^name action)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^failure <f> +)
}

sp {problem-space*action*apply*report-failure-multiple-arguments*create*copied-preds*flag
    (state <s> ^operator <o*1> ^problem-space <p*1> ^failure <f>)
    (<o*1> ^name report-failure-multiple-arguments)
    (<p*1> ^name action)
    (<f> ^argument-info <a*1>)
    (<a*1> ^predicates <preds>)
    -->
    (<f> ^copied-preds true +)
}

sp {problem-space*action*apply*report-failure-multiple-arguments*copy*predicates
    (state <s> ^operator <o> ^problem-space <p*1> ^failure <f*1>)
    (<o> ^name report-failure-multiple-arguments ^argument <a*2>)
    (<p*1> ^name action)
    (<f*1> ^argument-info <a*1>)
    (<a*1> ^predicates <preds>)
    (<a*2> ^<any> <arg1>)
    (<arg1> ^item-type object ^predicates <p*2>)
    (<p*2> ^{ << color shape size category name >> <prop> } <pred>)
   -{ (<o> ^argument <a*3>)
      (<a*3> ^<any> { <> <arg1> <arg2> })
     -{ (<arg2> ^predicates <p*3>)
        (<p*3> ^<prop> <pred>)}}
    -->
    (<preds> ^<prop> <pred> +)
}

sp {problem-space*action*apply*report-failure-multiple-arguments*create*failure
    (state <s> ^operator <o> ^problem-space <p*1>)
    (<o> ^name report-failure-multiple-arguments ^arg-name <arg-name>
          ^action-operator <aop>)
    (<p*1> ^name action)
    -->
    (<s> ^failure <f> +)
    (<f> ^type multiple-arguments + ^arg-name <arg-name> +
           ^action-operator <aop> + ^argument-info <arg-info> +)
    (<arg-info> ^item-type object + ^predicates <preds> +)
}

sp {problem-space*action*composite*elaborate*report-failure-multiple-arguments*argument
    (state <s> ^operator <o> + ^problem-space <p*1> ^action-operator <aop>)
    (<o> ^name report-failure-multiple-arguments ^arg-name <arg-name>)
    (<p*1> ^name action)
    (<aop> ^<arg-name> <arg>)
    -->
    (<o> ^argument <arg> +)
}

sp {problem-space*action*composite*propose*report-failure-multiple-arguments
    (state <s> ^problem-space <p*1> ^action-operator <aop>)
    (<p*1> ^name action)
    (<aop> ^<arg-name> <arg2> ^<arg-name> { <> <arg2> <arg1> })
    (<arg1> ^arg-type <any>)
    -->
    (<s> ^operator <o> + ^operator <o> > ^operator <o> =)
    (<o> ^name report-failure-multiple-arguments + ^action-operator <aop> +
           ^arg-name <arg-name> +)
}

sp {problem-space*action*apply*report-failure-unknown-goal*add*interaction*status
    (state <s> ^operator <o> ^problem-space <p*1> ^top-state <t*1>)
    (<o> ^name report-failure-unknown-goal ^action-operator <aop>)
    (<p*1> ^name action)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^failure <f> +)
    (<f> ^type unknown-goal + ^action <aop> +)
}

sp {action*apply*matched*action*remove*unmatched*arguments
    (state <s> ^match-action <ma> ^operator <o> ^problem-space <p*1>)
    (<ma> ^match-info <m*1> ^action-operator <aop>)
    (<m*1> ^op-info <op-info>)
    (<op-info> ^argument-name <arg-name> ^matches <arg-name> ^operator <o>
          -^matches-arg <arg>)
    (<aop> ^<arg-name> <arg>)
    (<p*1> ^name <n*1>)
    -->
    (<aop> ^<arg-name> <arg> -)
}

sp {action*elaborate*action*operator*predicate*default-handle
    (state <s> ^problem-space <p*1> ^operator <o> + ^problem-space <p*2>)
    (<p*1> ^name action)
    (<o> ^arg2 <arg2> ^name <op-name>)
    (<arg2> ^arg-type predicate ^default-handle <def>
          -^handle { <> <def> <h*1> })
    (<p*2> ^action <a*1>)
    (<a*1> ^type <any>)
    -->
    (<arg2> ^handle <def> +)
}

sp {action*elaborate*put-down*relation*from*desired
    (state <s> ^operator <o> + ^problem-space <p*1> ^desired <d*1>
          ^problem-space <p*2>)
    (<o> ^name op_put-down1 ^arg2 <arg2> ^arg1 <a*2>)
    (<p*1> ^name action)
    (<d*1> ^predicate <rel-pred>)
    (<rel-pred> ^type relation ^2 <obj2> ^1 <obj1> ^handle <rel-handle>)
    (<arg2> ^2 <obj2>)
    (<a*2> ^id <obj1>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type <any>)
    -->
    (<arg2> ^handle <rel-handle> +)
}

sp {action*elaborate*put-down*relation*from*action-operator
    (state <s> ^operator <o> + ^problem-space <p*1> ^action-to-match <a*2>
          ^problem-space <p*2>)
    (<o> ^name op_put-down1 ^arg2 <arg2>)
    (<p*1> ^name action)
    (<a*2> ^arg2 <a*3>)
    (<a*3> ^handle <rel-handle>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type <any>)
    -->
    (<arg2> ^handle <rel-handle> +)
}

sp {action*elaborate*operator*until-clause*from*action-operator
    (state <s> ^problem-space <p*1> ^match-action <m*2> ^match-action <m*1>
          ^operator <o> + ^problem-space <p*2>)
    (<p*1> ^name action)
    (<m*1> ^matched <o>)
    (<m*2> ^action-operator <a*2>)
    (<a*2> ^until-clause <until>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type <any>)
    -->
    (<o> ^until-clause <until> +)
}

sp {action*selection*apply*report-policy-learning-needed*mark*needed
    (state <s> ^name selection ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name report-policy-learning-needed)
    (<t*1> ^action-stack <a*1>)
    (<a*1> ^top <action>)
    -->
    (<action> ^policy-learning-needed true +)
}

sp {action*selection*propose*report-policy-learning-needed*top-selection
    (state <s> ^name selection ^impasse tie ^attribute operator
          ^top-state <t*1> ^superstate <s*1> ^problem-space <p*1>)
    (<t*1> ^action-stack <a*1>)
    (<a*1> ^top <action>)
    (<action> -^policy-learning-needed <p*3>)
    (<s*1> ^problem-space <p*2>)
    (<p*2> ^name action)
    (<p*1> ^learning <l*1>)
    (<l*1> ^type exploration)
    -->
    (<s> ^operator <o> + ^operator <o> = ^operator <o> >)
    (<o> ^name report-policy-learning-needed +)
}

sp {action*selection*apply*achieved-max-depth*mark*policy-learning-needed
    (state <s> ^name selection ^operator <o*1> ^problem-space <p*1>
          ^top-state <t*1>)
    (<o*1> ^name achieved-max-depth)
    (<p*1> ^name action)
    (<t*1> ^action-stack <a*1>)
    (<a*1> ^top <action>)
    -->
    (<action> ^policy-learning-needed true +)
}

sp {action*selection*apply*achieved-max-depth*report-no-action-selection-knowledge
    (state <s> ^name selection ^operator <o*1> ^problem-space <p*1>
          ^top-state <t*1>)
    (<o*1> ^name achieved-max-depth)
    (<p*1> ^name action)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^failure <f*1> +)
    (<f*1> ^type no-action-selection-knowledge +)
}

sp {action*selection*learning*retrospective*elaborate*current-subaction
    (state <s> ^name selection ^problem-space <p*1> ^subactions <s*1>
          ^problem-space <p*2>)
    (<p*1> ^name action)
    (<s*1> ^next <sub>)
    (<p*2> ^learning <l*1>)
    (<l*1> ^type retrospective)
    -->
    (<s> ^match-action <m*1> +)
    (<m*1> ^action-operator <sub> +)
}

sp {action*selection*apply*init-current-evaluation-depth*zero*no*goal
    (state <s> ^top-selection true ^operator <o> ^problem-space <p*1>
          ^problem-space <p*2>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^desired <d*1>)
      (<d*1> ^predicate <p*3>)}
    (<o> ^name init-current-evaluation-depth)
    (<p*1> ^name action)
    (<p*2> ^learning <l*1>)
    (<l*1> ^type exploration)
    -->
    (<s> ^max-evaluation-depth 0 +)
}

sp {action*selection*apply*init-current-evaluation-depth*max
    (state <s> ^top-selection true ^operator <o> ^problem-space <p*1>
          ^agent-params <a*1> ^superstate <s*1> ^problem-space <p*2>)
    (<o> ^name init-current-evaluation-depth)
    (<p*1> ^name action)
    (<a*1> ^action-search-depth <d>)
    (<s*1> ^desired <d*1>)
    (<d*1> ^predicate <any>)
    (<p*2> ^learning <l*1>)
    (<l*1> ^type exploration)
    -->
    (<s> ^max-evaluation-depth <d> +)
}

sp {games*selection*elaborate*evaluate-operator*default-desired-copy
    (state <s> ^problemspace games ^operator <o> +)
    (<o> ^name evaluate-operator)
    -->
    (<o> ^default-desired-copy yes + ^default-operator-copy yes +)
}

sp {action*selection*elaborate*evaluate-operator*default-desired-copy
    (state <s> ^operator <o> + ^problem-space <p*1>)
    (<o> ^name evaluate-operator)
    (<p*1> ^name action)
    -->
    (<o> ^default-desired-copy yes + ^default-operator-copy yes +)
}

sp {action*selection*learning*retrospective*elaborate*learning*use*chunking
    (state <s> ^name selection ^problem-space <ps>)
    (<ps> ^name action ^learning <learn>)
    (<learn> ^type retrospective)
    -->
    (<learn> ^use chunking +)
}

sp {action*selection*retrospective*elaborate*problem-space*subactions*copy-type
    (state <s> ^name selection ^problem-space <ps>)
    (<ps> ^name action ^learning <l*1>)
    (<l*1> ^type retrospective)
    -->
    (<ps> ^subactions <s*1> +)
    (<s*1> ^copy-type shallow +)
}

sp {action*problem-space*evaluate-operator*apply*look-ahead-operator*retrospective*advance*subaction
    (state <s> ^name evaluate-operator ^look-ahead-operator <o> ^operator <o>
          ^subactions <subs>)
    (<subs> ^next <cur>)
    (<cur> ^next <next>)
    -->
    (<subs> ^next <cur> - ^next <next> +)
}

sp {action*evaluate-operator*learning*retrospective*elaborate*problem-space*subactions*copy-type
    (state <s> ^name evaluate-operator ^problem-space <ps>)
    (<ps> ^name action ^learning <l*1>)
    (<l*1> ^type retrospective)
    -->
    (<ps> ^subactions <s*1> +)
    (<s*1> ^copy-type deep +)
}

sp {action*selection*evaluate-operator*elaborate*problem-space
    (state <s> ^name evaluate-operator ^superstate <s*1>)
    (<s*1> ^problem-space <p*1>)
    (<p*1> ^name action)
    -->
    (<s> ^problem-space <ps> +)
    (<ps> ^name action + ^default-state-copy no + ^default-operator-copy yes +
           ^default-desired-copy yes + ^action <action> + ^world <world> +
           ^learning <learn> +)
    (<action> ^type simulate + ^propose-action-operators true +)
    (<world> ^copy-type deep +)
}

sp {action*selection*evaluate-operator*elaborate*desired*success
    (state <s> ^name evaluate-operator ^desired <d> ^problem-space <p*1>)
    (<d> ^satisfied true)
    (<p*1> ^name action)
    -->
    (<s> ^success <d> +)
}

sp {action-operator-tie*elaborate*elaborate*report-failure-multiple-arguments*argument
    (state <s> ^name action-operator-tie ^operator <o> + ^item <item>
          ^superstate <s*1>)
    (<o> ^name report-failure-multiple-arguments ^arg-name <arg-name>)
    (<s*1> ^match-action <m*1>)
    (<m*1> ^match-info <m*2>)
    (<m*2> ^op-info <op-info>)
    (<op-info> ^argument-name <arg-name> ^operator <item> ^matches-arg <arg>)
    -->
    (<o> ^argument <arg> +)
}

sp {action*operator-tie*propose*report-failure-multiple-arguments
    (state <s> ^name action-operator-tie ^duplicated-argument <arg-name>
          ^superstate <s*1>)
    (<s*1> ^match-action <m*1>)
    (<m*1> ^action-operator <aop>)
    -->
    (<s> ^operator <o> + ^operator <o> > ^operator <o> =)
    (<o> ^name report-failure-multiple-arguments + ^action-operator <aop> +
           ^arg-name <arg-name> +)
}

sp {action*operator-tie*propose*report-failure-unmatched-action
    (state <s> ^name action-operator-tie ^unmatched <o> ^item <o>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name report-failure-unmatched-action +)
}

sp {action*operator-tie*propose*report-failure-missing-argument
    (state <s> ^name action-operator-tie ^superstate <s*1>)
    (<s*1> ^match-action <m*1>)
    (<m*1> ^action-operator <aop>)
    (<aop> ^missing-argument <arg-name>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name report-failure-missing-argument + ^action-operator <aop> +
           ^arg-name <arg-name> +)
}

sp {action-operator-tie*prefer*report-failure*unmatched*over*others
    (state <s> ^name action-operator-tie ^operator <o2> + ^operator <o1> +)
    (<o2> ^name report-failure-multiple-arguments)
    (<o1> ^name report-failure-unmatched-action)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {action-operator-tie*prefer*report-failure*missing*over*others
    (state <s> ^name action-operator-tie ^operator <o1> + ^operator <o2> +)
    (<o1> ^name report-failure-missing-argument)
    (<o2>
          ^name { << report-failure-multiple-arguments report-failure-unmatched-action >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {multiple-argument-instantiations*elaborate*duplicated-argument
    (state <s> ^name action-operator-tie ^item <o2> ^item { <> <o2> <o1> }
          ^superstate <s*1>)
    (<s*1> ^match-action <ma>)
    (<ma> ^match-info <info>)
    (<info> ^op-info <info2> ^op-info <info1>)
    (<info2> ^operator <o2> ^argument-name <arg-name> ^matches-arg <arg2>)
    (<info1> ^operator <o1> ^argument-name <arg-name>
          ^matches-arg { <> <arg2> <arg1> })
    -->
    (<s> ^duplicated-argument <arg-name> +)
}

sp {action*operator-tie*elaborate*unmatched*operator
    (state <s> ^name action-operator-tie ^item <o> ^superstate <s*1>)
    (<s*1> ^match-action <ma>)
    (<ma> -^matched <o>)
    -->
    (<s> ^unmatched <o> +)
}

sp {action*operator-tie*elaborate*matched*operator
    (state <s> ^name action-operator-tie ^item <o> ^superstate <s*1>)
    (<s*1> ^match-action <m*1>)
    (<m*1> ^matched <o>)
    -->
    (<s> ^matched <o> +)
}

sp {action*operator-tie*elaborate*state*name*action-operator-tie
    (state <s> ^impasse tie ^attribute operator ^superstate <s*2>
          ^superstate <s*1>)
    (<s*2> ^match-action <ma>)
    (<s*1> ^problem-space <p*1>)
    (<p*1> ^name action)
    -->
    (<s> ^name action-operator-tie + ^problem-space <ps> +)
    (<ps> ^name action + ^action <action> +)
}

sp {action*operator-tie*elaborate*state*name*selection
    (state <s> ^impasse tie ^attribute operator ^superstate <s*1>)
   -{ (<s> ^superstate <s*2>)
      (<s*2> ^match-action <m*1>)}
    (<s*1> ^problem-space <p*1>)
    (<p*1> ^name action)
    -->
    (<s> ^name selection + ^problem-space <ps> +)
    (<ps> ^name action + ^default-state-copy no + ^action <action> +
           ^world <world> + ^learning <learn> +)
    (<action> ^type simulate +)
    (<world> ^copy-type shallow +)
}

sp {learn-desired-elaboration-rule*apply*complete-learn-desired-elaboration-rule
    (state <s> ^name learn-desired-elaboration-rule ^operator <o*1>
          ^desired <des> ^superstate <ss>)
    (<o*1> ^name complete-learn-desired-elaboration-rule)
    -->
    (<ss> ^desired <des> +)
}

sp {learn-desired-elaboration-rule*propose*complete-learn-desired-elaboration-rule
    (state <s> ^name learn-desired-elaboration-rule ^desired <des>)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete-learn-desired-elaboration-rule +)
}

sp {learn-desired-elaboration-rule*apply*create-emptpy-goal
    (state <s> ^name learn-desired-elaboration-rule ^operator <o*1>
          ^superstate <ss>)
    (<o*1> ^name create-empty-goal)
    -->
    (<ss> ^desired <des> +)
}

sp {learn-desired-elaboration-rule*propose*create-emptpy-goal
    (state <s> ^name learn-desired-elaboration-rule)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name create-empty-goal +)
}

sp {action-learn-desired-elaboration-rule*prefer*complete*over*return-empty
    (state <s> ^name learn-desired-elaboration-rule ^operator <o2> +
          ^operator <o1> +)
    (<o2> ^name create-empty-goal)
    (<o1> ^name complete-learn-desired-elaboration-rule)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {action*learn-desired-elaboration-rule*reject*ground-argument*abstract
    (state <s> ^name learn-desired-elaboration-rule ^operator <o> +)
    (<o> ^match-type abstract ^name ground-argument)
    -->
    (<s> ^operator <o> -)
}

sp {learn-desired-elaboration-rule*all-predicates-grounded*turn*on*learning
    (state <s> ^name learn-desired-elaboration-rule ^desired <des>)
    -->
    (force-learn <s>)
}

sp {learn-desired-elaboration-rule*elaborate*problem-space
    (state <s> ^name learn-desired-elaboration-rule ^goal-id <goal>)
    -->
    (<s> ^problem-space <ps> +)
    (<ps> ^world <w*1> +)
    (<w*1> ^copy-type shallow +)
}

sp {learn-desired-elaboration-rule*elaborate*desired
    (state <s> ^name learn-desired-elaboration-rule ^ground-argument <arg>)
    (<arg> ^arg-type predicate-set ^instance <des>)
    -->
    (<s> ^desired <des> +)
}

sp {learn-desired-elaboration-rule*elaborate*ground-argument*goal-id
    (state <s> ^name learn-desired-elaboration-rule ^goal-id <gid>)
    -->
    (<s> ^ground-argument <arg> +)
    (<arg> ^arg-type predicate-set + ^generalized-rep <gid> +)
}

sp {learn-desired-elaboration-rule*elaborate*smem-info
    (state <s> ^name learn-desired-elaboration-rule ^superstate <s*1>)
    (<s*1> ^action-id <action-id>)
    (<action-id> ^procedural <proc> ^goal <goal>)
    -->
    (<s> ^goal-id <goal> + ^procedural-id <proc> +)
}

sp {learn-desired-elaboration-rule*elaborate*action-operator*from*superstate
    (state <s> ^name learn-desired-elaboration-rule ^superstate <s*1>)
    (<s*1> ^action-operator <action>)
    -->
    (<s> ^action-operator <action> +)
}

sp {learn-subaction-proposal*apply*complete-learn-subaction-proposal
    (state <s> ^name learn-subaction-proposal ^operator <o*1>
          ^subaction-operator <op> ^superstate <ss>)
    (<o*1> ^name complete-learn-subaction-proposal)
    -->
    (<ss> ^operator <op> +)
}

sp {learn-subaction-proposal*propose*complete-learn-subaction-proposal
    (state <s> ^name learn-subaction-proposal ^subaction-operator <op>)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete-learn-subaction-proposal +)
}

sp {learn-subaction-proposal*turn*learning*on*superstate
    (state <s> ^name learn-subaction-proposal)
    -->
    (force-learn <s>)
}

sp {learn-subaction-proposal*reject*ground-argument*default*procedural*if*abstract
    (state <s> ^name learn-subaction-proposal ^operator <o> +)
    (<o> ^name ground-argument ^match-type { << procedural default >> <m*1> }
          ^argument <a*1>)
    (<a*1> ^generalized-rep <g*1>)
    (<g*1> ^arg-status abstract)
    -->
    (<s> ^operator <o> -)
}

sp {learn-subaction-proposal*reject*ground-argument*abstract*if*real
    (state <s> ^name learn-subaction-proposal ^operator <o> +)
    (<o> ^match-type abstract ^name ground-argument ^argument <a*1>)
    (<a*1> ^generalized-rep <g*1>)
    (<g*1> ^arg-status { <> abstract <a*2> })
    -->
    (<s> ^operator <o> -)
}

sp {learn-subaction-proposal*prefer*create*others*over*create-op-arg
    (state <s> ^name learn-subaction-proposal ^operator <o2> +
          ^operator <o1> +)
    (<o2> ^name { << create-operator-argument >> <n*2> })
    (<o1> ^name { << create-operator >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {learn-subaction-proposal*apply*create-operator-argument*mark*arg-status*abstract
    (state <s> ^name learn-subaction-proposal ^operator <o>)
    (<o> ^name create-operator-argument ^argument <a*1> ^arg-instance <i>)
    (<a*1> ^arg-status abstract)
    -->
    (<i> ^arg-status abstract +)
}

sp {learn-subaction-proposal*apply*create-operator-argument
    (state <s> ^name learn-subaction-proposal ^operator <o>
          ^subaction-operator <sub-op>)
    (<o> ^name create-operator-argument ^arg-instance <i> ^arg-name <arg-name>)
    -->
    (<sub-op> ^<arg-name> <i> +)
}

sp {learn-subaction-proposal*propose*create-operator-argument
    (state <s> ^name learn-subaction-proposal ^ground-argument <gnd>
          ^subaction-id <s*1>)
    (<gnd> ^generalized-rep <sub-arg> ^instance <i>)
    (<s*1> ^<arg-name> <sub-arg>)
   -{ (<s> ^subaction-operator <s*2>)
      (<s*2> ^<arg-name> <arg>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name create-operator-argument + ^argument <sub-arg> +
           ^arg-name <arg-name> + ^arg-instance <i> +)
}

sp {learn-subaction-proposal*apply*create-operator
    (state <s> ^name learn-subaction-proposal ^operator <o>)
    (<o> ^name create-operator ^subaction <sub> ^perform <perform>)
    (<sub> ^op_name <name> ^action-handle <handle> ^handle <sub-handle>)
    -->
    (<s> ^subaction-operator <op> +)
    (<op> ^subaction-handle <sub-handle> + ^name <name> +
           ^action-handle <handle> + ^perform <perform> +)
}

sp {learn-subaction-proposal*elaborate*create-operator*elaborate*perform*default
    (state <s> ^name learn-subaction-proposal ^subaction-id <sub-id>
          ^operator <o> +)
    (<sub-id> -^perform <p*1>)
    (<o> ^name create-operator)
    -->
    (<o> ^perform multiple +)
}

sp {learn-subaction-proposal*elaborate*create-operator*copy*perform
    (state <s> ^name learn-subaction-proposal ^operator <o> +
          ^subaction-id <sub-id>)
    (<o> ^name create-operator)
    (<sub-id> ^perform <val>)
    -->
    (<o> ^perform <val> +)
}

sp {learn-subaction-proposal*propose*create-operator
    (state <s> ^name learn-subaction-proposal -^subaction-operator <s*1>
          ^subaction-id <sub>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name create-operator + ^subaction <sub> +)
}

sp {learn-subaction-proposal*elaborate*ground-argument*5*arguments
    (state <s> ^name learn-subaction-proposal ^subaction-id <sub>)
    (<sub> ^<arg5-name> <arg5> ^{ < <arg5-name> <arg4-name> } <arg4>
          ^{ < <arg4-name> <arg3-name> } <arg3>
          ^{ < <arg3-name> <arg2-name> } <arg2>
          ^{ < <arg2-name> <arg1-name> } <arg1>)
    (<arg5> ^arg-type <t5>)
    (<arg4> ^arg-type <t4>)
    (<arg3> ^arg-type <t3>)
    (<arg2> ^arg-type <t2>)
   -{ (<sub>
            ^{ <> <arg1-name> <> <arg2-name> <> <arg3-name> <> <arg4-name> <> <arg5-name> <arg6-name> } <a*1>)
      (<a*1> ^arg-type <a*2>)}
    (<arg1> ^arg-type <t1>)
    -->
    (<s> ^ground-argument <g*1> + ^ground-argument <g*2> +
           ^ground-argument <g*3> + ^ground-argument <g*4> +
           ^ground-argument <g*5> +)
    (<g*1> ^generalized-rep <arg1> +)
    (<g*2> ^generalized-rep <arg2> +)
    (<g*3> ^generalized-rep <arg3> +)
    (<g*4> ^generalized-rep <arg4> +)
    (<g*5> ^generalized-rep <arg5> +)
}

sp {learn-subaction-proposal*elaborate*ground-argument*4*arguments
    (state <s> ^name learn-subaction-proposal ^subaction-id <sub>)
    (<sub> ^<arg4-name> <arg4> ^{ < <arg4-name> <arg3-name> } <arg3>
          ^{ < <arg3-name> <arg2-name> } <arg2>
          ^{ < <arg2-name> <arg1-name> } <arg1>)
    (<arg4> ^arg-type <t4>)
    (<arg3> ^arg-type <t3>)
    (<arg2> ^arg-type <t2>)
   -{ (<sub>
            ^{ <> <arg1-name> <> <arg2-name> <> <arg3-name> <> <arg4-name> <arg5-name> } <a*1>)
      (<a*1> ^arg-type <a*2>)}
    (<arg1> ^arg-type <t1>)
    -->
    (<s> ^ground-argument <g*1> + ^ground-argument <g*2> +
           ^ground-argument <g*3> + ^ground-argument <g*4> +)
    (<g*1> ^generalized-rep <arg1> +)
    (<g*2> ^generalized-rep <arg2> +)
    (<g*3> ^generalized-rep <arg3> +)
    (<g*4> ^generalized-rep <arg4> +)
}

sp {learn-subaction-proposal*elaborate*ground-argument*3*arguments
    (state <s> ^name learn-subaction-proposal ^subaction-id <sub>)
    (<sub> ^<arg3-name> <arg3> ^{ < <arg3-name> <arg2-name> } <arg2>
          ^{ < <arg2-name> <arg1-name> } <arg1>)
    (<arg3> ^arg-type <t3>)
    (<arg2> ^arg-type <t2>)
   -{ (<sub>
            ^{ <> <arg1-name> <> <arg2-name> <> <arg3-name> <arg4-name> } <a*1>)
      (<a*1> ^arg-type <a*2>)}
    (<arg1> ^arg-type <t1>)
    -->
    (<s> ^ground-argument <g*1> + ^ground-argument <g*2> +
           ^ground-argument <g*3> +)
    (<g*1> ^generalized-rep <arg1> +)
    (<g*2> ^generalized-rep <arg2> +)
    (<g*3> ^generalized-rep <arg3> +)
}

sp {learn-subaction-proposal*elaborate*ground-argument*2*arguments
    (state <s> ^name learn-subaction-proposal ^subaction-id <sub>)
    (<sub> ^<arg2-name> <arg2> ^{ < <arg2-name> <arg1-name> } <arg1>)
    (<arg2> ^arg-type <t2>)
   -{ (<sub> ^{ <> <arg1-name> <> <arg2-name> <arg3-name> } <a*1>)
      (<a*1> ^arg-type <a*2>)}
    (<arg1> ^arg-type <t1>)
    -->
    (<s> ^ground-argument <g*1> + ^ground-argument <g*2> +)
    (<g*1> ^generalized-rep <arg1> +)
    (<g*2> ^generalized-rep <arg2> +)
}

sp {learn-subaction-proposal*elaborate*ground-argument*1*argument
    (state <s> ^name learn-subaction-proposal ^subaction-id <sub>)
    (<sub> ^<arg1-name> <arg1>)
   -{ (<sub> ^{ <> <arg1-name> <arg2-name> } <a*1>)
      (<a*1> ^arg-type <a*2>)}
    (<arg1> ^arg-type <t1>)
    -->
    (<s> ^ground-argument <g*1> +)
    (<g*1> ^generalized-rep <arg1> +)
}

sp {learn-subaction-propose*elaborate*ground-argument*arg-type*predicate-set
    (state <s> ^name learn-subaction-proposal ^ground-argument <gnd>)
    (<gnd> ^generalized-rep <g*1>)
    (<g*1> ^arg-type until-clause)
    -->
    (<gnd> ^arg-type predicate-set +)
}

sp {learn-subaction-proposal*elaborate*world*superstate
    (state <s> ^name learn-subaction-proposal ^superstate <s*1>)
    (<s*1> ^world <world>)
    -->
    (<s> ^world <world> +)
}

sp {learn-subaction-proposal*elaborate*procedural-id
    (state <s> ^name learn-subaction-proposal ^superstate <s*1>)
    (<s*1> ^action-id <a*1>)
    (<a*1> ^procedural <proc-id>)
    -->
    (<s> ^procedural-id <proc-id> +)
}

sp {learn-subaction-proposal*elaborate*action-operator
    (state <s> ^name learn-subaction-proposal ^superstate <s*1>)
    (<s*1> ^action-operator <action>)
    -->
    (<s> ^action-operator <action> +)
}

sp {action*state*no-change*unmatched-action*propose*report-failure-unmatched-action
    (state <s> ^name unmatched-action)
    -->
    (<s> ^operator <o> +)
    (<o> ^name report-failure-unmatched-action +)
}

sp {action*state*no-change*elaborate*state*name*learn-subaction-proposal
    (state <s> ^impasse no-change ^attribute state ^superstate <ss>
          ^superstate <s*2> ^superstate <s*1>)
    (<ss> ^action-id <a*1>)
    (<a*1> ^procedural <p*2>)
    (<p*2> ^subaction <sub>)
    (<sub> ^handle <handle>)
   -{ (<ss> ^operator <o> +)
      (<o> ^subaction-handle <handle>)}
    (<s*2> ^desired <d*1>)
    (<s*1> ^problem-space <p*1>)
    (<p*1> ^name action)
    -->
    (<s> ^name learn-subaction-proposal + ^subaction-id <sub> +)
}

sp {action*state*no-change*elaborate*state*name*learn-desired-elaboration-rule
    (state <s> ^impasse no-change ^attribute state ^superstate <s*2>
          ^superstate <s*1>)
   -{ (<s> ^superstate <s*3>)
      (<s*3> ^desired <d*1>)}
    (<s*2> ^action-operator <action>)
    (<s*1> ^problem-space <p*1>)
    (<p*1> ^name action)
    -->
    (<s> ^name learn-desired-elaboration-rule +)
}

sp {action*state*no-change*elaborate*state*name*unmatched-action
    (state <s> ^impasse no-change
          -^name { << learn-desired-elaboration-rule learn-subaction-proposal >> <n*1> }
          ^attribute state ^superstate <s*1>)
    (<s*1> ^problem-space <p*1>)
    (<p*1> ^name action)
    -->
    (<s> ^name unmatched-action +)
}

sp {action*state*no-change*elaborate*world
    (state <s> ^impasse no-change ^attribute state ^superstate <s*2>
          ^superstate <s*1>)
    (<s*2> ^world <w>)
    (<s*1> ^problem-space <p*1>)
    (<p*1> ^name action)
    -->
    (<s> ^world <w> +)
}

sp {action*apply*say*do*action-model
    (state <s> ^operator <o> ^problem-space <p*1> ^world <w*1>
          ^problem-space <p*2>)
    (<o> ^name op_say1 ^arg2 <a*3> ^arg1 <a*2>)
    (<p*1> ^name action)
    (<a*3> ^2 <person>)
    (<person> ^predicates <p*5>)
    (<p*5> ^category person)
    (<w*1> ^predicates <p*3>)
    (<p*3> ^predicate <heard>)
    (<heard> ^handle heard2)
    (<a*2> ^id <msg>)
   -{ (<heard> ^instance <heard-i>)
      (<heard-i> ^2 <msg> ^1 <person>)}
    (<msg> ^predicates <p*4>)
    (<p*4> ^sentence <any>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type simulate)
    -->
    (<heard> ^instance <i> +)
    (<i> ^1 <person> + ^2 <msg> +)
}

sp {action*simulate*apply*stop-leading*do*action-model*add*in*predicate
    (state <s> ^operator <o> ^problem-space <p*1> ^world <w*2> ^world <w*1>
          ^problem-space <p*2>)
    (<o> ^name op_stop-leading1 ^arg1 <a*2>)
    (<p*1> ^name action)
    (<w*2> ^predicates <p*3>)
    (<p*3> ^predicate <pred>)
    (<pred> ^handle in1)
    (<w*1> ^robot <r*1>)
    (<r*1> ^current-location <loc>)
    (<a*2> ^id <person>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type simulate)
    -->
    (<pred> ^instance <i> +)
    (<i> ^1 <person> + ^2 <loc> +)
}

sp {action*simulate*apply*stop-leading*do*action-model
    (state <s> ^operator <o> ^problem-space <p*1> ^problem-space <p*2>)
    (<o> ^name op_stop-leading1 ^arg1 <a*2>)
    (<p*1> ^name action)
    (<a*2> ^id <i*1>)
    (<i*1> ^predicates <preds>)
    (<preds> ^robot-status leading)
    (<p*2> ^action <a*1>)
    (<a*1> ^type simulate)
    -->
    (<preds> ^robot-status leading -)
}

sp {action*simulate*apply*start-leading*do*action-model*remove*relations
    (state <s> ^operator <o> ^problem-space <p*1> ^world <w*1>
          ^problem-space <p*2>)
    (<o> ^name op_start-leading1 ^arg1 <a*2>)
    (<p*1> ^name action)
    (<w*1> ^predicates <p*3>)
    (<p*3> ^predicate <pred>)
    (<pred> ^instance <i> ^handle <any>)
    (<a*2> ^id <person>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type simulate)
    (<i> ^<num> <person>)
    -->
    (<pred> ^instance <i> -)
}

sp {action*simulate*apply*start-leading*do*action-model
    (state <s> ^operator <o> ^problem-space <p*1> ^problem-space <p*2>)
    (<o> ^name op_start-leading1 ^arg1 <a*2>)
    (<p*1> ^name action)
    (<a*2> ^id <i*1>)
    (<i*1> ^predicates <preds>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type simulate)
    -->
    (<preds> ^robot-status leading +)
}

sp {action*apply*remember*do*action-model
    (state <s> ^operator <op> ^problem-space <p*1> ^problem-space <p*2>)
    (<op> ^name op_remember1 ^arg2 <a*3> ^arg1 <a*2>)
    (<p*1> ^name action)
    (<a*3> ^id <arg2>)
    (<arg2> ^predicates <p*3>)
    (<a*2> ^id <arg1>)
    (<arg1> ^predicates <preds>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type simulate)
    (<p*3> ^<att> <val>)
    -->
    (<preds> ^<att> <val> +)
}

sp {action*apply*op_find*do*action-model*remove*in*preds
    (state <s> ^operator <o*1> ^problem-space <p*1> ^world <w*2> ^world <w*1>
          ^problem-space <p*2>)
    (<o*1> ^name op_find1)
    (<p*1> ^name action)
    (<w*2> ^predicates <p*3>)
    (<p*3> ^predicate <in-pred>)
    (<in-pred> ^handle in1 ^instance <i>)
    (<i> ^2 <loc>)
    (<w*1> ^robot <robot>)
    (<robot> ^current-location <loc>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type simulate)
    -->
    (<in-pred> ^instance <i> -)
}

sp {action*apply*op_find*do*action-model*remove*old*location
    (state <s> ^operator <o*1> ^problem-space <p*1> ^world <w*1>
          ^problem-space <p*2>)
    (<o*1> ^name op_find1)
    (<p*1> ^name action)
    (<w*1> ^robot <robot>)
    (<robot> ^current-location <loc>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type simulate)
    -->
    (<robot> ^current-location <loc> -)
}

sp {action*apply*find*do*action-model*mark*invisible
    (state <s> ^operator <o> ^problem-space <p*1> ^world <w*1>
          ^problem-space <p*2>)
    (<o> ^name op_find1 ^arg1 <a*2>)
    (<p*1> ^name action)
    (<w*1> ^objects <o*1>)
    (<a*2> ^id <obj>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type simulate)
    (<o*1> ^object { <> <obj> <other> })
    (<other> ^predicates <preds>)
    -->
    (<preds> ^visible false + ^visible true -)
}

sp {action*apply*find*do*action-model*mark*visible
    (state <s> ^operator <o> ^problem-space <p*1> ^problem-space <p*2>)
    (<o> ^name op_find1 ^arg1 <a*2>)
    (<p*1> ^name action)
    (<a*2> ^id <obj>)
    (<obj> ^predicates <preds>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type simulate)
    -->
    (<preds> ^visible true + ^visible false -)
}

sp {action*apply*give*do*action-model*add*holding*relation
    (state <s> ^operator <o> ^problem-space <p*1> ^world <w*1>
          ^problem-space <p*2>)
    (<o> ^name op_give1 ^arg2 <a*3> ^arg1 <a*2>)
    (<p*1> ^name action)
    (<a*3> ^2 <person>)
    (<w*1> ^predicates <p*3>)
    (<p*3> ^predicate <pred>)
    (<pred> ^handle holding1)
    (<a*2> ^id <obj>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type simulate)
    -->
    (<pred> ^instance <i> +)
    (<i> ^1 <person> + ^2 <obj> +)
}

sp {action*apply*put-down*do*action-model*add*in*relation
    (state <s> ^operator <o> ^problem-space <p*1> ^world <w*2> ^world <w*1>
          ^problem-space <p*2>)
    (<o> -^arg2 <a*3> ^name op_put-down1 ^arg1 <a*2>)
    (<p*1> ^name action)
    (<w*2> ^predicates <p*3>)
    (<p*3> ^predicate <pred>)
    (<pred> ^handle in1)
    (<w*1> ^robot <r*1>)
    (<r*1> ^current-location <loc>)
    (<a*2> ^id <obj>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type simulate)
    -->
    (<pred> ^instance <i> +)
    (<i> ^1 <obj> + ^2 <loc> +)
}

sp {action*apply*putdown*do*action-model*on
    (state <s> ^operator <o> ^problem-space <p*1> ^world <w*1>
          ^problem-space <p*2>)
    (<o> ^name op_put-down1 ^arg2 <a*4> ^arg2 <a*3> ^arg1 <a*2>)
    (<p*1> ^name action)
    (<a*3> ^2 <obj2>)
    (<a*4> ^handle <pred-handle>)
    (<w*1> ^predicates <p*3>)
    (<p*3> ^predicate <pred>)
    (<pred> ^handle <pred-handle>)
    (<a*2> ^id <obj1>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type simulate)
    -->
    (<pred> ^instance <i> +)
    (<i> ^1 <obj1> + ^2 <obj2> +)
}

sp {action*apply*putdown*do*action-model*arm-status
    (state <s> ^operator <o> ^problem-space <p*1> ^problem-space <p*2>)
    (<o> ^name op_put-down1 ^arg1 <a*2>)
    (<p*1> ^name action)
    (<a*2> ^id <i*1>)
    (<i*1> ^predicates <obj1-preds>)
    (<obj1-preds> ^arm-status grabbed)
    (<p*2> ^action <a*1>)
    (<a*1> ^type simulate)
    -->
    (<obj1-preds> ^arm-status grabbed - ^arm-status not-grabbed +)
}

sp {action*apply*pickup*do*action-model*remove*relations*2
    (state <s> ^operator <o> ^problem-space <p*1> ^world <w*1>
          ^problem-space <p*2>)
    (<o> ^name op_pick-up1 ^arg1 <a*2>)
    (<p*1> ^name action)
    (<w*1> ^predicates <p*3>)
    (<p*3> ^predicate <pred>)
    (<pred> ^instance <i> ^handle <any>)
    (<i> ^2 <obj> ^1 <other>)
    (<a*2> ^id <obj>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type simulate)
    -->
    (<pred> ^instance <i> -)
}

sp {action*apply*pickup*do*action-model*remove*relations*1
    (state <s> ^operator <o> ^problem-space <p*1> ^world <w*1>
          ^problem-space <p*2>)
    (<o> ^name op_pick-up1 ^arg1 <a*2>)
    (<p*1> ^name action)
    (<w*1> ^predicates <p*3>)
    (<p*3> ^predicate <pred>)
    (<pred> ^instance <i> ^handle <any>)
    (<i> ^1 <obj> ^2 <other>)
    (<a*2> ^id <obj>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type simulate)
    -->
    (<pred> ^instance <i> -)
}

sp {action*apply*pickup*do*action-model
    (state <s> ^operator <op> ^problem-space <p*1> ^problem-space <p*2>)
    (<op> ^name op_pick-up1 ^arg1 <a*2>)
    (<p*1> ^name action)
    (<a*2> ^id <i*1>)
    (<i*1> ^predicates <preds>)
    (<preds> ^arm-status not-grabbed)
    (<p*2> ^action <a*1>)
    (<a*1> ^type simulate)
    -->
    (<preds> ^arm-status grabbed + ^arm-status not-grabbed -)
}

sp {action*apply*go-to-location*do*action-model*mark*old*objects*not*visible
    (state <s> ^operator <o> ^problem-space <p*1> ^world <world>
          ^problem-space <p*2>)
    (<o> ^name op_go-to-location1 ^arg2 <a*2>)
    (<p*1> ^name action)
    (<a*2> ^2 <new-loc>)
    (<world> ^objects <o*1> ^predicates <p*3>)
    (<p*3> ^predicate <in-pred>)
    (<in-pred> ^handle in1 ^instance <i>)
    (<i> ^2 { <> <new-loc> <old-loc> } ^1 <obj>)
    (<obj> ^predicates <preds>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type simulate)
    (<o*1> ^object <obj>)
    -->
    (<preds> ^visible true - ^visible false +)
}

sp {action*apply*go-to-location*do*action-model*mark*new*object*visible
    (state <s> ^operator <o> ^problem-space <p*1> ^world <world>
          ^problem-space <p*2>)
    (<o> ^name op_go-to-location1 ^arg2 <a*2>)
    (<p*1> ^name action)
    (<a*2> ^2 <new-loc>)
    (<world> ^objects <o*1> ^predicates <p*3>)
    (<p*3> ^predicate <in-pred>)
    (<in-pred> ^handle in1 ^instance <i>)
    (<i> ^2 <new-loc> ^1 <obj>)
    (<obj> ^predicates <preds>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type simulate)
    (<o*1> ^object <obj>)
    -->
    (<preds> ^visible false - ^visible true +)
}

sp {action*apply*go-to-location*do*action-model*remove*old*location
    (state <s> ^operator <o> ^problem-space <p*1> ^world <w*1>
          ^problem-space <p*2>)
    (<o> ^name op_go-to-location1 ^arg2 <a*2>)
    (<p*1> ^name action)
    (<a*2> ^2 <new-loc>)
    (<w*1> ^robot <robot>)
    (<robot> ^current-location { <> <new-loc> <old-loc> })
    (<old-loc> ^predicates <preds>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type simulate)
    -->
    (<robot> ^current-location <old-loc> -)
    (<preds> ^visible true - ^visible false +)
}

sp {action*apply*go-to-location*do*action-model*add*new*location
    (state <s> ^operator <o> ^problem-space <p*1> ^world <w*1>
          ^problem-space <p*2>)
    (<o> ^name op_go-to-location1 ^arg2 <a*2>)
    (<p*1> ^name action)
    (<a*2> ^2 <new-loc>)
    (<new-loc> ^predicates <preds>)
    (<w*1> ^robot <robot>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type simulate)
    -->
    (<robot> ^current-location <new-loc> +)
    (<preds> ^visible false - ^visible true +)
}

sp {action*simulate*apply*subcation*add*object*3
    (state <s> ^problem-space <p*1> ^action-id <a*2> ^operator <o>
          ^world <w*1> ^problem-space <p*2>)
    (<p*1> ^name action)
    (<a*2> ^procedural <p*3>)
    (<p*3> ^subaction <sub>)
    (<sub> ^model <m*1> ^handle <handle>)
    (<m*1> ^add-object <obj>)
    (<o> ^subaction-handle <handle>)
    (<w*1> ^objects <objs>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type simulate)
    (<obj> ^<prop3> <pred3> ^{ < <prop3> <prop2> } <pred2>
          ^{ < <prop2> <prop1> } <pred1>
          -^{ <> <prop3> <> <prop2> <> <prop1> <prop4> } <pred4>)
    -->
    (<objs> ^object <new> +)
    (<new> ^handle (make-constant-symbol obj-hand) + ^item-type object +
           ^predicates <preds> +)
    (<preds> ^<prop1> <pred1> + ^<prop2> <pred2> + ^<prop3> <pred3> +
           ^visible true + ^arm-status not-grabbed +)
}

sp {action*simulate*apply*subcation*add*object*2
    (state <s> ^problem-space <p*1> ^action-id <a*2> ^operator <o>
          ^world <w*1> ^problem-space <p*2>)
    (<p*1> ^name action)
    (<a*2> ^procedural <p*3>)
    (<p*3> ^subaction <sub>)
    (<sub> ^model <m*1> ^handle <handle>)
    (<m*1> ^add-object <obj>)
    (<o> ^subaction-handle <handle>)
    (<w*1> ^objects <objs>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type simulate)
    (<obj> ^<prop2> <pred2> ^{ < <prop2> <prop1> } <pred1>
          -^{ <> <prop2> <> <prop1> <prop3> } <pred3>)
    -->
    (<objs> ^object <new> +)
    (<new> ^handle (make-constant-symbol obj-hand) + ^item-type object +
           ^predicates <preds> +)
    (<preds> ^<prop1> <pred1> + ^<prop2> <pred2> + ^visible true +
           ^arm-status not-grabbed +)
}

sp {action*simulate*apply*subcation*add*object*1
    (state <s> ^problem-space <p*1> ^action-id <a*2> ^operator <o>
          ^world <w*1> ^problem-space <p*2>)
    (<p*1> ^name action)
    (<a*2> ^procedural <p*3>)
    (<p*3> ^subaction <sub>)
    (<sub> ^model <m*1> ^handle <handle>)
    (<m*1> ^add-object <obj>)
    (<o> ^subaction-handle <handle>)
    (<w*1> ^objects <objs>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type simulate)
    (<obj> ^<prop1> <pred1> -^{ <> <prop1> <prop2> } <pred2>)
    -->
    (<objs> ^object <new> +)
    (<new> ^handle (make-constant-symbol obj-hand) + ^item-type object +
           ^predicates <preds> +)
    (<preds> ^<prop1> <pred1> + ^visible true + ^arm-status not-grabbed +)
}

sp {action*apply*subaction*mark*performed
    (state <s> ^operator <o> ^problem-space <p*1> ^action-operator <op>
          ^problem-space <p*2>)
    (<o> ^perform once ^subaction-handle <sub-handle>)
    (<p*1> ^name action)
    (<p*2> ^action <a*1>)
    (<a*1> ^type simulate)
    -->
    (<op> ^performed <sub-handle> +)
}

sp {action*problem-space*simulate*composite*elaborate*problem-space
    (state <s> ^superstate <s*2> ^superstate <s*1>)
    (<s*1> ^problem-space <ss-ps>)
    (<ss-ps> ^name action ^action <a*1>)
    (<a*1> ^type simulate)
    (<s*2> ^operator <ss-op>)
    (<ss-op> ^action-handle <h>)
    -->
    (<s> ^problem-space <ps> +)
    (<ps> ^name action + ^action <action> + ^learning <learn> +
           ^world <world> + ^perception <perc> +)
    (<action> ^type simulate + ^propose-action-operators true +)
    (<world> ^copy-type shallow +)
    (<perc> ^attend-to-all-perception no +)
}

sp {op_turn1*propose*wait*during*command
    (state <s> ^name op_turn1 ^current-action <c*1>)
   -{ (<s> ^operator <o*1>)
      (<o*1> ^name wait)}
    (<c*1> ^turn-command <cmd>)
    (<cmd> -^status <s*1>)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name wait +)
}

sp {op_turn1*propose*report-failure*execution-failed
    (state <s> ^name op_turn1 ^current-action <c*2> ^current-action <c*1>)
    (<c*2> ^turn-command <t*1>)
    (<c*1> ^execution-operator <e*1>)
    (<e*1> ^action-handle <handle>)
    (<t*1> ^status { << failure interrupted >> <s*1> })
    -->
    (<s> ^operator <o> + ^operator <o> > ^operator <o> =)
    (<o> ^name report-failure + ^failure-type execution-failed +
           ^failure-info <handle> +)
}

sp {op_turn1*propose*report-failure*command-error
    (state <s> ^name op_turn1 ^current-action <c*2> ^current-action <c*1>)
    (<c*2> ^turn-command <t*1>)
    (<t*1> ^status error)
    (<c*1> ^execution-operator <e*1>)
    (<e*1> ^action-handle <handle>)
    -->
    (<s> ^operator <o> + ^operator <o> > ^operator <o> =)
    (<o> ^name report-failure + ^failure-type command-error +
           ^failure-info <handle> +)
}

sp {op_turn1*propose*report-failure*invalid-direction-failure
    (state <s> ^name op_turn1 ^direction-id <d*1> ^direction-handle <handle>)
    (<d*1> ^property <p*1>)
    (<p*1> ^handle { <> relative-direction1 <h*1> })
    -->
    (<s> ^operator <o> + ^operator <o> > ^operator <o> =)
    (<o> ^name report-failure + ^failure-type invalid-direction-failure +
           ^failure-info <handle> +)
}

sp {op_turn1*propose*report-failure*direction-retrieval-failure
    (state <s> ^name op_turn1 ^smem-query <s*1> ^direction-handle <handle>)
    (<s*1> ^result failure)
    -->
    (<s> ^operator <o> + ^operator <o> > ^operator <o> =)
    (<o> ^name report-failure + ^failure-type direction-retrieval-failure +
           ^failure-info <handle> +)
}

sp {op_turn1*elaborate*direction-id*from*retrieval
    (state <s> ^name op_turn1 ^direction-handle <dir-handle> ^smem-query <s*1>)
    (<s*1> ^result <dir-id>)
    (<dir-id> ^handle <dir-handle>)
    -->
    (<s> ^direction-id <dir-id> +)
}

sp {op_turn1*elaborate*smem-query-cue*direction
    (state <s> ^name op_turn1 ^direction-handle <dir-handle>)
    -->
    (<s> ^smem-query <q> +)
    (<q> ^cue <cue> + ^depth 2 +)
    (<cue> ^handle <dir-handle> +)
}

sp {op_turn1*elaborate*direction-handle*default
    (state <s> ^name op_turn1)
   -{ (<s> ^action-operator <a*1>)
      (<a*1> ^arg1 <a*2>)
      (<a*2> ^handle <h*1>)}
    -->
    (<s> ^direction-handle right1 +)
}

sp {op_turn1*elaborate*direction-handle*from*action-operator
    (state <s> ^name op_turn1 ^action-operator <a*1>)
    (<a*1> ^arg1 <a*2>)
    (<a*2> ^handle <dir-handle>)
    -->
    (<s> ^direction-handle <dir-handle> +)
}

sp {op_turn1*elaborate*problem-space*attend-to-all-perception*yes
    (state <s> ^name op_turn1 ^problem-space <p*1>)
    (<p*1> ^perception <p>)
    -->
    (<p> ^attend-to-all-perception yes +)
}

sp {op_turn*propose*report-success
    (state <s> ^name op_turn1 ^current-action <c*1>)
    (<c*1> ^turn-command <t*1>)
    (<t*1> ^status success)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name report-success +)
}

sp {op_turn1*apply*send-turn-command
    (state <s> ^name op_turn1 ^operator <o*1> ^direction-id <d*2>
          ^direction-id <d*1> ^current-action <a> ^top-state <t*2>
          ^top-state <t*1>)
    (<o*1> ^name send-turn-command)
    (<d*2> ^yaw <dy>)
    (<d*1> ^side <side>)
    (<t*2> ^io <i*2>)
    (<i*2> ^input-link <i*3>)
    (<i*3> ^self <s*1>)
    (<s*1> ^pose <p*1>)
    (<p*1> ^yaw <yaw>)
    (<t*1> ^io <i*1>)
    (<i*1> ^output-link <out>)
    -->
    (<out> ^do-control-law <law> +)
    (<law> ^name orient + ^parameters <p*2> + ^termination-condition <t*3> +)
    (<p*2> ^yaw (+ <yaw> <dy>) +)
    (<t*3> ^name stabilized +)
    (<a> ^turn-command <law> +)
}

sp {op_turn1*propose*send-turn-command
    (state <s> ^name op_turn1 ^direction-id <d*1>)
   -{ (<s> ^current-action <c*1>)
      (<c*1> ^turn-command <t*1>)}
    -->
    (<s> ^operator <o> +)
    (<o> ^name send-turn-command +)
}

sp {op_put-down1*tabletop*apply*report-failure*remove*put-down-command
    (state <s> ^name op_put-down1 ^operator <o*1> ^current-action <a>
          ^io <i*1>)
    (<o*1> ^name report-failure)
    (<a> ^put-down-command <cmd>)
    (<i*1> ^output-link <out>)
    (<out> ^put-down <cmd>)
    -->
    (<a> ^put-down-command <cmd> -)
    (<out> ^put-down <cmd> -)
}

sp {op_put-down1*tabletop*apply*report-failure*remove*grabbed
    (state <s> ^name op_put-down1 ^operator <o*1> ^held-object <h*1>)
    (<o*1> ^name report-failure)
    (<h*1> ^predicates <preds>)
    (<preds> ^arm-status grabbed)
    -->
    (<preds> ^arm-status grabbed -)
}

sp {op_put-down1*tabletop*apply*report-failure*report*failure
    (state <s> ^name op_put-down1 ^operator <o*1> ^held-object <obj>
          ^top-state <t*1>)
    (<o*1> ^name report-failure)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^failure <f> +)
    (<f> ^type missing-object + ^missing-object <obj> +)
}

sp {op_put-down1*tabletop*propose*report-failure
    (state <s> ^name op_put-down1 ^held-object <h*1> ^current-action <c*1>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^perception-monitor <p*2>)
      (<p*2> ^object-monitor <o*1>)
      (<o*1> ^new-object-info <n*1>)
      (<n*1> ^status <s*1>)}
    (<h*1> ^predicates <p*3>)
    (<p*3> ^visible false)
    (<c*1> ^put-down-command <p*1>)
    (<p*1> ^status complete)
    -->
    (<s> ^operator <o> +)
    (<o> ^name report-failure +)
}

sp {op_put-down1*tabletop*apply*report-success*remove*put-down-command
    (state <s> ^name op_put-down1 ^operator <o*1> ^current-action <a>
          ^io <i*1>)
    (<o*1> ^name report-success)
    (<a> ^put-down-command <cmd>)
    (<i*1> ^output-link <out>)
    (<out> ^put-down <cmd>)
    -->
    (<a> ^put-down-command <cmd> -)
    (<out> ^put-down <cmd> -)
}

sp {op_put-down1*tabletop*apply*report-success*remove*grabbed
    (state <s> ^name op_put-down1 ^operator <o*1> ^held-object <h*1>)
    (<o*1> ^name report-success)
    (<h*1> ^predicates <preds>)
    (<preds> ^arm-status grabbed)
    -->
    (<preds> ^arm-status grabbed -)
}

sp {op_put-down1*tabletop*apply*report-success
    (state <s> ^name op_put-down1 ^operator <o*1> ^current-action <a>)
    (<o*1> ^name report-success)
    -->
    (<a> ^status complete +)
}

sp {op_put-down1*tabletop*propose*report-success
    (state <s> ^name op_put-down1 ^held-object <h*1> ^current-action <c*1>)
    (<h*1> ^predicates <p*2>)
    (<p*2> ^visible true)
    (<c*1> ^put-down-command <p*1>)
    (<p*1> ^status complete)
    -->
    (<s> ^operator <o> +)
    (<o> ^name report-success +)
}

sp {op_put-down1*tabletop*reject*attend-to-scene-change*grabbed*object
    (state <s> ^name op_put-down1 ^operator <o> + ^current-action <c*1>
          ^target-object <t*1>)
    (<o> ^name attend-to-scene-change ^change <c*2>)
    (<c*1> ^put-down-command <cmd>)
    (<cmd> -^status <s*1>)
    (<c*2> ^object-info <o*1>)
    (<o*1> ^object-handle <handle>)
    (<t*1> ^handle <handle>)
    -->
    (<s> ^operator <o> -)
}

sp {op_put-down1*tabletop*reject*attend-to-scene-change*all*during*put-down
    (state <s> ^name op_put-down1 ^operator <o> + ^current-action <c*1>)
    (<o> ^name attend-to-scene-change ^change <c*3> ^change <c*2>)
    (<c*3> ^info <i*1>)
    (<i*1> ^category object)
    (<c*1> ^put-down-command <cmd>)
    (<cmd> -^status <s*1>)
    (<c*2> ^type { <> new-perception-object <any> })
    -->
    (<s> ^operator <o> -)
}

sp {op_put-down1*tabletop*reject*attend-to-new-object
    (state <s> ^name op_put-down1 ^operator <o> + ^current-action <c*1>)
    (<o> ^name attend-to-scene-change ^change <c*2>)
    (<c*2> ^type new-object)
    (<c*1> ^put-down-command <cmd>)
    (<cmd> -^status <s*1>)
    -->
    (<s> ^operator <o> -)
}

sp {op_put-down1*tabletop*reject*attend-to-missing-object*held*object
    (state <s> ^name op_put-down1 ^operator <o> + ^held-object <obj>)
    (<o> ^name attend-to-scene-change ^change <c*1> ^change <c*2>)
    (<c*1> ^type missing-object)
    (<c*2> ^object-info <o*1>)
    (<o*1> ^wm-obj <obj>)
    -->
    (<s> ^operator <o> -)
}

sp {op_put-down1*tabletop*propose*wait*during*commands
    (state <s> ^name op_put-down1 ^current-action <c*1>)
   -{ (<s> ^operator <o*1>)
      (<o*1> ^name wait)}
    (<c*1> ^put-down-command <cmd>)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name wait +)
}

sp {op_put-down1*tabletop*apply*send-put-down-command*relocate*object
    (state <s> ^name op_put-down1 ^operator <o> ^held-object <h*1>
          ^top-state <t*1>)
    (<o> ^name send-put-down-command ^destination <dest>)
    (<h*1> ^svs-obj <s*1>)
    (<dest> ^z <z> ^y <y> ^x <x>)
    (<s*1> ^id <id>)
    (<t*1> ^svs <s*2>)
    (<s*2> ^command <cmd>)
    -->
    (write |Moving object to tracked location| (crlf))
    (<cmd> ^set_transform <setxform> +)
    (<setxform> ^id <id> + ^position <pos> +)
    (<pos> ^x <x> + ^y <y> + ^z <z> +)
}

sp {op_put-down1*tabletop*apply*send-put-down-command*send
    (state <s> ^name op_put-down1 ^operator <o> ^current-action <a> ^io <i*1>)
    (<o> ^name send-put-down-command ^destination <dest>)
    (<dest> ^z <z> ^y <y> ^x <x>)
    (<i*1> ^output-link <out>)
    -->
    (<out> ^put-down <cmd> +)
    (<cmd> ^location <loc> +)
    (<loc> ^x <x> + ^y <y> + ^z <z> +)
    (<a> ^put-down-command <cmd> +)
}

sp {op_put-down1*tabletop*propose*send-put-down-command
    (state <s> ^name op_put-down1 ^projection-result <res> ^world <w*1>)
   -{ (<s> ^current-action <c*1>)
      (<c*1> ^put-down-command <p*1>)}
    (<w*1> ^robot <r*1>)
    (<r*1> ^arm <a*1>)
    (<a*1> ^moving-status wait)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name send-put-down-command + ^destination <res> +)
}

sp {op_put-down1*tabletop*apply*find-projection*copy*result
    (state <s> ^name op_put-down1 ^operator <o*1> ^projection-result <res>
          ^current-action <a>)
    (<o*1> ^name find-projection)
    -->
    (<a> ^projection-result <res> +)
}

sp {op_put-down1*tabletop*propose*find-projection
    (state <s> ^name op_put-down1 ^held-object <held> ^destination <dest>
          ^predicate-handle <pred-handle>)
   -{ (<s> ^current-action <c*1>)
      (<c*1> ^projection-result <p*1>)}
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name find-projection + ^predicate-handle <pred-handle> +
           ^arg-list <args> +)
    (<args> ^1 <held> + ^2 <dest> +)
}

sp {op_put-down1*tabletop*elaborate*problem-space*attend-to-all-perception
    (state <s> ^name op_put-down1 ^problem-space <p*1>)
    (<p*1> ^perception <p>)
    -->
    (<p> ^attend-to-all-perception yes +)
}

sp {op_put-down1*tabletop*prefer*find-projection*over*send-put-down
    (state <s> ^name op_put-down1 ^operator <o2> + ^operator <o1> +)
    (<o2> ^name send-put-down-command)
    (<o1> ^name find-projection)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {op_put-down1*tabletop*prefer*attend-to-scene-change*over*reports
    (state <s> ^name op_put-down1 ^operator <o1> + ^operator <o2> +)
    (<o1> ^name attend-to-scene-change)
    (<o2> ^name { << report-success report-failure >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {op_put-down1*tabletop*elaborate*projection-result*from*current-action
    (state <s> ^name op_put-down1 ^current-action <c*1>)
    (<c*1> ^projection-result <res>)
    -->
    (<s> ^projection-result <res> +)
}

sp {op_put-down1*tabletop*elaborate*destination*superoperator
    (state <s> ^name op_put-down1 ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^arg2 <a*1>)
    (<a*1> ^2 <obj>)
    -->
    (<s> ^destination <obj> +)
}

sp {op_put-down1*tabletop*elaborate*predicate-handle*superoperator
    (state <s> ^name op_put-down1 ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^arg2 <a*1>)
    (<a*1> ^handle <pred-handle>)
    -->
    (<s> ^predicate-handle <pred-handle> +)
}

sp {op_put-down1*tabletop*elaborate*held-object*superoperator
    (state <s> ^name op_put-down1 ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^arg1 <a*1>)
    (<a*1> ^id <obj>)
    -->
    (<s> ^held-object <obj> +)
}

sp {op_pick-up1*tabletop*apply*report-failure*remove*commands
    (state <s> ^name op_pick-up1 ^operator <o*1> ^current-action <a> ^io <i*1>)
    (<o*1> ^name report-failure)
    (<i*1> ^output-link <out>)
    (<out> ^<cmd-name> <cmd>)
    (<a> ^{ << pick-up-command reset-command >> <cmd-type> } <cmd>)
    -->
    (<a> ^<cmd-type> <cmd> -)
    (<out> ^<cmd-name> <cmd> -)
}

sp {op_pick-up1*tabletop*apply*report-failure*report*failure*stop-asking
    (state <s> ^name op_pick-up1 ^current-action <a> ^operator <o*1>)
    (<a> ^stop-asking true)
    (<o*1> ^name report-failure)
    -->
    (<a> ^status failure +)
}

sp {op_pick-up1*tabletop*apply*report-failure*report*failure
    (state <s> ^name op_pick-up1 ^operator <o*1> ^target-object <obj>
          ^top-state <t*1>)
   -{ (<s> ^current-action <c*1>)
      (<c*1> ^stop-asking true)}
    (<o*1> ^name report-failure)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^failure <f> +)
    (<f> ^type missing-object + ^missing-object <obj> +)
}

sp {op_pick-up1*tabletop*apply*report-failure*remove-arm-status
    (state <s> ^name op_pick-up1 ^operator <o*1> ^target-object <t*1>)
    (<o*1> ^name report-failure)
    (<t*1> ^predicates <preds>)
    (<preds> ^arm-status moving)
    -->
    (<preds> ^arm-status moving -)
}

sp {op_pick-up1*tabletop*propose*report-failure*missing*object*no*command
    (state <s> ^name op_pick-up1 ^target-object <t*1>)
   -{ (<s> ^current-action <c*1>)
      (<c*1> ^{ << reset-command pick-up-command >> <a*1> } <v*1>)}
    (<t*1> ^predicates <p*1>)
    (<p*1> ^visible false)
    -->
    (<s> ^operator <o> +)
    (<o> ^name report-failure +)
}

sp {op_pick-up1*tabletop*propose*report-failure*missing*object*reset*complete
    (state <s> ^name op_pick-up1 ^current-action <c*1> ^target-object <t*2>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^perception-monitor <p*1>)
      (<p*1> ^object-monitor <o*1>)
      (<o*1> ^new-object-info <n*1>)
      (<n*1> ^status <s*1>)}
    (<c*1> ^reset-command <r*1>)
    (<r*1> ^status complete)
    (<t*2> ^predicates <p*2>)
    (<p*2> ^visible false)
    -->
    (<s> ^operator <o> +)
    (<o> ^name report-failure +)
}

sp {op_pick-up1*tabletop*propose*report-failure
    (state <s> ^name op_pick-up1 ^current-action <c*1> ^target-object <t*2>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^perception-monitor <p*2>)
      (<p*2> ^object-monitor <o*1>)
      (<o*1> ^new-object-info <n*1>)
      (<n*1> ^status <s*2>)}
    (<c*1> ^pick-up-command <p*1>)
    (<t*2> ^predicates <p*3>)
    (<p*3> ^visible false)
    (<p*1> ^status { << failure interrupted >> <s*1> })
    -->
    (<s> ^operator <o> +)
    (<o> ^name report-failure +)
}

sp {op_pick-up1*tabletop*apply*report-success*remove*commands
    (state <s> ^name op_pick-up1 ^operator <o*1> ^current-action <a> ^io <i*1>)
    (<o*1> ^name report-success)
    (<i*1> ^output-link <out>)
    (<out> ^<cmd-name> <cmd>)
    (<a> ^{ << pick-up-command reset-command >> <cmd-type> } <cmd>)
    -->
    (<a> ^<cmd-type> <cmd> -)
    (<out> ^<cmd-name> <cmd> -)
}

sp {op_pick-up1*tabletop*apply*report-success*move*belief*to*arm
    (state <s> ^name op_pick-up1 ^operator <o*1> ^target-object <t*1>
          ^top-state <t*2> ^io <i*1>)
    (<o*1> ^name report-success)
    (<t*1> ^svs-obj <s*1>)
    (<s*1> ^id <id>)
    (<t*2> ^svs <s*3>)
    (<s*3> ^command <cmd>)
    (<i*1> ^input-link <i*2>)
    (<i*2> ^self <s*2>)
    (<s*2> ^pose <pose>)
    (<pose> ^z <z> ^y <y> ^x <x>)
    -->
    (<cmd> ^set_transform <xform> +)
    (<xform> ^id <id> + ^position <pos> +)
    (<pos> ^x <x> + ^y <y> + ^z <z> +)
}

sp {op_pick-up1*tabletop*apply*report-success*add*grabbed
    (state <s> ^name op_pick-up1 ^operator <o*1> ^target-object <t*1>)
    (<o*1> ^name report-success)
    (<t*1> ^predicates <preds>)
    (<preds> ^arm-status moving)
    -->
    (<preds> ^arm-status moving - ^arm-status grabbed +)
}

sp {op_pick-up1*tabletop*apply*report-success*mark*finished
    (state <s> ^name op_pick-up1 ^operator <o*1> ^current-action <a>)
    (<o*1> ^name report-success)
    -->
    (<a> ^status complete +)
}

sp {op_pick-up1*tabletop*propose*report-success
    (state <s> ^name op_pick-up1 ^current-action <c*1>)
    (<c*1> ^pick-up-command <p*1>)
    (<p*1> ^status complete)
    -->
    (<s> ^operator <o> +)
    (<o> ^name report-success +)
}

sp {op_pick-up1*tabletop*reject*attend-to-scene-change*grabbed*object
    (state <s> ^name op_pick-up1 ^operator <o> + ^current-action <c*1>
          ^target-object <obj>)
    (<o> ^name attend-to-scene-change ^change <c*2>)
    (<c*1> ^pick-up-command <cmd>)
    (<cmd> -^status <s*1>)
    (<c*2> ^object-info <o*1>)
    (<o*1> ^wm-obj <obj>)
    -->
    (<s> ^operator <o> -)
}

sp {op_pick-up1*tabletop*reject*attend-to-new-perception-object
    (state <s> ^name op_pick-up1 ^operator <o> + ^current-action <c*1>)
    (<o> ^name attend-to-scene-change ^change <c*2>)
    (<c*2> ^type new-perception-object)
    (<c*1> ^pick-up-command <cmd>)
    (<cmd> -^status <s*1>)
    -->
    (<s> ^operator <o> -)
}

sp {op_pick-up1*tabletop*reject*attend-to-missing-object
    (state <s> ^name op_pick-up1 ^operator <o> + ^target-object <obj>)
    (<o> ^name attend-to-scene-change ^change <c*1> ^change <c*2>)
    (<c*1> ^type missing-object)
    (<c*2> ^object-info <o*1>)
    (<o*1> ^wm-obj <obj>)
    -->
    (<s> ^operator <o> -)
}

sp {op_pick-up1*tabletop*propose*wait*during*commands
    (state <s> ^name op_pick-up1 ^current-action <c*1>)
   -{ (<s> ^operator <o*1>)
      (<o*1> ^name wait)}
    (<c*1> ^{ << pick-up-command reset-command >> <a*1> } <cmd>)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name wait +)
}

sp {op_pickup*apply*send-reset-command*remove*pick-up-command
    (state <s> ^name op_pick-up1 ^operator <o*1> ^current-action <a> ^io <i*1>)
    (<o*1> ^name send-reset-command)
    (<a> ^pick-up-command <cmd>)
    (<i*1> ^output-link <out>)
    (<out> ^pick-up <cmd>)
    -->
    (<a> ^pick-up-command <cmd> -)
    (<out> ^pick-up <cmd> -)
}

sp {op_pickup*apply*send-reset-command
    (state <s> ^name op_pick-up1 ^operator <o*1> ^current-action <a> ^io <i*1>)
    (<o*1> ^name send-reset-command)
    (<i*1> ^output-link <ol>)
    -->
    (<ol> ^reset <r> +)
    (<a> ^reset-command <r> +)
}

sp {op_pick-up1*tabletop*propose*send-reset-command
    (state <s> ^name op_pick-up1 ^world <w*1>)
   -{ (<s> ^current-action <c*1>)
      (<c*1> ^reset-command <r*2>)}
    (<w*1> ^robot <r*1>)
    (<r*1> ^arm <a*1>)
    (<a*1> ^moving-status { << failure home >> <m*1> })
    -->
    (<s> ^operator <o> +)
    (<o> ^name send-reset-command + ^actions <a*2> +)
    (<a*2> ^reset <r> +)
}

sp {execute-pickup*apply*send-pick-up-command*remove*reset-command
    (state <s> ^name op_pick-up1 ^operator <o*1> ^current-action <a> ^io <i*1>)
    (<o*1> ^name send-pick-up-command)
    (<a> ^reset-command <cmd>)
    (<i*1> ^output-link <out>)
    (<out> ^reset <cmd>)
    -->
    (<a> ^reset-command <cmd> -)
    (<out> ^reset <cmd> -)
}

sp {op_pick-up1*tabletop*apply*send-pick-up-command*mark*object*moving
    (state <s> ^name op_pick-up1 ^operator <o>)
    (<o> ^name send-pick-up-command ^object <o*1>)
    (<o*1> ^predicates <preds>)
    -->
    (<preds> ^arm-status moving +)
}

sp {op_pick-up1*tabletop*apply*send-pick-up-command*send
    (state <s> ^name op_pick-up1 ^operator <o> ^current-action <a> ^io <i*1>)
    (<o> ^name send-pick-up-command ^object <o*1>)
    (<i*1> ^output-link <ol>)
    (<o*1> ^handle <obj-handle>)
    -->
    (<ol> ^pick-up <cmd> +)
    (<cmd> ^object-handle <obj-handle> +)
    (<a> ^pick-up-command <cmd> +)
}

sp {op_pick-up1*tabletop*propose*send-pick-up-command
    (state <s> ^name op_pick-up1 ^target-object <obj> ^world <w*1>)
   -{ (<s> ^current-action <c*1>)
      (<c*1> ^pick-up-command <p*1>)}
    (<obj> ^predicates <p*2>)
    (<p*2> ^visible true)
    (<w*1> ^robot <r*1>)
    (<r*1> ^arm <a*1>)
    (<a*1> ^moving-status wait)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name send-pick-up-command + ^object <obj> +)
}

sp {op_pick-up1*tabletop*elaborate*problem-space*attend-to-all-perception
    (state <s> ^name op_pick-up1 ^problem-space <p*1>)
    (<p*1> ^perception <p>)
    -->
    (<p> ^attend-to-all-perception yes +)
}

sp {op_pick-up1*tabletop*prefer*attend-to-scene*over*failure*operators
    (state <s> ^name op_pick-up1 ^operator <o1> + ^operator <o2> +)
    (<o1> ^name attend-to-scene-change)
    (<o2> ^name { << report-failure send-reset-command >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {op_pick-up1*tabletop*prefer*attend-to-arm*over*report-success
    (state <s> ^name op_pick-up1 ^operator <o2> + ^operator <o1> +)
    (<o2> ^name report-success)
    (<o1> ^name attend-to-scene-change)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {op_pick-up1*tabletop*prefer*commands*over*report-failure
    (state <s> ^name op_pick-up1 ^operator <o2> + ^operator <o1> +)
    (<o2> ^name report-failure)
    (<o1> ^name { << send-pick-up-command send-reset-commmand >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {op_pick-up1*tabletop*elaborate*target-object*superoperator
    (state <s> ^name op_pick-up1 ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^arg1 <a*1>)
    (<a*1> ^id <obj>)
    -->
    (<s> ^target-object <obj> +)
}

sp {op_stop1*propose*report-failure*execution-failed
    (state <s> ^name op_stop1 ^current-action <c*2> ^current-action <c*1>)
    (<c*2> ^stop-command <s*1>)
    (<c*1> ^execution-operator <e*1>)
    (<e*1> ^action-handle <handle>)
    (<s*1> ^status { << failure interrupted >> <s*2> })
    -->
    (<s> ^operator <o> + ^operator <o> > ^operator <o> =)
    (<o> ^name report-failure + ^failure-type execution-failed +
           ^failure-info <handle> +)
}

sp {op_stop1*propose*report-failure*command-error
    (state <s> ^name op_stop1 ^current-action <c*2> ^current-action <c*1>)
    (<c*2> ^stop-command <s*1>)
    (<s*1> ^status error)
    (<c*1> ^execution-operator <e*1>)
    (<e*1> ^action-handle <handle>)
    -->
    (<s> ^operator <o> + ^operator <o> > ^operator <o> =)
    (<o> ^name report-failure + ^failure-type command-error +
           ^failure-info <handle> +)
}

sp {op_stop*propose*report-success
    (state <s> ^name op_stop1 ^current-action <c*1>)
    (<c*1> ^stop-command <s*1>)
    (<s*1> ^status success)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name report-success +)
}

sp {op_stop1*propose*wait*during*command
    (state <s> ^name op_stop1 ^current-action <c*1>)
   -{ (<s> ^operator <o*1>)
      (<o*1> ^name wait)}
    (<c*1> ^stop-command <cmd>)
    (<cmd> -^status <s*1>)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name wait +)
}

sp {op_stop1*apply*send-stop-command
    (state <s> ^name op_stop1 ^operator <o*1> ^current-action <a>
          ^top-state <t*1>)
    (<o*1> ^name send-stop-command)
    (<t*1> ^io <i*1>)
    (<i*1> ^output-link <out>)
    -->
    (<out> ^do-control-law <law> +)
    (<law> ^name stop + ^termination-condition <t*2> +)
    (<t*2> ^name stabilized +)
    (<a> ^stop-command <law> +)
}

sp {op_stop1*propose*send-stop-command
    (state <s> ^name op_stop1)
   -{ (<s> ^current-action <c*1>)
      (<c*1> ^stop-command <s*1>)}
    -->
    (<s> ^operator <o> +)
    (<o> ^name send-stop-command +)
}

sp {op_stop1*elaborate*problem-space*attend-to-all-perception*yes
    (state <s> ^name op_stop1 ^problem-space <p*1>)
    (<p*1> ^perception <p>)
    -->
    (<p> ^attend-to-all-perception yes +)
}

sp {op_orient1*propose*wait*during*command
    (state <s> ^name op_orient1 ^current-action <c*1>)
   -{ (<s> ^operator <o*1>)
      (<o*1> ^name wait)}
    (<c*1> ^orient-command <cmd>)
    (<cmd> -^status <s*1>)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name wait +)
}

sp {op_orient1*propose*report-failure*execution-failed
    (state <s> ^name op_orient1 ^current-action <c*2> ^current-action <c*1>)
    (<c*2> ^orient-command <o*1>)
    (<c*1> ^execution-operator <e*1>)
    (<e*1> ^action-handle <handle>)
    (<o*1> ^status { << failure interrupted >> <s*1> })
    -->
    (<s> ^operator <o> + ^operator <o> > ^operator <o> =)
    (<o> ^name report-failure + ^failure-type execution-failed +
           ^failure-info <handle> +)
}

sp {op_orient1*propose*report-failure*command-error
    (state <s> ^name op_orient1 ^current-action <c*2> ^current-action <c*1>)
    (<c*2> ^orient-command <o*1>)
    (<c*1> ^execution-operator <e*1>)
    (<e*1> ^action-handle <handle>)
    (<o*1> ^status { << interrupted error >> <s*1> })
    -->
    (<s> ^operator <o> + ^operator <o> > ^operator <o> =)
    (<o> ^name report-failure + ^failure-type command-error +
           ^failure-info <handle> +)
}

sp {op_orient1*propose*report-failure*invalid-direction-failure
    (state <s> ^name op_orient1 ^direction-id <d*1> ^direction-handle <handle>)
    (<d*1> ^property <p*1>)
    (<p*1> ^handle { <> cardinal-direction1 <h*1> })
    -->
    (<s> ^operator <o> + ^operator <o> > ^operator <o> =)
    (<o> ^name report-failure + ^failure-type invalid-direction-failure +
           ^failure-info <handle> +)
}

sp {op_orient1*propose*report-failure*direction-retrieval-failure
    (state <s> ^name op_orient1 ^smem-query <s*1> ^direction-handle <handle>)
    (<s*1> ^result failure)
    -->
    (<s> ^operator <o> + ^operator <o> > ^operator <o> =)
    (<o> ^name report-failure + ^failure-type direction-retrieval-failure +
           ^failure-info <handle> +)
}

sp {op_orient*propose*report-success
    (state <s> ^name op_orient1 ^current-action <c*1>)
    (<c*1> ^orient-command <o*1>)
    (<o*1> ^status success)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name report-success +)
}

sp {op_orient1*apply*send-orient-command
    (state <s> ^name op_orient1 ^operator <o> ^current-action <a>
          ^top-state <t*1>)
    (<o> ^name send-orient-command ^yaw <yaw>)
    (<t*1> ^io <i*1>)
    (<i*1> ^output-link <out>)
    -->
    (<out> ^do-control-law <law> +)
    (<law> ^name orient + ^parameters <p*1> + ^termination-condition <t*2> +)
    (<p*1> ^yaw <yaw> +)
    (<t*2> ^name stabilized +)
    (<a> ^orient-command <law> +)
}

sp {op_orient1*propose*send-orient-command
    (state <s> ^name op_orient1 ^direction-id <d*1>)
   -{ (<s> ^current-action <c*1>)
      (<c*1> ^orient-command <o*1>)}
    (<d*1> ^yaw <yaw>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name send-orient-command + ^yaw <yaw> +)
}

sp {op_orient1*elaborate*direction-id*from*retrieval
    (state <s> ^name op_orient1 ^direction-handle <dir-handle>
          ^smem-query <s*1>)
    (<s*1> ^result <dir-id>)
    (<dir-id> ^handle <dir-handle>)
    -->
    (<s> ^direction-id <dir-id> +)
}

sp {op_orient1*elaborate*smem-query-cue*direction
    (state <s> ^name op_orient1 ^direction-handle <dir-handle>)
    -->
    (<s> ^smem-query <q> +)
    (<q> ^cue <cue> + ^depth 2 +)
    (<cue> ^handle <dir-handle> +)
}

sp {op_orient1*elaborate*direction-handle*default
    (state <s> ^name op_orient1)
   -{ (<s> ^action-operator <a*1>)
      (<a*1> ^arg1 <a*2>)
      (<a*2> ^handle <dir-handle>)}
    -->
    (<s> ^direction-handle north1 +)
}

sp {op_orient1*elaborate*direction-handle*from*action-operator
    (state <s> ^name op_orient1 ^action-operator <a*1>)
    (<a*1> ^arg1 <a*2>)
    (<a*2> ^handle <dir-handle>)
    -->
    (<s> ^direction-handle <dir-handle> +)
}

sp {op_orient1*elaborate*problem-space*attend-to-all-perception*yes
    (state <s> ^name op_orient1 ^problem-space <p*1>)
    (<p*1> ^perception <p>)
    -->
    (<p> ^attend-to-all-perception yes +)
}

sp {op_move1*apply*report-failure*mark*status*failure
    (state <s> ^name op_move1 ^operator <o*1> ^current-action <a>)
    (<o*1> ^name report-failure)
    -->
    (<a> ^status failure +)
}

sp {op_move1*propose*report-failure*non*visible*destination
    (state <s> ^name op_move1 -^child-action <c*1> ^destination <d*1>)
    (<d*1> ^predicates <p*1>)
    (<p*1> ^visible false)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name report-failure +)
}

sp {op_move1*propose*report-failure*non*visible*target
    (state <s> ^name op_move1 -^child-action <c*1> ^target-object <obj>)
   -{ (<obj> ^predicates <p*2>)
      (<p*2> ^arm-status <a*1>)}
    (<obj> ^predicates <p*1>)
    (<p*1> ^visible false)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name report-failure +)
}

sp {op_move1*apply*op_put-down1*elaborate*status*complete
    (state <s> ^name op_move1 ^child-action <c*1> ^operator <o*1>
          ^current-action <a>)
    (<c*1> ^status complete)
    (<o*1> ^name op_put-down1)
    -->
    (<a> ^status complete +)
}

sp {op_move*propose*op_put-down1
    (state <s> ^name op_move1 ^destination <dest> ^predicate-handle <ph>
          ^target-object <obj>)
    (<dest> ^predicates <p*2>)
    (<p*2> ^visible true)
    (<obj> ^predicates <p*1>)
    (<p*1> ^arm-status grabbed)
    -->
    (<s> ^operator <o> +)
    (<o> ^name op_put-down1 + ^action-handle put-down1 + ^arg1 <arg1> +
           ^arg2 <arg2> +)
    (<arg1> ^arg-type object + ^id <obj> +)
    (<arg2> ^arg-type predicate + ^handle <ph> + ^default-handle on1 +
           ^any-predicate true + ^2 <dest> +)
}

sp {op_move1*propose*op_pick-up1
    (state <s> ^name op_move1 ^target-object <obj>)
   -{ (<obj> ^predicates <p*2>)
      (<p*2> ^arm-status grabbed)}
    (<obj> ^predicates <p*1>)
    (<p*1> ^visible true)
    -->
    (<s> ^operator <op> +)
    (<op> ^name op_pick-up1 + ^action-handle pick-up1 + ^arg1 <arg1> +)
    (<arg1> ^arg-type object + ^id <obj> +)
}

sp {op_move1*elaborate*destination*from*superoperator
    (state <s> ^name op_move1 ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^arg2 <a*1>)
    (<a*1> ^2 <obj>)
    -->
    (<s> ^destination <obj> +)
}

sp {op_move1*elaborate*predicate-handle*from*superoperator
    (state <s> ^name op_move1 ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^arg2 <a*1>)
    (<a*1> ^handle <ph>)
    -->
    (<s> ^predicate-handle <ph> +)
}

sp {op_move1*elaborate*target-object*from*superoperator
    (state <s> ^name op_move1 ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^arg1 <a*1>)
    (<a*1> ^id <obj>)
    -->
    (<s> ^target-object <obj> +)
}

sp {op_follow-wall1*propose*wait*during*command*execution
    (state <s> ^name op_follow-wall1 ^current-action <c*1>)
   -{ (<s> ^operator <o*1>)
      (<o*1> ^name wait)}
    (<c*1> ^{ << follow-wall-command stop-command >> <a*1> } <cmd>)
    (<cmd> -^status <s*1>)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name wait +)
}

sp {op_follow-wall1*apply*send-stop-command
    (state <s> ^name op_follow-wall1 ^operator <o*1> ^current-action <a>
          ^top-state <t*1>)
    (<o*1> ^name send-stop-command)
    (<t*1> ^io <i*1>)
    (<i*1> ^output-link <out>)
    -->
    (<out> ^do-control-law <law> +)
    (<law> ^name stop + ^termination-condition <t*2> +)
    (<t*2> ^name stabilized +)
    (<a> ^stop-command <law> +)
}

sp {op_follow-wall1*propose*send-stop-command
    (state <s> ^name op_follow-wall1 ^until-clause <u*1>)
   -{ (<s> ^current-action <c*1>)
      (<c*1> ^stop-command <s*1>)}
    (<u*1> ^satisfied true)
    -->
    (<s> ^operator <o> +)
    (<o> ^name send-stop-command +)
}

sp {op_follow-wall1*propose*report-failure*execution-failed
    (state <s> ^name op_follow-wall1 ^current-action <c*2>
          ^current-action <c*1>)
    (<c*1> ^execution-operator <e*1>)
    (<e*1> ^action-handle <handle>)
    (<c*2> ^{ << follow-wall-command stop-command >> <a*1> } <v*1>)
    (<v*1> ^status { << failure interrupted >> <s*1> })
    -->
    (<s> ^operator <o> + ^operator <o> > ^operator <o> =)
    (<o> ^name report-failure + ^failure-type execution-failed +
           ^failure-info <handle> +)
}

sp {op_follow-wall1*propose*report-failure*command-error
    (state <s> ^name op_follow-wall1 ^current-action <c*2>
          ^current-action <c*1>)
    (<c*1> ^execution-operator <e*1>)
    (<e*1> ^action-handle <handle>)
    (<c*2> ^{ << follow-wall-command stop-command >> <a*1> } <v*1>)
    (<v*1> ^status error)
    -->
    (<s> ^operator <o> + ^operator <o> > ^operator <o> =)
    (<o> ^name report-failure + ^failure-type command-error +
           ^failure-info <handle> +)
}

sp {op_follow-wall1*propose*report-failure*unsatisfied-until-clause*after*stop
    (state <s> ^name op_follow-wall1 ^until-clause <until>
          ^current-action <c*2> ^current-action <c*1>)
    (<until> -^satisfied true)
    (<c*2> ^stop-command <s*1>)
    (<s*1> ^status success)
    (<c*1> ^execution-operator <e*1>)
    (<e*1> ^action-handle <handle>)
    -->
    (<s> ^operator <o> + ^operator <o> > ^operator <o> =)
    (<o> ^name report-failure + ^failure-type unsatisfied-until-clause +
           ^failure-info <handle> +)
}

sp {op_follow-wall1*propose*report-failure*unsatisfied-until-clause*after*follow-wall
    (state <s> ^name op_follow-wall1 ^until-clause <until>
          ^current-action <c*2> ^current-action <c*1>)
   -{ (<s> ^current-action <c*3>)
      (<c*3> ^stop-command <s*1>)}
    (<until> -^satisfied true)
    (<c*2> ^follow-wall-command <f*1>)
    (<f*1> ^status success)
    (<c*1> ^execution-operator <e*1>)
    (<e*1> ^action-handle <handle>)
    -->
    (<s> ^operator <o> + ^operator <o> > ^operator <o> =)
    (<o> ^name report-failure + ^failure-type unsatisfied-until-clause +
           ^failure-info <handle> +)
}

sp {op_follow-wall1*propose*report-failure*invalid-direction-failure
    (state <s> ^name op_follow-wall1 ^direction-id <d*1>
          ^direction-handle <handle>)
    (<d*1> ^property <p*1>)
    (<p*1> ^handle { <> relative-direction1 <h*1> })
    -->
    (<s> ^operator <o> + ^operator <o> > ^operator <o> =)
    (<o> ^name report-failure + ^failure-type invalid-direction-failure +
           ^failure-info <handle> +)
}

sp {op_follow-wall1*propose*report-failure*direction-retrieval-failure
    (state <s> ^name op_follow-wall1 ^smem-query <s*1>
          ^direction-handle <handle>)
    (<s*1> ^result failure)
    -->
    (<s> ^operator <o> + ^operator <o> > ^operator <o> =)
    (<o> ^name report-failure + ^failure-type direction-retrieval-failure +
           ^failure-info <handle> +)
}

sp {op_follow-wall*propose*report-success*stopped
    (state <s> ^name op_follow-wall1 ^until-clause <u*1> ^current-action <c*1>)
    (<u*1> ^satisfied true)
    (<c*1> ^stop-command <s*1>)
    (<s*1> ^status success)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name report-success +)
}

sp {op_follow-wall*propose*report-success*finished
    (state <s> ^name op_follow-wall1 -^until-clause <u*1>
          ^current-action <c*1>)
    (<c*1> ^follow-wall-command <f*1>)
    (<f*1> ^status success)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name report-success +)
}

sp {op_follow-wall1*apply*send-follow-wall-command*no*until
    (state <s> ^name op_follow-wall1 ^operator <o> ^current-action <a>
          ^top-state <t*1>)
    (<o> ^name send-follow-wall-command ^side <side>)
    (<t*1> ^io <i*1>)
    (<i*1> ^output-link <out>)
    -->
    (<out> ^do-control-law <law> +)
    (<law> ^name follow-wall + ^parameters <p*1> +
           ^termination-condition <t*2> +)
    (<p*1> ^side <side> +)
    (<t*2> ^name stabilized +)
    (<a> ^follow-wall-command <law> +)
}

sp {op_follow-wall1*propose*send-follow-wall-command
    (state <s> ^name op_follow-wall1 ^wall-side <side>)
   -{ (<s> ^current-action <c*2>)
      (<c*2> ^stop-command <s*1>)}
   -{ (<s> ^current-action <c*1>)
      (<c*1> ^follow-wall-command <f*1>)}
    -->
    (<s> ^operator <o> +)
    (<o> ^name send-follow-wall-command + ^side <side> +)
}

sp {op_follow-wall*elaborate*wall-side*from*direction-id
    (state <s> ^name op_follow-wall1 ^direction-id <d*1>)
    (<d*1> ^side <side>)
    -->
    (<s> ^wall-side <side> +)
}

sp {op_follow-wall1*elaborate*direction-id*from*retrieval
    (state <s> ^name op_follow-wall1 ^direction-handle <dir-handle>
          ^smem-query <s*1>)
    (<s*1> ^result <dir-id>)
    (<dir-id> ^handle <dir-handle>)
    -->
    (<s> ^direction-id <dir-id> +)
}

sp {op_follow-wall1*elaborate*smem-query-cue*direction
    (state <s> ^name op_follow-wall1 ^direction-handle <dir-handle>)
    -->
    (<s> ^smem-query <q> +)
    (<q> ^cue <cue> + ^depth 2 +)
    (<cue> ^handle <dir-handle> +)
}

sp {op_follow-wall1*elaborate*direction-handle*default
    (state <s> ^name op_follow-wall1)
   -{ (<s> ^action-operator <a*1>)
      (<a*1> ^arg1 <a*2>)
      (<a*2> ^id <i*1>)
      (<i*1> ^predicates <p*1>)
      (<p*1> ^relative-direction1 <dir-handle>)}
    -->
    (<s> ^direction-handle left1 +)
}

sp {op_follow-wall1*elaborate*direction-handle*from*action-operator
    (state <s> ^name op_follow-wall1 ^action-operator <a*1>)
    (<a*1> ^arg1 <a*2>)
    (<a*2> ^id <i*1>)
    (<i*1> ^predicates <p*1>)
    (<p*1> ^relative-direction1 <dir-handle>)
    -->
    (<s> ^direction-handle <dir-handle> +)
}

sp {op_follow-wall1*elaborate*until-clause*from*superoperator
    (state <s> ^name op_follow-wall1 ^action-operator <a*1>)
    (<a*1> ^until-clause <term>)
    -->
    (<s> ^until-clause <term> +)
}

sp {op_follow-wall1*elaborate*attend-to-all-perception*yes
    (state <s> ^name op_follow-wall1 ^problem-space <p*1>)
    (<p*1> ^perception <p>)
    -->
    (<p> ^attend-to-all-perception yes +)
}

sp {action*execute*apply*store-subaction*predicate*arg*predicate*default
    (state <s> ^operator <o> ^problem-space <p*1> ^smem <s*1>)
    (<o> ^name store-subaction ^subaction <s*2>)
    (<p*1> ^name action)
    (<s*1> ^command <cmd>)
    (<s*2> ^<arg-name> <a*1>)
    (<a*1> ^predicate <p*2>)
    (<p*2> ^{ << id 1 2 3 4 5 >> <a*2> } <v*1>)
    (<v*1> ^{ << default imagined >> <a*3> } <def>)
    -->
    (<cmd> ^store <def> +)
}

sp {action*execute*apply*store-subaction*arg*predicate*slot
    (state <s> ^operator <o> ^problem-space <p*1> ^smem <s*1>)
    (<o> ^name store-subaction ^subaction <s*2>)
    (<p*1> ^name action)
    (<s*1> ^command <cmd>)
    (<s*2> ^<arg-name> <a*1>)
    (<a*1> ^predicate <p*2>)
    (<p*2> ^{ << id 1 2 3 4 5 >> <a*2> } <slot>)
    -->
    (<cmd> ^store <slot> +)
}

sp {action*execute*apply*store-subaction*predicate*arg*default
    (state <s> ^operator <o> ^problem-space <p*1> ^smem <s*1>)
    (<o> ^name store-subaction ^subaction <s*2>)
    (<p*1> ^name action)
    (<s*1> ^command <cmd>)
    (<s*2> ^<arg-name> <a*1>)
    (<a*1> ^{ << id 1 2 3 4 5 >> <a*2> } <v*1>)
    (<v*1> ^{ << default imagined >> <a*3> } <def>)
    -->
    (<cmd> ^store <def> +)
}

sp {action*execute*apply*store-subaction*arg*slots
    (state <s> ^operator <o> ^problem-space <p*1> ^smem <s*1>)
    (<o> ^name store-subaction ^subaction <s*2>)
    (<p*1> ^name action)
    (<s*1> ^command <cmd>)
    (<s*2> ^<arg-name> <a*1>)
    (<a*1> ^{ << id 1 2 3 4 5 predicate >> <a*2> } <slot>)
    -->
    (<cmd> ^store <slot> +)
}

sp {action*execute*apply*store-subaction*argument
    (state <s> ^operator <o> ^problem-space <p*1> ^smem <s*1>)
    (<o> ^name store-subaction ^subaction <s*2>)
    (<p*1> ^name action)
    (<s*1> ^command <cmd>)
    (<s*2> ^<arg-name> <arg>)
    (<arg> ^arg-type <any>)
    -->
    (<cmd> ^store <arg> +)
}

sp {action*execute*apply*store-subaction*store*root
    (state <s> ^operator <o> ^problem-space <p*1> ^action-id <a*1> ^smem <s*1>)
    (<o> ^name store-subaction ^subaction <sub>)
    (<p*1> ^name action)
    (<a*1> ^procedural <proc>)
    (<s*1> ^command <cmd>)
    -->
    (<proc> ^subaction <sub> +)
    (<cmd> ^store <sub> + ^store <proc> +)
}

sp {action*execute*apply*store-subaction*remove*subaction
    (state <s> ^operator <o> ^store-subaction <sub> ^problem-space <p*1>)
    (<o> ^name store-subaction ^subaction <sub>)
    (<p*1> ^name action)
    -->
    (<s> ^store-subaction <sub> -)
}

sp {action*execute*propose*store-subaction
    (state <s> ^problem-space <p*1> ^store-subaction <sub>
          ^problem-space <p*2>)
    (<p*1> ^name action)
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name store-subaction + ^subaction <sub> +)
}

sp {learn-task-subaction*apply*return-subaction-structure
    (state <s> ^name learn-task-subaction ^operator <o> ^superstate <ss>)
    (<o> ^name return-subaction-structure ^subaction-structure <struct>)
    -->
    (<ss> ^store-subaction <struct> +)
}

sp {learn-task-subaction*propose*return-subaction-structure
    (state <s> ^name learn-task-subaction ^subaction-structure <struct>)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name return-subaction-structure + ^subaction-structure <struct> +)
}

sp {learn-task-subaciton*apply*create-subaction-argument*mark*until-clause
    (state <s> ^name learn-task-subaction ^operator <o>
          ^subaction-structure <struct>)
    (<o> ^name create-subaction-argument ^argument-info <arg-info>)
    (<arg-info> ^argument <a*1> ^generalized <g*1>)
    (<a*1> ^arg-type until-clause)
    (<g*1> ^generalized-rep <gen-rep>)
    -->
    (<gen-rep> ^arg-type until-clause +)
}

sp {learn-task-subaciton*apply*create-subaction-argument*copy*arg-status
    (state <s> ^name learn-task-subaction ^operator <o>
          ^subaction-structure <struct> ^subaction-id <s*1>)
    (<o> ^name create-subaction-argument ^argument-info <arg-info>)
    (<s*1> ^procedural <p*1>)
    (<arg-info> ^generalized <g*1> ^arg-name <arg-name>)
    (<g*1> ^generalized-rep <gen-rep>)
    (<p*1> ^<arg-name> <a*1>)
    (<a*1> ^arg-status <status>)
    -->
    (<gen-rep> ^arg-status <status> +)
}

sp {learn-task-subaciton*apply*create-subaction-argument
    (state <s> ^name learn-task-subaction ^operator <o>
          ^subaction-structure <struct>)
    (<o> ^name create-subaction-argument ^argument-info <arg-info>)
    (<arg-info> ^generalized <g*1> ^arg-name <arg-name>)
    (<g*1> ^generalized-rep <gen-rep>)
    -->
    (<struct> ^<arg-name> <gen-rep> +)
}

sp {learn-task-subaction*propose*create-subaction-argument
    (state <s> ^name learn-task-subaction ^subaction-structure <struct>
          ^argument-info <arg-info>)
    (<arg-info> ^arg-name <arg-name> ^generalized <g*1>)
    (<struct> -^<arg-name> <a*1>)
    (<g*1> ^generalized-rep <gen>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name create-subaction-argument + ^argument-info <arg-info> +)
}

sp {learn-task-subaction*apply*create-subaction*copy*perform
    (state <s> ^name learn-task-subaction ^operator <o*1>
          ^subaction-structure <struct> ^subaction-id <s*1>)
    (<o*1> ^name create-subaction)
    (<s*1> ^perform <perf>)
    -->
    (<struct> ^perform <perf> +)
}

sp {learn-task-subaction*apply*create-subaction*copy*handle
    (state <s> ^name learn-task-subaction ^operator <o*1>
          ^subaction-structure <struct> ^subaction <s*1>)
    (<o*1> ^name create-subaction)
    (<s*1> ^action-handle <handle>)
    -->
    (<struct> ^action-handle <handle> +
           ^handle (make-constant-symbol subaction) +)
}

sp {learn-task-subaction*apply*create-subaction*copy*name
    (state <s> ^name learn-task-subaction ^operator <o*1>
          ^subaction-structure <struct> ^subaction <s*1>)
    (<o*1> ^name create-subaction)
    (<s*1> ^name <op-name>)
    -->
    (<struct> ^op_name <op-name> +)
}

sp {learn-task-subaction*apply*create-subaction*create*structure
    (state <s> ^name learn-task-subaction ^operator <o*1>)
    (<o*1> ^name create-subaction)
    -->
    (<s> ^subaction-structure <struct> +)
}

sp {learn-task-subaction*propose*create-subaction
    (state <s> ^name learn-task-subaction)
   -{ (<s> ^subaction-structure <s*1>)
      (<s*1> ^op_name <o*1>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name create-subaction +)
}

sp {learn-task-subaction*elaborate*generalize-argument*arg-type*predicate-set
    (state <s> ^name learn-task-subaction ^generalize-argument <gen>)
    (<gen> ^instance <i*1>)
    (<i*1> ^arg-type until-clause)
    -->
    (<gen> ^arg-type predicate-set +)
}

sp {learn-task-subaction*elaborate*argument-info
    (state <s> ^name learn-task-subaction ^subaction <s*1>)
    (<s*1> ^<arg-name> <arg>)
    (<arg> ^arg-type <arg-type>)
    -->
    (<s> ^argument-info <arg-info> + ^generalize-argument <gen> +)
    (<arg-info> ^arg-name <arg-name> + ^arg-type <arg-type> +
           ^argument <arg> + ^generalized <gen> +)
    (<gen> ^instance <arg> +)
}

sp {learn-task-subaction*elaborate*subaction-id*from*smem-query
    (state <s> ^name learn-task-subaction ^subaction <s*1> ^smem-query <s*2>)
    (<s*1> ^action-handle <action-handle>)
    (<s*2> ^result <res>)
    (<res> ^handle <action-handle>)
    -->
    (<s> ^subaction-id <res> +)
}

sp {learn-task-subaction*elaborate*smem-query*subaction*handle
    (state <s> ^name learn-task-subaction ^subaction <s*1>)
    (<s*1> ^action-handle <action-handle>)
    -->
    (<s> ^smem-query <query> +)
    (<query> ^cue <cue> + ^depth 8 +)
    (<cue> ^handle <action-handle> +)
}

sp {learn-task-subaction*elaborate*subaction
    (state <s> ^name learn-task-subaction ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^subaction <sub>)
    -->
    (<s> ^subaction <sub> +)
}

sp {learn-task-subaction*elaborate*action-id
    (state <s> ^name learn-task-subaction ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^action-id <id>)
    -->
    (<s> ^action-id <id> +)
}

sp {learn-task-subaction*elaborate*action
    (state <s> ^name learn-task-subaction ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^action-operator <action>)
    -->
    (<s> ^action-operator <action> +)
}

sp {action*problem-space*prefer*store-subaction*over*learn-task-subaction
    (state <s> ^operator <o2> + ^operator <o1> + ^problem-space <p*1>)
    (<o2> ^name learn-task-subaction)
    (<o1> ^name store-subaction)
    (<p*1> ^name action)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {action*problem-space*execute*prefer*report-success*over*proposed*action
    (state <s> ^operator <o2> + -^child-action <c*1> -^name execute-action
          ^operator <o1> + ^problem-space <p*1> ^problem-space <p*2>)
    (<o1> ^name report-success)
    (<p*1> ^name action)
    (<o2> ^action-handle <any>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {action*problem-space*execute*prefer*child-action*over*report-success
    (state <s> ^child-action <c*1> -^name execute-action ^operator <o1> +
          ^operator <o2> + ^problem-space <p*1> ^problem-space <p*2>)
    (<c*1> ^execution-operator <o1>)
    (<o2> ^name report-success)
    (<p*1> ^name action)
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {action*problem-space*execute*prefer*child-action*over*non-child
    (state <s> ^child-action <c*1> -^name execute-action ^operator <o1> +
          ^problem-space <p*1> ^operator { <> <o1> <o2> } +
          ^problem-space <p*2>)
    (<c*1> ^execution-operator <o1>)
    (<p*1> ^name action)
    (<o2> ^action-handle <any>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {action*problem-space*execute*prefer*smem*over*others
    (state <s> ^operator <o2> + -^name execute-action ^problem-space <p*1>
          ^operator <o1> + ^problem-space <p*2>)
    (<o2>
          -^name { << smem-query smem-retrieve smem-retrieve-lti smem-store >> <n*2> })
    (<p*1> ^name action)
    (<o1>
          ^name { << smem-query smem-retrieve smem-retrieve-lti smem-store >> <n*1> })
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {action*problem-space*reject*operators*if*unproposed*subaction
    (state <s> ^action-id <a*2> -^name execute-action ^problem-space <p*1>
          ^operator <o> + ^problem-space <p*2>)
    (<p*1> ^name action)
    (<a*2> ^procedural <p*3>)
    (<p*3> ^subaction <s*1>)
    (<s*1> ^handle <sub-handle>)
   -{ (<s> ^operator <o1> +)
      (<o1> ^subaction-handle <sub-handle>)}
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    -->
    (<s> ^operator <o> -)
}

sp {action*problem-space*execute*propose*child-action
    (state <s> ^problem-space <p*1> ^child-action <a> ^problem-space <p*2>)
    (<p*1> ^name action)
    (<a> ^execution-operator <ex>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    -->
    (<s> ^operator <ex> + ^operator <ex> >)
}

sp {action*problem-space*execute*apply*report-success*remove*output*commands
    (state <s> ^operator <o*1> ^problem-space <p*1> ^current-action <a>
          ^io <i*1> ^problem-space <p*2>)
    (<o*1> ^name report-success)
    (<p*1> ^name action)
    (<i*1> ^output-link <out>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    (<out> ^<out-name> <cmd>)
    (<a> ^<cmd-name> <cmd>)
    -->
    (<out> ^<out-name> <cmd> -)
}

sp {action*problem-space*execute*apply*report-success*mark*status*success
    (state <s> ^operator <o*1> ^problem-space <p*1> ^current-action <a>
          ^problem-space <p*2>)
    (<o*1> ^name report-success)
    (<p*1> ^name action)
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    -->
    (<a> ^status success +)
}

sp {action*problem-space*execute*propose*report-success*desired*satisfied
    (state <s> ^desired <d*1> ^problem-space <p*1> ^problem-space <p*2>)
    (<d*1> ^satisfied true)
    (<p*1> ^name action)
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name report-success +)
}

sp {action*problem-space*execute*action*status*pop*action
    (state <s> ^problem-space <p*1> ^child-action <a> ^operator <o>
          ^action-stack <stack> ^problem-space <p*2>)
    (<p*1> ^name action)
    (<a> ^execution-operator <o> ^status <status>)
    (<stack> ^top <a> ^changes <c>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    -->
    (<c> ^pop <a> +)
}

sp {action*problem-space*execute*apply*action-operator*push*action
    (state <s> ^copied-level2 true ^problem-space <p*1>
          ^new-action-segment <seg> ^operator <o> ^top-state <t*1>
          ^problem-space <p*2>)
    (<p*1> ^name action)
    (<seg> ^action-handle <action-handle>)
    (<o> ^action-handle <action-handle>)
    (<t*1> ^action-stack <a*2>)
    (<a*2> ^changes <c>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    -->
    (<c> ^push <seg> +)
}

sp {action*problem-space*execute*apply*action-operator*copy*until-clause*relation*predicate
    (state <s> ^problem-space <p*1> ^new-action-segment <seg> ^operator <o>
          ^problem-space <p*2>)
    (<p*1> ^name action)
    (<seg> ^action-handle <action-handle> ^execution-operator <e*1>)
    (<o> ^action-handle <action-handle> ^until-clause <u*1>)
    (<u*1> ^predicate <until-pred>)
    (<until-pred> ^type relation ^2 <obj2> ^handle <pred-handle> ^1 <obj1>)
    (<e*1> ^until-clause <new-until>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    -->
    (<new-until> ^predicate <new-pred> +)
    (<new-pred> ^type relation + ^handle <pred-handle> + ^1 <obj1> +
           ^2 <obj2> +)
}

sp {action*problem-space*execute*apply*action-operator*copy*until-clause*state*predicate
    (state <s> ^problem-space <p*1> ^new-action-segment <seg> ^operator <o>
          ^problem-space <p*2>)
    (<p*1> ^name action)
    (<seg> ^action-handle <action-handle> ^execution-operator <e*1>)
    (<o> ^action-handle <action-handle> ^until-clause <u*1>)
    (<u*1> ^predicate <until-pred>)
    (<until-pred> ^type state ^handle <pred-handle> ^1 <obj>)
    (<e*1> ^until-clause <new-until>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    -->
    (<new-until> ^predicate <new-pred> +)
    (<new-pred> ^type state + ^handle <pred-handle> + ^1 <obj> +)
}

sp {action*problem-space*execute*apply*action-operator*copy*abstract*predicate*object*predicates
    (state <s> ^problem-space <p*1> ^new-action-segment <seg> ^operator <o>
          ^problem-space <p*2>)
    (<p*1> ^name action)
    (<seg> ^action-handle <action-handle> ^execution-operator <e*1>)
    (<o> ^action-handle <action-handle> ^<arg-name> <arg>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    (<arg> ^arg-type predicate ^2 <pred-obj> ^2 <v*1>)
   -{ (<s> ^world <w*1>)
      (<w*1> ^objects <o*1>)
      (<o*1> ^object <pred-obj>)}
    (<v*1> ^predicates <p*3>)
    (<e*1> ^<arg-name> <a*2>)
    (<a*2> ^2 <v*2>)
    (<v*2> ^predicates <new-preds>)
    (<p*3> ^<prop-name> <pred-name>)
    -->
    (<new-preds> ^<prop-name> <pred-name> +)
}

sp {action*problem-space*execute*apply*action-operator*copy*abstract*object*predicates
    (state <s> ^problem-space <p*1> ^new-action-segment <seg> ^operator <o>
          ^problem-space <p*2>)
    (<p*1> ^name action)
    (<seg> ^action-handle <action-handle> ^execution-operator <e*1>)
    (<o> ^action-handle <action-handle> ^<arg-name> <arg>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    (<arg> ^arg-type object ^id <obj> ^id <i*1>)
   -{ (<s> ^world <w*1>)
      (<w*1> ^objects <o*1>)
      (<o*1> ^object <obj>)}
    (<i*1> ^predicates <p*3>)
    (<e*1> ^<arg-name> <a*2>)
    (<a*2> ^id <i*2>)
    (<i*2> ^predicates <new-preds>)
    (<p*3> ^<prop-name> <pred-name>)
    -->
    (<new-preds> ^<prop-name> <pred-name> +)
}

sp {action*problem-space*execute*apply*action-operator*mark*copied-level2
    (state <s> ^copied-level1 true ^problem-space <p*1>
          ^new-action-segment <seg> ^operator <o> ^problem-space <p*2>)
    (<p*1> ^name action)
    (<seg> ^action-handle <action-handle>)
    (<o> ^action-handle <action-handle>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    -->
    (<s> ^copied-level2 true +)
}

sp {action*problem-space*execute*apply*action-operator*copy*until-clause
    (state <s> ^problem-space <p*1> ^new-action-segment <seg> ^operator <o>
          ^problem-space <p*2>)
    (<p*1> ^name action)
    (<seg> ^action-handle <action-handle> ^execution-operator <ex-op>)
    (<o> ^action-handle <action-handle> ^until-clause <until>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    -->
    (<ex-op> ^until-clause <new-clause> +)
}

sp {action*problem-space*execute*apply*action-operator*copy*abstract*predicate*arg*default-handle
    (state <s> ^problem-space <p*1> ^new-action-segment <seg> ^operator <o>
          ^problem-space <p*2>)
    (<p*1> ^name action)
    (<seg> ^action-handle <action-handle> ^execution-operator <ex-op>)
    (<o> ^action-handle <action-handle> ^<arg-name> <arg>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    (<arg> -^handle <h*1> ^arg-type predicate ^2 <pred-obj>
          ^default-handle <pred-handle>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^maps <m*1>)
      (<m*1> ^map <m*2>)
      (<m*2> ^waypoint <pred-obj>)}
   -{ (<s> ^world <w*1>)
      (<w*1> ^objects <o*1>)
      (<o*1> ^object <pred-obj>)}
    -->
    (<ex-op> ^<arg-name> <new-arg> +)
    (<new-arg> ^arg-type predicate + ^handle <pred-handle> + ^2 <new-obj> +)
    (<new-obj> ^item-type object + ^predicates <preds> +)
}

sp {action*problem-space*execute*apply*action-operator*copy*abstract*predicate*arg
    (state <s> ^problem-space <p*1> ^new-action-segment <seg> ^operator <o>
          ^problem-space <p*2>)
    (<p*1> ^name action)
    (<seg> ^action-handle <action-handle> ^execution-operator <ex-op>)
    (<o> ^action-handle <action-handle> ^<arg-name> <arg>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    (<arg> ^arg-type predicate ^2 <pred-obj> ^handle <pred-handle>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^maps <m*1>)
      (<m*1> ^map <m*2>)
      (<m*2> ^waypoint <pred-obj>)}
   -{ (<s> ^world <w*1>)
      (<w*1> ^objects <o*1>)
      (<o*1> ^object <pred-obj>)}
    -->
    (<ex-op> ^<arg-name> <new-arg> +)
    (<new-arg> ^arg-type predicate + ^handle <pred-handle> + ^2 <new-obj> +)
    (<new-obj> ^item-type object + ^predicates <preds> +)
}

sp {action*problem-space*execute*apply*action-operator*copy*predicate*arg*waypoint
    (state <s> ^problem-space <p*1> ^new-action-segment <seg> ^operator <o>
          ^top-state <t*1> ^problem-space <p*2>)
    (<p*1> ^name action)
    (<seg> ^action-handle <action-handle> ^execution-operator <ex-op>)
    (<o> ^action-handle <action-handle> ^<arg-name> <arg>)
    (<t*1> ^maps <m*1>)
    (<m*1> ^map <m*2>)
    (<m*2> ^waypoint <wp>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    (<arg> ^arg-type predicate ^2 <wp> ^handle <pred-handle>)
    -->
    (<ex-op> ^<arg-name> <new-arg> +)
    (<new-arg> ^arg-type predicate + ^handle <pred-handle> + ^2 <wp> +)
}

sp {action*problem-space*execute*apply*action-operator*copy*predicate*arg*default-handle
    (state <s> ^problem-space <p*1> ^new-action-segment <seg> ^operator <o>
          ^world <w*1> ^problem-space <p*2>)
    (<p*1> ^name action)
    (<seg> ^action-handle <action-handle> ^execution-operator <ex-op>)
    (<o> ^action-handle <action-handle> ^<arg-name> <arg>)
    (<w*1> ^objects <o*1>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    (<arg> -^handle <h*1> ^arg-type predicate ^default-handle <pred-handle>
          ^2 <pred-obj>)
    (<o*1> ^object <pred-obj>)
    -->
    (<ex-op> ^<arg-name> <new-arg> +)
    (<new-arg> ^arg-type predicate + ^handle <pred-handle> + ^2 <pred-obj> +)
}

sp {action*problem-space*execute*apply*action-operator*copy*predicate*arg
    (state <s> ^problem-space <p*1> ^new-action-segment <seg> ^operator <o>
          ^world <w*1> ^problem-space <p*2>)
    (<p*1> ^name action)
    (<seg> ^action-handle <action-handle> ^execution-operator <ex-op>)
    (<o> ^action-handle <action-handle> ^<arg-name> <arg>)
    (<w*1> ^objects <o*1>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    (<arg> ^arg-type predicate ^2 <pred-obj> ^handle <pred-handle>)
    (<o*1> ^object <pred-obj>)
    -->
    (<ex-op> ^<arg-name> <new-arg> +)
    (<new-arg> ^arg-type predicate + ^handle <pred-handle> + ^2 <pred-obj> +)
}

sp {action*problem-space*execute*apply*action-operator*copy*concept*arg
    (state <s> ^problem-space <p*1> ^new-action-segment <seg> ^operator <o>
          ^problem-space <p*2>)
    (<p*1> ^name action)
    (<seg> ^action-handle <action-handle> ^execution-operator <ex-op>)
    (<o> ^action-handle <action-handle> ^<arg-name> <arg>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    (<arg> ^arg-type concept ^handle <concept>)
    -->
    (<ex-op> ^<arg-name> <new-arg> +)
    (<new-arg> ^arg-type concept + ^handle <concept> +)
}

sp {action*problem-space*execute*apply*action-operator*copy*abstract*object*arg
    (state <s> ^problem-space <p*1> ^new-action-segment <seg> ^operator <o>
          ^problem-space <p*2>)
    (<p*1> ^name action)
    (<seg> ^action-handle <action-handle> ^execution-operator <ex-op>)
    (<o> ^action-handle <action-handle> ^<arg-name> <arg>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    (<arg> ^arg-type object ^id <obj>)
   -{ (<s> ^world <w*1>)
      (<w*1> ^objects <o*1>)
      (<o*1> ^object <obj>)}
    -->
    (<ex-op> ^<arg-name> <new-arg> +)
    (<new-arg> ^arg-type object + ^id <new-obj> +)
    (<new-obj> ^item-type object + ^predicates <new-preds> +)
}

sp {action*problem-space*execute*apply*action-operator*copy*object*arg
    (state <s> ^problem-space <p*1> ^new-action-segment <seg> ^operator <o>
          ^world <w*1> ^problem-space <p*2>)
    (<p*1> ^name action)
    (<seg> ^action-handle <action-handle> ^execution-operator <ex-op>)
    (<o> ^action-handle <action-handle> ^<arg-name> <arg>)
    (<w*1> ^objects <o*1>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    (<arg> ^arg-type object ^id <obj>)
    (<o*1> ^object <obj>)
    -->
    (<ex-op> ^<arg-name> <new-arg> +)
    (<new-arg> ^arg-type object + ^id <obj> +)
}

sp {action*problem-space*execute*apply*action-operator*mark*copied-level1
    (state <s> ^problem-space <p*1> ^new-action-segment <seg> ^operator <o>
          ^problem-space <p*2>)
    (<p*1> ^name action)
    (<seg> ^action-handle <action-handle>)
    (<o> ^action-handle <action-handle>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    -->
    (<s> ^copied-level1 true +)
}

sp {action*problem-space*execute*apply*action-operator*copy*info*execution-operator
    (state <s> ^problem-space <p*1> ^new-action-segment <n*1> ^operator <o>
          ^problem-space <p*2>)
    (<p*1> ^name action)
    (<n*1> ^execution-operator <ex>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    (<o> ^{ << subaction-handle perform >> <att> } <val>)
    -->
    (<ex> ^<att> <val> +)
}

sp {action*problem-space*execute*apply*action-operator*create*new-action-segment
    (state <s> ^operator <o> -^child-action <child> -^name execute-action
          ^problem-space <p*1> ^problem-space <p*2>)
    (<p*1> ^name action)
    (<o> ^action-handle <action-handle> ^name <name>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    -->
    (<s> ^new-action-segment <seg> +)
    (<seg> ^action-handle <action-handle> + ^start-of-execution true +
           ^execution-operator <ex-op> +)
    (<ex-op> ^name <name> + ^action-handle <action-handle> +)
}

sp {action*problem-space*execute*elaborate*problem-space
    (state <s> ^superstate <ss> -^default-problem-space no)
    (<ss> ^problem-space <ss-ps> ^operator <ss-op>)
    (<ss-ps> ^name action ^action <a*1>)
    (<a*1> ^type execute)
    (<ss-op> ^action-handle <h>)
    -->
    (<s> ^problem-space <ps> +)
    (<ps> ^name action + ^action <action> + ^learning <learn> +
           ^world <world> + ^perception <perc> +)
    (<action> ^type execute +)
    (<world> ^copy-type shallow +)
}

sp {action*problem-space*execute*elaborate*child-action
    (state <s> ^problem-space <p*1> ^current-action <c*1> ^problem-space <p*2>)
    (<p*1> ^name action)
    (<c*1> ^next { <> none <child> })
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    -->
    (<s> ^child-action <child> +)
}

sp {action*problem-space*execute*elaborate*parent-action
    (state <s> ^problem-space <p*1> ^current-action <c*1> ^problem-space <p*2>)
    (<p*1> ^name action)
    (<c*1> ^prev { <> none <parent> })
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    -->
    (<s> ^parent-action <parent> +)
}

sp {action*problem-space*execute*elaborate*current-action*from*superstate*child-action
    (state <s> ^problem-space <p*1> ^action-operator <o> ^superstate <s*1>
          ^problem-space <p*2>)
    (<p*1> ^name action)
    (<s*1> ^child-action <a>)
    (<a> ^execution-operator <o>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    -->
    (<s> ^current-action <a> +)
}

sp {action*problem-space*execute*elaborate*current-action*from*superstate*current-action
    (state <s> ^problem-space <p*1> ^action-operator <o> ^superstate <s*1>
          ^problem-space <p*2>)
    (<p*1> ^name action)
    (<s*1> ^current-action <a>)
    (<a> ^execution-operator <o>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    -->
    (<s> ^current-action <a> +)
}

sp {action*problem-space*execute*elaborate*action-stack*from*top-state
    (state <s> ^problem-space <p*1> ^top-state <t*1> ^problem-space <p*2>)
    (<p*1> ^name action)
    (<t*1> ^action-stack <stack>)
    (<p*2> ^action <a*1>)
    (<a*1> ^type execute)
    -->
    (<s> ^action-stack <stack> +)
}

sp {action*prefer*report-failure*bad-arguments*over*unknown-goal
    (state <s> ^operator <o2> + ^problem-space <p*1> ^operator <o1> +)
    (<o2> ^name report-failure-unknown-goal)
    (<p*1> ^name action)
    (<o1>
          ^name { << report-failure-multiple-arguments report-failure-missing-argument >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {action*execute*composite*reject*all*operators*if*no*desired
    (state <s> ^action-id <a*1> -^desired <d*1> ^problem-space <ps>
          ^operator <o> +)
    (<ps> ^name action ^action <a*2>)
    (<a*2> ^type execute)
    (<a*1> ^goal <g*1>)
    -->
    (<s> ^operator <o> -)
}

sp {action*composite-action*reject*perform*once*subaction*if*performed
    (state <s> ^operator <o> + ^problem-space <p*1> ^action-operator <a*1>)
    (<o> ^perform once ^subaction-handle <sub-handle>)
    (<p*1> ^name action)
    (<a*1> ^performed <sub-handle>)
    -->
    (<s> ^operator <o> -)
}

sp {action*best*preference*evaluate-operator*matched
    (state <s> ^operator <o> + ^problem-space <p*1> ^match-action <m*1>)
    (<o> ^name evaluate-operator ^superoperator <eval-op>)
    (<p*1> ^name action)
    (<m*1> ^matched <eval-op>)
    -->
    (<s> ^operator <o> >)
}

sp {action*best*preference*operator*matched
    (state <s> ^problem-space <p*1> ^match-action <m*1> ^operator <o> +)
    (<p*1> ^name action)
    (<m*1> ^matched <o>)
    -->
    (<s> ^operator <o> >)
}

sp {action*problem-space*learning*elaborate*action-operator*deep*until-clause*relation*predicate
    (state <s> ^deep-copy-action-operator <d*1> ^deep-copy-world <d*2>
          ^action-operator <a*1>)
    (<d*2> ^copy-objects-map <objs-map>)
    (<objs-map> ^entry <obj2-e> ^entry <obj1-e>)
    (<obj2-e> ^copy <obj2> ^source <src-obj2>)
    (<obj1-e> ^copy <obj1> ^source <src-obj1>)
    (<d*1> ^until-clause <u*1>)
    (<u*1> ^predicate <src-pred>)
    (<src-pred> ^type relation ^2 <src-obj2> ^1 <src-obj1>
          ^handle <pred-handle>)
    (<a*1> ^until-clause <new-until>)
    -->
    (<new-until> ^predicate <new-pred> +)
    (<new-pred> ^type relation + ^handle <pred-handle> + ^1 <obj1> +
           ^2 <obj2> +)
}

sp {action*problem-space*elaborate*action-operator*deep*copy*until-clause*state*predicate
    (state <s> ^deep-copy-action-operator <d*1> ^deep-copy-world <d*2>
          ^action-operator <a*1>)
    (<d*2> ^copy-objects-map <objs-map>)
    (<objs-map> ^entry <obj-e>)
    (<obj-e> ^copy <obj> ^source <src-obj>)
    (<d*1> ^until-clause <u*1>)
    (<u*1> ^predicate <src-pred>)
    (<src-pred> ^type state ^1 <src-obj> ^property-handle <prop-handle>
          ^handle <pred-handle>)
    (<a*1> ^until-clause <new-until>)
    -->
    (<new-until> ^predicate <new-pred> +)
    (<new-pred> ^type state + ^handle <pred-handle> +
           ^property-handle <prop-handle> + ^1 <obj> +)
}

sp {action*problem-space*elaborate*action-operator*deep*copy*until-clause
    (state <s> ^deep-copy-action-operator <src-op> ^action-operator <new-op>)
    (<src-op> ^until-clause <src-until>)
    -->
    (<new-op> ^until-clause <new-until> +)
}

sp {action*problem-space*elaborate*action-operator*deep*copy*predicate*argument*new*level2
    (state <s> ^deep-copy-action-operator <src-op> ^action-operator <new-op>)
    (<src-op> ^<arg-name> <src-arg>)
    (<src-arg> ^arg-type predicate ^2 <src-obj>)
   -{ (<s> ^deep-copy-world <d*1>)
      (<d*1> ^copy-objects-map <c*1>)
      (<c*1> ^entry <e*1>)
      (<e*1> ^source <src-obj>)}
    (<src-obj> ^predicates <p*1>)
    (<new-op> ^<arg-name> <new-arg>)
    (<new-arg> ^2 <new-obj>)
    (<new-obj> ^predicates <new-preds>)
    (<p*1> ^<prop-name> <pred-name>)
    -->
    (<new-preds> ^<prop-name> <pred-name> +)
}

sp {action*problem-space*elaborate*action-operator*deep*copy*predicate*argument*new*level1
    (state <s> ^deep-copy-action-operator <src-op> ^action-operator <new-op>)
    (<src-op> ^<arg-name> <src-arg>)
    (<src-arg> ^arg-type predicate ^2 <src-obj> ^handle <pred-handle>)
   -{ (<s> ^deep-copy-world <d*1>)
      (<d*1> ^copy-objects-map <c*1>)
      (<c*1> ^entry <e*1>)
      (<e*1> ^source <src-obj>)}
    (<src-obj> ^handle <obj-handle>)
    -->
    (<new-op> ^<arg-name> <new-arg> +)
    (<new-arg> ^arg-type predicate + ^handle <pred-handle> + ^2 <new-obj> +)
    (<new-obj> ^item-type object + ^handle <obj-handle> +
           ^predicates <preds> +)
}

sp {action*problem-space*elaborate*action-operator*deep*copy*predicate*argument*existing
    (state <s> ^deep-copy-action-operator <src-op> ^deep-copy-world <d*1>
          ^action-operator <new-op>)
    (<d*1> ^copy-objects-map <c*1>)
    (<c*1> ^entry <obj-e>)
    (<obj-e> ^copy <obj> ^source <src-obj>)
    (<src-op> ^<arg-name> <src-arg>)
    (<src-arg> ^arg-type predicate ^2 <src-obj> ^handle <handle>)
    -->
    (<new-op> ^<arg-name> <new-arg> +)
    (<new-arg> ^arg-type predicate + ^handle <pred> + ^2 <obj> +)
}

sp {action*problem-space*elaborate*action-operator*deep*copy*concept*argument
    (state <s> ^deep-copy-action-operator <src-op> ^action-operator <new-op>)
    (<src-op> ^<arg-name> <src-arg>)
    (<src-arg> ^arg-type concept ^id <concept>)
    -->
    (<new-op> ^<arg-name> <new-arg> +)
    (<new-arg> ^arg-type concept + ^id <concept> +)
}

sp {action*problem-space*elaborate*action-operator*deep*copy*object*argument*new*copy*predicates
    (state <s> ^deep-copy-action-operator <src-op> ^action-operator <new-op>)
    (<src-op> ^<arg-name> <src-arg>)
    (<src-arg> ^arg-type object ^id <src-obj>)
   -{ (<s> ^deep-copy-world <d*1>)
      (<d*1> ^copy-objects-map <c*1>)
      (<c*1> ^entry <e*1>)
      (<e*1> ^source <src-obj>)}
    (<src-obj> ^predicates <p*1>)
    (<new-op> ^<arg-name> <new-arg>)
    (<new-arg> ^id <new-obj>)
    (<new-obj> ^predicates <new-preds>)
    (<p*1> ^<prop-name> <pred-name>)
    -->
    (<new-preds> ^<prop-name> <pred-name> +)
}

sp {action*problem-space*elaborate*action-operator*deep*copy*object*arugment*new
    (state <s> ^deep-copy-action-operator <src-op> ^action-operator <new-op>)
    (<src-op> ^<arg-name> <src-arg>)
    (<src-arg> ^arg-type object ^id <src-obj>)
   -{ (<s> ^deep-copy-world <d*1>)
      (<d*1> ^copy-objects-map <c*1>)
      (<c*1> ^entry <e*1>)
      (<e*1> ^source <src-obj>)}
    (<src-obj> ^handle <obj-handle>)
    -->
    (<new-op> ^<arg-name> <new-arg> +)
    (<new-arg> ^arg-type object + ^id <new-obj> +)
    (<new-obj> ^item-type object + ^handle <obj-handle> +
           ^predicates <preds> +)
}

sp {action*problem-space*elaborate*action-operator*deep*copy*object*argument*existing
    (state <s> ^deep-copy-action-operator <src-op> ^deep-copy-world <d*1>
          ^action-operator <new-op>)
    (<d*1> ^copy-objects-map <c*1>)
    (<c*1> ^entry <obj-e>)
    (<obj-e> ^copy <new-obj> ^source <src-obj>)
    (<src-op> ^<arg-name> <src-arg>)
    (<src-arg> ^arg-type object ^id <src-obj>)
    -->
    (<new-op> ^<arg-name> <new-arg> +)
    (<new-arg> ^arg-type object + ^id <new-obj> +)
}

sp {action*problem-space*elaborate*action-operator*deep*copy*level*1
    (state <s> ^deep-copy-action-operator <src-op> ^action-operator <new-op>)
    (<src-op> ^<att> <val>)
    (<val> -^<sub> <s*1>)
    -->
    (<new-op> ^<att> <val> +)
}

sp {action*problem-space*elaborate*action-operator*deep
    (state <s> ^name evaluate-operator ^problem-space <p*1> ^superstate <s*1>)
    (<p*1> ^name action)
    (<s*1> ^superstate <s*2>)
    (<s*2> ^action-operator <operator>)
    -->
    (<s> ^deep-copy-action-operator <operator> +
           ^action-operator <new-operator> +)
}

sp {action*elaborate*action-operator*superoperator
    (state <s> ^problem-space <p*1> ^superstate <s*1>)
    (<p*1> ^name action)
    (<s*1> ^operator <o>)
    (<o> ^action-handle <h>)
    -->
    (<s> ^action-operator <o> +)
}

sp {action*composite-action*elaborate*action-id*from*query*result
    :o-support
    (state <s> ^problem-space <p*1> ^smem-query <query> ^action-operator <a*1>)
    (<p*1> ^name action)
    (<a*1> ^action-handle <action-handle>)
    (<query> ^cue <c*1> ^result <id>)
    (<c*1> ^handle <action-handle>)
    -->
    (<s> ^action-id <id> +)
}

sp {action*problem-space*elaborate*smem-query
    (state <s> ^action-operator <action-op> -^action-id <a*1>
          ^problem-space <p*1>)
    (<p*1> ^name action)
    (<action-op> ^action-handle <action-handle>)
    -->
    (<s> ^smem-query <query> +)
    (<query> ^cue <cue> + ^depth 8 +)
    (<cue> ^handle <action-handle> +)
}

sp {action*elaborate*action-id*from*superstate*no*action-operator
    (state <s> ^superstate <s*1> -^action-operator <a*1> ^problem-space <p*1>)
    (<p*1> ^name action)
    (<s*1> ^action-id <id>)
    -->
    (<s> ^action-id <id> +)
}

sp {action*elaborate*action-id*from*superstate
    (state <s> ^problem-space <p*1> ^action-operator <a*1> ^superstate <s*1>)
    (<p*1> ^name action)
    (<a*1> ^action-handle <handle>)
    (<s*1> ^action-id <id>)
    (<id> ^handle <handle>)
    -->
    (<s> ^action-id <id> +)
}

sp {action*elaborate*desired*satisfied*6*predicates
    (state <s> ^problem-space <p*1> ^desired <d>)
    (<p*1> ^name action)
    (<d> ^predicate <p6> ^predicate { < <p6> <p5> } ^predicate { < <p5> <p4> }
          ^predicate { < <p4> <p3> } ^predicate { < <p3> <p2> }
          ^predicate { < <p2> <p1> }
          -^predicate { <> <p1> <> <p2> <> <p3> <> <p4> <> <p5> <> <p6> <p7> })
    (<p6> ^satisfied true)
    (<p5> ^satisfied true)
    (<p4> ^satisfied true)
    (<p3> ^satisfied true)
    (<p2> ^satisfied true)
    (<p1> ^satisfied true)
    -->
    (<d> ^satisfied true +)
}

sp {action*elaborate*desired*satisfied*5*predicates
    (state <s> ^problem-space <p*1> ^desired <d>)
    (<p*1> ^name action)
    (<d> ^predicate <p5> ^predicate { < <p5> <p4> } ^predicate { < <p4> <p3> }
          ^predicate { < <p3> <p2> } ^predicate { < <p2> <p1> }
          -^predicate { <> <p1> <> <p2> <> <p3> <> <p4> <> <p5> <p6> })
    (<p5> ^satisfied true)
    (<p4> ^satisfied true)
    (<p3> ^satisfied true)
    (<p2> ^satisfied true)
    (<p1> ^satisfied true)
    -->
    (<d> ^satisfied true +)
}

sp {action*elaborate*desired*satisfied*4*predicates
    (state <s> ^problem-space <p*1> ^desired <d>)
    (<p*1> ^name action)
    (<d> ^predicate <p4> ^predicate { < <p4> <p3> } ^predicate { < <p3> <p2> }
          ^predicate { < <p2> <p1> }
          -^predicate { <> <p1> <> <p2> <> <p3> <> <p4> <p5> })
    (<p4> ^satisfied true)
    (<p3> ^satisfied true)
    (<p2> ^satisfied true)
    (<p1> ^satisfied true)
    -->
    (<d> ^satisfied true +)
}

sp {action*elaborate*desired*satisfied*3*predicates
    (state <s> ^problem-space <p*1> ^desired <d>)
    (<p*1> ^name action)
    (<d> ^predicate <p3> ^predicate { < <p3> <p2> } ^predicate { < <p2> <p1> }
          -^predicate { <> <p1> <> <p2> <> <p3> <p4> })
    (<p3> ^satisfied true)
    (<p2> ^satisfied true)
    (<p1> ^satisfied true)
    -->
    (<d> ^satisfied true +)
}

sp {action*elaborate*desired*satisfied*2*predicates
    (state <s> ^problem-space <p*1> ^desired <d>)
    (<p*1> ^name action)
    (<d> ^predicate <p2> ^predicate { < <p2> <p1> }
          -^predicate { <> <p1> <> <p2> <p3> })
    (<p2> ^satisfied true)
    (<p1> ^satisfied true)
    -->
    (<d> ^satisfied true +)
}

sp {action*elaborate*desired*satisfied*1*predicate
    (state <s> ^problem-space <p*1> ^desired <d>)
    (<p*1> ^name action)
    (<d> ^predicate <p1> -^predicate { <> <p1> <p2> })
    (<p1> ^satisfied true)
    -->
    (<d> ^satisfied true +)
}

sp {action*elaborate*desired*relation*predicate*satisfied
    (state <s> ^problem-space <p*1> ^desired <d*1> ^world <w*1>)
    (<p*1> ^name action)
    (<d*1> ^predicate <p>)
    (<p> ^type relation ^2 <obj2> ^handle <rel-handle> ^1 <obj1>)
    (<w*1> ^predicates <preds>)
    (<preds> ^predicate <pred>)
    (<pred> ^handle <rel-handle> ^instance <i>)
    (<i> ^2 <obj2> ^1 <obj1>)
    -->
    (<p> ^satisfied true +)
}

sp {action*elaborate*desired*state*predicate*satisfied*visible
    (state <s> ^problem-space <p*1> ^desired <des> ^world <w*1>)
    (<p*1> ^name action)
    (<des> ^predicate <pred>)
    (<pred> ^handle visible1 ^type state ^1 <obj>)
    (<w*1> ^objects <o*1>)
    (<obj> ^predicates <p*2>)
    (<p*2> ^visible true)
    (<o*1> ^object <obj>)
    -->
    (<pred> ^satisfied true +)
}

sp {action*elaborate*desired*state*predicate*satisfied
    (state <s> ^problem-space <p*1> ^desired <d*1>)
    (<p*1> ^name action)
    (<d*1> ^predicate <p>)
    (<p> ^type state ^handle <pred-name> ^1 <obj>)
    (<obj> ^predicates <preds>)
    (<preds> ^<prop-handle> <pred-name>)
    -->
    (<p> ^satisfied true +)
}

sp {action*problem-space*match-action*elaborate*op-info*op-matched*5*argument
    (state <s> ^match-action <ma>)
    (<ma> ^match-info <m*1>)
    (<m*1> ^op-info <op-info>)
    (<op-info> ^argument-name <arg5> ^matches <arg5>
          ^argument-name { < <arg5> <arg4> } ^matches <arg4>
          ^argument-name { < <arg4> <arg3> } ^matches <arg3>
          ^argument-name { < <arg3> <arg2> } ^matches <arg2>
          ^argument-name { < <arg2> <arg1> }
          -^argument-name { <> <arg1> <> <arg2> <> <arg3> <> <arg4> <> <arg5> <arg6> }
          ^matches <arg1> ^operator <op>)
    -->
    (<ma> ^matched <op> +)
}

sp {action*problem-space*match-action*elaborate*op-info*op-matched*4*argument
    (state <s> ^match-action <ma>)
    (<ma> ^match-info <m*1>)
    (<m*1> ^op-info <op-info>)
    (<op-info> ^argument-name <arg4> ^matches <arg4>
          ^argument-name { < <arg4> <arg3> } ^matches <arg3>
          ^argument-name { < <arg3> <arg2> } ^matches <arg2>
          ^argument-name { < <arg2> <arg1> }
          -^argument-name { <> <arg1> <> <arg2> <> <arg3> <> <arg4> <arg5> }
          ^matches <arg1> ^operator <op>)
    -->
    (<ma> ^matched <op> +)
}

sp {action*problem-space*match-action*elaborate*op-info*op-matched*3*argument
    (state <s> ^match-action <ma>)
    (<ma> ^match-info <m*1>)
    (<m*1> ^op-info <op-info>)
    (<op-info> ^argument-name <arg3> ^matches <arg3>
          ^argument-name { < <arg3> <arg2> } ^matches <arg2>
          ^argument-name { < <arg2> <arg1> }
          -^argument-name { <> <arg1> <> <arg2> <> <arg3> <arg4> }
          ^matches <arg1> ^operator <op>)
    -->
    (<ma> ^matched <op> +)
}

sp {action*problem-space*match-action*elaborate*op-info*op-matched*2*argument
    (state <s> ^match-action <ma>)
    (<ma> ^match-info <m*1>)
    (<m*1> ^op-info <op-info>)
    (<op-info> ^argument-name <arg2> ^matches <arg2>
          ^argument-name { < <arg2> <arg1> }
          -^argument-name { <> <arg1> <> <arg2> <arg3> } ^matches <arg1>
          ^operator <op>)
    -->
    (<ma> ^matched <op> +)
}

sp {action*problem-space*match-action*elaborate*op-info*op-matched*1*argument
    (state <s> ^match-action <ma>)
    (<ma> ^match-info <m*1>)
    (<m*1> ^op-info <op-info>)
    (<op-info> ^argument-name <arg1> -^argument-name { <> <arg1> <arg2> }
          ^matches <arg1> ^operator <op>)
    -->
    (<ma> ^matched <op> +)
}

sp {action*problem-space*match-action*elaborate*op-info*op-matched*no*arguments
    (state <s> ^match-action <ma>)
   -{ (<ma> ^action-operator <a*4>)
      (<a*4> ^missing-argument <m*2>)}
   -{ (<ma> ^action-operator <a*1>)
      (<a*1> ^<arg-name> <a*2>)
      (<a*2> ^arg-type { << object predicate concept >> <a*3> })}
    (<ma> ^match-info <m*1>)
    (<m*1> ^op-info <op-info>)
    (<op-info> ^operator <op>)
    -->
    (<ma> ^matched <op> +)
}

sp {action*problem-space*match-action*elaborate*op-info*argument-name*from*match
    (state <s> ^match-action <ma>)
    (<ma> ^match-info <m*1>)
    (<m*1> ^op-info <op-info>)
    (<op-info> ^operator <o*1>)
    (<o*1> ^<arg-name> <a*1>)
    (<a*1> ^arg-type { <> until-clause <arg-type> })
    -->
    (<op-info> ^argument-name <arg-name> +)
}

sp {action*problem-space*match-action*elaborate*op-info*argument-name*missing-argument
    (state <s> ^match-action <ma>)
    (<ma> ^match-info <m*1> ^action-operator <a*1>)
    (<m*1> ^op-info <op-info>)
    (<a*1> ^missing-argument <arg-name>)
    -->
    (<op-info> ^argument-name <arg-name> +)
}

sp {action*problem-space*match-action*elaborate*op-info*argument-name
    (state <s> ^match-action <ma>)
    (<ma> ^match-info <m*1> ^action-operator <a*1>)
    (<m*1> ^op-info <op-info>)
    (<a*1> ^<arg-name> <a*2>)
    (<a*2> ^arg-type { <> until-clause <arg-type> })
    -->
    (<op-info> ^argument-name <arg-name> +)
}

sp {action*problem-space*match-action*elaborate*match-info*op-info*matches*argument*predicate*any-predicate*abstract
    (state <s> ^match-action <ma>)
    (<ma> ^match-info <m*1> ^action-operator <a*1>)
    (<m*1> ^op-info <op-info>)
    (<op-info> ^object-info <obj-info> ^operator <o*1>)
    (<obj-info> ^matches true ^argument <arg-name> ^candidate <cand>
          ^object <obj2>)
    (<a*1> ^<arg-name> <m-arg>)
    (<m-arg> ^arg-type predicate ^2 <obj2> ^handle <handle>)
    (<o*1> ^<arg-name> <op-arg>)
    (<op-arg> ^any-predicate true ^arg-type predicate ^2 <cand>)
    -->
    (<op-info> ^matches <arg-name> + ^matches-arg <m-arg> +)
}

sp {action*problem-space*match-action*elaborate*match-info*op-info*matches*argument*predicate*abstract
    (state <s> ^match-action <ma>)
    (<ma> ^match-info <m*1> ^action-operator <a*1>)
    (<m*1> ^op-info <op-info>)
    (<op-info> ^object-info <obj-info> ^operator <o*1>)
    (<obj-info> ^matches true ^argument <arg-name> ^candidate <cand>
          ^object <obj2>)
    (<a*1> ^<arg-name> <m-arg>)
    (<m-arg> ^arg-type predicate ^2 <obj2> ^handle <handle>)
    (<o*1> ^<arg-name> <op-arg>)
    (<op-arg> ^arg-status abstract ^arg-type predicate ^2 <cand>
          ^handle <handle>)
    -->
    (<op-info> ^matches <arg-name> + ^matches-arg <m-arg> +)
}

sp {action*problem-space*match-action*elaborate*match-info*op-info*matches*argument*object*abstract
    (state <s> ^match-action <ma>)
    (<ma> ^match-info <m*1> ^action-operator <a*1>)
    (<m*1> ^op-info <op-info>)
    (<op-info> ^object-info <obj-info> ^operator <o*1>)
    (<obj-info> ^matches true ^argument <arg-name> ^candidate <cand>
          ^object <obj>)
    (<a*1> ^<arg-name> <m-arg>)
    (<m-arg> ^arg-type object ^id <obj>)
    (<o*1> ^<arg-name> <op-arg>)
    (<op-arg> ^arg-status abstract ^arg-type object ^id <cand>)
    -->
    (<op-info> ^matches <arg-name> + ^matches-arg <m-arg> +)
}

sp {action*problem-space*match-action*elaborate*object-info*matches*5*predicate
    (state <s> ^match-action <m*1>)
    (<m*1> ^match-info <m*2>)
    (<m*2> ^op-info <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> ^candidate <c*1> ^predicates <preds>)
    (<c*1> ^predicates <cand-preds>)
    (<cand-preds> ^<prop5> <pred5> ^{ < <prop5> <prop4> } <pred4>
          ^{ < <prop4> <prop3> } <pred3> ^{ < <prop3> <prop2> } <pred2>
          ^{ < <prop2> <prop1> } <pred1>)
    (<preds> ^<prop5> <pred5> ^<prop4> <pred4> ^<prop3> <pred3>
          ^<prop2> <pred2>
          -^{ <> <prop1> <> <prop2> <> <prop3> <> <prop4> <> <prop5> <prop6> } <p*1>
          ^<prop1> <pred1>)
    -->
    (<obj-info> ^matches true +)
}

sp {action*problem-space*match-action*elaborate*object-info*matches*4*predicate
    (state <s> ^match-action <m*1>)
    (<m*1> ^match-info <m*2>)
    (<m*2> ^op-info <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> ^candidate <c*1> ^predicates <preds>)
    (<c*1> ^predicates <cand-preds>)
    (<cand-preds> ^<prop4> <pred4> ^{ < <prop4> <prop3> } <pred3>
          ^{ < <prop3> <prop2> } <pred2> ^{ < <prop2> <prop1> } <pred1>)
    (<preds> ^<prop4> <pred4> ^<prop3> <pred3> ^<prop2> <pred2>
          -^{ <> <prop1> <> <prop2> <> <prop3> <> <prop4> <prop5> } <p*1>
          ^<prop1> <pred1>)
    -->
    (<obj-info> ^matches true +)
}

sp {action*problem-space*match-action*elaborate*object-info*matches*3*predicate
    (state <s> ^match-action <m*1>)
    (<m*1> ^match-info <m*2>)
    (<m*2> ^op-info <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> ^candidate <c*1> ^predicates <preds>)
    (<c*1> ^predicates <cand-preds>)
    (<cand-preds> ^<prop3> <pred3> ^{ < <prop3> <prop2> } <pred2>
          ^{ < <prop2> <prop1> } <pred1>)
    (<preds> ^<prop3> <pred3> ^<prop2> <pred2>
          -^{ <> <prop1> <> <prop2> <> <prop3> <prop4> } <p*1>
          ^<prop1> <pred1>)
    -->
    (<obj-info> ^matches true +)
}

sp {action*problem-space*match-action*elaborate*object-info*matches*2*predicate
    (state <s> ^match-action <m*1>)
    (<m*1> ^match-info <m*2>)
    (<m*2> ^op-info <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> ^candidate <c*1> ^predicates <preds>)
    (<c*1> ^predicates <cand-preds>)
    (<cand-preds> ^<prop2> <pred2> ^{ < <prop2> <prop1> } <pred1>)
    (<preds> ^<prop2> <pred2> -^{ <> <prop1> <> <prop2> <prop3> } <p*1>
          ^<prop1> <pred1>)
    -->
    (<obj-info> ^matches true +)
}

sp {action*problem-space*match-action*elaborate*object-info*matches*1*predicate
    (state <s> ^match-action <m*1>)
    (<m*1> ^match-info <m*2>)
    (<m*2> ^op-info <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> ^candidate <c*1> ^predicates <preds>)
    (<c*1> ^predicates <cand-preds>)
    (<cand-preds> ^<prop1> <pred1>)
    (<preds> -^{ <> <prop1> <prop2> } <p*1> ^<prop1> <pred1>)
    -->
    (<obj-info> ^matches true +)
}

sp {action*problem-space*match-action*elaborate*object-info*predicates*from*object
    (state <s> ^match-action <m*1> ^agent-params <a*1>)
    (<m*1> ^match-info <m*2>)
    (<m*2> ^op-info <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> ^predicates <preds> ^object <o*2>)
    (<a*1> ^object-rep-info <rep-info>)
    (<o*2> ^predicates <p*1>)
    (<p*1> ^<prop> <pred>)
    (<rep-info> -^ignore-level2 <prop>)
    -->
    (<preds> ^<prop> <pred> +)
}

sp {action*problem-space*match-action*elaborate*match-info*elaborate*object-info*predicate*arg
    (state <s> ^match-action <ma>)
    (<ma> ^match-info <m*1> ^action-operator <a*1>)
    (<m*1> ^op-info <op-info>)
    (<op-info> ^operator <o*1>)
    (<o*1> ^<arg-name> <op-arg>)
    (<op-arg> ^arg-status abstract ^arg-type predicate ^2 <cand>)
    (<a*1> ^<arg-name> <m-arg>)
    (<m-arg> ^arg-type predicate ^2 <obj>)
    -->
    (<op-info> ^object-info <obj-info> +)
    (<obj-info> ^argument <arg-name> + ^object <obj> + ^candidate <cand> +
           ^predicates <preds> +)
}

sp {action*problem-space*match-action*elaborate*match-info*elaborate*object-info*object*arg
    (state <s> ^match-action <ma>)
    (<ma> ^match-info <m*1> ^action-operator <a*1>)
    (<m*1> ^op-info <op-info>)
    (<op-info> ^operator <o*1>)
    (<o*1> ^<arg-name> <op-arg>)
    (<op-arg> ^arg-status abstract ^arg-type object ^id <cand>)
    (<a*1> ^<arg-name> <m-arg>)
    (<m-arg> ^arg-type object ^id <obj>)
    -->
    (<op-info> ^object-info <obj-info> +)
    (<obj-info> ^argument <arg-name> + ^object <obj> + ^candidate <cand> +
           ^predicates <preds> +)
}

sp {action*problem-space*match-action*elaborate*match-info*op-info*matches*argument*predicate*any-predicate
    (state <s> ^match-action <ma>)
    (<ma> ^match-info <m*1> ^action-operator <a*1>)
    (<m*1> ^op-info <op-info>)
    (<op-info> ^operator <o*1>)
    (<o*1> ^<arg-name> <op-arg>)
    (<op-arg> ^any-predicate true ^arg-type predicate ^2 <obj2>)
    (<a*1> ^<arg-name> <m-arg>)
    (<m-arg> ^arg-type predicate ^2 <obj2> ^handle <handle>)
    -->
    (<op-info> ^matches <arg-name> + ^matches-arg <m-arg> +)
}

sp {action*problem-space*match-action*elaborate*match-info*op-info*matches*argument*predicate
    (state <s> ^match-action <ma>)
    (<ma> ^match-info <m*1> ^action-operator <a*1>)
    (<m*1> ^op-info <op-info>)
    (<op-info> ^operator <o*1>)
    (<o*1> ^<arg-name> <op-arg>)
    (<op-arg> ^arg-type predicate ^2 <obj2> ^handle <handle>)
    (<a*1> ^<arg-name> <m-arg>)
    (<m-arg> ^arg-type predicate ^2 <obj2> ^handle <handle>)
    -->
    (<op-info> ^matches <arg-name> + ^matches-arg <m-arg> +)
}

sp {action*problem-space*match-action*elaborate*match-info*op-info*matches*argument*concept
    (state <s> ^match-action <ma>)
    (<ma> ^match-info <m*1> ^action-operator <a*1>)
    (<m*1> ^op-info <op-info>)
    (<op-info> ^operator <o*1>)
    (<o*1> ^<arg-name> <op-arg>)
    (<op-arg> ^arg-type concept ^handle <handle>)
    (<a*1> ^<arg-name> <m-arg>)
    (<m-arg> ^arg-type concept ^handle <handle>)
    -->
    (<op-info> ^matches <arg-name> + ^matches-arg <m-arg> +)
}

sp {action*problem-space*match-action*elaborate*match-info*op-info*matches*argument*remember*HACK
    (state <s> ^match-action <ma>)
    (<ma> ^action-operator <aop> ^match-info <m*1>)
    (<aop> ^action-handle remember1 ^arg1 <m-arg>)
    (<m-arg> ^arg-type object)
    (<m*1> ^op-info <op-info>)
    (<op-info> ^operator <o*1>)
    (<o*1> ^arg1 <op-arg>)
    (<op-arg> ^arg-type object)
    -->
    (<op-info> ^matches arg1 + ^matches-arg <m-arg> +)
}

sp {action*problem-space*match-action*elaborate*match-info*op-info*matches*argument*object
    (state <s> ^match-action <ma>)
    (<ma> ^match-info <m*1> ^action-operator <a*1>)
    (<m*1> ^op-info <op-info>)
    (<op-info> ^operator <o*1>)
    (<o*1> ^<arg-name> <op-arg>)
    (<op-arg> ^arg-type object ^id <obj>)
    (<a*1> ^<arg-name> <m-arg>)
    (<m-arg> ^arg-type object ^id <obj>)
    -->
    (<op-info> ^matches <arg-name> + ^matches-arg <m-arg> +)
}

sp {action*problem-space*match-action*elaborate*match-info*op-info*evaluate-operator
    (state <s> ^operator <o> + ^match-action <ma>)
    (<o> ^name evaluate-operator ^superoperator <ss-op>)
    (<ma> ^match-info <info> ^action-operator <a-op>)
    (<ss-op> ^action-handle <handle>)
    (<a-op> ^action-handle <handle>)
    -->
    (<info> ^op-info <op-info> +)
    (<op-info> ^operator <ss-op> +)
}

sp {action*problem-space*match-action*elaborate*match-info*op-info*operator
    (state <s> ^match-action <ma> ^operator <op> +)
    (<ma> ^match-info <info> ^action-operator <a-op>)
    (<a-op> ^action-handle <handle>)
    (<op> ^action-handle <handle>)
    -->
    (<info> ^op-info <op-info> +)
    (<op-info> ^operator <op> +)
}

sp {action*problem-space*match-action*elaborate*operator-matches
    (state <s> ^match-action <ma>)
    (<ma> ^action-operator <aop>)
    -->
    (<ma> ^match-info <info> +)
}

sp {anystate*apply*ground-argument*predicate-set*copy*predicate
    (state <s> ^operator <o> ^ground-argument <arg>)
    (<o> ^arg-type predicate-set ^name ground-argument ^argument <arg>)
    (<arg> ^ground-pred <g*1> ^instance <i>)
    (<g*1> ^instance <gp>)
    -->
    (<i> ^predicate <gp> +)
}

sp {anystate*apply*ground-argument*predicate-set*create*instance
    (state <s> ^operator <o> ^ground-argument <arg>)
    (<o> ^arg-type predicate-set ^name ground-argument ^argument <arg>)
    -->
    (<arg> ^instance <i> +)
}

sp {anystate*reject*ground-argument*predicate-set*ungrounded*pred
    (state <s> ^operator <o> + ^ground-argument <arg>)
    (<o> ^arg-type predicate-set ^name ground-argument ^argument <arg>)
    (<arg> ^ground-pred <gp>)
    (<gp> -^instance <i*1>)
    -->
    (<s> ^operator <o> -)
}

sp {anystate*propose*ground-argument*predicate-set
    (state <s> ^ground-argument <arg>)
   -{ (<arg> ^instance <i*1>)
      (<i*1> ^predicate <p*1>)}
    (<arg> ^arg-type predicate-set)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name ground-argument + ^argument <arg> + ^arg-type predicate-set +)
}

sp {anystate*ground-argument*expand*predicate-set*3
    (state <s> ^ground-argument <arg>)
    (<arg> ^arg-type predicate-set ^generalized-rep <gen>)
    (<gen> ^predicate <p3> ^predicate { < <p3> <p2> }
          ^predicate { < <p2> <p1> }
          -^predicate { > <p3> <> <p2> <> <p1> <p4> })
    -->
    (<s> ^ground-argument <gp1> + ^ground-argument <gp2> +
           ^ground-argument <gp3> +)
    (<gp1> ^arg-type single-predicate + ^generalized-rep <p1> +)
    (<gp2> ^arg-type single-predicate + ^generalized-rep <p2> +)
    (<gp3> ^arg-type single-predicate + ^generalized-rep <p3> +)
    (<arg> ^ground-pred <gp1> + ^ground-pred <gp2> + ^ground-pred <gp3> +)
}

sp {anystate*ground-argument*expand*predicate-set*2
    (state <s> ^ground-argument <arg>)
    (<arg> ^arg-type predicate-set ^generalized-rep <gen>)
    (<gen> ^predicate <p2> ^predicate { < <p2> <p1> }
          -^predicate { <> <p2> <> <p1> <p3> })
    -->
    (<s> ^ground-argument <gp1> + ^ground-argument <gp2> +)
    (<gp1> ^arg-type single-predicate + ^generalized-rep <p1> +)
    (<gp2> ^arg-type single-predicate + ^generalized-rep <p2> +)
    (<arg> ^ground-pred <gp1> + ^ground-pred <gp2> +)
}

sp {anystate*ground-argument*expand*predicate-set*1
    (state <s> ^ground-argument <arg>)
    (<arg> ^arg-type predicate-set ^generalized-rep <gen>)
    (<gen> ^predicate <p1> -^predicate { <> <p1> <p2> })
    -->
    (<s> ^ground-argument <gp1> +)
    (<gp1> ^arg-type single-predicate + ^generalized-rep <p1> +)
    (<arg> ^ground-pred <gp1> +)
}

sp {anystate*apply*ground-argument*single-predicate*relation*create*instance
    (state <s> ^operator <o> ^ground-argument <arg>)
    (<o> ^pred-type relation ^arg-type single-predicate ^name ground-argument
          ^argument <arg> ^2 <obj2> ^handle <handle> ^1 <obj1>)
    -->
    (<arg> ^instance <i> +)
    (<i> ^type relation + ^handle <handle> + ^1 <obj1> + ^2 <obj2> +)
}

sp {anystate*propose*ground-argument*single-predicate*relation
    (state <s> ^ground-argument <arg>)
    (<arg> -^instance <i*4> ^arg-type single-predicate ^generalized-rep <g*1>
          ^ground-obj1 <g*3> ^ground-obj2 <g*4> ^ground-handle <g*2>)
    (<g*1> ^type relation)
    (<g*4> ^instance <i*3>)
    (<g*3> ^instance <i*2>)
    (<g*2> ^instance <i*1>)
    (<i*1> ^handle <handle>)
    (<i*3> ^id <obj2>)
    (<i*2> ^id <obj1>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name ground-argument + ^argument <arg> +
           ^arg-type single-predicate + ^pred-type relation +
           ^handle <handle> + ^1 <obj1> + ^2 <obj2> +)
}

sp {anystate*ground-argument*expand*predicate*relation
    (state <s> ^ground-argument <arg>)
    (<arg> ^arg-type single-predicate ^generalized-rep <gen>)
    (<gen> ^type relation ^2 <obj2-slot> ^1 <obj1-slot> ^id <pred-slot>)
    -->
    (<s> ^ground-argument <gpred> + ^ground-argument <gobj1> +
           ^ground-argument <gobj2> +)
    (<gpred> ^generalized-rep <gen-pred> +)
    (<gen-pred> ^arg-type predicate-handle + ^id <pred-slot> +)
    (<gobj1> ^generalized-rep <gen-obj1> +)
    (<gen-obj1> ^arg-type object + ^id <obj1-slot> +)
    (<gobj2> ^generalized-rep <gen-obj2> +)
    (<gen-obj2> ^arg-type object + ^id <obj2-slot> +)
    (<arg> ^ground-handle <gpred> + ^ground-obj1 <gobj1> +
           ^ground-obj2 <gobj2> +)
}

sp {anystate*apply*ground-argument*single-predicate*state*create*instance
    (state <s> ^operator <o> ^ground-argument <arg>)
    (<o> ^pred-type state ^arg-type single-predicate ^name ground-argument
          ^argument <arg> ^handle <handle> ^1 <obj1>)
    -->
    (<arg> ^instance <i> +)
    (<i> ^type state + ^handle <handle> + ^1 <obj1> +)
}

sp {anystate*propose*ground-argument*single-predicate*state
    (state <s> ^ground-argument <arg>)
    (<arg> -^instance <i*3> ^generalized-rep <g*1> ^ground-obj1 <g*3>
          ^ground-handle <g*2>)
    (<g*1> ^type state)
    (<g*3> ^instance <i*2>)
    (<g*2> ^instance <i*1>)
    (<i*1> ^handle <handle>)
    (<i*2> ^id <obj1>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name ground-argument + ^argument <arg> +
           ^arg-type single-predicate + ^pred-type state + ^handle <handle> +
           ^1 <obj1> +)
}

sp {anystate*ground-argument*expand*predicate*state
    (state <s> ^ground-argument <arg>)
    (<arg> ^generalized-rep <gen>)
    (<gen> ^type state ^1 <obj1-slot> ^id <pred-slot>)
    -->
    (<s> ^ground-argument <gpred> + ^ground-argument <gobj1> +)
    (<gpred> ^generalized-rep <gen-pred> +)
    (<gen-pred> ^arg-type predicate-handle + ^id <pred-slot> +)
    (<gobj1> ^generalized-rep <gen-obj1> +)
    (<gen-obj1> ^arg-type object + ^id <obj1-slot> +)
    (<arg> ^ground-handle <gpred> + ^ground-obj1 <gobj1> +)
}

sp {anystate*apply*ground-argument*predicate*create*instance
    (state <s> ^operator <o>)
    (<o> ^arg-type predicate ^name ground-argument ^argument <arg> ^2 <obj2>
          ^handle <pred-handle>)
    -->
    (<arg> ^instance <i> +)
    (<i> ^arg-type predicate + ^handle <pred-handle> + ^2 <obj2> +)
}

sp {anystate*propose*ground-argument*predicate
    (state <s> ^ground-argument <arg>)
    (<arg> -^instance <i*3> ^generalized-rep <g*1> ^ground-obj2 <g*3>
          ^ground-handle <g*2>)
    (<g*1> ^arg-type predicate)
    (<g*3> ^instance <i*2>)
    (<g*2> ^instance <i*1>)
    (<i*1> ^handle <handle>)
    (<i*2> ^id <obj2>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name ground-argument + ^argument <arg> + ^arg-type predicate +
           ^handle <handle> + ^2 <obj2> +)
}

sp {anystate*elaborate*ground-argument*predicate*object*arg-status*abstract
    (state <s> ^ground-argument <parg>)
    (<parg> ^generalized-rep <g*1> ^ground-obj2 <g*2>)
    (<g*1> ^arg-status abstract)
    (<g*2> ^generalized-rep <rep>)
    -->
    (<rep> ^arg-status abstract +)
}

sp {anystate*ground-argument*expand*predicate
    (state <s> ^ground-argument <arg>)
    (<arg> ^generalized-rep <gen>)
    (<gen> ^arg-type predicate ^2 <obj2-slot> ^id <pred-slot>)
    -->
    (<s> ^ground-argument <gpred> + ^ground-argument <gobj2> +)
    (<gpred> ^generalized-rep <gen-pred> +)
    (<gen-pred> ^arg-type predicate-handle + ^id <pred-slot> +)
    (<gobj2> ^generalized-rep <gen-obj2> +)
    (<gen-obj2> ^arg-type object + ^id <obj2-slot> +)
    (<arg> ^ground-handle <gpred> + ^ground-obj2 <gobj2> +)
}

sp {anystate*apply*ground-argument*predicate-handle*create*instance
    (state <s> ^operator <o>)
    (<o> ^arg-type predicate-handle ^name ground-argument ^argument <arg>
          ^handle <pred-handle>)
    -->
    (<arg> ^instance <i> +)
    (<i> ^arg-type predicate-handle + ^handle <pred-handle> +)
}

sp {anystate*propose*ground-argument*predicate-handle*matches*default
    (state <s> ^ground-argument <arg>)
    (<arg> -^instance <i*1> ^generalized-rep <gen>)
    (<gen> ^arg-type predicate-handle ^id <i*2>)
    (<i*2> ^default <d*1>)
    (<d*1> ^predicate-handle <pred-handle>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name ground-argument + ^argument <arg> +
           ^arg-type predicate-handle + ^match-type default +
           ^handle <pred-handle> +)
}

sp {anystate*propose*ground-argument*predicate-handle*matches*procedural
    (state <s> ^ground-argument <arg> ^procedural-id <p*1>
          ^action-operator <a*1>)
    (<arg> -^instance <i*1> ^generalized-rep <gen>)
    (<gen> ^arg-type predicate-handle ^id <pred-slot>)
    (<p*1> ^<arg-name> <parg>)
    (<parg> ^arg-type predicate ^id <pred-slot>)
    (<a*1> ^<arg-name> <a*2>)
    (<a*2> ^handle <pred-handle>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name ground-argument + ^argument <arg> +
           ^arg-type predicate-handle + ^match-type procedural +
           ^handle <pred-handle> +)
}

sp {anystate*apply*ground-argument*concept*create*instance
    (state <s> ^operator <o>)
    (<o> ^arg-type concept ^name ground-argument ^argument <arg>
          ^handle <conc-handle>)
    -->
    (<arg> ^instance <i> +)
    (<i> ^arg-type concept + ^handle <conc-handle> +)
}

sp {anystate*propose*ground-argument*concept*matches*default
    (state <s> ^ground-argument <arg>)
    (<arg> -^instance <i*1> ^generalized-rep <gen>)
    (<gen> ^arg-type concept ^id <i*2>)
    (<i*2> ^default <d*1>)
    (<d*1> ^predicate-handle <conc-handle>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name ground-argument + ^argument <arg> + ^arg-type concept +
           ^match-type default + ^handle <conc-handle> +)
}

sp {anystate*propose*ground-argument*concept*matches*procedural
    (state <s> ^ground-argument <arg> ^procedural-id <p*1>
          ^action-operator <a*1>)
    (<arg> -^instance <i*1> ^generalized-rep <gen>)
    (<gen> ^arg-type concept ^id <conc-slot>)
    (<p*1> ^<arg-name> <parg>)
    (<parg> ^arg-type concept ^id <conc-slot>)
    (<a*1> ^<arg-name> <a*2>)
    (<a*2> ^handle <conc-handle>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name ground-argument + ^argument <arg> + ^arg-type concept +
           ^match-type procedural + ^handle <conc-handle> +)
}

sp {anystate*apply*ground-argument*object*abstract*6*predicate
    (state <s> ^operator <o>)
    (<o> ^match-type abstract ^arg-type object ^name ground-argument
          ^object-rep <rep> ^argument <arg>)
    (<rep> ^<prop6> <pred6> ^{ < <prop6> <prop5> } <pred5>
          ^{ < <prop5> <prop4> } <pred4> ^{ < <prop4> <prop3> } <pred3>
          ^{ < <prop3> <prop2> } <pred2> ^{ < <prop2> <prop1> } <pred1>
          -^{ <prop6> <> <prop1> <> <prop2> <> <prop3> <> <prop4> <> <prop5> <> <prop6> } <p*1>)
    -->
    (<arg> ^instance <i> +)
    (<i> ^arg-type object + ^id <obj> +)
    (<obj> ^item-type object + ^predicates <preds> +)
    (<preds> ^<prop1> <pred1> + ^<prop2> <pred2> + ^<prop3> <pred3> +
           ^<prop4> <pred4> + ^<prop5> <pred5> + ^<prop6> <pred6> +)
}

sp {anystate*apply*ground-argument*object*abstract*5*predicate
    (state <s> ^operator <o>)
    (<o> ^match-type abstract ^arg-type object ^name ground-argument
          ^object-rep <rep> ^argument <arg>)
    (<rep> ^<prop5> <pred5> ^{ < <prop5> <prop4> } <pred4>
          ^{ < <prop4> <prop3> } <pred3> ^{ < <prop3> <prop2> } <pred2>
          ^{ < <prop2> <prop1> } <pred1>
          -^{ <prop5> <> <prop1> <> <prop2> <> <prop3> <> <prop4> <> <prop5> } <p*1>)
    -->
    (<arg> ^instance <i> +)
    (<i> ^arg-type object + ^id <obj> +)
    (<obj> ^item-type object + ^predicates <preds> +)
    (<preds> ^<prop1> <pred1> + ^<prop2> <pred2> + ^<prop3> <pred3> +
           ^<prop4> <pred4> + ^<prop5> <pred5> +)
}

sp {anystate*apply*ground-argument*object*abstract*4*predicate
    (state <s> ^operator <o>)
    (<o> ^match-type abstract ^arg-type object ^name ground-argument
          ^object-rep <rep> ^argument <arg>)
    (<rep> ^<prop4> <pred4> ^{ < <prop4> <prop3> } <pred3>
          ^{ < <prop3> <prop2> } <pred2> ^{ < <prop2> <prop1> } <pred1>
          -^{ <> <prop1> <> <prop2> <> <prop3> <> <prop4> <prop5> } <p*1>)
    -->
    (<arg> ^instance <i> +)
    (<i> ^arg-type object + ^id <obj> +)
    (<obj> ^item-type object + ^predicates <preds> +)
    (<preds> ^<prop1> <pred1> + ^<prop2> <pred2> + ^<prop3> <pred3> +
           ^<prop4> <pred4> +)
}

sp {anystate*apply*ground-argument*object*abstract*3*predicate
    (state <s> ^operator <o>)
    (<o> ^match-type abstract ^arg-type object ^name ground-argument
          ^object-rep <rep> ^argument <arg>)
    (<rep> ^<prop3> <pred3> ^{ < <prop3> <prop2> } <pred2>
          ^{ < <prop2> <prop1> } <pred1>
          -^{ <> <prop1> <> <prop2> <> <prop3> <prop4> } <p*1>)
    -->
    (<arg> ^instance <i> +)
    (<i> ^arg-type object + ^id <obj> +)
    (<obj> ^item-type object + ^predicates <preds> +)
    (<preds> ^<prop1> <pred1> + ^<prop2> <pred2> + ^<prop3> <pred3> +)
}

sp {anystate*apply*ground-argument*object*abstract*2*predicate
    (state <s> ^operator <o>)
    (<o> ^match-type abstract ^arg-type object ^name ground-argument
          ^object-rep <rep> ^argument <arg>)
    (<rep> ^<prop2> <pred2> ^{ < <prop2> <prop1> } <pred1>
          -^{ <> <prop1> <> <prop2> <prop3> } <p*1>)
    -->
    (<arg> ^instance <i> +)
    (<i> ^arg-type object + ^id <obj> +)
    (<obj> ^item-type object + ^predicates <preds> +)
    (<preds> ^<prop1> <pred1> + ^<prop2> <pred2> +)
}

sp {anystate*apply*ground-argument*object*abstract*1*predicate
    (state <s> ^operator <o>)
    (<o> ^match-type abstract ^arg-type object ^name ground-argument
          ^object-rep <rep> ^argument <arg>)
    (<rep> ^<prop1> <pred1> -^{ <> <prop1> <prop2> } <p*1>)
    -->
    (<arg> ^instance <i> +)
    (<i> ^arg-type object + ^id <obj> +)
    (<obj> ^item-type object + ^predicates <preds> +)
    (<preds> ^<prop1> <pred1> +)
}

sp {anystate*apply*ground-argument*object*procedural*default*create*instance
    (state <s> ^operator <o>)
    (<o> ^arg-type object ^name ground-argument
          ^match-type { << procedural default >> <m*1> } ^argument <arg>
          ^id <obj>)
    -->
    (<arg> ^instance <i> +)
    (<i> ^arg-type object + ^id <obj> +)
}

sp {anystate*propose*ground-argument*object*matches*abstract
    (state <s> ^ground-argument <arg>)
    (<arg> -^instance <i*1> ^generalized-rep <gen>)
    (<gen> ^arg-type object ^id <i*2>)
    (<i*2> ^default <def>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name ground-argument + ^argument <arg> + ^arg-type object +
           ^match-type abstract + ^object-rep <def> +)
}

sp {anystate*propose*ground-argument*object*matches*default*6
    (state <s> ^ground-argument <arg> ^world <w*1>)
    (<arg> -^instance <i*1> ^generalized-rep <gen>)
    (<gen> ^arg-type object ^id <i*2>)
    (<w*1> ^objects <o*1>)
    (<i*2> ^default <def>)
    (<def> ^<prop6> <pred6> ^{ < <prop6> <prop5> } <pred5>
          ^{ < <prop5> <prop4> } <pred4> ^{ < <prop4> <prop3> } <pred3>
          ^{ < <prop3> <prop2> } <pred2> ^{ < <prop2> <prop1> } <pred1>
          -^{ <prop6> <> <prop1> <> <prop2> <> <prop3> <> <prop4> <> <prop5> <> <prop6> } <p*1>)
    (<o*1> ^object <obj>)
    (<obj> ^predicates <preds>)
    (<preds> ^<prop6> <pred6> ^<prop5> <pred5> ^<prop4> <pred4>
          ^<prop3> <pred3> ^<prop2> <pred2> ^<prop1> <pred1>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name ground-argument + ^argument <arg> + ^arg-type object +
           ^match-type default + ^id <obj> +)
}

sp {anystate*propose*ground-argument*object*matches*default*5
    (state <s> ^ground-argument <arg> ^world <w*1>)
    (<arg> -^instance <i*1> ^generalized-rep <gen>)
    (<gen> ^arg-type object ^id <i*2>)
    (<w*1> ^objects <o*1>)
    (<i*2> ^default <def>)
    (<def> ^<prop5> <pred5> ^{ < <prop5> <prop4> } <pred4>
          ^{ < <prop4> <prop3> } <pred3> ^{ < <prop3> <prop2> } <pred2>
          ^{ < <prop2> <prop1> } <pred1>
          -^{ <prop5> <> <prop1> <> <prop2> <> <prop3> <> <prop4> <> <prop5> } <p*1>)
    (<o*1> ^object <obj>)
    (<obj> ^predicates <preds>)
    (<preds> ^<prop5> <pred5> ^<prop4> <pred4> ^<prop3> <pred3>
          ^<prop2> <pred2> ^<prop1> <pred1>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name ground-argument + ^argument <arg> + ^arg-type object +
           ^match-type default + ^id <obj> +)
}

sp {anystate*propose*ground-argument*object*matches*default*4
    (state <s> ^ground-argument <arg> ^world <w*1>)
    (<arg> -^instance <i*1> ^generalized-rep <gen>)
    (<gen> ^arg-type object ^id <i*2>)
    (<w*1> ^objects <o*1>)
    (<i*2> ^default <def>)
    (<def> ^<prop4> <pred4> ^{ < <prop4> <prop3> } <pred3>
          ^{ < <prop3> <prop2> } <pred2> ^{ < <prop2> <prop1> } <pred1>
          -^{ <> <prop1> <> <prop2> <> <prop3> <> <prop4> <prop5> } <p*1>)
    (<o*1> ^object <obj>)
    (<obj> ^predicates <preds>)
    (<preds> ^<prop4> <pred4> ^<prop3> <pred3> ^<prop2> <pred2>
          ^<prop1> <pred1>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name ground-argument + ^argument <arg> + ^arg-type object +
           ^match-type default + ^id <obj> +)
}

sp {anystate*propose*ground-argument*object*matches*default*3
    (state <s> ^ground-argument <arg> ^world <w*1>)
    (<arg> -^instance <i*1> ^generalized-rep <gen>)
    (<gen> ^arg-type object ^id <i*2>)
    (<w*1> ^objects <o*1>)
    (<i*2> ^default <def>)
    (<def> ^<prop3> <pred3> ^{ < <prop3> <prop2> } <pred2>
          ^{ < <prop2> <prop1> } <pred1>
          -^{ <> <prop1> <> <prop2> <> <prop3> <prop4> } <p*1>)
    (<o*1> ^object <obj>)
    (<obj> ^predicates <preds>)
    (<preds> ^<prop3> <pred3> ^<prop2> <pred2> ^<prop1> <pred1>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name ground-argument + ^argument <arg> + ^arg-type object +
           ^match-type default + ^id <obj> +)
}

sp {anystate*propose*ground-argument*object*matches*default*2
    (state <s> ^ground-argument <arg> ^world <w*1>)
    (<arg> -^instance <i*1> ^generalized-rep <gen>)
    (<gen> ^arg-type object ^id <i*2>)
    (<w*1> ^objects <o*1>)
    (<i*2> ^default <def>)
    (<def> ^<prop2> <pred2> ^{ < <prop2> <prop1> } <pred1>
          -^{ <> <prop1> <> <prop2> <prop3> } <p*1>)
    (<o*1> ^object <obj>)
    (<obj> ^predicates <preds>)
    (<preds> ^<prop2> <pred2> ^<prop1> <pred1>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name ground-argument + ^argument <arg> + ^arg-type object +
           ^match-type default + ^id <obj> +)
}

sp {anystate*propose*ground-argument*object*matches*default*1
    (state <s> ^ground-argument <arg> ^world <w*1>)
    (<arg> -^instance <i*1> ^generalized-rep <gen>)
    (<gen> ^arg-type object ^id <i*2>)
    (<w*1> ^objects <o*1>)
    (<i*2> ^default <def>)
    (<def> ^<prop1> <pred1> -^{ <> <prop1> <prop2> } <p*1>)
    (<o*1> ^object <obj>)
    (<obj> ^predicates <preds>)
    (<preds> ^<prop1> <pred1>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name ground-argument + ^argument <arg> + ^arg-type object +
           ^match-type default + ^id <obj> +)
}

sp {anystate*propose*ground-argument*object*matches*procedural*depth*2
    (state <s> ^ground-argument <arg> ^procedural-id <p*1>
          ^action-operator <a*1>)
    (<arg> -^instance <i*1> ^generalized-rep <gen>)
    (<gen> ^arg-type object ^id <obj-slot>)
    (<p*1> ^<arg-name> <parg>)
    (<parg> ^arg-type predicate ^2 <obj-slot>)
    (<a*1> ^<arg-name> <a*2>)
    (<a*2> ^2 <obj>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name ground-argument + ^argument <arg> + ^arg-type object +
           ^match-type procedural + ^id <obj> +)
}

sp {anystate*propose*ground-argument*object*matches*procedural*depth*1
    (state <s> ^ground-argument <arg> ^procedural-id <p*1>
          ^action-operator <a*1>)
    (<arg> -^instance <i*1> ^generalized-rep <gen>)
    (<gen> ^arg-type object ^id <obj-slot>)
    (<p*1> ^<arg-name> <parg>)
    (<parg> ^arg-type object ^id <obj-slot>)
    (<a*1> ^<arg-name> <a*2>)
    (<a*2> ^id <obj>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name ground-argument + ^argument <arg> + ^arg-type object +
           ^match-type procedural + ^id <obj> +)
}

sp {anystate*prefer*ground-argument*default*over*others
    (state <s> ^operator <o2> + ^ground-argument <arg> ^operator <o1> +)
    (<o2> ^match-type abstract ^name ground-argument ^argument <arg>)
    (<o1> ^match-type default ^argument <arg> ^name ground-argument)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {anystate*prefer*ground-argument*procedural*over*others
    (state <s> ^operator <o2> + ^ground-argument <arg> ^operator <o1> +)
    (<o2> ^name ground-argument ^argument <arg>
          ^match-type { << default abstract >> <m*1> })
    (<o1> ^match-type procedural ^argument <arg> ^name ground-argument)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {anystate*apply*generalize-argument*predicate-set*3
    (state <s> ^operator <o> ^generalize-argument <arg>)
    (<o> ^arg-type predicate-set ^name generalize-argument ^argument <arg>)
    (<arg> ^generalize-pred <pred3> ^generalize-pred { < <pred3> <pred2> }
          ^generalize-pred { < <pred2> <pred1> }
          -^generalize-pred { <> <pred3> <> <pred2> <> <pred1> <pred4> })
    (<pred3> ^generalized-rep <rep3>)
    (<pred2> ^generalized-rep <rep2>)
    (<pred1> ^generalized-rep <rep1>)
    -->
    (<arg> ^generalized-rep <rep> +)
    (<rep> ^predicate <rep1> + ^predicate <rep2> + ^predicate <rep3> +)
}

sp {anystate*apply*generalize-argument*predicate-set*2
    (state <s> ^operator <o> ^generalize-argument <arg>)
    (<o> ^arg-type predicate-set ^name generalize-argument ^argument <arg>)
    (<arg> ^generalize-pred <pred2> ^generalize-pred { < <pred2> <pred1> }
          -^generalize-pred { <> <pred2> <> <pred1> <pred3> })
    (<pred2> ^generalized-rep <rep2>)
    (<pred1> ^generalized-rep <rep1>)
    -->
    (<arg> ^generalized-rep <rep> +)
    (<rep> ^predicate <rep1> + ^predicate <rep2> +)
}

sp {anystate*apply*generalize-argument*predicate-set*1
    (state <s> ^operator <o> ^generalize-argument <arg>)
    (<o> ^arg-type predicate-set ^name generalize-argument ^argument <arg>)
    (<arg> ^generalize-pred <pred1> -^generalize-pred { <> <pred1> <pred2> })
    (<pred1> ^generalized-rep <rep1>)
    -->
    (<arg> ^generalized-rep <rep> +)
    (<rep> ^predicate <rep1> +)
}

sp {anystate*propose*generalize-argument*predicate-set
    (state <s> ^generalize-argument <arg>)
    (<arg> -^ungeneralized-preds true -^generalized-rep <g*1>
          ^arg-type predicate-set)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name generalize-argument + ^argument <arg> +
           ^arg-type predicate-set +)
}

sp {anystate*elaborate*generalize-argument*predicate-set*ungeneralized-pred
    (state <s> ^generalize-argument <arg>)
    (<arg> ^arg-type predicate-set ^generalize-pred <gen-pred>)
    (<gen-pred> -^generalized-rep <g*1>)
    -->
    (<arg> ^ungeneralized-preds true +)
}

sp {anystate*generalize-argument*expand*predicate-set
    (state <s> ^generalize-argument <arg>)
    (<arg> ^arg-type predicate-set ^instance <i*1>)
    (<i*1> ^predicate <pred>)
    -->
    (<s> ^generalize-argument <gen-pred> +)
    (<gen-pred> ^arg-type single-predicate + ^instance <pred> +)
    (<arg> ^generalize-pred <gen-pred> +)
}

sp {anystate*apply*generalize-argument*single-predicate*relation
    (state <s> ^operator <o> ^generalize-argument <arg>)
    (<o> ^pred-type relation ^arg-type single-argument
          ^name generalize-argument ^argument <arg> ^2 <obj2-slot>
          ^1 <obj1-slot> ^id <pred-slot>)
    -->
    (<arg> ^generalized-rep <rep> +)
    (<rep> ^type relation + ^id <pred-slot> + ^1 <obj1-slot> +
           ^2 <obj2-slot> +)
}

sp {anystate*propose*generalize-argument*single-predicate*relation
    (state <s> ^generalize-argument <arg>)
    (<arg> -^generalized-rep <g*7> ^instance <i*1> ^generalize-obj1 <g*3>
          ^generalize-obj2 <g*5> ^generalize-handle <g*1>)
    (<i*1> ^type relation)
    (<g*5> ^generalized-rep <g*6>)
    (<g*3> ^generalized-rep <g*4>)
    (<g*1> ^generalized-rep <g*2>)
    (<g*6> ^id <obj2-slot>)
    (<g*4> ^id <obj1-slot>)
    (<g*2> ^id <pred-slot>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name generalize-argument + ^argument <arg> +
           ^arg-type single-argument + ^pred-type relation + ^id <pred-slot> +
           ^1 <obj1-slot> + ^2 <obj2-slot> +)
}

sp {anystate*generalize-argument*expand*single-predicate*relation
    (state <s> ^generalize-argument <arg>)
    (<arg> ^instance <i>)
    (<i> ^type relation ^2 <obj2> ^handle <handle> ^1 <obj1>)
    -->
    (<s> ^generalize-argument <gen-pred> + ^generalize-argument <gen-obj1> +
           ^generalize-argument <gen-obj2> +)
    (<gen-pred> ^instance <pred-i> +)
    (<pred-i> ^arg-type predicate-handle + ^handle <handle> +)
    (<gen-obj1> ^instance <obj1-i> +)
    (<obj1-i> ^arg-type object + ^id <obj1> +)
    (<gen-obj2> ^instance <obj2-i> +)
    (<obj2-i> ^arg-type object + ^id <obj2> +)
    (<arg> ^generalize-handle <gen-pred> + ^generalize-obj1 <gen-obj1> +
           ^generalize-obj2 <gen-obj2> +)
}

sp {anystate*apply*generalize-argument*single-predicate*state
    (state <s> ^operator <o> ^generalize-argument <arg>)
    (<o> ^pred-type state ^arg-type single-argument ^name generalize-argument
          ^argument <arg> ^1 <obj1-slot> ^id <pred-slot>)
    -->
    (<arg> ^generalized-rep <rep> +)
    (<rep> ^type state + ^id <pred-slot> + ^1 <obj1-slot> +)
}

sp {anystate*propose*generalize-argument*single-predicate*state
    (state <s> ^generalize-argument <arg>)
    (<arg> -^generalized-rep <g*5> ^instance <i*1> ^generalize-obj1 <g*3>
          ^generalize-handle <g*1>)
    (<i*1> ^type state)
    (<g*3> ^generalized-rep <g*4>)
    (<g*1> ^generalized-rep <g*2>)
    (<g*4> ^id <obj1-slot>)
    (<g*2> ^id <pred-slot>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name generalize-argument + ^argument <arg> +
           ^arg-type single-argument + ^pred-type state + ^id <pred-slot> +
           ^1 <obj1-slot> +)
}

sp {anystate*generalize-argument*expand*single-predicate*state
    (state <s> ^generalize-argument <arg>)
    (<arg> ^instance <i>)
    (<i> ^type state ^handle <handle> ^1 <obj1>)
    -->
    (<s> ^generalize-argument <gen-obj1> + ^generalize-argument <gen-pred> +)
    (<gen-pred> ^instance <pred-i> +)
    (<pred-i> ^arg-type predicate-handle + ^handle <handle> +)
    (<gen-obj1> ^instance <obj1-i> +)
    (<obj1-i> ^arg-type object + ^id <obj1> +)
    (<arg> ^generalize-handle <gen-pred> + ^generalize-obj1 <gen-obj1> +)
}

sp {anystate*apply*generalize-argument*predicate*procedural
    (state <s> ^operator <o> ^generalize-argument <arg>)
    (<o> ^arg-type predicate ^name generalize-argument ^argument <arg>
          ^2 <obj-slot> ^id <pred-slot>)
    -->
    (<arg> ^generalized-rep <gen> +)
    (<gen> ^arg-type predicate + ^id <pred-slot> + ^2 <obj-slot> +)
}

sp {anystate*propose*generalize-argument*predicate
    (state <s> ^generalize-argument <arg>)
    (<arg> -^generalized-rep <g*5> ^instance <i*1> ^generalize-obj2 <g*3>
          ^generalize-handle <g*1>)
    (<i*1> ^arg-type predicate)
    (<g*3> ^generalized-rep <g*4>)
    (<g*1> ^generalized-rep <g*2>)
    (<g*4> ^id <obj-slot>)
    (<g*2> ^id <pred-slot>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name generalize-argument + ^argument <arg> + ^arg-type predicate +
           ^id <pred-slot> + ^2 <obj-slot> +)
}

sp {anystate*generalize-argument*expand*predicate*generalize*object
    (state <s> ^generalize-argument <arg>)
    (<arg> ^instance <i>)
    (<i> ^arg-type predicate ^2 <obj> ^handle <handle>)
    -->
    (<s> ^generalize-argument <gen-obj> + ^generalize-argument <gen-pred> +)
    (<gen-pred> ^instance <pred-i> +)
    (<pred-i> ^arg-type predicate-handle + ^handle <handle> +)
    (<gen-obj> ^instance <obj-i> +)
    (<obj-i> ^arg-type object + ^id <obj> +)
    (<arg> ^generalize-handle <gen-pred> + ^generalize-obj2 <gen-obj> +)
}

sp {anystate*apply*generalize-argument*predicate-handle*default
    (state <s> ^operator <o> ^generalize-argument <arg>)
    (<o> ^match-type default ^arg-type predicate-handle
          ^name generalize-argument ^argument <arg> ^predicate-handle <handle>)
    -->
    (<arg> ^generalized-rep <rep> +)
    (<rep> ^arg-type predicate-handle + ^id <pred-slot> +)
    (<pred-slot> ^default <def> +)
    (<def> ^predicate-handle <handle> +)
}

sp {anystate*propose*generalize-argument*predicate-handle*default
    (state <s> ^generalize-argument <arg>)
    (<arg> -^generalized-rep <g*1> ^instance <i>)
    (<i> ^arg-type predicate-handle ^handle <handle>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name generalize-argument + ^argument <arg> +
           ^arg-type predicate-handle + ^match-type default +
           ^predicate-handle <handle> +)
}

sp {anystate*apply*generalize-argument*predicate-handle*procedural
    (state <s> ^operator <o> ^generalize-argument <arg>)
    (<o> ^match-type procedural ^arg-type predicate-handle
          ^name generalize-argument ^argument <arg> ^id <pred-slot>)
    -->
    (<arg> ^generalized-rep <gen> +)
    (<gen> ^arg-type predicate-handle + ^id <pred-slot> +)
}

sp {anystate*propose*generalize-argument*predicate-handle*procedural
    (state <s> ^generalize-argument <arg> ^action-id <a*1>
          ^action-operator <a*2>)
    (<arg> -^generalized-rep <g*1> ^instance <i>)
    (<i> ^arg-type predicate-handle ^handle <handle>)
    (<a*1> ^procedural <p*1>)
    (<a*2> ^<arg-name> <a*3>)
    (<a*3> ^handle <handle>)
    (<p*1> ^<arg-name> <parg>)
    (<parg> ^arg-type predicate ^id <pred-slot>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name generalize-argument + ^argument <arg> +
           ^arg-type predicate-handle + ^match-type procedural +
           ^id <pred-slot> +)
}

sp {anystate*apply*generalize-argument*concept*default
    (state <s> ^operator <o> ^generalize-argument <arg>)
    (<o> ^match-type default ^arg-type concept ^name generalize-argument
          ^argument <arg> ^predicate-handle <handle>)
    -->
    (<arg> ^generalized-rep <rep> +)
    (<rep> ^arg-type concept + ^id <conc-slot> +)
    (<conc-slot> ^default <def> +)
    (<def> ^predicate-handle <handle> +)
}

sp {anystate*propose*generalize-argument*concept*default
    (state <s> ^generalize-argument <arg>)
    (<arg> -^generalized-rep <g*1> ^instance <i>)
    (<i> ^arg-type concept ^handle <handle>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name generalize-argument + ^argument <arg> + ^arg-type concept +
           ^match-type default + ^predicate-handle <handle> +)
}

sp {anystate*apply*generalize-argument*concept*procedural
    (state <s> ^operator <o> ^generalize-argument <arg>)
    (<o> ^match-type procedural ^arg-type concept ^name generalize-argument
          ^argument <arg> ^id <conc-slot>)
    -->
    (<arg> ^generalized-rep <gen> +)
    (<gen> ^arg-type concept + ^id <conc-slot> +)
}

sp {anystate*propose*generalize-argument*concept*procedural
    (state <s> ^generalize-argument <arg> ^action-id <a*1>
          ^action-operator <a*2>)
    (<arg> -^generalized-rep <g*1> ^instance <i>)
    (<i> ^arg-type concept ^handle <handle>)
    (<a*1> ^procedural <p*1>)
    (<a*2> ^<arg-name> <a*3>)
    (<a*3> ^handle <handle>)
    (<p*1> ^<arg-name> <parg>)
    (<parg> ^arg-type concept ^id <conc-slot>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name generalize-argument + ^argument <arg> + ^arg-type concept +
           ^match-type procedural + ^id <conc-slot> +)
}

sp {anystate*apply*generalize-argument*object*default*5*predicates
    (state <s> ^operator <o> ^generalize-argument <arg>)
    (<o> ^match-type default ^arg-type object ^name generalize-argument
          ^argument <arg> ^predicates <def-preds>)
    (<def-preds> ^<prop5> <pred5> ^{ < <prop5> <prop4> } <pred4>
          ^{ < <prop4> <prop3> } <pred3> ^{ < <prop3> <prop2> } <pred2>
          ^{ < <prop2> <prop1> } <pred1>
          -^{ <> <prop5> <> <prop4> <> <prop3> <> <prop2> <> <prop1> <prop6> } <pred6>)
    -->
    (<arg> ^generalized-rep <rep> +)
    (<rep> ^arg-type object + ^id <obj-slot> +)
    (<obj-slot> ^default <def> +)
    (<def> ^<prop1> <pred1> + ^<prop2> <pred2> + ^<prop3> <pred3> +
           ^<prop4> <pred4> + ^<prop5> <pred5> +)
}

sp {anystate*apply*generalize-argument*object*default*4*predicates
    (state <s> ^operator <o> ^generalize-argument <arg>)
    (<o> ^match-type default ^arg-type object ^name generalize-argument
          ^argument <arg> ^predicates <def-preds>)
    (<def-preds> ^<prop4> <pred4> ^{ < <prop4> <prop3> } <pred3>
          ^{ < <prop3> <prop2> } <pred2> ^{ < <prop2> <prop1> } <pred1>
          -^{ <> <prop4> <> <prop3> <> <prop2> <> <prop1> <prop5> } <pred5>)
    -->
    (<arg> ^generalized-rep <rep> +)
    (<rep> ^arg-type object + ^id <obj-slot> +)
    (<obj-slot> ^default <def> +)
    (<def> ^<prop1> <pred1> + ^<prop2> <pred2> + ^<prop3> <pred3> +
           ^<prop4> <pred4> +)
}

sp {anystate*apply*generalize-argument*object*default*3*predicates
    (state <s> ^operator <o> ^generalize-argument <arg>)
    (<o> ^match-type default ^arg-type object ^name generalize-argument
          ^argument <arg> ^predicates <def-preds>)
    (<def-preds> ^<prop3> <pred3> ^{ < <prop3> <prop2> } <pred2>
          ^{ < <prop2> <prop1> } <pred1>
          -^{ <> <prop3> <> <prop2> <> <prop1> <prop4> } <pred4>)
    -->
    (<arg> ^generalized-rep <rep> +)
    (<rep> ^arg-type object + ^id <obj-slot> +)
    (<obj-slot> ^default <def> +)
    (<def> ^<prop1> <pred1> + ^<prop2> <pred2> + ^<prop3> <pred3> +)
}

sp {anystate*apply*generalize-argument*object*default*2*predicates
    (state <s> ^operator <o> ^generalize-argument <arg>)
    (<o> ^match-type default ^arg-type object ^name generalize-argument
          ^argument <arg> ^predicates <def-preds>)
    (<def-preds> ^<prop2> <pred2> ^{ < <prop2> <prop1> } <pred1>
          -^{ <> <prop2> <> <prop1> <prop3> } <pred3>)
    -->
    (<arg> ^generalized-rep <rep> +)
    (<rep> ^arg-type object + ^id <obj-slot> +)
    (<obj-slot> ^default <def> +)
    (<def> ^<prop1> <pred1> + ^<prop2> <pred2> +)
}

sp {anystate*apply*generalize-argument*object*default*1*predicate
    (state <s> ^operator <o> ^generalize-argument <arg>)
    (<o> ^match-type default ^arg-type object ^name generalize-argument
          ^argument <arg> ^predicates <def-preds>)
    (<def-preds> ^<prop1> <pred1> -^{ <> <prop1> <prop2> } <pred2>)
    -->
    (<arg> ^generalized-rep <rep> +)
    (<rep> ^arg-type object + ^id <obj-slot> +)
    (<obj-slot> ^default <def> +)
    (<def> ^<prop1> <pred1> +)
}

sp {anystate*elaborate*generalize-argument*object*default*predicates
    (state <s> ^operator <o> + ^generalize-argument <arg>)
    (<o> ^match-type default ^arg-type object ^name generalize-argument
          ^argument <arg> ^instance <i*1> ^predicates <def-preds>)
    (<i*1> ^predicates <preds>)
    (<preds>
          ^{ << modifier1 color shape size category property spatial-shape >> <prop-handle> } <pred-handle>)
    -->
    (<def-preds> ^<prop-handle> <pred-handle> +)
}

sp {anystate*elaborate*generalize-argument*object*default*predicates*sentence
    (state <s> ^operator <o> + ^generalize-argument <arg> ^subaction-id <s*1>)
    (<o> ^match-type default ^arg-type object ^name generalize-argument
          ^argument <arg> ^instance <i*1> ^predicates <def-preds>)
    (<i*1> ^predicates <preds>)
    (<preds> ^sentence <sent>)
    (<s*1> ^handle { << say1 ask1 >> <h*1> })
    -->
    (<def-preds> ^sentence <sent> +)
}

sp {anystate*propose*generalize-argument*object*default
    (state <s> ^generalize-argument <arg>)
    (<arg> -^generalized-rep <g*1> ^instance <i>)
    (<i> ^arg-type object ^id <obj>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name generalize-argument + ^argument <arg> + ^arg-type object +
           ^match-type default + ^instance <obj> + ^predicates <preds> +)
}

sp {anystate*apply*generalize-argument*object*procedural
    (state <s> ^operator <o> ^generalize-argument <arg>)
    (<o> ^match-type procedural ^arg-type object ^name generalize-argument
          ^argument <arg> ^id <obj-slot>)
    -->
    (<arg> ^generalized-rep <gen> +)
    (<gen> ^arg-type object + ^id <obj-slot> +)
}

sp {anystate*propose*generalize-argument*object*procedural*level2
    (state <s> ^generalize-argument <arg> ^action-id <a*1>
          ^action-operator <a*2>)
    (<arg> -^generalized-rep <g*1> ^instance <i>)
    (<i> ^arg-type object ^id <obj>)
    (<a*1> ^procedural <p*1>)
    (<a*2> ^<arg-name> <a*3>)
    (<a*3> ^2 <obj>)
    (<p*1> ^<arg-name> <parg>)
    (<parg> ^arg-type predicate ^2 <obj-slot>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name generalize-argument + ^argument <arg> + ^arg-type object +
           ^match-type procedural + ^id <obj-slot> +)
}

sp {anystate*propose*generalize-argument*object*procedural*level1
    (state <s> ^generalize-argument <arg> ^action-id <a*1>
          ^action-operator <a*2>)
    (<arg> -^generalized-rep <g*1> ^instance <i>)
    (<i> ^arg-type object ^id <obj>)
    (<a*1> ^procedural <p*1>)
    (<a*2> ^<arg-name> <a*3>)
    (<a*3> ^id <obj>)
    (<p*1> ^<arg-name> <parg>)
    (<parg> ^arg-type object ^id <obj-slot>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name generalize-argument + ^argument <arg> + ^arg-type object +
           ^match-type procedural + ^id <obj-slot> +)
}

sp {anystate*generalize-argument*prefer*procedural*over*default
    (state <s> ^operator <o2> + ^generalize-argument <arg> ^operator <o1> +)
    (<o2> ^match-type default ^name generalize-argument ^argument <arg>)
    (<o1> ^match-type procedural ^argument <arg> ^name generalize-argument)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {execute-primitive-action*elaborate*until-clause*satisfied*3*predicates
    (state <s> ^problem-space <p*1> ^until-clause <until>)
    (<p*1> ^name action)
    (<until> ^predicate <p3> ^predicate <p2> ^predicate <p1>
          -^predicate { <> <p1> <> <p2> <> <p3> <p4> }
          ^predicate { > <p2> <p*3> } ^predicate { > <p1> <p*2> })
    (<p3> ^satisfied true)
    (<p2> ^satisfied true)
    (<p1> ^satisfied true)
    -->
    (<until> ^satisfied true +)
}

sp {execute-primitive-action*elaborate*until-clause*satisfied*2*predicates
    (state <s> ^problem-space <p*1> ^until-clause <until>)
    (<p*1> ^name action)
    (<until> ^predicate <p2> ^predicate <p1>
          -^predicate { <> <p1> <> <p2> <p3> } ^predicate { > <p1> <p*2> })
    (<p2> ^satisfied true)
    (<p1> ^satisfied true)
    -->
    (<until> ^satisfied true +)
}

sp {execute-primitive-action*elaborate*until-clause*satisfied*1*predicate
    (state <s> ^problem-space <p*1> ^until-clause <until>)
    (<p*1> ^name action)
    (<until> ^predicate <p1> -^predicate { <> <p1> <p2> })
    (<p1> ^satisfied true)
    -->
    (<until> ^satisfied true +)
}

sp {execute-primitive-action*elaborate*until-clause*state*relation*satisfied
    (state <s> ^problem-space <p*1> ^until-clause <until> ^world <world>)
    (<p*1> ^name action)
    (<until> ^predicate <until-pred>)
    (<until-pred> ^type relation ^2 <obj2> ^handle <pred-handle> ^1 <obj1>)
    (<world> ^objects <o*2> ^objects <o*1> ^predicates <p*2>)
    (<p*2> ^predicate <pred>)
    (<pred> ^handle <pred-handle> ^instance <i>)
    (<i> ^2 <obj2> ^1 <obj1>)
    (<o*2> ^object <obj2>)
    (<o*1> ^object <obj1>)
    -->
    (<until-pred> ^satisfied true +)
}

sp {execute-primitive-action*elaborate*until-clause*state*predicate*satisfied
    (state <s> ^problem-space <p*1> ^until-clause <until> ^world <w*1>)
    (<p*1> ^name action)
    (<until> ^predicate <pred>)
    (<pred> ^type state ^handle <pred-handle> ^1 <obj>)
    (<w*1> ^objects <o*1>)
    (<obj> ^predicates <p*2>)
    (<p*2> ^<prop-handle> <pred-handle>)
    (<o*1> ^object <obj>)
    -->
    (<pred> ^satisfied true +)
}

sp {execute-primitive-action*elaborate*until-clause*state*predicate*satisfied*visible
    (state <s> ^problem-space <p*1> ^until-clause <until> ^world <w*1>)
    (<p*1> ^name action)
    (<until> ^predicate <pred>)
    (<pred> ^handle visible1 ^type state ^1 <obj>)
    (<w*1> ^objects <o*1>)
    (<obj> ^predicates <p*2>)
    (<p*2> ^visible true)
    (<o*1> ^object <obj>)
    -->
    (<pred> ^satisfied true +)
}

sp {action*elaborate*until-clause*from*action-operator
    (state <s> ^problem-space <p*1> ^action-operator <a*1>)
    (<p*1> ^name action)
    (<a*1> ^until-clause <until>)
    -->
    (<s> ^until-clause <until> +)
}

sp {composite-action*propose*op_ask1*message*current-action
    (state <s> ^problem-space <ps> ^current-action <c*1>)
    (<ps> ^name action ^action <a*1>)
    (<a*1> ^propose-action-operators true)
    (<c*1> ^execution-operator <ex-op>)
    (<ex-op> ^action-handle ask1 ^arg1 <a*2>)
    (<a*2> ^id <obj>)
   -{ (<s> ^world <w*1>)
      (<w*1> ^objects <o*1>)
      (<o*1> ^object <obj>)}
    (<obj> ^predicates <p*1>)
    (<p*1> ^category message)
    -->
    (<s> ^operator <o> +)
    (<o> ^name op_ask1 + ^action-handle ask1 + ^arg1 <arg1> +)
    (<arg1> ^arg-type object + ^arg-status abstract + ^id <obj> +)
}

sp {composite-action*propose*op_say1*message*current-action
    (state <s> ^problem-space <ps> ^current-action <c*1>)
    (<ps> ^name action ^action <a*1>)
    (<a*1> ^propose-action-operators true)
    (<c*1> ^execution-operator <ex-op>)
    (<ex-op> ^action-handle say1 ^arg1 <a*2>)
    (<a*2> ^id <obj>)
   -{ (<s> ^world <w*1>)
      (<w*1> ^objects <o*1>)
      (<o*1> ^object <obj>)}
    (<obj> ^predicates <p*1>)
    (<p*1> ^category message)
    -->
    (<s> ^operator <o> +)
    (<o> ^name op_say1 + ^action-handle say1 + ^arg1 <arg1> +)
    (<arg1> ^arg-type object + ^arg-status abstract + ^id <obj> +)
}

sp {composite-action*propose*op_say1*message
    (state <s> ^problem-space <ps> ^world <w*3> ^world <w*2> ^world <w*1>)
    (<ps> ^name action ^action <a*1>)
    (<a*1> ^propose-action-operators true)
    (<w*3> ^predicates <p*1>)
    (<p*1> ^predicate <heard>)
    (<heard> ^handle heard2)
    (<w*2> ^objects <o*2>)
    (<w*1> ^objects <o*1>)
    (<o*2> ^object <person>)
    (<person> ^predicates <p*4> ^predicates <p*3>)
    (<p*4> ^visible true)
    (<p*3> ^category person)
    (<o*1> ^object <obj>)
   -{ (<heard> ^instance <i>)
      (<i> ^2 <obj> ^1 <person>)}
    (<obj> ^predicates <p*2>)
    (<p*2> ^category message)
    -->
    (<s> ^operator <op> +)
    (<op> ^name op_say1 + ^action-handle say1 + ^arg1 <arg1> + ^arg2 <arg2> +)
    (<arg1> ^arg-type object + ^arg-status abstract + ^id <obj> +)
    (<arg2> ^arg-type predicate + ^handle to1 + ^2 <person> +)
}

sp {composite-action*propose*driving-operator*op_explore
    (state <s> ^problem-space <ps>)
    (<ps> ^name action ^action <a*2> ^action <a*1>)
    (<a*2> ^propose-driving-operators true)
    (<a*1> ^propose-action-operators true)
    -->
    (<s> ^operator <o> +)
    (<o> ^name op_explore1 + ^action-handle explore1 +)
}

sp {composite-action*propose*op_follow-person1
    (state <s> ^problem-space <ps> ^world <w*1>)
    (<ps> ^name action ^action <a*2> ^action <a*1>)
    (<a*2> ^propose-driving-operators true)
    (<a*1> ^propose-action-operators true)
    (<w*1> ^objects <o*1>)
    (<o*1> ^object <person>)
    (<person> ^predicates <preds>)
    (<preds> ^category person ^visible true)
    -->
    (<s> ^operator <op> +)
    (<op> ^name op_follow-person1 + ^action-handle follow-person1 +
           ^arg1 <arg1> +)
    (<arg1> ^arg-type object + ^id <person> +)
}

sp {action*propose*op_go-to-location1*object
    (state <s> ^problem-space <ps> ^world <w*1>)
    (<ps> ^name action ^action <a*2> ^action <a*1>)
    (<a*2> ^propose-driving-operators true)
    (<a*1> ^propose-action-operators true)
    (<w*1> ^objects <o*1>)
    (<o*1> ^object <obj>)
    (<obj> ^predicates <p*1>)
    (<p*1> ^category { << person object >> <c*1> })
    -->
    (<s> ^operator <o> +)
    (<o> ^name op_go-to-location1 + ^action-handle go-to-location1 +
           ^arg2 <arg2> +)
    (<arg2> ^arg-type predicate + ^handle to1 + ^2 <obj> +)
}

sp {composite-action*propose*driving-operator*op_face1
    (state <s> ^problem-space <ps> ^world <w*3> ^world <w*2> ^world <w*1>)
    (<ps> ^name action ^action <a*2> ^action <a*1>)
    (<a*2> ^propose-driving-operators true)
    (<a*1> ^propose-action-operators true)
    (<w*3> ^predicates <p*1>)
    (<p*1> ^predicate <in-pred>)
    (<in-pred> ^handle in1 ^instance <i>)
    (<i> ^2 <cur-loc> ^1 <obj>)
    (<w*2> ^robot <r*1>)
    (<r*1> ^current-location <cur-loc>)
    (<w*1> ^objects <o*1>)
    (<obj> ^predicates <preds>)
    (<preds> ^arm-status not-grabbed ^category { << object person >> <c*1> })
    (<o*1> ^object <obj>)
    -->
    (<s> ^operator <scan-op> +)
    (<scan-op> ^name op_face1 + ^action-handle face1 + ^arg1 <obj-arg> +)
    (<obj-arg> ^arg-type object + ^id <obj> +)
}

sp {composite-action*propose*driving-operator*op_scan1
    (state <s> ^problem-space <ps>)
    (<ps> ^name action ^action <a*2> ^action <a*1>)
    (<a*2> ^propose-driving-operators true)
    (<a*1> ^propose-action-operators true)
    -->
    (<s> ^operator <scan-op> +)
    (<scan-op> ^name op_scan1 + ^action-handle scan1 +)
}

sp {composite-action*propose*driving-operator*op_drive-forward1
    (state <s> ^problem-space <ps>)
    (<ps> ^name action ^action <a*2> ^action <a*1>)
    (<a*2> ^propose-driving-operators true)
    (<a*1> ^propose-action-operators true)
    -->
    (<s> ^operator <drive-op> +)
    (<drive-op> ^name op_drive-forward1 + ^action-handle drive-forward1 +)
}

sp {composite-action*propose*driving-operator*op_stop1
    (state <s> ^problem-space <ps>)
    (<ps> ^name action ^action <a*2> ^action <a*1>)
    (<a*2> ^propose-driving-operators true)
    (<a*1> ^propose-action-operators true)
    -->
    (<s> ^operator <o> +)
    (<o> ^name op_stop1 + ^action-handle stop1 +)
}

sp {composite-action*propose*driving-operator*op_orient1*each*direction
    (state <s> ^problem-space <ps>)
    (<ps> ^name action ^action <a*2> ^action <a*1>)
    (<a*2> ^propose-driving-operators true)
    (<a*1> ^propose-action-operators true)
    -->
    (<s> ^operator <on> + ^operator <os> + ^operator <oe> + ^operator <ow> +)
    (<on> ^name op_orient1 + ^action-handle orient1 + ^arg1 <n-arg1> +)
    (<n-arg1> ^arg-type concept + ^handle north1 +)
    (<os> ^name op_orient1 + ^action-handle orient1 + ^arg1 <s-arg1> +)
    (<s-arg1> ^arg-type concept + ^handle south1 +)
    (<oe> ^name op_orient1 + ^action-handle orient1 + ^arg1 <e-arg1> +)
    (<e-arg1> ^arg-type concept + ^handle east1 +)
    (<ow> ^name op_orient1 + ^action-handle orient1 + ^arg1 <w-arg1> +)
    (<w-arg1> ^arg-type concept + ^handle west1 +)
}

sp {composite-action*propose*driving-operator*op_follow-wall1
    (state <s> ^problem-space <ps>)
    (<ps> ^name action ^action <a*2> ^action <a*1>)
    (<a*2> ^propose-driving-operators true)
    (<a*1> ^propose-action-operators true)
    -->
    (<s> ^operator <left-op> + ^operator <right-op> +)
    (<left-op> ^name op_follow-wall1 + ^action-handle follow-wall1 +
           ^arg1 <left-arg1> +)
    (<left-arg1> ^arg-type object + ^arg-status abstract + ^id <left-wall> +)
    (<left-wall> ^item-type object + ^predicates <left-preds> +)
    (<left-preds> ^category object + ^relative-direction1 left1 +
           ^spatial-shape wall1 +)
    (<right-op> ^name op_follow-wall1 + ^action-handle follow-wall1 +
           ^arg1 <right-arg1> +)
    (<right-arg1> ^arg-type object + ^arg-status abstract + ^id <right-wall> +)
    (<right-wall> ^item-type object + ^predicates <right-preds> +)
    (<right-preds> ^category object + ^relative-direction1 right1 +
           ^spatial-shape wall1 +)
}

sp {composite-action*propose*driving-operator*op_turn1
    (state <s> ^problem-space <ps>)
    (<ps> ^name action ^action <a*2> ^action <a*1>)
    (<a*2> ^propose-driving-operators true)
    (<a*1> ^propose-action-operators true)
    -->
    (<s> ^operator <oleft> + ^operator <oright> + ^operator <oaround> +)
    (<oleft> ^name op_turn1 + ^action-handle turn1 + ^arg1 <left-arg1> +)
    (<left-arg1> ^arg-type concept + ^handle left1 +)
    (<oright> ^name op_turn1 + ^action-handle turn1 + ^arg1 <right-arg1> +)
    (<right-arg1> ^arg-type concept + ^handle right1 +)
    (<oaround> ^name op_turn1 + ^action-handle turn1 + ^arg1 <around-arg1> +)
    (<around-arg1> ^arg-type concept + ^handle around1 +)
}

sp {composite-action*propose*op_stop-leading1
    (state <s> ^problem-space <ps> ^world <w*1>)
    (<ps> ^name action ^action <a*1>)
    (<a*1> ^propose-action-operators true)
    (<w*1> ^objects <o*1>)
    (<o*1> ^object <person>)
    (<person> ^predicates <preds>)
    (<preds> ^robot-status leading ^category person)
    -->
    (<s> ^operator <op> +)
    (<op> ^name op_stop-leading1 + ^action-handle stop-leading1 +
           ^arg1 <arg1> +)
    (<arg1> ^arg-type object + ^id <person> +)
}

sp {composite-action*propose*op_start-leading1
    (state <s> ^problem-space <ps> ^world <w*1>)
    (<ps> ^name action ^action <a*1>)
    (<a*1> ^propose-action-operators true)
    (<w*1> ^objects <o*1>)
    (<o*1> ^object <person>)
    (<person> ^predicates <preds>)
    (<preds> -^robot-status leading ^category person ^visible true)
    -->
    (<s> ^operator <op> +)
    (<op> ^name op_start-leading1 + ^action-handle start-leading1 +
           ^arg1 <arg1> +)
    (<arg1> ^arg-type object + ^id <person> +)
}

sp {composite-action*propose*op_find
    (state <s> ^problem-space <ps> ^world <w*1>)
    (<ps> ^name action ^action <a*1>)
    (<a*1> ^propose-action-operators true)
    (<w*1> ^objects <o*1>)
    (<o*1> ^object <obj>)
    (<obj> ^predicates <p*1>)
    (<p*1> ^visible false)
    -->
    (<s> ^operator <op> +)
    (<op> ^name op_find1 + ^action-handle find1 + ^arg1 <arg1> +)
    (<arg1> ^arg-type object + ^id <obj> +)
}

sp {composite-action*propose*op_give1
    (state <s> ^problem-space <ps> ^world <w*2> ^world <w*1>)
    (<ps> ^name action ^action <a*1>)
    (<a*1> ^propose-action-operators true)
    (<w*2> ^objects <o*2>)
    (<w*1> ^objects <o*1>)
    (<o*2> ^object <person>)
    (<person> ^predicates <p*3> ^predicates <p*2>)
    (<p*3> ^category person)
    (<p*2> ^visible true)
    (<o*1> ^object <obj1>)
    (<obj1> ^predicates <p*1>)
    (<p*1> ^arm-status grabbed)
    -->
    (<s> ^operator <op> +)
    (<op> ^name op_give1 + ^action-handle give1 + ^arg1 <arg1> +
           ^arg2 <arg2> +)
    (<arg1> ^arg-type object + ^id <obj1> +)
    (<arg2> ^arg-type predicate + ^handle to1 + ^2 <person> +)
}

sp {composite-action*propose*op_put-down1*with*obj2
    (state <s> ^problem-space <ps> ^world <w*2> ^world <w*1>)
    (<ps> ^name action ^action <a*1>)
    (<a*1> ^propose-action-operators true)
    (<w*2> ^objects <o*2>)
    (<w*1> ^objects <o*1>)
    (<o*2> ^object <obj2>)
    (<obj2> ^predicates <p*3> ^predicates <p*2>)
    (<p*3> ^category object)
    (<p*2> ^visible true)
    (<o*1> ^object { <> <obj2> <obj1> })
    (<obj1> ^predicates <p*1>)
    (<p*1> ^arm-status grabbed)
    -->
    (<s> ^operator <op> +)
    (<op> ^name op_put-down1 + ^action-handle put-down1 + ^arg1 <arg1> +
           ^arg2 <arg2> +)
    (<arg1> ^arg-type object + ^id <obj1> +)
    (<arg2> ^arg-type predicate + ^default-handle on1 + ^any-predicate true +
           ^2 <obj2> +)
}

sp {composite-action*propose*op_put-down1
    (state <s> ^problem-space <ps> ^world <w*1>)
    (<ps> ^name action ^action <a*1>)
    (<a*1> ^propose-action-operators true)
    (<w*1> ^objects <o*1>)
    (<o*1> ^object <obj>)
    (<obj> ^predicates <p*1>)
    (<p*1> ^arm-status grabbed)
    -->
    (<s> ^operator <op> +)
    (<op> ^name op_put-down1 + ^action-handle put-down1 + ^arg1 <arg1> +)
    (<arg1> ^arg-type object + ^id <obj> +)
}

sp {composite-action*propose*op_pick-up1*mobile
    (state <s> ^world <w*1> ^problem-space <ps>)
   -{ (<s> ^world <w*2>)
      (<w*2> ^objects <o*2>)
      (<o*2> ^object <o*3>)
      (<o*3> ^predicates <p*1>)
      (<p*1> ^arm-status grabbed)}
    (<ps> ^name action ^action <a*1>)
    (<a*1> ^propose-action-operators true)
    (<w*1> ^objects <o*1>)
    (<o*1> ^object <obj>)
    (<obj> ^predicates <preds>)
    (<preds> ^category object ^visible true ^arm-status not-grabbed)
    -->
    (<s> ^operator <op> +)
    (<op> ^name op_pick-up1 + ^action-handle pick-up1 + ^arg1 <arg1> +)
    (<arg1> ^arg-type object + ^id <obj> +)
}

sp {action*propose*op_go-to-location1
    (state <s> ^problem-space <ps> ^world <w*1>)
    (<ps> ^name action ^action <a*1>)
    (<a*1> ^propose-action-operators true)
    (<w*1> ^objects <o*1>)
    (<o*1> ^object <loc>)
   -{ (<s> ^world <w*2>)
      (<w*2> ^robot <r*1>)
      (<r*1> ^current-location <loc>)}
    (<loc> ^predicates <p*1>)
    (<p*1> ^category location)
    -->
    (<s> ^operator <o> +)
    (<o> ^name op_go-to-location1 + ^action-handle go-to-location1 +
           ^arg2 <arg2> +)
    (<arg2> ^arg-type predicate + ^handle to1 + ^2 <loc> +)
}

sp {action*propose*op_do-nothing
    (state <s> ^problem-space <ps>)
    (<ps> ^name action ^action <a*2> ^action <a*1>)
    (<a*2> ^type execute)
    (<a*1> ^propose-action-operators true)
    -->
    (<s> ^operator <o> +)
    (<o> ^name op_do-nothing + ^action-handle do-nothing1 +)
}

sp {problem-space*perception*attend-to-robot*yes*propose*attend-to-scene-change
    (state <s> ^top-state <t*1> ^problem-space <p*1>)
    (<t*1> ^perception-monitor <p*3>)
    (<p*3> ^changes <c*1>)
    (<c*1> ^change <change>)
    (<change> ^info <i*1>)
    (<i*1> ^category robot)
    (<p*1> ^perception <p*2>)
    (<p*2> ^attend-to-robot yes)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name attend-to-scene-change + ^change <change> +)
}

sp {problem-space*perception*attend-to-object*propose*attend-to-scene-change
    (state <s> ^top-state <t*1> ^problem-space <p*1>)
    (<t*1> ^perception-monitor <p*3>)
    (<p*3> ^changes <c*1>)
    (<c*1> ^change <change>)
    (<change> ^object-info <o*1>)
    (<o*1> ^object-handle <obj-handle>)
    (<p*1> ^perception <p*2>)
    (<p*2> ^attend-to-object <obj-handle>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name attend-to-scene-change + ^change <change> +)
}

sp {problem-space*perception*attend-to-all-perception*yes*propose*attend-to-scene-change
    (state <s> ^top-state <t*1> ^problem-space <p*1>)
    (<t*1> ^perception-monitor <p*3>)
    (<p*3> ^changes <c*1>)
    (<c*1> ^change <change>)
    (<p*1> ^perception <p*2>)
    (<p*2> ^attend-to-all-perception yes)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name attend-to-scene-change + ^change <change> +)
}

sp {problem-space*default-operator-copy*yes*copy*until-clause*relation*predicate
    (state <s> ^problem-space <p*1> ^deep-copy-world <dcw> ^operator <o> +)
    (<p*1> ^default-operator-copy yes)
    (<dcw> ^copy-objects-map <c*2> ^copy-objects-map <c*1>)
    (<c*2> ^entry <obj2-e>)
    (<obj2-e> ^copy <obj2> ^source <src-obj2>)
    (<c*1> ^entry <obj1-e>)
    (<obj1-e> ^copy <obj1> ^source <src-obj1>)
    (<o> ^duplicate-of <src-op> ^<arg-name> <new-arg>)
    (<src-op> ^<arg-name> <src-arg>)
    (<src-arg> ^arg-type until-clause ^predicate <src-pred>)
    (<src-pred> ^2 <src-obj2> ^1 <src-obj1> ^type relation
          ^handle <pred-handle>)
    -->
    (<new-arg> ^predicate <new-pred> +)
    (<new-pred> ^type relation + ^handle <pred-handle> + ^1 <obj1> +
           ^2 <obj2> +)
}

sp {problem-space*default-operator-copy*yes*copy*until-clause*state*predicate
    (state <s> ^problem-space <p*1> ^deep-copy-world <dcw> ^operator <o> +)
    (<p*1> ^default-operator-copy yes)
    (<dcw> ^copy-objects-map <c*1>)
    (<c*1> ^entry <obj-e>)
    (<obj-e> ^copy <obj> ^source <src-obj>)
    (<o> ^duplicate-of <src-op> ^<arg-name> <new-arg>)
    (<src-op> ^<arg-name> <src-arg>)
    (<src-arg> ^arg-type until-clause ^predicate <src-pred>)
    (<src-pred> ^1 <src-obj> ^type state ^property-handle <prop-handle>
          ^handle <pred-handle>)
    -->
    (<new-arg> ^predicate <new-pred> +)
    (<new-pred> ^type state + ^handle <pred-handle> +
           ^property-handle <prop-handle> + ^1 <obj> +)
}

sp {problem-space*default-operator-copy*yes*copy*until-clause*arg
    (state <s> ^problem-space <p*1> ^operator <o> +)
    (<p*1> ^default-operator-copy yes)
    (<o> ^duplicate-of <src-op>)
    (<src-op> ^<arg-name> <src-arg>)
    (<src-arg> ^arg-type until-clause)
    -->
    (<o> ^<arg-name> <new-arg> +)
    (<new-arg> ^arg-type until-clause +)
}

sp {problem-space*default-operator-copy*yes*copy*predicate*abstract*object*predicates
    (state <s> ^problem-space <p*1> ^operator <o> +)
    (<p*1> ^default-operator-copy yes)
    (<o> ^duplicate-of <d*2> ^<arg-name> <new-arg>)
    (<d*2> ^<arg-name> <src-arg>)
    (<src-arg> ^arg-type predicate ^2 <src-obj> ^2 <v*1> ^handle <pred-handle>)
   -{ (<s> ^deep-copy-world <d*1>)
      (<d*1> ^copy-objects-map <c*1>)
      (<c*1> ^entry <e*1>)
      (<e*1> ^source <src-obj>)}
    (<v*1> ^predicates <p*2>)
    (<new-arg> ^2 <v*2>)
    (<v*2> ^predicates <new-preds>)
    (<p*2> ^<prop-name> <pred-name>)
    -->
    (<new-preds> ^<prop-name> <pred-name> +)
}

sp {problem-space*default-operator-copy*yes*copy*predicate*abstract
    (state <s> ^problem-space <p*1> ^operator <o> +)
    (<p*1> ^default-operator-copy yes)
    (<o> ^duplicate-of <src-op>)
    (<src-op> ^<arg-name> <src-arg>)
    (<src-arg> ^arg-type predicate ^2 <src-obj> ^handle <pred-handle>)
   -{ (<s> ^deep-copy-world <d*1>)
      (<d*1> ^copy-objects-map <c*1>)
      (<c*1> ^entry <e*1>)
      (<e*1> ^source <src-obj>)}
    -->
    (<o> ^<arg-name> <new-arg> +)
    (<new-arg> ^arg-type predicate + ^handle <pred-handle> + ^2 <new-obj> +)
    (<new-obj> ^item-type object + ^predicates <new-preds> +)
}

sp {problem-space*default-operator-copy*yes*copy*predicate*arg
    (state <s> ^problem-space <p*1> ^deep-copy-world <dcw> ^operator <o> +)
    (<p*1> ^default-operator-copy yes)
    (<dcw> ^copy-objects-map <c*1>)
    (<c*1> ^entry <obj-e>)
    (<obj-e> ^copy <obj> ^source <src-obj>)
    (<o> ^duplicate-of <src-op>)
    (<src-op> ^<arg-name> <src-arg>)
    (<src-arg> ^arg-type predicate ^2 <src-obj> ^handle <pred-handle>)
    -->
    (<o> ^<arg-name> <new-arg> +)
    (<new-arg> ^arg-type predicate + ^handle <pred-handle> + ^2 <obj> +)
}

sp {problem-space*default-operator-copy*yes*copy*concept*arg
    (state <s> ^problem-space <p*1> ^operator <o> +)
    (<p*1> ^default-operator-copy yes)
    (<o> ^duplicate-of <src-op>)
    (<src-op> ^<arg-name> <src-arg>)
    (<src-arg> ^arg-type concept ^handle <concept-handle>)
    -->
    (<o> ^<arg-name> <new-arg> +)
    (<new-arg> ^arg-type concept + ^handle <concept-handle> +)
}

sp {problem-space*default-operator-copy*yes*copy*abstract*object*arg*predicates
    (state <s> ^problem-space <p*1> ^operator <o> +)
    (<p*1> ^default-operator-copy yes)
    (<o> ^duplicate-of <d*2> ^<arg-name> <new-arg>)
    (<d*2> ^<arg-name> <src-arg>)
    (<src-arg> ^arg-type object ^id <obj> ^id <i*1>)
   -{ (<s> ^deep-copy-world <d*1>)
      (<d*1> ^copy-objects-map <c*1>)
      (<c*1> ^entry <e*1>)
      (<e*1> ^source <obj>)}
    (<i*1> ^predicates <p*2>)
    (<new-arg> ^id <i*2>)
    (<i*2> ^predicates <new-preds>)
    (<p*2> ^<prop-name> <pred-name>)
    -->
    (<new-preds> ^<prop-name> <pred-name> +)
}

sp {problem-space*default-operator-copy*yes*copy*abstract*object*arg
    (state <s> ^problem-space <p*1> ^operator <o> +)
    (<p*1> ^default-operator-copy yes)
    (<o> ^duplicate-of <src-op>)
    (<src-op> ^<arg-name> <src-arg>)
    (<src-arg> ^arg-type object ^id <obj>)
   -{ (<s> ^deep-copy-world <d*1>)
      (<d*1> ^copy-objects-map <c*1>)
      (<c*1> ^entry <e*1>)
      (<e*1> ^source <obj>)}
    -->
    (<o> ^<arg-name> <new-arg> +)
    (<new-arg> ^arg-type object + ^id <new-obj> +)
    (<new-obj> ^item-type object + ^predicates <preds> +)
}

sp {problem-space*default-operator-copy*yes*copy*object*arg
    (state <s> ^problem-space <p*1> ^deep-copy-world <dcw> ^operator <o> +)
    (<p*1> ^default-operator-copy yes)
    (<dcw> ^copy-objects-map <c*1>)
    (<c*1> ^entry <obj-e>)
    (<obj-e> ^copy <obj> ^source <src-obj>)
    (<o> ^duplicate-of <src-op>)
    (<src-op> ^<arg-name> <src-arg>)
    (<src-arg> ^arg-type object ^id <src-obj>)
    -->
    (<o> ^<arg-name> <new-arg> +)
    (<new-arg> ^arg-type object + ^id <obj> +)
}

sp {problem-space*default-operator-copy*yes*elaborate*dont-copy
    (state <s> ^problem-space <ps>)
    (<ps> ^default-operator-copy yes)
    -->
    (<ps> ^dont-copy arg1 + ^dont-copy arg2 + ^dont-copy until-clause +)
}

sp {problem-space*default-desired-copy*yes*copy*relation*predicate
    (state <s> ^problem-space <p*1> ^deep-copy-world <dcw> ^desired <des>)
    (<p*1> ^default-desired-copy yes)
    (<dcw> ^copy-objects-map <c*2> ^copy-objects-map <c*1>)
    (<c*2> ^entry <obj2-e>)
    (<obj2-e> ^copy <obj2> ^source <src-obj2>)
    (<c*1> ^entry <obj1-e>)
    (<obj1-e> ^copy <obj1> ^source <src-obj1>)
    (<des> ^duplicate-of <d*1>)
    (<d*1> ^predicate <src-pred>)
    (<src-pred> ^type relation ^2 <src-obj2> ^1 <src-obj1>
          ^handle <pred-handle>)
    -->
    (<des> ^predicate <new-pred> +)
    (<new-pred> ^type relation + ^handle <pred-handle> + ^1 <obj1> +
           ^2 <obj2> +)
}

sp {problem-space*default-desired-copy*yes*copy*state*predicate
    (state <s> ^problem-space <p*1> ^deep-copy-world <dcw> ^desired <des>)
    (<p*1> ^default-desired-copy yes)
    (<dcw> ^copy-objects-map <c*1>)
    (<c*1> ^entry <obj-e>)
    (<obj-e> ^copy <obj> ^source <src-obj>)
    (<des> ^duplicate-of <d*1>)
    (<d*1> ^predicate <src-pred>)
    (<src-pred> ^type state ^1 <src-obj> ^property-handle <prop-handle>
          ^handle <pred-handle>)
    -->
    (<des> ^predicate <new-pred> +)
    (<new-pred> ^type state + ^handle <pred-handle> +
           ^property-handle <prop-handle> + ^1 <obj> +)
}

sp {problem-space*default-desired-copy*yes*elaborate*dont-copy
    (state <s> ^problem-space <ps>)
    (<ps> ^default-desired-copy yes)
    -->
    (<ps> ^dont-copy predicate +)
}

sp {anystate*deep-copy-subactions*copy*until-clause*relation*predicate
    (state <s> ^deep-copy-subactions <d*1> ^deep-copy-world <d*2>)
    (<d*1> ^copy-subactions-map <c*1>)
    (<c*1> ^entry <sub-e>)
    (<sub-e> ^copy <c*2> ^source <s*1>)
    (<d*2> ^copy-objects-map <objs-map>)
    (<objs-map> ^entry <obj2-e> ^entry <obj1-e>)
    (<obj2-e> ^copy <obj2> ^source <src-obj2>)
    (<obj1-e> ^copy <obj1> ^source <src-obj1>)
    (<c*2> ^until-clause <new-until>)
    (<s*1> ^until-clause <u*1>)
    (<u*1> ^predicate <src-pred>)
    (<src-pred> ^2 <src-obj2> ^1 <src-obj1> ^type relation
          ^handle <pred-handle>)
    -->
    (<new-until> ^predicate <new-pred> +)
    (<new-pred> ^type relation + ^handle <pred-handle> + ^1 <obj1> +
           ^2 <obj2> +)
}

sp {anystate*deep-copy-subactions*copy*until-clause*state*predicate
    (state <s> ^deep-copy-subactions <d*1> ^deep-copy-world <d*2>)
    (<d*1> ^copy-subactions-map <c*1>)
    (<c*1> ^entry <sub-e>)
    (<sub-e> ^copy <c*2> ^source <s*1>)
    (<d*2> ^copy-objects-map <objs-map>)
    (<objs-map> ^entry <obj-e>)
    (<obj-e> ^copy <obj> ^source <src-obj>)
    (<c*2> ^until-clause <new-until>)
    (<s*1> ^until-clause <u*1>)
    (<u*1> ^predicate <src-pred>)
    (<src-pred> ^1 <src-obj> ^type state ^property-handle <prop-handle>
          ^handle <pred-handle>)
    -->
    (<new-until> ^predicate <new-pred> +)
    (<new-pred> ^type state + ^handle <pred-handle> +
           ^property-handle <prop-handle> + ^1 <obj> +)
}

sp {anystate*deep-copy-subactions*copy*until-clause
    (state <s> ^deep-copy-subactions <d*1>)
    (<d*1> ^copy-subactions-map <c*1>)
    (<c*1> ^entry <sub-e>)
    (<sub-e> ^copy <sub> ^source <src-sub>)
    (<src-sub> ^until-clause <src-until>)
    -->
    (<sub> ^until-clause <new-until> +)
}

sp {anystate*deep-copy-subactions*copy*subaction*predicate*arg*abstract*predicates
    (state <s> ^deep-copy-subactions <d*1>)
    (<d*1> ^copy-subactions-map <c*1>)
    (<c*1> ^entry <sub-e>)
    (<sub-e> ^copy <c*3> ^source <s*1>)
    (<s*1> ^<arg-name> <src-arg>)
    (<src-arg> ^arg-type predicate ^2 <src-obj>)
   -{ (<s> ^deep-copy-world <d*2>)
      (<d*2> ^copy-objects-map <c*2>)
      (<c*2> ^entry <e*1>)
      (<e*1> ^source <src-obj>)}
    (<src-obj> ^predicates <p*1>)
    (<c*3> ^<arg-name> <new-arg>)
    (<new-arg> ^id <i*1>)
    (<i*1> ^predicates <new-preds>)
    (<p*1> ^<prop-name> <pred-name>)
    -->
    (<new-preds> ^<prop-name> <pred-name> +)
}

sp {anystate*deep-copy-subactions*copy*subaction*predicate*arg*absract*handle
    (state <s> ^deep-copy-subactions <d*1>)
    (<d*1> ^copy-subactions-map <c*1>)
    (<c*1> ^entry <sub-e>)
    (<sub-e> ^copy <c*3> ^source <s*1>)
    (<s*1> ^<arg-name> <src-arg>)
    (<src-arg> ^arg-type predicate ^2 <src-obj>)
   -{ (<s> ^deep-copy-world <d*2>)
      (<d*2> ^copy-objects-map <c*2>)
      (<c*2> ^entry <e*1>)
      (<e*1> ^source <src-obj>)}
    (<src-obj> ^handle <h>)
    (<c*3> ^<arg-name> <new-arg>)
    (<new-arg> ^2 <new-obj>)
    (<new-obj> -^handle { <> <h> <h*1> })
    -->
    (<new-obj> ^handle <h> +)
}

sp {anystate*deep-copy-subactions*copy*subaction*predicate*arg*abstract
    (state <s> ^deep-copy-subactions <d*1>)
    (<d*1> ^copy-subactions-map <c*1>)
    (<c*1> ^entry <sub-e>)
    (<sub-e> ^copy <sub> ^source <src-sub>)
    (<src-sub> ^<arg-name> <src-arg>)
    (<src-arg> ^arg-type predicate ^2 <src-obj> ^handle <pred-handle>)
   -{ (<s> ^deep-copy-world <d*2>)
      (<d*2> ^copy-objects-map <c*2>)
      (<c*2> ^entry <e*1>)
      (<e*1> ^source <src-obj>)}
    -->
    (<sub> ^<arg-name> <new-arg> +)
    (<new-arg> ^arg-type predicate + ^handle <pred-handle> + ^2 <new-obj> +)
    (<src-obj> ^item-type object + ^predicates <preds> +)
}

sp {anystate*deep-copy-subactions*copy*subaction*predicate*arg
    (state <s> ^deep-copy-subactions <d*1> ^deep-copy-world <d*2>)
    (<d*1> ^copy-subactions-map <c*1>)
    (<c*1> ^entry <sub-e>)
    (<sub-e> ^copy <sub> ^source <src-sub>)
    (<d*2> ^copy-objects-map <c*2>)
    (<c*2> ^entry <obj-e>)
    (<obj-e> ^copy <obj> ^source <src-obj>)
    (<src-sub> ^<arg-name> <src-arg>)
    (<src-arg> ^arg-type predicate ^2 <src-obj> ^handle <pred-handle>)
    -->
    (<sub> ^<arg-name> <new-arg> +)
    (<new-arg> ^arg-type predicate + ^handle <pred-handle> + ^2 <obj> +)
}

sp {anystate*deep-copy-subactions*copy*subaction*concept*arg
    (state <s> ^deep-copy-subactions <d*1>)
    (<d*1> ^copy-subactions-map <c*1>)
    (<c*1> ^entry <sub-e>)
    (<sub-e> ^copy <sub> ^source <src-sub>)
    (<src-sub> ^<arg-name> <src-arg>)
    (<src-arg> ^arg-type concept ^handle <concept-handle>)
    -->
    (<sub> ^<arg-name> <new-arg> +)
    (<new-arg> ^arg-type concept + ^handle <concept-handle> +)
}

sp {anystate*deep-copy-subactions*copy*subaction*object*arg*abstract*predicates
    (state <s> ^deep-copy-subactions <d*1>)
    (<d*1> ^copy-subactions-map <c*1>)
    (<c*1> ^entry <sub-e>)
    (<sub-e> ^copy <c*3> ^source <s*1>)
    (<s*1> ^<arg-name> <src-arg>)
    (<src-arg> ^arg-type object ^id <src-obj>)
   -{ (<s> ^deep-copy-world <d*2>)
      (<d*2> ^copy-objects-map <c*2>)
      (<c*2> ^entry <e*1>)
      (<e*1> ^source <src-obj>)}
    (<src-obj> ^predicates <p*1>)
    (<c*3> ^<arg-name> <new-arg>)
    (<new-arg> ^id <i*1>)
    (<i*1> ^predicates <new-preds>)
    (<p*1> ^<prop-name> <pred-name>)
    -->
    (<new-preds> ^<prop-name> <pred-name> +)
}

sp {anystate*deep-copy-subactions*copy*subaction*object*arg*abstract*handle
    (state <s> ^deep-copy-subactions <d*1>)
    (<d*1> ^copy-subactions-map <c*1>)
    (<c*1> ^entry <sub-e>)
    (<sub-e> ^copy <c*3> ^source <s*1>)
    (<s*1> ^<arg-name> <src-arg>)
    (<src-arg> ^arg-type object ^id <src-obj>)
   -{ (<s> ^deep-copy-world <d*2>)
      (<d*2> ^copy-objects-map <c*2>)
      (<c*2> ^entry <e*1>)
      (<e*1> ^source <src-obj>)}
    (<src-obj> ^handle <h>)
    (<c*3> ^<arg-name> <new-arg>)
    (<new-arg> ^id <new-obj>)
    (<new-obj> -^handle { <> <h> <h*1> })
    -->
    (<new-obj> ^handle <h> +)
}

sp {anystate*deep-copy-subactions*copy*subaction*object*arg*abstract
    (state <s> ^deep-copy-subactions <d*1>)
    (<d*1> ^copy-subactions-map <c*1>)
    (<c*1> ^entry <sub-e>)
    (<sub-e> ^copy <sub> ^source <src-sub>)
    (<src-sub> ^<arg-name> <src-arg>)
    (<src-arg> ^arg-type object ^id <src-obj>)
   -{ (<s> ^deep-copy-world <d*2>)
      (<d*2> ^copy-objects-map <c*2>)
      (<c*2> ^entry <e*1>)
      (<e*1> ^source <src-obj>)}
    -->
    (<sub> ^<arg-name> <new-arg> +)
    (<new-arg> ^arg-type object + ^id <new-obj> +)
    (<new-obj> ^item-type object + ^predicates <preds> +)
}

sp {anystate*deep-copy-subactions*copy*subaction*object*arg
    (state <s> ^deep-copy-subactions <d*1> ^deep-copy-world <d*2>)
    (<d*1> ^copy-subactions-map <c*1>)
    (<c*1> ^entry <sub-e>)
    (<sub-e> ^copy <sub> ^source <src-sub>)
    (<d*2> ^copy-objects-map <c*2>)
    (<c*2> ^entry <obj-e>)
    (<obj-e> ^copy <obj> ^source <src-obj>)
    (<src-sub> ^<arg-name> <src-arg>)
    (<src-arg> ^arg-type object ^id <src-obj>)
    -->
    (<sub> ^<arg-name> <new-arg> +)
    (<new-arg> ^arg-type object + ^id <obj> +)
}

sp {anystate*deep-copy-subactions*copy*subaction*argument*arg-status
    (state <s> ^deep-copy-subactions <d*1>)
    (<d*1> ^copy-subactions-map <c*1>)
    (<c*1> ^entry <e>)
    (<e> ^copy <c*2> ^source <s*1>)
    (<c*2> ^<arg-name> <copy-arg>)
    (<s*1> ^<arg-name> <a*1>)
    (<a*1> ^arg-status <status>)
    -->
    (<copy-arg> ^arg-status <status> +)
}

sp {anystate*deep-copy-subactions*copy*subaction*name
    (state <s> ^deep-copy-subactions <d*1>)
    (<d*1> ^copy-subactions-map <c*1>)
    (<c*1> ^entry <e>)
    (<e> ^copy <sub> ^source <src-sub>)
    (<src-sub> ^action-handle <handle>)
    -->
    (<sub> ^action-handle <handle> +)
}

sp {anystate*deep-copy-subactions*elaborate*subaction*none
    (state <s> ^deep-copy-subactions <d*1>)
    (<d*1> ^copy-subactions-map <c*1>)
    (<c*1> ^entry <e>)
    (<e> ^source <src-sub> ^copy <sub>)
    (<src-sub> ^next none)
    -->
    (<sub> ^next none +)
}

sp {anystate*deep-copy-subactions*elaborate*subaction*recursively
    (state <s> ^deep-copy-subactions <d*1>)
    (<d*1> ^copy-subactions-map <map>)
    (<map> ^entry <e>)
    (<e> ^copy <sub> ^source <src-sub>)
    (<src-sub> ^next { <> none <src-next-sub> })
    -->
    (<sub> ^next <new-next-sub> +)
    (<map> ^entry <new-e> +)
    (<new-e> ^source <src-next-sub> + ^copy <new-next-sub> +)
}

sp {anystate*deep-copy-subactions*elaborate*next*subaction*none
    (state <s> ^deep-copy-subactions <dcs>)
    (<dcs> ^source <s*1> ^copy <copy>)
    (<s*1> ^next none)
    -->
    (<copy> ^next none +)
}

sp {anystate*deep-copy-subactions*elaborate*answer
    (state <s> ^deep-copy-subactions <dcs>)
    (<dcs> ^copy <copy> ^source <s*1>)
    (<s*1> ^answer <h>)
    -->
    (<copy> ^answer <h> +)
}

sp {anystate*deep-copy-subactions*elaborate*next*subaction
    (state <s> ^deep-copy-subactions <dcs>)
    (<dcs> ^copy-subactions-map <map> ^copy <copy> ^source <s*1>)
    (<s*1> ^next { <> none <src-next-sub> })
    -->
    (<copy> ^next <new-next-sub> +)
    (<map> ^entry <e> +)
    (<e> ^source <src-next-sub> + ^copy <new-next-sub> +)
}

sp {anystate*deep-copy-subactions*elaborate*copy
    (state <s> ^deep-copy-subactions <dcs>)
    (<dcs> ^source <source>)
    -->
    (<dcs> ^copy <copy> + ^copy-subactions-map <map> +)
}

sp {problem-space*subactions*copy-type*deep*elaborate*subactions*copy*from*deep-copy-subactions
    (state <s> ^deep-copy-subactions <dcs> ^problem-space <p*1>)
    (<dcs> ^copy <copy> ^source <source>)
    (<p*1> ^subactions <subs>)
    (<subs> ^copy-type deep ^source <source>)
    -->
    (<s> ^subactions <copy> +)
}

sp {problem-space*subactions*copy-type*deep*elaborate*deep-copy-subactions
    (state <s> ^problem-space <p*1>)
    (<p*1> ^subactions <subs>)
    (<subs> ^copy-type deep ^source <source>)
    -->
    (<s> ^deep-copy-subactions <dcs> +)
    (<dcs> ^source <source> +)
}

sp {problem-space*subactions*copy-type*shallow*elaborate*subactions
    (state <s> ^problem-space <p*1>)
    (<p*1> ^subactions <subs>)
    (<subs> ^copy-type shallow ^source <source>)
    -->
    (<s> ^subactions <source> +)
}

sp {problem-space*subactions*source*elaborate*default
    (state <s> ^superstate <s*1> ^problem-space <ps>)
    (<s*1> ^subactions <subactions>)
    (<ps> ^subactions <subs>)
    (<subs> -^source { <> <subactions> <s*2> })
    -->
    (<subs> ^source <subactions> +)
}

sp {anystate*deep-copy-world*copy*predicate*instance*size*3
    (state <s> ^deep-copy-world <dcw> ^problem-space <p*1>)
    (<dcw> ^copy-predicates-map <c*1> ^copy-objects-map <com>)
    (<c*1> ^entry <pred-e>)
    (<pred-e> ^copy <pred> ^source <src-pred>)
    (<src-pred> ^instance <src-i>)
    (<src-i> -^4 <v*1> ^2 <src-obj2> ^3 <src-obj3> ^1 <src-obj1>)
    (<p*1> ^world <w*1>)
    (<w*1> ^copy-type deep)
    (<com> ^<src-obj2> <obj3> ^<src-obj2> <obj2> ^<src-obj1> <obj1>)
    -->
    (<pred> ^instance <new-i> +)
    (<new-i> ^1 <obj1> + ^2 <obj2> + ^3 <obj3> +)
}

sp {anystate*deep-copy-world*copy*predicate*instance*size*2
    (state <s> ^deep-copy-world <dcw> ^problem-space <p*1>)
    (<dcw> ^copy-predicates-map <c*1> ^copy-objects-map <com>)
    (<c*1> ^entry <pred-e>)
    (<pred-e> ^copy <pred> ^source <src-pred>)
    (<src-pred> ^instance <src-i>)
    (<src-i> -^3 <v*1> ^2 <src-obj2> ^1 <src-obj1>)
    (<p*1> ^world <w*1>)
    (<w*1> ^copy-type deep)
    (<com> ^<src-obj2> <obj2> ^<src-obj1> <obj1>)
    -->
    (<pred> ^instance <new-i> +)
    (<new-i> ^1 <obj1> + ^2 <obj2> +)
}

sp {anystate*deep-copy-world*copy*predicate*instance*size*1*set*object
    (state <s> ^deep-copy-world <dcw>)
    (<dcw> ^copy-set-map <c*1> ^copy-objects-map <c*2>)
    (<c*1> ^entry <set-e>)
    (<set-e> ^copy <set> ^source <src-set>)
    (<c*2> ^entry <obj-e>)
    (<obj-e> ^copy <obj> ^source <src-obj>)
    (<src-set> ^<elem> <src-obj>)
    -->
    (<set> ^<elem> <obj> +)
}

sp {anystate*deep-copy-world*copy*predicate*instance*size*1*set
    (state <s> ^deep-copy-world <dcw>)
    (<dcw> ^copy-set-map <set-map> ^copy-predicates-map <c*1>)
    (<c*1> ^entry <e>)
    (<e> ^copy <pred> ^source <src-pred>)
    (<src-pred> ^instance <src-instance>)
    (<src-instance> -^2 <v*1> ^1 <src-set>)
    (<src-set> -^item-type <i*1>)
    -->
    (<pred> ^instance <new-instance> +)
    (<new-instance> ^1 <new-set> +)
    (<set-map> ^entry <new-e> +)
    (<new-e> ^source <src-set> + ^copy <new-set> +)
}

sp {anystate*deep-copy-world*copy*predicate*handle
    (state <s> ^deep-copy-world <d*1>)
    (<d*1> ^copy-predicates-map <c*1>)
    (<c*1> ^entry <e>)
    (<e> ^copy <pred> ^source <s*1>)
    (<s*1> ^handle <pred-handle>)
    -->
    (<pred> ^handle <pred-handle> +)
}

sp {anystate*deep-copy-world*copy*predicate
    (state <s> ^deep-copy-world <dcw>)
    (<dcw> ^copy-predicates-map <map> ^copy <c*1> ^source <s*1>)
    (<c*1> ^predicates <preds>)
    (<s*1> ^predicates <p*1>)
    (<p*1> ^predicate <src-pred>)
    -->
    (<preds> ^predicate <new-pred> +)
    (<map> ^entry <e> +)
    (<e> ^source <src-pred> + ^copy <new-pred> +)
}

sp {anystate*deep-copy-world*copy*object*predicates
    (state <s> ^deep-copy-world <d*1>)
    (<d*1> ^copy-objects-map <c*1>)
    (<c*1> ^entry <e>)
    (<e> ^copy <c*2> ^source <s*1>)
    (<c*2> ^predicates <preds>)
    (<s*1> ^predicates <src-preds>)
    (<src-preds> ^<pred-name> <pred-val>)
    -->
    (<preds> ^<pred-name> <pred-val> +)
}

sp {anystate*deep-copy-world*copy*object*handle
    (state <s> ^deep-copy-world <d*1>)
    (<d*1> ^copy-objects-map <c*1>)
    (<c*1> ^entry <e>)
    (<e> ^copy <obj> ^source <src-obj>)
    (<src-obj> ^handle <handle>)
    -->
    (<obj> ^handle <handle> +)
}

sp {anystate*deep-copy-world*copy*object
    (state <s> ^deep-copy-world <dcw>)
    (<dcw> ^copy <c*1> ^copy-objects-map <map> ^source <s*1>)
    (<c*1> ^objects <objs>)
    (<s*1> ^objects <o*1>)
    (<o*1> ^object <src-obj>)
    (<src-obj> ^item-type <type>)
    -->
    (<objs> ^object <new-obj> +)
    (<new-obj> ^item-type <type> + ^predicates <preds> +)
    (<map> ^entry <e> + ^<src-obj> <new-obj> +)
    (<e> ^source <src-obj> + ^copy <new-obj> +)
}

sp {anystate*deep-copy-world*copy*robot*arm
    (state <s> ^deep-copy-world <dcw>)
    (<dcw> ^copy <c*1> ^source <s*1>)
    (<c*1> ^robot <r*2>)
    (<r*2> ^arm <arm>)
    (<s*1> ^robot <r*1>)
    (<r*1> ^arm <a*1>)
    (<a*1> ^<att-name> <att-val>)
    -->
    (<arm> ^<att-name> <att-val> +)
}

sp {anystate*deep-copy-world*copy*robot*current-location
    (state <s> ^deep-copy-world <dcw>)
    (<dcw> ^copy <c*1> ^copy-objects-map <c*2> ^source <s*1>)
    (<c*2> ^entry <e>)
    (<e> ^copy <loc> ^source <src-loc>)
    (<s*1> ^robot <r*1>)
    (<r*1> ^current-location <src-loc>)
    (<c*1> ^robot <robot>)
    -->
    (<robot> ^current-location <loc> +)
}

sp {anystate*deep-copy-world*elaborate*copy
    (state <s> ^deep-copy-world <dcw>)
    (<dcw> ^source <src>)
    -->
    (<dcw> ^copy <new-world> + ^copy-objects-map <objs-map> +
           ^copy-predicates-map <preds-map> + ^copy-set-map <set-map> +)
    (<new-world> ^objects <objs> + ^predicates <preds> + ^robot <robot> +)
    (<robot> ^arm <arm> +)
}

sp {problem-space*world*copy-type*deep*elaborate*world*from*deep-copy-world
    (state <s> ^deep-copy-world <dcw> ^problem-space <p*1>)
    (<dcw> ^copy <world-copy> ^source <src-world>)
    (<p*1> ^world <w>)
    (<w> ^copy-type deep ^source <src-world>)
    -->
    (<s> ^world <world-copy> +)
}

sp {problem-space*world*copy-type*deep*elaborate*deep-copy-world
    (state <s> ^problem-space <p*1>)
    (<p*1> ^world <w>)
    (<w> ^copy-type deep ^source <world>)
    -->
    (<s> ^deep-copy-world <dcw> +)
    (<dcw> ^source <world> +)
}

sp {problem-space*world*copy-type*shallow*elaborate*world
    (state <s> ^problem-space <p*1>)
    (<p*1> ^world <w>)
    (<w> -^copy-type deep ^copy-type shallow ^source <world>)
    -->
    (<s> ^world <world> +)
}

sp {problem-space*world*source*elaborate*default
    (state <s> ^superstate <s*1> ^problem-space <ps>)
    (<s*1> ^world <world>)
    (<ps> ^world <w>)
    (<w> -^source { <> <world> <s*2> })
    -->
    (<w> ^source <world> +)
}

sp {action*composite-action*learning*retrospective*apply*change-subaction-arg
    (state <s> ^name evaluate-operator ^operator <o> ^problem-space <p*1>
          ^problem-space <p*2>)
    (<o> ^name change-subaction-arg ^new-obj <new> ^argument <arg>)
    (<p*1> ^name action)
    (<arg> ^id <old>)
    (<p*2> ^learning <l*1>)
    (<l*1> ^type retrospective)
    -->
    (<arg> ^id <old> - ^id <new> +)
}

sp {action*composite-action*learning*retrospective*propose*change-subaction-arg
    (state <s> ^name evaluate-operator ^problem-space <p*1> ^subactions <subs>
          ^world <w*1> ^problem-space <p*2>)
    (<p*1> ^name action)
    (<subs> ^answer <h> ^next <n*1>)
    (<w*1> ^objects <o*1>)
    (<p*2> ^learning <l*1>)
    (<l*1> ^type retrospective)
    (<n*1> ^<arg-name> <arg>)
    (<arg> ^arg-type object ^id <obj>)
    (<obj> ^handle <h>)
    (<o*1> ^object <ans>)
    (<ans> ^item-type object ^predicates <p*3>)
    (<p*3> ^modifier1 answer1)
    -->
    (<s> ^operator <o> + ^operator <o> > ^operator <o> =)
    (<o> ^name change-subaction-arg + ^argument <arg> + ^new-obj <ans> +)
}

sp {action*composite-action*learning*retrospective*elaborate*desired*satisfied*superstate
    (state <s> ^desired <d*1> ^superstate <s*1> ^problem-space <p*1>
          ^superstate <ss> ^problem-space <p*2>)
    (<d*1> ^satisfied true)
    (<s*1> ^name learn-proposal-rule)
    (<p*1> ^name action)
    (<p*2> ^learning <l*1>)
    (<l*1> ^type retrospective)
    -->
    (<ss> ^desired <d*2> +)
    (<d*2> ^satisfied true +)
}

sp {action*composite-action*learning*retrospective*elaborate*desired*if*none
    (state <s> ^superstate <s*1> ^problem-space <p*1> ^problem-space <p*2>)
   -{ (<s> ^desired <d*1>)
      (<d*1> ^predicate <p*3>)}
    (<s*1> ^name learn-proposal-rule)
    (<p*1> ^name action)
    (<p*2> ^learning <l*1>)
    (<l*1> ^type retrospective)
    -->
    (<s> ^desired <des> +)
}

sp {action*composite-action*learning*retrospective*elaborate*problem-space*subactions*copy-type
    (state <s> ^superstate <s*1> ^problem-space <ps>)
    (<s*1> ^name learn-proposal-rule)
    (<ps> ^name action ^learning <l*1>)
    (<l*1> ^type retrospective)
    -->
    (<ps> ^subactions <s*2> +)
    (<s*2> ^copy-type shallow +)
}

sp {problem-space*learning*elaborate*type*from*superstate
    (state <s> ^superstate <s*1> ^problem-space <p*1>)
    (<s*1> ^problem-space <p*2>)
    (<p*2> ^learning <l*1>)
    (<l*1> ^type <type>)
    (<p*1> ^learning <learn>)
    (<learn> -^type { <> <type> <t*1> })
    -->
    (<learn> ^type <type> +)
}

sp {chunk*in*selection*space
    (state <s> ^problem-space <p*1>)
    (<p*1> ^learning <l*1>)
    (<l*1> ^use chunking)
    -->
    (force-learn <s>)
}

sp {top-state*apply*any-op*remove*completed*svs*commands
    (state <s> ^top-state <s> ^svs <s*1> ^operator <o>)
    (<s*1> ^command <cmd>)
    (<cmd> ^{ <> extract <> extract_once <type> } <val>)
    (<val> ^status <status>)
    -->
    (<cmd> ^<type> <val> -)
}

sp {top-state*apply*any-op*remove*monitor*filters
    (state <s> ^top-state <s> ^svs <s*2> ^svs <s*1> ^operator <o>)
    (<s*2> ^spatial-scene <scene>)
    (<s*1> ^command <cmd>)
    (<cmd> ^extract <filter>)
    (<filter> ^a <a*1> ^type { << monitor_position monitor_volume >> <t*1> })
    (<a*1> ^id <id>)
   -{ (<scene> ^child <c*1>)
      (<c*1> ^id <id>)}
    -->
    (<cmd> ^extract <filter> -)
}

sp {apply*operator*remove*interrupted*command
    (state <s> ^io <i*1> ^operator <op>)
    (<i*1> ^output-link <ol>)
    (<ol> ^{ << do-control-law face-point >> <cmd-name> } <cmd>)
    (<cmd> ^status interrupted)
    -->
    (<ol> ^<cmd-name> <cmd> -)
}

sp {apply*operator*remove*successful*command
    (state <s> ^io <i*1> ^operator <op>)
    (<i*1> ^output-link <ol>)
    (<ol> ^{ << send-message >> <cmd-name> } <com>)
    (<com> ^status <status>)
    -->
    (<ol> ^<cmd-name> <com> -)
}

sp {attend-to-stale-object*apply*internally-link-objects*monitor*perception
    (state <s> ^name attend-to-stale-object ^agent-params <a*1> ^operator <o>)
    (<a*1> ^debug-perception true)
    (<o> ^name internally-link-objects ^dest-info <d*1> ^src-info <s*1>)
    (<d*1> ^object-handle <dest>)
    (<s*1> ^object-handle <src>)
    -->
    (write |Internally linking object | <dest> | to | <src> (crlf))
}

sp {attend-to-stale-object*apply*internally-link-objects
    (state <s> ^name attend-to-stale-object ^operator <o>)
    (<o> ^name internally-link-objects ^dest-info <dest-obj-info>
          ^src-info <s*1>)
    (<s*1> ^object-handle <src-handle>)
    -->
    (<dest-obj-info> ^internal-link <src-handle> +)
}

sp {attend-to-stale-object*prefer*internally-link-objects*higher*overlap
    (state <s> ^name attend-to-stale-object ^operator <o2> + ^operator <o1> +)
    (<o2> ^name internally-link-objects ^overlap <o*1>)
    (<o1> ^name internally-link-objects ^overlap { > <o*1> <overlap1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {attend-to-stale-object*elaborate*internally-link-objects*overlap
    (state <s> ^name attend-to-stale-object ^operator <o> +
          ^overlap-results <o*1>)
    (<o> ^name internally-link-objects ^src-info <s*1>)
    (<s*1> ^perception-obj <p*1>)
    (<p*1> ^id <src-perc-id>)
    (<o*1> ^result <res>)
    (<res> ^object-b <src-perc-id> ^overlap <overlap>)
    -->
    (<o> ^overlap <overlap> +)
}

sp {attend-to-stale-object*propose*internally-link-objects
    (state <s> ^name attend-to-stale-object ^contained-by <src-obj-info>
          ^object-info <dest-obj-info>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name internally-link-objects + ^src-info <src-obj-info> +
           ^dest-info <dest-obj-info> +)
}

sp {attend-to-stale-object*apply*check-for-occlusion*occluded*add*info
    (state <s> ^object-occluded true ^name attend-to-stale-object
          ^operator <o*1> ^object-info <obj-info>
          ^occlusion-check-period <period> ^io <i*1>)
    (<o*1> ^name check-for-occlusion)
    (<obj-info> ^status <status>)
    (<i*1> ^input-link <i*2>)
    (<i*2> ^time <t*1>)
    (<t*1> ^seconds <cur-t>)
    -->
    (<obj-info> ^check-occlusion-time (+ <cur-t> <period>) +)
    (<status> ^is-occluded true +)
}

sp {attend-to-stale-object*apply*check-for-occlusion*not-occluded*cant-find
    (state <s> ^missing true ^object-occluded false
          ^name attend-to-stale-object ^operator <o*1> ^object-info <obj-info>)
    (<o*1> ^name check-for-occlusion)
    -->
    (<obj-info> ^cant-find true +)
}

sp {attend-to-stale-object*apply*check-for-occlusion*not-occluded*mark-for-deletion
    (state <s> ^object-occluded false -^missing true
          ^name attend-to-stale-object ^operator <o*1> ^object-info <obj-info>)
    (<o*1> ^name check-for-occlusion)
    -->
    (<obj-info> ^mark-for-deletion true +)
}

sp {attend-to-stale-object*propose*check-for-occlusion
    (state <s> ^name attend-to-stale-object ^object-info <obj-info>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name check-for-occlusion + ^object-info <obj-info> +
           ^report-to-superstate true + ^report-to-top-state false +)
}

sp {attend-to-stale-object*reject*superoperator
    (state <s> ^name attend-to-stale-object ^operator <o> ^superstate <ss>)
    (<o> ^name link-objects ^modify-scene-command <m*1>)
    (<m*1> ^status complete)
    -->
    (<ss> ^redo-attend true +)
}

sp {attend-to-stale-object*apply*link-objects*monitor*perception
    (state <s> ^name attend-to-stale-object ^agent-params <a*1> ^operator <o>)
    (<a*1> ^debug-perception true)
    (<o> ^name link-objects ^modify-scene-command <cmd>)
    (<cmd> ^destination-handle <dest> ^source-handle <src>)
    -->
    (write |Linking object | <src> | to | <dest> (crlf))
}

sp {attend-to-stale-object*apply*link-objects
    (state <s> ^name attend-to-stale-object ^operator <o> ^io <i*1>)
    (<o> ^name link-objects ^modify-scene-command <cmd>)
    (<i*1> ^output-link <ol>)
    -->
    (<ol> ^modify-scene <cmd> +)
}

sp {attend-to-stale-object*elaborate*link-objects*src-handle
    (state <s> ^name attend-to-stale-object ^operator <o> +
          ^contained-fragment-id <src-handle>)
    (<o> ^name link-objects ^modify-scene-command <cmd>)
    -->
    (<cmd> ^source-handle <src-handle> +)
}

sp {attend-to-stale-object*propose*link-objects
    (state <s> ^found-contained-fragment true ^name attend-to-stale-object
          ^object-info <o*1>)
    (<o*1> ^object-handle <dest-handle>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name link-objects + ^modify-scene-command <cmd> +)
    (<cmd> ^type link + ^destination-handle <dest-handle> +)
}

sp {attend-to-stale-object*prefer*others*over*check-for-occlusion
    (state <s> ^name attend-to-stale-object ^operator <o2> + ^operator <o1> +)
    (<o2> ^name check-for-occlusion)
    (<o1>
          ^name { << overlap-command intersect-command internally-link-objects link-objects >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {attend-to-stale-object*prefer*external*to*internal*link
    (state <s> ^name attend-to-stale-object ^operator <o2> + ^operator <o1> +)
    (<o2> ^name internally-link-objects)
    (<o1> ^name link-objects)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {attend-to-stale-object*prefer*overlap-command*over*link-objects
    (state <s> ^name attend-to-stale-object ^operator <o1> + ^operator <o2> +)
    (<o1> ^name overlap-command)
    (<o2> ^name { << link-objects internally-link-objects >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {attend-to-stale-object*elaborate*found-contained-fragment
    (state <s> ^name attend-to-stale-object ^contained-fragment-id <id>)
    -->
    (<s> ^found-contained-fragment true +)
}

sp {attend-to-stale-object*elaborate*contained-by
    (state <s> ^name attend-to-stale-object ^overlap-results <o*2>
          ^object-info <o*1> ^contained-by-threshold <t> ^top-state <t*1>)
    (<o*1> ^belief-obj <b*1>)
    (<t*1> ^perception-monitor <p*1>)
    (<p*1> ^object-monitor <o*3>)
    (<o*3> ^object-info <cont-obj-info>)
    (<cont-obj-info> ^perception-obj <p*2>)
    (<p*2> ^id <cont-id>)
    (<o*2> ^result <res>)
    (<res> ^object-b <cont-id> ^object-a <stale-id> ^overlap { > <t> <o*4> })
    (<b*1> ^id <stale-id>)
    -->
    (<s> ^contained-by <cont-obj-info> +)
}

sp {attend-to-stale-object*elaborate*contained-fragment
    (state <s> ^name attend-to-stale-object ^overlap-results <o*2>
          ^object-info <o*1> ^contained-threshold <t>)
    (<o*1> ^belief-obj <b*1>)
    (<b*1> ^id <stale-id>)
    (<o*2> ^result <res>)
    (<res> ^object-b <stale-id> ^overlap { > <t> <o*3> } ^object-a <cont-id>)
    -->
    (<s> ^contained-fragment-id <cont-id> +)
}

sp {attend-to-stale-object*elaborate*overlap-results
    (state <s> ^name attend-to-stale-object)
    -->
    (<s> ^overlap-results <res> +)
}

sp {attend-to-stale-object*elaborate*intersected-perc-id*from*intersect-command
    (state <s> ^name attend-to-stale-object ^intersect-command <i*1>)
    (<i*1> ^result { <> none <obj-id> })
    -->
    (<s> ^intersected-perc-id <obj-id> +)
}

sp {attend-to-stale-object*elaborate*agent-params*contained-by-threshold
    (state <s> ^name attend-to-stale-object ^agent-params <a*1>)
    (<a*1> ^contained-by-threshold <t>)
    -->
    (<s> ^contained-by-threshold <t> +)
}

sp {attend-to-stale-object*elaborate*agent-params*contained-threshold
    (state <s> ^name attend-to-stale-object ^agent-params <a*1>)
    (<a*1> ^contained-threshold <t>)
    -->
    (<s> ^contained-threshold <t> +)
}

sp {attend-to-stale-object*elaborate*agent-params*occlusion-check-period
    (state <s> ^name attend-to-stale-object ^agent-params <a*1>)
    (<a*1> ^occlusion-check-period <p>)
    -->
    (<s> ^occlusion-check-period <p> +)
}

sp {attend-to-stale-object*elaborate*missing*true
    (state <s> ^name attend-to-stale-object ^object-info <o*1>)
    (<o*1> ^missing true)
    -->
    (<s> ^missing true +)
}

sp {attend-to-stale-object*elaborate*object-info
    (state <s> ^name attend-to-stale-object ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^object-info <obj-info>)
    -->
    (<s> ^object-info <obj-info> +)
}

sp {attend-to-stale-object*apply*overlap-command*debug-perception*report*overlap
    (state <s> ^name attend-to-stale-object ^agent-params <a*1>
          ^operator <o*1> ^overlap-command <o*2>)
    (<a*1> ^debug-perception true)
    (<o*1> ^name overlap-command)
    (<o*2> ^result <res>)
    (<res> ^overlap <val> ^object-b <b> ^object-a <a>)
    -->
    (write |Overlap: | <val> | of | <a> | is contained by | <b> (crlf))
}

sp {attend-to-stale-object*apply*overlap-command*copy-result
    (state <s> ^name attend-to-stale-object ^operator <o*1>
          ^overlap-results <results> ^overlap-command <cmd>)
    (<o*1> ^name overlap-command)
    (<cmd> ^result <res>)
    (<res> ^overlap { <> none <o*2> })
    -->
    (<s> ^overlap-command <cmd> -)
    (<results> ^result <res> +)
}

sp {attend-to-stale-object*propose*overlapt-command*contained-by
    (state <s> ^name attend-to-stale-object ^intersected-perc-id <perc-id>
          ^object-info <o*1> ^top-state <t*1>)
   -{ (<s> ^overlap-results <o*4>)
      (<o*4> ^result <r*1>)
      (<r*1> ^object-b <perc-id>)}
    (<o*1> ^belief-obj <b*1>)
    (<t*1> ^perception-monitor <p*1>)
    (<p*1> ^object-monitor <o*2>)
    (<o*2> ^object-info <o*3>)
    (<o*3> ^perception-obj <p*2>)
    (<p*2> ^id <perc-id>)
    (<b*1> ^id <stale-id>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name overlap-command + ^object-a <stale-id> + ^object-b <perc-id> +)
}

sp {attend-to-stale-object*propose*overlap-command*contains*new*fragment
    (state <s> ^name attend-to-stale-object ^intersected-perc-id <perc-id>
          ^object-info <o*1>)
   -{ (<s> ^overlap-results <o*4>)
      (<o*4> ^result <r*1>)
      (<r*1> ^object-a <perc-id>)}
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^perception-monitor <p*1>)
      (<p*1> ^object-monitor <o*2>)
      (<o*2> ^object-info <o*3>)
      (<o*3> ^perception-obj <p*2>)
      (<p*2> ^id <perc-id>)}
    (<o*1> ^belief-obj <b*1>)
    (<b*1> ^id <stale-id>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name overlap-command + ^object-a <perc-id> + ^object-b <stale-id> +)
}

sp {attend-to-stale-object*propose*intersect-command
    (state <s> ^name attend-to-stale-object ^object-info <o*1>)
   -{ (<s> ^intersect-command <i*1>)
      (<i*1> ^result <r*1>)}
    (<o*1> ^belief-obj <b*1>)
    (<b*1> ^id <id>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name intersect-command + ^object-id <id> +
           ^candidate-set <perc-objs> +)
    (<perc-objs> ^type tag_select + ^a <a*1> + ^tag_name object-source +
           ^tag_value perception +)
    (<a*1> ^type all_nodes +)
}

sp {evaluate-shrunken-object*prefer*others*over*check-for-occlusion
    (state <s> ^name evaluate-shrunken-object ^operator <o2> +
          ^operator <o1> +)
    (<o2> ^name check-for-occlusion)
    (<o1> ^name { << overlap-command intersect-command link-objects >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {evaluate-shrunken-object*prefer*overlap-command*over*link-objects
    (state <s> ^name evaluate-shrunken-object ^operator <o2> +
          ^operator <o1> +)
    (<o2> ^name link-objects)
    (<o1> ^name overlap-command)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {evaluate-shrunken-object*reject*superoperator
    (state <s> ^name evaluate-shrunken-object ^operator <o> ^superstate <ss>)
    (<o> ^name link-objects ^modify-scene-command <m*1>)
    (<m*1> ^status complete)
    -->
    (<ss> ^redo-attend true +)
}

sp {evaluate-shrunken-object*apply*link-objects*monitor*perception
    (state <s> ^name evaluate-shrunken-object ^agent-params <a*1>
          ^operator <o>)
    (<a*1> ^debug-perception true)
    (<o> ^name link-objects ^modify-scene-command <cmd>)
    (<cmd> ^destination-handle <dest> ^source-handle <source>)
    -->
    (write |Linking object | <source> | to | <dest> (crlf))
}

sp {evaluate-shrunken-object*apply*link-objects
    (state <s> ^name evaluate-shrunken-object ^operator <o> ^io <i*1>)
    (<o> ^name link-objects ^modify-scene-command <cmd>)
    (<i*1> ^output-link <ol>)
    -->
    (<ol> ^modify-scene <cmd> +)
}

sp {evaluate-shrunken-object*elaborate*link-objects*source-handle
    (state <s> ^name evaluate-shrunken-object ^operator <o> +
          ^contained-fragment-id <src-handle>)
    (<o> ^name link-objects ^modify-scene-command <cmd>)
    -->
    (<cmd> ^source-handle <src-handle> +)
}

sp {evaluate-shrunken-object*propose*link-objects
    (state <s> ^found-contained-fragment true ^name evaluate-shrunken-object
          ^object-info <o*1>)
    (<o*1> ^object-handle <dest-handle>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name link-objects + ^modify-scene-command <cmd> +)
    (<cmd> ^type link + ^destination-handle <dest-handle> +)
}

sp {evaluate-shrunken-object*apply*overlap-command*debug-perception*report*overlap
    (state <s> ^name evaluate-shrunken-object ^agent-params <a*1>
          ^operator <o*1> ^overlap-command <o*2>)
    (<a*1> ^debug-perception true)
    (<o*1> ^name overlap-command)
    (<o*2> ^result <res>)
    (<res> ^overlap <val> ^object-b <b> ^object-a <a>)
    -->
    (write |Overlap: | <val> | of | <a> | is contained by | <b> (crlf))
}

sp {evaluate-shrunken-object*apply*overlap-command*copy-result
    (state <s> ^name evaluate-shrunken-object ^operator <o*1>
          ^overlap-results <results> ^overlap-command <cmd>
          ^agent-params <a*1>)
    (<o*1> ^name overlap-command)
    (<a*1> ^debug-perception <flag>)
    (<cmd> ^result <res>)
    (<res> ^overlap { <> none <o*2> })
    -->
    (<s> ^overlap-command <cmd> -)
    (<results> ^result <res> +)
}

sp {evaluate-shrunken-object*propose*overlap-command*contains
    (state <s> ^name evaluate-shrunken-object ^intersect-command <i*1>
          ^object-info <o*1>)
    (<i*1> ^result { <> none <perc-id> })
   -{ (<s> ^overlap-results <o*4>)
      (<o*4> ^result <r*1>)
      (<r*1> ^object-a <perc-id>)}
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^perception-monitor <p*1>)
      (<p*1> ^object-monitor <o*2>)
      (<o*2> ^object-info <o*3>)
      (<o*3> ^perception-obj <p*2>)
      (<p*2> ^id <perc-id>)}
    (<o*1> ^belief-obj <b*1>)
    (<b*1> ^id <stale-id>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name overlap-command + ^object-a <perc-id> + ^object-b <stale-id> +)
}

sp {evaluate-shrunken-object*propose*intersect-command
    (state <s> ^name evaluate-shrunken-object ^object-info <o*1>)
   -{ (<s> ^intersect-command <i*1>)
      (<i*1> ^result <r*1>)}
    (<o*1> ^belief-obj <b*1>)
    (<b*1> ^id <id>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name intersect-command + ^object-id <id> +
           ^candidate-set <perc-objs> +)
    (<perc-objs> ^type tag_select + ^a <a*1> + ^tag_name object-source +
           ^tag_value perception +)
    (<a*1> ^type all_nodes +)
}

sp {evaluate-shrunken-object*apply*check-for-occlusion*occluded*update-pose
    (state <s> ^object-occluded false ^name evaluate-shrunken-object
          ^operator <o*1> ^object-info <obj-info>)
    (<o*1> ^name check-for-occlusion)
    -->
    (<obj-info> ^update-pose true +)
}

sp {evaluate-shrunken-object*propose*check-for-occlusion
    (state <s> ^name evaluate-shrunken-object ^object-info <obj-info>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name check-for-occlusion + ^object-info <obj-info> +
           ^report-to-superstate true + ^report-to-top-state true +)
}

sp {evaluate-shrunken-object*elaborate*found-contained-fragment
    (state <s> ^name evaluate-shrunken-object ^contained-fragment-id <id>)
    -->
    (<s> ^found-contained-fragment true +)
}

sp {evaluate-shrunken-object*elaborate*contained-fragment
    (state <s> ^name evaluate-shrunken-object ^overlap-results <o*1>
          ^contained-threshold <t>)
    (<o*1> ^result <res>)
    (<res> ^overlap { > <t> <o*2> } ^object-a <id>)
    -->
    (<s> ^contained-fragment-id <id> +)
}

sp {evaluate-shrunken-object*elaborate*overlap-results
    (state <s> ^name evaluate-shrunken-object)
    -->
    (<s> ^overlap-results <res> +)
}

sp {evaluate-shrunken-object*elaborate*agent-params*contained-threshold
    (state <s> ^name evaluate-shrunken-object ^agent-params <a*1>)
    (<a*1> ^contained-threshold <t>)
    -->
    (<s> ^contained-threshold <t> +)
}

sp {evaluate-shrunken-object*elaborate*object-info
    (state <s> ^name evaluate-shrunken-object ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^object-info <obj-info>)
    -->
    (<s> ^object-info <obj-info> +)
}

sp {evaluate-grown-object*prefer*others*over*copy-object
    (state <s> ^name evaluate-grown-object ^operator <o2> + ^operator <o1> +)
    (<o2> ^name copy-object)
    (<o1> ^name { <> copy-object <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {evaluate-grown-object*prefer*overlap*intersect*over*link
    (state <s> ^name evaluate-grown-object ^operator <o2> + ^operator <o1> +)
    (<o2> ^name internally-link-objects)
    (<o1> ^name { << overlap-command intersect-command >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {evaluate-grown-object*prefer*intersect*over*overlap
    (state <s> ^name evaluate-grown-object ^operator <o2> + ^operator <o1> +)
    (<o2> ^name overlap-command)
    (<o1> ^name intersect-command)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {evaluate-grown-object*apply*copy-object*remove*old*recheck-growth
    (state <s> ^name evaluate-grown-object ^operator <o> ^io <i*1>)
    (<o> ^name copy-object ^object-info <o*1>)
    (<o*1> ^differences <diffs>)
    (<diffs> ^recheck-growth-at <r>)
    (<i*1> ^input-link <i*2>)
    (<i*2> ^time <t*1>)
    (<t*1> ^seconds { > <r> <t> })
    -->
    (<diffs> ^recheck-growth-at <r> -)
}

sp {evaluate-grown-object*apply*copy-object*mark-recheck-growth
    (state <s> ^name evaluate-grown-object ^operator <o> ^agent-params <a*1>
          ^io <i*1>)
    (<o> ^name copy-object ^object-info <o*1>)
    (<o*1> ^differences <diffs>)
    (<a*1> ^recheck-growth-delay <d>)
    (<i*1> ^input-link <i*2>)
    (<i*2> ^time <t*1>)
    (<t*1> ^seconds <t>)
    -->
    (<diffs> ^recheck-growth-at (+ <t> <d>) +)
}

sp {evaluate-grown-object*apply*copy-object
    (state <s> ^name evaluate-grown-object ^operator <o>)
    (<o> ^name copy-object ^object-info <obj-info>)
    -->
    (<obj-info> ^update-pose true +)
}

sp {evaluate-grown-object*propose*copy-object
    (state <s> ^name evaluate-grown-object ^object-info <obj-info>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name copy-object + ^object-info <obj-info> +)
}

sp {evaluate-grown-object*apply*internally-link-objects*monitor*perception
    (state <s> ^name evaluate-grown-object ^agent-params <a*1> ^operator <o>)
    (<a*1> ^debug-perception true)
    (<o> ^name internally-link-objects ^dest-info <d*1> ^src-info <s*1>)
    (<s*1> ^object-handle <src-handle>)
    (<d*1> ^object-handle <dest-handle>)
    -->
    (write |Internally linking object | <dest-handle> | to | <src-handle> (crlf))
}

sp {evaluate-grown-object*apply*internally-link-objects*link
    (state <s> ^name evaluate-grown-object ^operator <o>)
    (<o> ^name internally-link-objects ^dest-info <dest-info> ^src-info <s*1>)
    (<s*1> ^object-handle <src-handle>)
    -->
    (<dest-info> ^internal-link <src-handle> +)
}

sp {evaluate-grown-object*elaborate*internally-link-objects*dest-id
    (state <s> ^name evaluate-grown-object ^operator <o> +
          ^contained-object-info <dest-info>)
    (<o> ^name internally-link-objects)
    -->
    (<o> ^dest-info <dest-info> +)
}

sp {evaluate-grown-object*propose*internally-link-object
    (state <s> ^found-contained-object true ^name evaluate-grown-object
          ^object-info <obj-info>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name internally-link-objects + ^src-info <obj-info> +)
}

sp {evaluate-grown-object*apply*overlap-command*debug-perception*report*overlap
    (state <s> ^name evaluate-grown-object ^agent-params <a*1> ^operator <o*1>
          ^overlap-command <o*2>)
    (<a*1> ^debug-perception true)
    (<o*1> ^name overlap-command)
    (<o*2> ^result <res>)
    (<res> ^overlap <val> ^object-b <b> ^object-a <a>)
    -->
    (write |Overlap: | <val> | of | <a> | is contained by | <b> (crlf))
}

sp {evaluate-grown-object*apply*overlap-command*copy-result
    (state <s> ^name evaluate-grown-object ^operator <o*1>
          ^overlap-results <results> ^overlap-command <cmd>)
    (<o*1> ^name overlap-command)
    (<cmd> ^result <res>)
    (<res> ^overlap { <> none <o*2> })
    -->
    (<s> ^overlap-command <cmd> -)
    (<results> ^result <res> +)
}

sp {evaluate-grown-object*propose*overlap-command*contains
    (state <s> ^name evaluate-grown-object ^intersect-command <i*1>
          ^object-info <o*1> ^top-state <t*1>)
    (<i*1> ^result { <> none <belief-id> })
   -{ (<s> ^overlap-results <o*3>)
      (<o*3> ^result <r*1>)
      (<r*1> ^object-a <belief-id>)}
    (<o*1> ^perception-obj <p*1>)
    (<t*1> ^perception-monitor <p*2>)
    (<p*2> ^object-monitor <o*2>)
    (<o*2> ^object-info <obj-info>)
    (<obj-info> -^perception-obj <p*3> ^belief-obj <b*1>)
    (<b*1> ^id <belief-id>)
    (<p*1> ^id <perc-id>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name overlap-command + ^object-a <belief-id> + ^object-b <perc-id> +)
}

sp {evaluate-grown-object*propose*intersect-command
    (state <s> ^name evaluate-grown-object ^object-info <o*1>)
   -{ (<s> ^intersect-command <i*1>)
      (<i*1> ^result <r*1>)}
    (<o*1> ^perception-obj <p*1>)
    (<p*1> ^id <id>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name intersect-command + ^object-id <id> +
           ^candidate-set <perc-objs> +)
    (<perc-objs> ^type tag_select + ^a <a*1> + ^tag_name object-source +
           ^tag_value belief +)
    (<a*1> ^type all_nodes +)
}

sp {evaluate-grown-object*elaborate*found-contained-object
    (state <s> ^name evaluate-grown-object ^contained-object-info <obj>)
    -->
    (<s> ^found-contained-object true +)
}

sp {evaluate-grown-object*elaborate*contained-object
    (state <s> ^name evaluate-grown-object ^overlap-results <o*2>
          ^object-info <o*1> ^contained-threshold <t> ^top-state <t*1>)
    (<o*1> ^perception-obj <p*1>)
    (<t*1> ^perception-monitor <p*2>)
    (<p*2> ^object-monitor <o*3>)
    (<o*3> ^object-info <obj-info>)
    (<obj-info> ^belief-obj <b*1>)
    (<b*1> ^id <a>)
    (<o*2> ^result <res>)
    (<res> ^object-a <a> ^object-b <grown-id> ^overlap { > <t> <o*4> })
    (<p*1> ^id <grown-id>)
    -->
    (<s> ^contained-object-info <obj-info> +)
}

sp {evaluate-grown-object*elaborate*overlap-results
    (state <s> ^name evaluate-grown-object)
    -->
    (<s> ^overlap-results <res> +)
}

sp {evaluate-grown-object*elaborate*agent-params*contained-threshold
    (state <s> ^name evaluate-grown-object ^agent-params <a*1>)
    (<a*1> ^contained-threshold <t>)
    -->
    (<s> ^contained-threshold <t> +)
}

sp {evaluate-grown-object*elaborate*object-info
    (state <s> ^name evaluate-grown-object ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^object-info <obj-info>)
    -->
    (<s> ^object-info <obj-info> +)
}

sp {attend-to-changed-waypoint*apply*same-location
    (state <s> ^name attend-to-changed-waypoint ^operator <o*1>
          ^new-waypoint <new-wp> ^top-state <t*1>)
    (<o*1> ^name same-location)
    (<t*1> ^world <w*1>)
    (<w*1> ^robot <rob>)
    (<rob> ^current-waypoint { <> <new-wp> <old-wp> })
    -->
    (<rob> ^current-waypoint <old-wp> - ^current-waypoint <new-wp> +)
}

sp {attend-to-changed-waypoint*propose*same-location
    (state <s> ^name attend-to-changed-waypoint
          ^new-waypoint-handle <wp-handle> ^top-state <t*1>)
    (<t*1> ^world <w*1>)
    (<w*1> ^robot <r*1>)
    (<r*1> ^current-location <loc>)
    (<loc> ^waypoint <wp-handle>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name same-location +)
}

sp {attend-to-changed-waypoint*prefer*leave*over*enter
    (state <s> ^name attend-to-changed-waypoint ^operator <o2> +
          ^operator <o1> +)
    (<o2> ^name enter-new-waypoint)
    (<o1> ^name leave-old-waypoint)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {attend-to-changed-waypoint*prefer*same-location*over*others
    (state <s> ^name attend-to-changed-waypoint ^operator <o1> +
          ^operator <o2> +)
    (<o1> ^name same-location)
    (<o2> ^name { << leave-old-waypoint enter-new-waypoint >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {attend-to-changed-waypoint*elaborate*new-waypoint*topstate
    (state <s> ^name attend-to-changed-waypoint
          ^new-waypoint-handle <wp-handle> ^top-state <t*1>)
    (<t*1> ^maps <m*1>)
    (<m*1> ^map <m*2>)
    (<m*2> ^waypoint <wp>)
    (<wp> ^handle <wp-handle>)
    -->
    (<s> ^new-waypoint <wp> +)
}

sp {attend-to-changed-waypoint*elaborate*new-waypoint-handle
    (state <s> ^name attend-to-changed-waypoint ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^new-waypoint-handle <wp-handle>)
    -->
    (<s> ^new-waypoint-handle <wp-handle> +)
}

sp {attend-to-changed-waypoint*propose*enter-new-waypoint
    (state <s> ^name attend-to-changed-waypoint ^new-waypoint <wp>
          ^top-state <t*1>)
    (<t*1> ^world <w*1>)
    (<w*1> ^robot <rob>)
    (<rob> -^current-waypoint <wp>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name enter-new-waypoint + ^new-waypoint <wp> +)
}

sp {attend-to-changed-waypoint*propose*leave-old-waypoint
    (state <s> ^name attend-to-changed-waypoint ^new-waypoint <wp>
          ^top-state <t*1>)
    (<t*1> ^world <w*1>)
    (<w*1> ^robot <r*1>)
    (<r*1> ^current-waypoint { <> <wp> <old-wp> })
    -->
    (<s> ^operator <o> +)
    (<o> ^name leave-old-waypoint + ^old-waypoint <old-wp> +)
}

sp {enter-new-waypoint*apply*add-location-to-world*create*change*add-smem-object
    (state <s> ^name enter-new-waypoint ^operator <o> ^top-state <t*1>)
    (<o> ^name add-location-to-world ^location <loc>)
    (<t*1> ^perception-monitor <p*1>)
    (<p*1> ^changes <ch>)
    -->
    (<ch> ^change <c> +)
    (<c> ^type new-object + ^smem-obj <loc> +)
}

sp {enter-new-waypoint*propose*add-location-to-world
    (state <s> ^name enter-new-waypoint ^retrieved-location { <> none <loc> })
    (<loc> ^handle <loc-handle>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^world <w*1>)
      (<w*1> ^objects <o*1>)
      (<o*1> ^object <o*2>)
      (<o*2> ^handle <loc-handle>)}
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name add-location-to-world + ^location <loc> +)
}

sp {enter-new-waypoint*retrieve-location*failure*copy*location
    :o-support
    (state <s> ^name enter-new-waypoint ^smem-query <q> ^new-waypoint <n*1>)
    (<q> ^result failure ^cue <c*1>)
    (<n*1> ^handle <wp-handle>)
    (<c*1> ^waypoint <wp-handle>)
    -->
    (<s> ^new-location none + ^retrieved-location none +)
}

sp {enter-new-waypoint*retrieve-location*success*copy*location
    :o-support
    (state <s> ^name enter-new-waypoint ^new-waypoint <n*1> ^smem-query <q>)
    (<n*1> ^handle <wp-handle>)
    (<q> ^cue <c*1> ^result { <> failure <loc> })
    (<c*1> ^waypoint <wp-handle>)
    -->
    (<s> ^new-location <loc> + ^retrieved-location <loc> +)
}

sp {enter-new-waypoint*retrieve-location*elaborate*smem-query
    (state <s> ^new-location none -^retrieved-location <r*1>
          ^name enter-new-waypoint ^new-waypoint <n*1>)
    (<n*1> ^handle <wp-handle>)
    -->
    (<s> ^smem-query <query> +)
    (<query> ^cue <cue> + ^depth 2 +)
    (<cue> ^object-instance true + ^waypoint <wp-handle> +)
}

sp {enter-new-waypoint*prefer*retrieve-previous-episode*over*add*new-information
    (state <s> ^name enter-new-waypoint ^operator <o2> + ^operator <o1> +)
    (<o2> ^name add-new-information)
    (<o1> ^name retrieve-previous-episode)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {enter-new-waypoint*apply*retrieve-previous-episode*failure*copy*result*bad*match
    (state <s> ^name enter-new-waypoint ^operator <o*1> ^epmem <e*1>)
    (<o*1> ^name retrieve-previous-episode)
    (<e*1> ^result <res>)
    (<res> ^success <q> ^normalized-match-score { < 1.000000 <n*1> })
    -->
    (<s> ^retrieved-episode none +)
}

sp {enter-new-waypoint*apply*retrieve-previous-episode*failure*copy*result
    (state <s> ^name enter-new-waypoint ^operator <o*1> ^epmem <e*1>)
    (<o*1> ^name retrieve-previous-episode)
    (<e*1> ^result <r*1>)
    (<r*1> ^failure <q>)
    -->
    (<s> ^retrieved-episode none +)
}

sp {enter-new-waypoint*apply*retrieve-previous-episode*success*copy*result
    (state <s> ^name enter-new-waypoint ^operator <o*1> ^epmem <e*1>)
    (<o*1> ^name retrieve-previous-episode)
    (<e*1> ^result <res>)
    (<res> ^normalized-match-score 1.000000 ^success <q> ^retrieved <episode>)
    -->
    (<s> ^retrieved-episode <episode> +)
}

sp {enter-new-waypoint*apply*retrieve-previous-episode*query
    (state <s> ^name enter-new-waypoint ^operator <o> ^epmem <e*1>)
    (<o> ^name retrieve-previous-episode ^location <l*1>)
    (<l*1> ^handle <loc-handle>)
    (<e*1> ^command <cmd>)
    -->
    (<cmd> ^query <q> +)
    (<q> ^world <w*1> +)
    (<w*1> ^robot <r*1> +)
    (<r*1> ^current-location <c*1> +)
    (<c*1> ^handle <loc-handle> +)
}

sp {enter-new-waypoint*propose*retrieve-previous-episode
    (state <s> ^name enter-new-waypoint -^retrieved-episode <r*1>
          ^new-location <loc>)
    (<loc> ^handle <h>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name retrieve-previous-episode + ^location <loc> +)
}

sp {enter-new-waypoint*apply*add-new-information*set*location*visible
    (state <s> ^name enter-new-waypoint ^operator <o*1> ^new-location <n*1>)
    (<o*1> ^name add-new-information)
    (<n*1> ^predicates <preds>)
    -->
    (<preds> ^visible true + ^visible false - ^object-status confirmed +
           ^object-status unconfirmed -)
}

sp {enter-new-waypoint*add*in*predicates*for*visible*objects
    (state <s> ^name enter-new-waypoint ^operator <o*1>
          ^new-location { <> none <loc> } ^top-state <t*2> ^top-state <t*1>)
    (<o*1> ^name add-new-information)
    (<t*2> ^world <w*2>)
    (<w*2> ^objects <o*2>)
    (<t*1> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <in-pred>)
    (<in-pred> ^handle in1)
    (<o*2> ^object <obj>)
   -{ (<in-pred> ^instance <cur-i>)
      (<cur-i> ^2 <loc> ^1 <obj>)}
   -{ (<obj> ^predicates <p*3>)
      (<p*3> ^arm-status grabbed)}
    (<obj> ^predicates <p*2>)
    (<p*2> ^visible true)
    -->
    (<in-pred> ^instance <i> +)
    (<i> ^1 <obj> + ^2 <loc> +)
}

sp {enter-new-waypoint*apply*add-new-information*add*epmem-obj
    (state <s> ^name enter-new-waypoint ^operator <o*1>
          ^retrieved-episode <r*2> ^retrieved-episode <r*1>
          ^new-location <n*1> ^top-state <t*2>)
    (<o*1> ^name add-new-information)
    (<n*1> ^handle <loc-handle>)
    (<t*2> ^perception-monitor <p*2>)
    (<p*2> ^changes <chgs>)
    (<r*2> ^world <w*2>)
    (<w*2> ^predicates <p*1>)
    (<p*1> ^predicate <in-pred>)
    (<in-pred> ^handle in1 ^instance <i>)
    (<i> ^2 <v*1> ^1 <obj>)
    (<v*1> ^handle <loc-handle>)
    (<r*1> ^world <w*1>)
    (<w*1> ^objects <o*2>)
    (<obj> ^predicates <p*3> ^handle <obj-handle>)
    (<p*3> ^object-status confirmed)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^world <w*3>)
      (<w*3> ^objects <o*3>)
      (<o*3> ^object <o*4>)
      (<o*4> ^handle <obj-handle>)}
    (<o*2> ^object <obj>)
    -->
    (<chgs> ^change <c> +)
    (<c> ^type new-object + ^epmem-obj <obj> +)
}

sp {enter-new-waypoint*apply*add-new-information*current-location
    (state <s> ^name enter-new-waypoint ^operator <o*1>
          ^new-location { <> none <loc> } ^top-state <t*1>)
    (<o*1> ^name add-new-information)
    (<t*1> ^world <w*1>)
    (<w*1> ^robot <rob>)
    -->
    (<rob> ^current-location <loc> +)
}

sp {enter-new-waypoint*apply*add-new-information*current-waypoint
    (state <s> ^name enter-new-waypoint ^operator <o*1> ^new-waypoint <wp>
          ^top-state <t*1>)
    (<o*1> ^name add-new-information)
    (<t*1> ^world <w*1>)
    (<w*1> ^robot <rob>)
    -->
    (<rob> ^current-waypoint <wp> +)
}

sp {enter-new-waypoint*propose*add-new-information
    (state <s> ^name enter-new-waypoint)
    -->
    (<s> ^operator <o> +)
    (<o> ^name add-new-information +)
}

sp {enter-new-waypoint*elaborate*new-location*none
    (state <s> ^name enter-new-waypoint ^new-waypoint <n*1>)
    (<n*1> ^handle <wp-handle>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^world <w*1>)
      (<w*1> ^objects <o*1>)
      (<o*1> ^object <o*2>)
      (<o*2> ^waypoint <wp-handle>)}
    -->
    (<s> ^new-location none +)
}

sp {enter-new-waypoint*elaborate*new-location
    (state <s> ^name enter-new-waypoint ^new-waypoint <n*1> ^top-state <t*1>)
    (<n*1> ^handle <wp-handle>)
    (<t*1> ^world <w*1>)
    (<w*1> ^objects <o*1>)
    (<o*1> ^object <loc>)
    (<loc> ^waypoint <wp-handle>)
    -->
    (<s> ^new-location <loc> +)
}

sp {enter-new-waypoint*elaborate*new-waypoint*superstate
    (state <s> ^name enter-new-waypoint ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^new-waypoint <wp>)
    -->
    (<s> ^new-waypoint <wp> +)
}

sp {leave-old-waypoint*apply*extract-metric-info*copy*scale
    (state <s> ^name leave-old-waypoint ^operator <o*1> ^scale-filter <s*1>
          ^confirmed-object <obj>)
    (<o*1> ^name extract-metric-info)
    (<obj> ^svs-obj <s*2>)
    (<s*2> ^id <id>)
    (<s*1> ^result <r*1>)
    (<r*1> ^record <r>)
    (<r> ^params <p*1> ^value <scale>)
    (<p*1> ^a <id>)
    (<scale> ^z <z> ^y <y> ^x <x>)
    -->
    (<obj> ^scale <nscale> +)
    (<nscale> ^x <x> + ^y <y> + ^z <z> +)
}

sp {leave-old-waypoint*apply*extract-metric-info*copy*rotation
    (state <s> ^name leave-old-waypoint ^operator <o*1> ^rotation-filter <r*1>
          ^confirmed-object <obj>)
    (<o*1> ^name extract-metric-info)
    (<obj> ^svs-obj <s*1>)
    (<s*1> ^id <id>)
    (<r*1> ^result <r*2>)
    (<r*2> ^record <r>)
    (<r> ^params <p*1> ^value <rot>)
    (<p*1> ^a <id>)
    (<rot> ^z <z> ^y <y> ^x <x>)
    -->
    (<obj> ^rotation <nrot> +)
    (<nrot> ^x <x> + ^y <y> + ^z <z> +)
}

sp {leave-old-waypoint*apply*extract-metric-info*copy*position
    (state <s> ^name leave-old-waypoint ^operator <o*1> ^position-filter <p*1>
          ^confirmed-object <obj>)
    (<o*1> ^name extract-metric-info)
    (<obj> ^svs-obj <s*1>)
    (<s*1> ^id <id>)
    (<p*1> ^result <r*1>)
    (<r*1> ^record <r>)
    (<r> ^params <p*2> ^value <pos>)
    (<p*2> ^a <id>)
    (<pos> ^z <z> ^y <y> ^x <x>)
    -->
    (<obj> ^position <npos> +)
    (<npos> ^x <x> + ^y <y> + ^z <z> +)
}

sp {leave-old-waypoint*apply*extract-metric-info
    (state <s> ^name leave-old-waypoint ^operator <o*1>
          ^{ << position-filter rotation-filter scale-filter >> <type> } <filter>)
    (<o*1> ^name extract-metric-info)
    (<filter> ^status <any>)
    -->
    (<s> ^extracted-metric-info true +)
}

sp {leave-old-waypoint*apply*extract-metric-info*create*filters
    (state <s> ^name leave-old-waypoint ^operator <o*1>
          ^confirmed-object <c*1> ^top-state <t*1>)
    (<o*1> ^name extract-metric-info)
    (<c*1> ^svs-obj <s*1>)
    (<s*1> ^id <id>)
    (<t*1> ^svs <s*2>)
    (<s*2> ^command <cmd>)
    -->
    (<cmd> ^extract_once <pos> + ^extract_once <rot> + ^extract_once <scale> +)
    (<pos> ^type node_position + ^a <node> +)
    (<rot> ^type node_rotation + ^a <node> +)
    (<scale> ^type node_scale + ^a <node> +)
    (<node> ^type node + ^id <id> +)
    (<s> ^position-filter <pos> + ^rotation-filter <rot> +
           ^scale-filter <scale> +)
}

sp {leave-old-waypoint*propose*extract-metric-info
    (state <s> ^confirmed-objects true -^extracted-metric-info true
          ^name leave-old-waypoint)
    -->
    (<s> ^operator <o> +)
    (<o> ^name extract-metric-info +)
}

sp {leave-old-waypoint*prefer*extract-metric-info*over*remove-old-information
    (state <s> ^name leave-old-waypoint ^operator <o2> + ^operator <o1> +)
    (<o2> ^name remove-old-information)
    (<o1> ^name extract-metric-info)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {leave-old-waypoint*prefer*remove-unconfirmed-objects*over*others
    (state <s> ^name leave-old-waypoint ^operator <o1> + ^operator <o2> +)
    (<o1> ^name remove-unconfirmed-objects)
    (<o2> ^name { << extract-metric-info remove-old-information >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {leave-old-waypoint*apply*remove-unconfirmed-objects*attend*delete-object
    (state <s> ^name leave-old-waypoint ^operator <o> ^top-state <t*2>
          ^top-state <t*1>)
    (<o> ^name remove-unconfirmed-objects ^remove-object <obj>)
    (<t*2> ^perception-monitor <p*2>)
    (<p*2> ^object-monitor <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> ^wm-obj <obj>)
    (<t*1> ^perception-monitor <p*1>)
    (<p*1> ^changes <chgs>)
    -->
    (<chgs> ^change <c> +)
    (<c> ^type delete-object + ^object-info <obj-info> +)
}

sp {leave-old-waypoint*elaborate*remove-unconfirmed-objects*remove-object
    (state <s> ^name leave-old-waypoint ^operator <o> +
          ^unconfirmed-object <obj>)
    (<o> ^name remove-unconfirmed-objects)
    -->
    (<o> ^remove-object <obj> +)
}

sp {leave-old-waypoint*propose*remove-unconfirmed-objects
    (state <s> ^unconfirmed-objects true ^name leave-old-waypoint)
    -->
    (<s> ^operator <o> +)
    (<o> ^name remove-unconfirmed-objects +)
}

sp {leave-old-waypoint*remove*any*metric*info
    (state <s> ^name leave-old-waypoint ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name remove-old-information)
    (<t*1> ^world <w*1>)
    (<w*1> ^objects <o*2>)
    (<o*2> ^object <obj>)
    (<obj> ^{ << position rotation scale >> <att> } <val>)
    -->
    (<obj> ^<att> <val> -)
}

sp {leave-old-waypoint*apply*remove-old-information*cleanup*svs*filters
    (state <s> ^name leave-old-waypoint ^operator <o*1> ^top-state <t*1>
          ^{ << position-filter rotation-filter scale-filter >> <type> } <filter>)
    (<o*1> ^name remove-old-information)
    (<t*1> ^svs <s*1>)
    (<s*1> ^command <cmd>)
    (<cmd> ^extract_once <filter>)
    -->
    (<cmd> ^extract_once <filter> -)
}

sp {leave-old-waypoint*apply*remove-old-information*remove*old-location
    (state <s> ^name leave-old-waypoint ^operator <o*1> ^old-location <loc>
          ^top-state <t*1>)
    (<o*1> ^name remove-old-information)
    (<t*1> ^world <w*1>)
    (<w*1> ^robot <rob>)
    (<rob> ^current-location <loc>)
    -->
    (<rob> ^current-location <loc> -)
}

sp {leave-old-waypoint*apply*remove-old-information*remove*old-waypoint
    (state <s> ^name leave-old-waypoint ^operator <o*1> ^old-waypoint <wp>
          ^top-state <t*1>)
    (<o*1> ^name remove-old-information)
    (<t*1> ^world <w*1>)
    (<w*1> ^robot <rob>)
    (<rob> ^current-waypoint <wp>)
    -->
    (<rob> ^current-waypoint <wp> -)
}

sp {leave-old-waypoint*apply*remove-old-information*remove*belief*task*objects
    (state <s> ^name leave-old-waypoint ^confirmed-object <obj>
          ^operator <o*1> ^top-state <t*1>)
    (<obj> ^task-object true ^svs-obj <s*2>)
    (<o*1> ^name remove-old-information)
    (<s*2> ^id <id>)
    (<t*1> ^svs <s*1>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^delete_node <d*1> +)
    (<d*1> ^id <id> +)
}

sp {leave-old-waypoint*apply*remove-old-information*attend*delete-object
    (state <s> ^name leave-old-waypoint ^confirmed-object <obj>
          ^operator <o*1> ^top-state <t*2> ^top-state <t*1>)
   -{ (<obj> ^predicates <p*3>)
      (<p*3> ^arm-status grabbed)}
    (<obj> -^task-object true)
    (<o*1> ^name remove-old-information)
    (<t*2> ^perception-monitor <p*2>)
    (<p*2> ^object-monitor <o*2>)
    (<o*2> ^object-info <obj-info>)
    (<obj-info> ^wm-obj <obj>)
    (<t*1> ^perception-monitor <p*1>)
    (<p*1> ^changes <chgs>)
    -->
    (<chgs> ^change <c> +)
    (<c> ^type delete-object + ^object-info <obj-info> +)
}

sp {leave-old-waypoint*propose*remove-old-information
    (state <s> ^name leave-old-waypoint)
    -->
    (<s> ^operator <o> +)
    (<o> ^name remove-old-information +)
}

sp {leave-old-waypoint*elaborate*confirmed-objects*true
    (state <s> ^name leave-old-waypoint ^confirmed-object <c*1>)
    (<c*1> ^svs-obj <any>)
    -->
    (<s> ^confirmed-objects true +)
}

sp {leave-old-waypoint*elaborate*confirmed-objects
    (state <s> ^name leave-old-waypoint ^top-state <t*1>)
    (<t*1> ^world <w*1>)
    (<w*1> ^objects <o*1>)
    (<o*1> ^object <obj>)
    (<obj> ^predicates <preds>)
    (<preds> ^object-status confirmed)
    -->
    (<s> ^confirmed-object <obj> +)
}

sp {leave-old-waypoint*elaborate*unconfirmed-objects*true
    (state <s> ^name leave-old-waypoint ^unconfirmed-object <any>)
    -->
    (<s> ^unconfirmed-objects true +)
}

sp {leave-old-waypoint*elaborate*unconfirmed-object
    (state <s> ^name leave-old-waypoint ^top-state <t*1>)
    (<t*1> ^world <w*1>)
    (<w*1> ^objects <o*1>)
    (<o*1> ^object <obj>)
    (<obj> -^task-object true ^predicates <p*1>)
    (<p*1> ^object-status unconfirmed)
    -->
    (<s> ^unconfirmed-object <obj> +)
}

sp {leave-old-waypoint*elaborate*old-location
    (state <s> ^name leave-old-waypoint ^top-state <t*1>)
    (<t*1> ^world <w*1>)
    (<w*1> ^robot <r*1>)
    (<r*1> ^current-location <old-loc>)
    -->
    (<s> ^old-location <old-loc> +)
}

sp {leave-old-waypoint*elaborate*old-waypoint
    (state <s> ^name leave-old-waypoint ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^old-waypoint <wp>)
    -->
    (<s> ^old-waypoint <wp> +)
}

sp {anystate*apply*attend-to-scene-change*new-object-predicate*remove*debug-perception*print
    (state <s> ^agent-params <a*1> ^operator <o>)
    (<a*1> ^debug-perception true)
    (<o> ^name attend-to-scene-change ^change <c>)
    (<c> ^type new-object-predicate ^property-handle <prop-handle>
          ^predicate-handle <pred-handle> ^object-info <o*2>
          ^object-info <o*1>)
    (<o*2> ^wm-obj <w*1>)
    (<o*1> ^object-handle <handle>)
    (<w*1> ^predicates <wm-preds>)
    (<wm-preds> ^<prop-handle> { <> <pred-handle> <other-pred> })
    -->
    (write |Object | <handle> |: Removing predicate | <prop-handle> |=| <other-pred> (crlf))
}

sp {anystate*apply*attend-to-scene-change*new-object-predicate*debug-perception*print
    (state <s> ^agent-params <a*1> ^operator <o>)
    (<a*1> ^debug-perception true)
    (<o> ^name attend-to-scene-change ^change <c>)
    (<c> ^type new-object-predicate ^property-handle <prop-handle>
          ^predicate-handle <pred-handle> ^object-info <o*2>
          ^object-info <o*1>)
    (<o*2> ^wm-obj <w*1>)
    (<o*1> ^object-handle <handle>)
    (<w*1> ^predicates <wm-preds>)
    -->
    (write |Object | <handle> |: Adding predicate | <prop-handle> |=| <pred-handle> (crlf))
}

sp {anystate*apply*attend-to-scene-change*new-object-predicate*remove
    (state <s> ^operator <o>)
    (<o> ^name attend-to-scene-change ^change <c>)
    (<c> ^type new-object-predicate ^property-handle <prop-handle>
          ^predicate-handle <pred-handle> ^object-info <o*1>)
    (<o*1> ^wm-obj <w*1>)
    (<w*1> ^predicates <wm-preds>)
    (<wm-preds> ^<prop-handle> { <> <pred-handle> <other-pred> })
    -->
    (<wm-preds> ^<prop-handle> <other-pred> -)
}

sp {anystate*apply*attend-to-scene-change*new-object-predicate*add
    (state <s> ^operator <o>)
    (<o> ^name attend-to-scene-change ^change <c>)
    (<c> ^type new-object-predicate ^property-handle <prop-handle>
          ^predicate-handle <pred-handle> ^object-info <o*1>)
    (<o*1> ^wm-obj <w*1>)
    (<w*1> ^predicates <wm-preds>)
    -->
    (<wm-preds> ^<prop-handle> <pred-handle> +)
}

sp {anystate*apply*attend-to-scene-change*attend-to-missing-object*debug-perception*print
    (state <s> ^agent-params <a*1> ^operator <o>)
    (<a*1> ^debug-perception true)
    (<o> ^name attend-to-scene-change ^change <c>)
    (<c> ^type missing-object ^object-info <o*1>)
    (<o*1> ^object-handle <handle>)
    -->
    (write |Missing object | <handle> (crlf))
}

sp {anystate*apply*attend-to-scene-change*missing-object*delete*belief*object
    (state <s> ^operator <o> ^top-state <t*1>)
    (<o> ^name attend-to-scene-change ^change <change>)
    (<change> ^type missing-object ^object-info <obj-info>)
    (<obj-info> ^wm-obj <obj> ^belief-obj <b*1>)
    (<obj> ^task-object true)
    (<b*1> ^id <id>)
    (<t*1> ^svs <s*1>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^delete_node <d*1> +)
    (<d*1> ^id <id> +)
}

sp {anystate*apply*attend-to-scene-change*missing-object*delete*object
    (state <s> ^operator <o>)
    (<o> ^name attend-to-scene-change ^change <change>)
    (<change> ^type missing-object ^object-info <obj-info>)
    (<obj-info> ^wm-obj <obj>)
    (<obj> -^task-object true)
    -->
    (<obj-info> ^delete-object true +)
}

sp {anystate*apply*attend-to-scene-change*update-pose*debug-perception*print
    (state <s> ^agent-params <a*1> ^operator <o>)
    (<a*1> ^debug-perception true)
    (<o> ^name attend-to-scene-change ^change <c>)
    (<c> ^type update-pose ^object-info <o*1>)
    (<o*1> ^object-handle <obj-handle>)
    -->
    (write |Object | <obj-handle> |: updated pose| (crlf))
}

sp {anystate*apply*attend-to-scene-change*update-pose*cleanup
    (state <s> ^operator <o> ^top-state <t*1>)
    (<o> ^name attend-to-scene-change ^change <c*1> ^change <c*2>)
    (<c*1> ^type update-pose)
    (<c*2> ^object-info <obj-info>)
    (<obj-info> ^update-pose true ^copy-command <copy>)
    (<copy> ^status success)
    (<t*1> ^svs <s*1>)
    (<s*1> ^command <cmd>)
    -->
    (<obj-info> ^update-pose true - ^copy-command <copy> -)
    (<cmd> ^copy_transform <copy> -)
}

sp {anystate*apply*attend-to-scene-change*update-pose*svs*copy_node*grabbed
    (state <s> ^operator <o> ^top-state <t*1>)
    (<o> ^name attend-to-scene-change ^change <c*1> ^change <c*2>)
    (<c*1> ^type update-pose)
    (<c*2> ^object-info <obj-info>)
    (<obj-info> ^wm-obj <w*1> ^belief-obj <b*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^arm-status grabbed)
    (<b*1> ^id <bel-id>)
    (<t*1> ^svs <s*1>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^copy_transform <copy> +)
    (<copy> ^source robot + ^destination <bel-id> + ^position yes +
           ^rotation no + ^scale no +)
    (<obj-info> ^copy-command <copy> +)
}

sp {anystate*apply*attend-to-scene-change*update-pose*svs*copy_node
    (state <s> ^operator <o> ^top-state <t*1>)
    (<o> ^name attend-to-scene-change ^change <c*1> ^change <c*2>)
    (<c*1> ^type update-pose)
    (<c*2> ^object-info <obj-info>)
   -{ (<obj-info> ^wm-obj <w*1>)
      (<w*1> ^predicates <p*2>)
      (<p*2> ^arm-status grabbed)}
    (<obj-info> ^perception-obj <p*1> ^belief-obj <b*1>)
    (<b*1> ^id <bel-id>)
    (<p*1> ^id <perc-id>)
    (<t*1> ^svs <s*1>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^copy_transform <copy> +)
    (<copy> ^source <perc-id> + ^destination <bel-id> + ^position yes +
           ^rotation yes + ^scale yes +)
    (<obj-info> ^copy-command <copy> +)
}

sp {anystate*apply*attend-to-scene-change*update-pose*remove*update*flag*no*perception
    (state <s> ^operator <o> ^top-state <t*1>)
    (<o> ^name attend-to-scene-change ^change <c*1> ^change <c*2>)
    (<c*1> ^type update-pose)
    (<c*2> ^object-info <obj-info>)
   -{ (<obj-info> ^wm-obj <w*1>)
      (<w*1> ^predicates <p*1>)
      (<p*1> ^arm-status grabbed)}
    (<obj-info> -^perception-obj <any> ^update-pose true)
    (<t*1> ^svs <s*1>)
    (<s*1> ^command <cmd>)
    -->
    (<obj-info> ^update-pose true -)
}

sp {attend-to-scene-change*evaluate-moved-object*apply*check-for-occlusion*not-occluded*update-pose
    (state <s> ^object-occluded false ^name attend-to-scene-change
          ^operator <o>)
    (<o> ^change-type moved-object ^name check-for-occlusion
          ^object-info <obj-info>)
    -->
    (<obj-info> ^update-pose true +)
}

sp {attend-to-scene-change*evaluate-moved-object*apply*check-for-occlusion*magic*update-pose
    (state <s> ^name attend-to-scene-change ^agent-params <a*1> ^operator <o>)
    (<a*1> ^domain magicbot)
    (<o> ^change-type moved-object ^name check-for-occlusion
          ^object-info <obj-info>)
    -->
    (<obj-info> ^update-pose true +)
}

sp {attend-to-scene-change*evaluate-moved-object*elaborate*check-for-occlusion*parameters
    (state <s> ^name attend-to-scene-change ^operator <o> +)
    (<o> ^change-type moved-object ^name check-for-occlusion
          ^object-info <obj-info>)
    -->
    (<o> ^object-info <obj-info> + ^report-to-top-state true +
           ^report-to-superstate true +)
}

sp {attend-to-scene-change*recheck-occlusion*elaborate*check-for-occlusion*parameters
    (state <s> ^name attend-to-scene-change ^operator <o> +)
    (<o> ^change-type recheck-occlusion ^name check-for-occlusion
          ^object-info <obj-info>)
    -->
    (<o> ^object-info <obj-info> + ^report-to-top-state true +
           ^report-to-superstate false +)
}

sp {anystate*apply*attend-to-scene-change*debug-perception*report-change*arm*actions
    (state <s> ^agent-params <a*1> ^operator <o>)
    (<a*1> ^debug-perception true)
    (<o> ^name attend-to-scene-change ^change <c>)
    (<c> ^type { << arm-status-change >> <type> })
    -->
    (write |Change | <type> (crlf))
}

sp {anystate*apply*attend-to-scene-change*debug-perception*report-change*belief
    (state <s> ^agent-params <a*1> ^operator <o>)
    (<a*1> ^debug-perception true)
    (<o> ^name attend-to-scene-change ^change <c>)
    (<c> ^object-info <o*1> ^type <type>)
    (<o*1> ^object-handle <handle>)
    -->
    (write |Change | <type> | on object | <handle> (crlf))
}

sp {delete-object*prefer*all*over*complete
    (state <s> ^name delete-object ^operator <o2> + ^operator <o1> +)
    (<o2> ^name complete-delete-object)
    (<o1> ^name { << retrieve-smem-object update-smem-object >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {delete-object*apply*complete-delete-object*debug-perception*print
    (state <s> ^name delete-object ^agent-params <a*1> ^operator <o*1>
          ^object-info <o*2>)
    (<a*1> ^debug-perception true)
    (<o*1> ^name complete-delete-object)
    (<o*2> ^object-handle <handle>)
    -->
    (write |Deleting object| <handle> (crlf))
}

sp {delete-object*apply*complete-delete-object*remove*change
    (state <s> ^name delete-object ^operator <o*1> ^top-state <t*1>
          ^superstate <s*1>)
    (<o*1> ^name complete-delete-object)
    (<t*1> ^perception-monitor <p*1>)
    (<p*1> ^changes <chgs>)
    (<chgs> ^change <c>)
    (<s*1> ^scene-change <c>)
    -->
    (<chgs> ^change <c> -)
}

sp {delete-object*apply*operator*complete-delete-object*remove*predicates
    (state <s> ^name delete-object ^operator <o*1> ^object-info <o*2>
          ^top-state <t*1>)
    (<o*1> ^name complete-delete-object)
    (<o*2> ^wm-obj <obj>)
    (<t*1> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <pred>)
    (<pred> ^instance <i>)
    (<i> ^<num> <obj>)
    -->
    (<pred> ^instance <i> -)
}

sp {delete-object*apply*operator*complete-delete-object*remove*from*svs
    (state <s> ^name delete-object ^operator <o*1> ^object-info <o*2>
          ^top-state <t*1>)
    (<o*1> ^name complete-delete-object)
    (<o*2> ^belief-obj <b*1>)
    (<b*1> ^id <id>)
    (<t*1> ^svs <s*1>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^delete_node <d*1> +)
    (<d*1> ^id <id> +)
}

sp {delete-object*apply*complete-delete-object*remove*from*world
    (state <s> ^name delete-object ^operator <o*1> ^object-info <o*2>
          ^top-state <t*1>)
    (<o*1> ^name complete-delete-object)
    (<o*2> ^wm-obj <obj>)
    (<t*1> ^world <w*1>)
    (<w*1> ^objects <objs>)
    (<objs> ^object <obj>)
    -->
    (<objs> ^object <obj> -)
}

sp {delete-object*apply*complete-delete-object*remove*object-info
    (state <s> ^name delete-object ^operator <o*1> ^object-info <obj-info>
          ^top-state <t*1>)
    (<o*1> ^name complete-delete-object)
    (<t*1> ^perception-monitor <p*1>)
    (<p*1> ^object-monitor <obj-mon>)
    (<obj-mon> ^object-info <obj-info>)
    -->
    (<obj-mon> ^object-info <obj-info> -)
}

sp {delete-object*propose*complete-delete-object
    (state <s> ^name delete-object)
    -->
    (<s> ^operator <o> +)
    (<o> ^name complete-delete-object +)
}

sp {delete-object*elaborate*world-obj*from*object-info
    (state <s> ^name delete-object ^object-info <o*1>)
    (<o*1> ^wm-obj <obj>)
    -->
    (<s> ^world-obj <obj> +)
}

sp {delete-object*elaborate*object-info*from*superstate
    (state <s> ^name delete-object ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^object-info <obj-info>)
    -->
    (<s> ^object-info <obj-info> +)
}

sp {delete-object*apply*update-smem-object*remove*level2*predicates
    (state <s> ^name delete-object ^operator <o*1> ^smem-obj <obj>
          ^agent-params <a*1>)
    (<o*1> ^name update-smem-object)
    (<a*1> ^object-rep-info <obj-rep>)
    (<obj> ^<prop> <pred>)
    (<obj-rep> -^ignore-level2 <prop> -^ignore-level1 <prop>
          -^copy-level1 <prop>)
   -{ (<s> ^object-info <o*2>)
      (<o*2> ^wm-obj <w*1>)
      (<w*1> ^predicates <p*1>)
      (<p*1> ^<prop> <pred>)}
    -->
    (<obj> ^<prop> <pred> -)
}

sp {delete-object*apply*update-smem-object*remove*level1*predicates
    (state <s> ^name delete-object ^operator <o*1> ^smem-obj <obj>
          ^agent-params <a*1>)
    (<o*1> ^name update-smem-object)
    (<a*1> ^object-rep-info <obj-rep>)
    (<obj-rep> ^copy-level1 <prop>)
    (<obj> ^<prop> <pred>)
   -{ (<s> ^object-info <o*2>)
      (<o*2> ^wm-obj <w*1>)
      (<w*1> ^<prop> <pred>)}
    -->
    (<obj> ^<prop> <pred> -)
}

sp {delete-object*apply*update-smem-object*add*level2*predicates
    (state <s> ^name delete-object ^operator <o*1> ^smem-obj <obj>
          ^object-info <o*2> ^agent-params <a*1>)
    (<o*1> ^name update-smem-object)
    (<o*2> ^wm-obj <w*1>)
    (<w*1> ^predicates <p*1>)
    (<a*1> ^object-rep-info <obj-rep>)
    (<p*1> ^<prop> <pred>)
    (<obj-rep> -^ignore-level2 <prop>)
    -->
    (<obj> ^<prop> <pred> +)
}

sp {delete-object*apply*update-smem-object*add*level1*predicates
    (state <s> ^name delete-object ^operator <o*1> ^smem-obj <obj>
          ^object-info <o*2> ^agent-params <a*1>)
    (<o*1> ^name update-smem-object)
    (<o*2> ^wm-obj <w*1>)
    (<a*1> ^object-rep-info <obj-rep>)
    (<obj-rep> ^copy-level1 <prop>)
    (<w*1> ^<prop> <pred>)
    -->
    (<obj> ^<prop> <pred> +)
}

sp {delete-object*apply*update-smem-object*mark*updated
    (state <s> ^name delete-object ^operator <o*1>)
    (<o*1> ^name update-smem-object)
    -->
    (<s> ^updated-smem-object true +)
}

sp {delete-object*apply*update-smem-object*store*smem
    (state <s> ^name delete-object ^operator <o*1> ^smem-obj <obj> ^smem <s*1>)
    (<o*1> ^name update-smem-object)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^store <obj> +)
}

sp {delete-object*propose*update-smem-object
    (state <s> ^name delete-object -^updated-smem-object <u*1>
          ^smem-obj { <> none <s*1> })
    -->
    (<s> ^operator <o> +)
    (<o> ^name update-smem-object +)
}

sp {delete-object*apply*retrieve-smem-object*failure*copy*object
    (state <s> ^name delete-object ^operator <o> ^smem <s*2> ^smem <s*1>)
    (<o> ^name retrieve-smem-object ^cue <cue>)
    (<s*1> ^result <r*1>)
    (<r*1> ^failure <cue>)
    (<s*2> ^command <cmd>)
    -->
    (<s> ^smem-obj none +)
    (<cmd> ^query <cue> -)
}

sp {delete-object*apply*retrieve-smem-object*success*copy*object
    (state <s> ^name delete-object ^operator <o> ^smem <s*2> ^smem <s*1>)
    (<o> ^name retrieve-smem-object ^cue <cue>)
    (<s*1> ^result <res>)
    (<res> ^success <cue> ^retrieved <obj-lti>)
    (<s*2> ^command <cmd>)
    -->
    (<s> ^smem-obj <obj-lti> +)
    (<cmd> ^query <cue> -)
}

sp {delete-object*apply*retrieve-smem-object*create*query
    (state <s> ^name delete-object ^operator <o> ^smem <s*1>)
    (<o> ^name retrieve-smem-object ^cue <cue>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^query <cue> +)
}

sp {delete-object*propose*retrieve-smem-object*from*epmem
    (state <s> ^name delete-object -^smem-obj <s*1> ^object-info <o*2>
          ^object-info <o*1>)
    (<o*2> ^wm-obj <w*1>)
    (<w*1> ^in-smem true)
    (<o*1> ^object-handle <obj-handle>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name retrieve-smem-object + ^cue <cue> +)
    (<cue> ^handle <obj-handle> +)
}

sp {anystate*apply*attend-to-scene-change*attend-to-newly-not-visible-object*debug-perception*print
    (state <s> ^agent-params <a*1> ^operator <o>)
    (<a*1> ^debug-perception true)
    (<o> ^name attend-to-scene-change ^change <c>)
    (<c> ^type newly-not-visible-object ^object-info <o*1>)
    (<o*1> ^object-handle <handle>)
    -->
    (write |Object | <handle> |: marking visible=false| (crlf))
}

sp {anystate*apply*attend-to-scene-change*attend-to-newly-not-visible-object*remove*visible*true
    (state <s> ^operator <o>)
    (<o> ^name attend-to-scene-change ^change <c>)
    (<c> ^type newly-not-visible-object ^object-info <o*1>)
    (<o*1> ^wm-obj <w*1>)
    (<w*1> ^predicates <wm-preds>)
    (<wm-preds> ^visible true)
    -->
    (<wm-preds> ^visible true -)
}

sp {anystate*apply*attend-to-scene-change*attend-to-newly-not-visible-object*add*visible*false
    (state <s> ^operator <o>)
    (<o> ^name attend-to-scene-change ^change <c>)
    (<c> ^type newly-not-visible-object ^object-info <o*1>)
    (<o*1> ^wm-obj <w*1>)
    (<w*1> ^predicates <wm-preds>)
    -->
    (<wm-preds> ^visible false +)
}

sp {anystate*apply*attend-to-scene-change*attend-to-newly-visible-object*debug-perception*print
    (state <s> ^agent-params <a*1> ^operator <o>)
    (<a*1> ^debug-perception true)
    (<o> ^name attend-to-scene-change ^change <c>)
    (<c> ^type newly-visible-object ^object-info <o*1>)
    (<o*1> ^object-handle <handle>)
    -->
    (write |Object | <handle> |: marking visible=true| (crlf))
}

sp {anystate*apply*attend-to-scene-change*attend-to-newly-visible-object*remove*old*in*predicate
    (state <s> ^operator <o> ^top-state <t*1>)
    (<o> ^name attend-to-scene-change ^change <c>)
    (<c> ^type newly-visible-object ^object-info <o*1>)
    (<o*1> ^wm-obj <obj>)
    (<t*1> ^world <world>)
    (<world> ^robot <r*1> ^predicates <p*1>)
    (<r*1> ^current-location <cur-loc>)
    (<p*1> ^predicate <in-pred>)
    (<in-pred> ^handle in1 ^instance <i>)
    (<i> ^1 <obj> ^2 { <> <cur-loc> <old-loc> })
    (<old-loc> ^predicates <p*2>)
    (<p*2> ^category location)
    -->
    (<in-pred> ^instance <i> -)
}

sp {anystate*apply*attend-to-scene-change*attend-to-newly-visible-object*add*in*predicate
    (state <s> ^operator <o> ^top-state <t*1>)
    (<o> ^name attend-to-scene-change ^change <c>)
    (<c> ^type newly-visible-object ^object-info <o*1>)
    (<o*1> ^wm-obj <obj>)
    (<t*1> ^world <world>)
    (<world> ^robot <r*1> ^predicates <p*1>)
    (<r*1> ^current-location <cur-loc>)
    (<p*1> ^predicate <in-pred>)
   -{ (<in-pred> ^instance <i>)
      (<i> ^2 <cur-loc> ^1 <obj>)}
    (<in-pred> ^handle in1)
    -->
    (<in-pred> ^instance <i> +)
    (<i> ^1 <obj> + ^2 <cur-loc> +)
}

sp {anystate*apply*attend-to-scene-change*attend-to-newly-visible-object*change*object-status*to*confirmed
    (state <s> ^operator <o>)
    (<o> ^name attend-to-scene-change ^change <c>)
    (<c> ^type newly-visible-object ^object-info <o*1>)
    (<o*1> ^wm-obj <w*1>)
    (<w*1> ^predicates <wm-preds>)
    (<wm-preds> ^object-status unconfirmed)
    -->
    (<wm-preds> ^object-status unconfirmed - ^object-status confirmed +)
}

sp {anystate*apply*attend-to-scene-change*attend-to-newly-visible-object*create*object-status*confirmed
    (state <s> ^operator <o>)
    (<o> ^name attend-to-scene-change ^change <c>)
    (<c> ^type newly-visible-object ^object-info <o*1>)
    (<o*1> ^wm-obj <w*1>)
    (<w*1> ^predicates <wm-preds>)
    (<wm-preds> -^object-status <o*2>)
    -->
    (<wm-preds> ^object-status confirmed +)
}

sp {anystate*apply*attend-to-scene-change*attend-to-newly-visible-object*remove*visible*false
    (state <s> ^operator <o>)
    (<o> ^name attend-to-scene-change ^change <c>)
    (<c> ^type newly-visible-object ^object-info <o*1>)
    (<o*1> ^wm-obj <w*1>)
    (<w*1> ^predicates <wm-preds>)
    (<wm-preds> ^visible false)
    -->
    (<wm-preds> ^visible false -)
}

sp {anystate*apply*attend-to-scene-change*attend-to-newly-visible-object*add*visible*true
    (state <s> ^operator <o>)
    (<o> ^name attend-to-scene-change ^change <c>)
    (<c> ^type newly-visible-object ^object-info <o*1>)
    (<o*1> ^wm-obj <w*1>)
    (<w*1> ^predicates <wm-preds>)
    -->
    (<wm-preds> ^visible true +)
}

sp {anystate*apply*attend-to-scene-change*create-belief-object*debug-perception*print
    (state <s> ^agent-params <a*1> ^operator <o>)
    (<a*1> ^debug-perception true)
    (<o> ^name attend-to-scene-change ^change <c>)
    (<c> ^type create-belief-object ^object-info <o*1>)
    (<o*1> ^object-handle <obj-handle>)
    -->
    (write |Created belief object for | <obj-handle> (crlf))
}

sp {anystate*apply*attend-to-scene-change*create-belief-object*svs*create_node*magicbot
    (state <s> ^agent-params <a*1> ^operator <o> ^top-state <t*1>)
    (<a*1> ^domain magicbot)
    (<o> ^name attend-to-scene-change ^change <c*1> ^change <c*2>)
    (<c*1> ^type create-belief-object)
    (<c*2> ^object-info <obj-info>)
    (<obj-info> -^belief-obj <b*1> ^belief-id <bel-id> ^perception-obj <p*1>)
    (<p*1> ^id <perc-id>)
    (<t*1> ^svs <s*1>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^copy_node <copy> +)
    (<copy> ^id <bel-id> + ^source <perc-id> + ^adjust false +)
}

sp {anystate*apply*attend-to-scene-change*create-belief-object*svs*create_node*tabletop
    (state <s> ^agent-params <a*1> ^operator <o> ^top-state <t*1>)
    (<a*1> ^domain tabletop)
    (<o> ^name attend-to-scene-change ^change <c*1> ^change <c*2>)
    (<c*1> ^type create-belief-object)
    (<c*2> ^object-info <obj-info>)
    (<obj-info> -^belief-obj <b*1> ^belief-id <bel-id> ^perception-obj <p*1>)
    (<p*1> ^id <perc-id>)
    (<t*1> ^svs <s*1>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^copy_node <copy> +)
    (<copy> ^id <bel-id> + ^source <perc-id> + ^adjust true +)
}

sp {attend-to-new-object*apply*add-object-to-world*create*belief*object*from*epmem-obj
    (state <s> ^source-type epmem-obj ^name attend-to-new-object ^operator <o>
          ^source-obj <src> ^top-state <t*1>)
    (<o> ^name add-object-to-world ^new-object-rep <n*1>)
    (<src> ^rotation <rot> ^position <pos> ^scale <scl>)
    (<scl> ^z <sz> ^y <sy> ^x <sx>)
    (<rot> ^z <rz> ^y <ry> ^x <rx>)
    (<pos> ^z <pz> ^y <py> ^x <px>)
    (<n*1> ^handle <h>)
    (<t*1> ^svs <s*1>)
    (<s*1> ^command <svs-cmd>)
    -->
    (<svs-cmd> ^add_node <add> +)
    (<add> ^id (concat bel- <h>) + ^parent world + ^geometry box +
           ^position <npos> + ^rotation <nrot> + ^scale <nscl> +
           ^tags <tags> +)
    (<npos> ^x <px> + ^y <py> + ^z <pz> +)
    (<nrot> ^x <rx> + ^y <ry> + ^z <rz> +)
    (<nscl> ^x <sx> + ^y <sy> + ^z <sz> +)
    (<tags> ^object-source belief +)
}

sp {attend-to-new-object*apply*add-object-to-world*debug-perception*print
    (state <s> ^name attend-to-new-object ^agent-params <a*1> ^operator <o>)
    (<a*1> ^debug-perception true)
    (<o> ^name add-object-to-world ^new-object-rep <obj>)
    (<obj> ^handle <h>)
    -->
    (write |Adding object | <h> (crlf))
    (write (cmd print <obj> |-d| 2) (crlf))
}

sp {attend-to-new-object*apply*add-object-to-world*create*object-info*perception-obj
    (state <s> ^source-type perception-obj ^name attend-to-new-object
          ^operator <o> ^source-obj <s*1> ^object-monitor <obj-mon>)
    (<o> ^name add-object-to-world ^new-object-rep <obj>)
    (<obj> ^handle <h>)
    (<s*1> ^id <pid>)
    -->
    (<obj-mon> ^object-info <obj-info> +)
    (<obj-info> ^object-handle <h> + ^wm-obj <obj> +
           ^belief-id (concat bel- <h>) + ^perception-id <pid> +)
}

sp {attend-to-new-object*apply*add-object-to-world*create*object-info*not*perception-obj
    (state <s> ^name attend-to-new-object ^operator <o>
          ^source-type { <> perception-obj <s*1> } ^object-monitor <obj-mon>)
    (<o> ^name add-object-to-world ^new-object-rep <obj>)
    (<obj> ^handle <h>)
    -->
    (<obj-mon> ^object-info <obj-info> +)
    (<obj-info> ^object-handle <h> + ^wm-obj <obj> +
           ^belief-id (concat bel- <h>) + ^perception-id <h> +)
}

sp {attend-to-new-object*apply*add-object-to-world*remove*attend*change
    (state <s> ^name attend-to-new-object ^operator <o*1> ^top-state <t*1>
          ^superstate <s*1>)
    (<o*1> ^name add-object-to-world)
    (<t*1> ^perception-monitor <p*1>)
    (<p*1> ^changes <chgs>)
    (<chgs> ^change <chg>)
    (<s*1> ^scene-change <chg>)
    -->
    (<chgs> ^change <chg> -)
}

sp {attend-to-new-object*apply*add-object-to-world*visible*add*in*predicate
    (state <s> ^source-type perception-obj ^name attend-to-new-object
          ^operator <o> ^top-state <t*1>)
    (<o> ^name add-object-to-world ^new-object-rep <obj>)
    (<t*1> ^world <world>)
    (<world> ^robot <r*1> ^predicates <p*1>)
    (<r*1> ^current-location <cur-loc>)
    (<p*1> ^predicate <in-pred>)
   -{ (<in-pred> ^instance <curi>)
      (<curi> ^2 <cur-loc> ^1 <obj>)}
    (<in-pred> ^handle in1)
    -->
    (<in-pred> ^instance <i> +)
    (<i> ^1 <obj> + ^2 <cur-loc> +)
}

sp {attend-to-new-object*apply*add-object-to-world*add*object*to*world
    (state <s> ^name attend-to-new-object ^operator <o> ^top-state <t*1>)
    (<o> ^name add-object-to-world ^new-object-rep <obj>)
    (<t*1> ^world <w*1>)
    (<w*1> ^objects <objs>)
    -->
    (<objs> ^object <obj> +)
}

sp {attend-to-new-object*apply*match-smem-object*failure*mark*matches*none
    (state <s> ^name attend-to-new-object ^operator <o> ^smem <s*2>
          ^smem <s*1>)
    (<o> ^name match-smem-object ^cue <cue>)
    (<s*1> ^result <r*1>)
    (<r*1> ^failure <cue>)
    (<s*2> ^command <cmd>)
    -->
    (<s> ^matches-smem-object none +)
    (<cmd> ^query <cue> -)
}

sp {attend-to-new-object*apply*match-smem-object*success*copy*object
    (state <s> ^name attend-to-new-object ^operator <o> ^smem <s*2>
          ^smem <s*1>)
    (<o> ^name match-smem-object ^cue <cue>)
    (<s*1> ^result <res>)
    (<res> ^success <cue> ^retrieved <obj-lti>)
    (<s*2> ^command <cmd>)
    -->
    (<s> ^matches-smem-object <obj-lti> +)
    (<cmd> ^query <cue> -)
}

sp {attend-to-new-object*apply*match-smem-object*create*query
    (state <s> ^name attend-to-new-object ^operator <o> ^smem <s*1>)
    (<o> ^name match-smem-object ^cue <cue>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^query <cue> +)
}

sp {attend-to-new-object*elaborate*match-smem-object*cue*from*perception
    (state <s> ^source-type perception-obj ^name attend-to-new-object
          ^operator <o> + ^perception-object-info <obj-info>)
    (<o> ^name match-smem-object ^cue <cue>)
    (<obj-info> ^properties <p*1>)
    (<p*1> ^property-info <prop-info>)
    (<prop-info> ^property-handle <prop> ^predicate-handle <pred>)
    -->
    (<cue> ^<prop> <pred> +)
}

sp {attend-to-new-object*reject*match-smem-object*no*perceptual*properties
    (state <s> ^name attend-to-new-object ^perception-object-info <obj-info>
          ^operator <o> +)
   -{ (<obj-info> ^properties <p*1>)
      (<p*1> ^property-info <p*2>)
      (<p*2> ^predicate-handle <p*3>)}
    (<o> ^name match-smem-object)
    -->
    (<s> ^operator <o> -)
}

sp {attend-to-new-object*propose*match-smem-object*from*perception
    (state <s> ^source-type perception-obj -^matches-smem-object <m*1>
          ^name attend-to-new-object ^perception-object-info <obj-info>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name match-smem-object + ^cue <cue> +)
    (<cue> ^object-instance true + ^item-type object +)
}

sp {attend-to-new-object*propose*match-smem-object*using*handle
    (state <s> ^name attend-to-new-object -^matches-smem-object <m*1>
          ^source-obj <s*3> ^source-type { <> smem-obj <s*2> }
          ^source-type { <> perception-obj <s*1> })
    (<s*3> ^handle <obj-handle>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name match-smem-object + ^cue <cue> +)
    (<cue> ^object-instance true + ^handle <obj-handle> +)
}

sp {create-new-object*apply*complete-create-new-object
    (state <s> ^name create-new-object ^operator <o> ^superstate <ss>)
    (<o> ^name complete-create-new-object ^new-object-rep <obj>)
    -->
    (<ss> ^new-object-rep <obj> +)
}

sp {create-new-object*propose*complete-create-new-object
    (state <s> ^copied-predicates true ^name create-new-object
          ^new-object-rep <rep>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name complete-create-new-object + ^new-object-rep <rep> +)
}

sp {create-new-object*apply*copy-predicate*copy*epmem-predicate
    (state <s> ^name create-new-object ^operator <o> ^new-object-rep <n*1>)
    (<o> ^name copy-predicates ^epmem-predicate <p>)
    (<p> ^predicate <pred> ^property <prop>)
    (<n*1> ^predicates <preds>)
   -{ (<o> ^smem-predicate <s*1>)
      (<s*1> ^property <prop>)}
   -{ (<o> ^perception-predicate <p*1>)
      (<p*1> ^property <prop>)}
    -->
    (<preds> ^<prop> <pred> +)
}

sp {create-new-object*apply*copy-predicate*smem*copy*waypoint
    (state <s> ^name create-new-object ^operator <o*1> ^new-object-rep <rep>
          ^smem-obj <s*1>)
    (<o*1> ^name copy-predicates)
    (<s*1> ^waypoint <wp>)
    -->
    (<rep> ^waypoint <wp> +)
}

sp {create-new-object*apply*copy-predicate*copy*smem-predicate
    (state <s> ^name create-new-object ^operator <o> ^new-object-rep <n*1>)
    (<o> ^name copy-predicates ^smem-predicate <p>)
    (<p> ^predicate <pred> ^property <prop>)
    (<n*1> ^predicates <preds>)
   -{ (<o> ^perception-predicate <p*1>)
      (<p*1> ^property <prop>)}
    -->
    (<preds> ^<prop> <pred> +)
}

sp {create-new-object*apply*copy-predicate*copy*imagined-predicate
    (state <s> ^name create-new-object ^operator <o> ^new-object-rep <n*1>)
    (<o> ^name copy-predicates ^imagined-predicate <p>)
    (<p> ^predicate <pred> ^property <prop>)
    (<n*1> ^predicates <preds>)
    -->
    (<preds> ^<prop> <pred> +)
}

sp {create-new-object*apply*copy-predicate*copy*perception-predicate
    (state <s> ^name create-new-object ^operator <o> ^new-object-rep <n*1>)
    (<o> ^name copy-predicates ^perception-predicate <p>)
    (<p> ^predicate <pred> ^property <prop>)
    (<n*1> ^predicates <preds>)
    -->
    (<preds> ^<prop> <pred> +)
}

sp {create-new-object*apply*copy-predicates*mark*copied-predicates
    (state <s> ^name create-new-object ^operator <o*1>)
    (<o*1> ^name copy-predicates)
    -->
    (<s> ^copied-predicates true +)
}

sp {create-new-object*elaborate*copy-predicates*epmem-predicate
    (state <s> ^name create-new-object ^operator <o> + ^new-object-rep <n*1>
          ^epmem-obj <e*1> -^ignore-predicate <prop>)
    (<o> ^name copy-predicates)
    (<n*1> ^predicates <preds>)
    (<e*1> ^predicates <p*1>)
    (<p*1> ^<prop> <pred>)
    -->
    (<o> ^epmem-predicate <p> +)
    (<p> ^property <prop> + ^predicate <pred> +)
}

sp {create-new-object*elaborate*copy-predicates*smem-predicate
    (state <s> ^name create-new-object ^operator <o> + ^new-object-rep <n*1>
          ^smem-obj <s*1> -^ignore-predicate <prop>)
    (<o> ^name copy-predicates)
    (<n*1> ^predicates <preds>)
    (<s*1> ^<prop> <pred>)
    -->
    (<o> ^smem-predicate <p> +)
    (<p> ^property <prop> + ^predicate <pred> +)
}

sp {create-new-object*elaborate*copy-predicates*perception-predicate
    (state <s> ^source-type perception-obj ^name create-new-object
          ^operator <o> + ^new-object-rep <n*1> ^object-info <obj-info>
          -^ignore-predicate <prop>)
    (<o> ^name copy-predicates)
    (<obj-info> ^properties <p*1>)
    (<p*1> ^property-info <prop-info>)
    (<prop-info> ^property-handle <prop> ^predicate-handle <pred>)
    (<n*1> ^predicates <preds>)
    -->
    (<o> ^perception-predicate <p> +)
    (<p> ^property <prop> + ^predicate <pred> +)
}

sp {create-new-object*elaborate*copy-predicates*imagined-predicate
    (state <s> ^source-type imagined-obj ^name create-new-object
          ^operator <o> + ^new-object-rep <n*1> ^source-obj <s*1>
          -^ignore-predicate <prop>)
    (<o> ^name copy-predicates)
    (<n*1> ^predicates <preds>)
    (<s*1> ^predicates <p*1>)
    (<p*1> ^<prop> <pred>)
    -->
    (<o> ^imagined-predicate <p> +)
    (<p> ^property <prop> + ^predicate <pred> +)
}

sp {create-new-object*propose*copy-predicates
    (state <s> ^name create-new-object -^copied-predicates <c*1>
          ^new-object-rep <n*1>)
    (<n*1> ^predicates <preds>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name copy-predicates +)
}

sp {create-new-object*apply*initialize-object*mark*object-status*unconfirmed
    (state <s> ^name create-new-object ^operator <o*1> ^new-object-rep <n*1>
          ^source-type { <> perception-obj <s*1> })
    (<o*1> ^name initialize-object)
    (<n*1> ^predicates <preds>)
    -->
    (<preds> ^object-status unconfirmed + ^visible false +)
}

sp {create-new-object*apply*initialize-object*mark*object-status*confirmed
    (state <s> ^source-type perception-obj ^name create-new-object
          ^operator <o*1> ^new-object-rep <n*1>)
    (<o*1> ^name initialize-object)
    (<n*1> ^predicates <preds>)
    -->
    (<preds> ^object-status confirmed + ^visible true +)
}

sp {create-new-object*apply*initialize-object*mark*in-smem
    (state <s> ^name create-new-object ^operator <o*1> ^new-object-rep <rep>
          ^smem-obj <smem>)
    (<o*1> ^name initialize-object)
    -->
    (<rep> ^in-smem true +)
}

sp {create-new-object*apply*initialize-object*copy*handle
    (state <s> ^name create-new-object ^operator <o*1> ^new-object-rep <rep>
          ^object-handle <h>)
    (<o*1> ^name initialize-object)
    -->
    (<rep> ^handle <h> +)
}

sp {create-new-object*apply*initialize-object*create*new*rep
    (state <s> ^name create-new-object ^operator <o*1>)
    (<o*1> ^name initialize-object)
    -->
    (<s> ^new-object-rep <rep> +)
    (<rep> ^item-type object + ^predicates <preds> +)
}

sp {create-new-object*propose*initialize-object
    (state <s> ^name create-new-object)
   -{ (<s> ^new-object-rep <n*1>)
      (<n*1> ^handle <h>)}
    -->
    (<s> ^operator <o> +)
    (<o> ^name initialize-object +)
}

sp {create-new-object*prefer*initialize*over*copy
    (state <s> ^name create-new-object ^operator <o2> + ^operator <o1> +)
    (<o2> ^name copy-predicates)
    (<o1> ^name initialize-object)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {create-new-object*elaborate*ignore-predicate
    (state <s> ^name create-new-object)
    -->
    (<s> ^ignore-predicate handle + ^ignore-predicate item-type +
           ^ignore-predicate object-instance + ^ignore-predicate predicates +
           ^ignore-predicate in-smem + ^ignore-predicate room1 +
           ^ignore-predicate storage1 + ^ignore-predicate arm-status +
           ^ignore-predicate object-status + ^ignore-predicate visible +
           ^ignore-predicate dialog-object + ^ignore-predicate waypoint +)
}

sp {create-new-object*elaborate*object-handle*from*perception-obj
    (state <s> ^source-type perception-obj ^name create-new-object
          ^source-obj <s*2>)
   -{ (<s> ^smem-obj <s*1>)
      (<s*1> ^handle <h*1>)}
    (<s*2> ^id <obj-handle>)
    -->
    (<s> ^object-handle <obj-handle> +)
}

sp {create-new-object*elaborate*object-handle*from*source-obj
    (state <s> ^name create-new-object ^source-obj <s*2>)
   -{ (<s> ^smem-obj <s*1>)
      (<s*1> ^handle <h*1>)}
    (<s*2> ^handle <obj-handle>)
    -->
    (<s> ^object-handle <obj-handle> +)
}

sp {create-new-object*elaborate*object-handle*from*smem-obj
    (state <s> ^name create-new-object ^smem-obj <s*1>)
    (<s*1> ^handle <obj-handle>)
    -->
    (<s> ^object-handle <obj-handle> +)
}

sp {create-new-object*elaborate*input-link-obj*matching*perception-obj
    (state <s> ^source-type perception-obj ^name create-new-object
          ^source-obj <pobj> ^object-monitor <o*1>)
    (<o*1> ^new-object-info <obj-info>)
    (<obj-info> ^perception-obj <pobj>)
    -->
    (<s> ^object-info <obj-info> +)
}

sp {create-new-object*elaborate*object-monitor
    (state <s> ^name create-new-object ^top-state <t*1>)
    (<t*1> ^perception-monitor <p*1>)
    (<p*1> ^object-monitor <obj-mon>)
    -->
    (<s> ^object-monitor <obj-mon> +)
}

sp {create-new-object*elaborate*epmem-obj*source-object
    (state <s> ^source-type epmem-obj ^name create-new-object
          ^source-obj <obj>)
    -->
    (<s> ^epmem-obj <obj> +)
}

sp {create-new-object*elaborate*smem-obj*source-object
    (state <s> ^source-type smem-obj ^name create-new-object ^source-obj <obj>)
    -->
    (<s> ^smem-obj <obj> +)
}

sp {create-new-object*elaborate*smem-obj*from*superoperator
    (state <s> ^name create-new-object ^superstate <s*1>)
    (<s*1> ^operator <ssop>)
    (<ssop> ^smem-obj <obj>)
    -->
    (<s> ^smem-obj <obj> +)
}

sp {create-new-object*elaborate*source*info*from*superoperator
    (state <s> ^name create-new-object ^superstate <s*1>)
    (<s*1> ^operator <ssop>)
    (<ssop> ^source-obj <obj> ^source-type <type>)
    -->
    (<s> ^source-type <type> + ^source-obj <obj> +)
}

sp {update-existing-object*apply*create-belief-object
    (state <s> ^name update-existing-object ^operator <o> ^top-state <t*1>)
    (<o> ^name create-belief-object ^rotation <rot> ^position <pos>
          ^scale <scl> ^belief-id <bel-id>)
    (<scl> ^z <sz> ^y <sy> ^x <sx>)
    (<rot> ^z <rz> ^y <ry> ^x <rx>)
    (<pos> ^z <pz> ^y <py> ^x <px>)
    (<t*1> ^svs <s*1>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^add_node <add> +)
    (<add> ^id <bel-id> + ^parent world + ^geometry box + ^position <npos> +
           ^rotation <nrot> + ^scale <nscl> + ^tags <tags> +)
    (<npos> ^x <px> + ^y <py> + ^z <pz> +)
    (<nrot> ^x <rx> + ^y <ry> + ^z <rz> +)
    (<nscl> ^x <sx> + ^y <sy> + ^z <sz> +)
    (<tags> ^object-source belief +)
}

sp {update-existing-object*propose*create-belief-object*source-type*epmem
    (state <s> ^source-type epmem-obj ^name update-existing-object
          ^existing-obj <exist-obj> ^source-obj <src>)
    (<exist-obj> -^belief-obj <b*1> ^belief-id <bel-id>)
    (<src> ^rotation <rot> ^position <pos> ^scale <scl>)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name create-belief-object + ^belief-id <bel-id> + ^position <pos> +
           ^rotation <rot> + ^scale <scl> +)
}

sp {attend-to-new-object*apply*ignore-new-object
    (state <s> ^name attend-to-new-object ^operator <o*1> ^top-state <t*1>
          ^superstate <s*1>)
    (<o*1> ^name ignore-new-object)
    (<t*1> ^perception-monitor <p*1>)
    (<p*1> ^changes <chs>)
    (<chs> ^change <c>)
    (<c> ^info <info>)
    (<s*1> ^change-info <info>)
    -->
    (<chs> ^change <c> -)
}

sp {update-existing-object*apply*remove-change-info
    (state <s> ^name update-existing-object ^operator <o> ^top-state <t*1>)
    (<o> ^name remove-change-info ^change-info <info>)
    (<t*1> ^perception-monitor <p*1>)
    (<p*1> ^changes <chgs>)
    (<chgs> ^change <c>)
    (<c> ^info <info>)
    -->
    (<chgs> ^change <c> -)
}

sp {update-existing-object*propose*remove-change-info
    (state <s> ^name update-existing-object ^superstate <s*1>)
    (<s*1> ^superstate <s*2>)
    (<s*2> ^change-info <info>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name remove-change-info + ^change-info <info> +)
}

sp {update-existing-object*apply*link-imagined-object*debug-perception*print
    (state <s> ^name update-existing-object ^agent-params <a*1> ^operator <o>)
    (<a*1> ^debug-perception true)
    (<o> ^name link-imagined-object ^existing-obj <e*1> ^imagined-obj <i*1>)
    (<e*1> ^handle <obj-handle>)
    (<i*1> ^handle <imag-handle>)
    -->
    (write |Linking imagined object | <imag-handle> | to existing object | <obj-handle> (crlf))
}

sp {update-existing-object*apply*link-imagined-object
    (state <s> ^name update-existing-object ^operator <o>)
    (<o> ^name link-imagined-object ^existing-obj <obj> ^imagined-obj <imag>)
    -->
    (<imag> ^linked-to <obj> +)
}

sp {update-existing-object*propose*link-imagined-object
    (state <s> ^source-type imagined-obj ^name update-existing-object
          ^existing-obj <e*1> ^source-obj <imag>)
    (<e*1> ^wm-obj <obj>)
    (<imag> -^linked-to <obj>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name link-imagined-object + ^imagined-obj <imag> +
           ^existing-obj <obj> +)
}

sp {update-existing-object*apply*link-perception-object*monitor*perception
    (state <s> ^name update-existing-object ^agent-params <a*1> ^operator <o>)
    (<a*1> ^debug-perception true)
    (<o> ^name link-perception-object ^existing-obj-id <obj-id>
          ^perception-obj-id <perc-id>)
    -->
    (write |Linking object | <perc-id> | to | <obj-id>)
}

sp {update-existing-object*apply*link-perception-object
    (state <s> ^name update-existing-object ^operator <o> ^io <i*1>)
    (<o> ^name link-perception-object ^existing-obj-id <obj-id>
          ^perception-obj-id <perc-id>)
    (<i*1> ^output-link <ol>)
    -->
    (<ol> ^modify-scene <ms> +)
    (<ms> ^type link + ^source-handle <perc-id> +
           ^destination-handle <obj-id> +)
}

sp {update-existing-object*propose*link-perception-object
    (state <s> ^source-type perception-obj ^name update-existing-object
          ^existing-obj <e*1> ^source-obj <s*1>)
    (<e*1> ^perception-id <obj-id>)
    (<s*1> ^id <perc-id>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name link-perception-object + ^perception-obj-id <perc-id> +
           ^existing-obj-id <obj-id> +)
}

sp {update-existing-object*elaborate*worst*preference*remove-change-info
    (state <s> ^name update-existing-object ^operator <o> +)
    (<o> ^name remove-change-info)
    -->
    (<s> ^operator <o> <)
}

sp {update-existing-object*elaborate*info*from*superoperator
    (state <s> ^name update-existing-object ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^existing-obj <ex-obj> ^source-obj <obj> ^source-type <type>)
    -->
    (<s> ^source-type <type> + ^source-obj <obj> + ^existing-obj <ex-obj> +)
}

sp {match-existing-object*predicate-conflict*debug-perception*print
    (state <s> ^name match-existing-object ^agent-params <a*1>
          ^candidate-set <c*1> ^object-handle <handle>)
    (<a*1> ^debug-perception true)
    (<c*1> ^candidate <cand>)
    (<cand> ^predicate-conflict true ^object-info <o*1>)
    (<o*1> ^object-handle <cand-handle>)
    -->
    (write |Matching | <handle> | against | <cand-handle> | failed: predicate conflict| (crlf))
}

sp {match-existing-object*elaborate*candidate*predicate-conflict*2
    (state <s> ^name match-existing-object ^predicates-to-match <obj-preds>
          ^candidate-set <c*1>)
    (<c*1> ^candidate <cand>)
    (<cand> ^object-info <o*1>)
    (<o*1> ^wm-obj <w*1>)
    (<w*1> ^predicates <cand-preds>)
    (<obj-preds> ^<prop> <p*1>)
   -{ (<s> ^ignore-predicate <i*1>)
      (<i*1> ^predicate <prop>)}
    (<cand-preds> ^<prop> { <> <p*1> <pred> })
    -->
    (<cand> ^predicate-conflict true +)
}

sp {match-existing-object*elaborate*candidate*predicate-conflict*1
    (state <s> ^name match-existing-object ^predicates-to-match <obj-preds>
          ^candidate-set <c*1>)
    (<c*1> ^candidate <cand>)
    (<cand> ^object-info <o*1>)
    (<o*1> ^wm-obj <w*1>)
    (<w*1> ^predicates <cand-preds>)
    (<cand-preds> ^<prop> <p*1>)
   -{ (<s> ^ignore-predicate <i*1>)
      (<i*1> ^predicate <prop>)}
    (<obj-preds> ^<prop> { <> <p*1> <pred> })
    -->
    (<cand> ^predicate-conflict true +)
}

sp {match-existing-object*elaborate*candidate-set*candidate*valid*true*none*false
    (state <s> ^name match-existing-object ^candidate-set <c*1>)
    (<c*1> ^candidate <cand>)
    (<cand> -^valid false)
    -->
    (<cand> ^valid true +)
}

sp {match-existing-object*elaborate*candidate-set*candidate*valid*false*predicate-conflict
    (state <s> ^name match-existing-object ^candidate-set <c*1>)
    (<c*1> ^candidate <cand>)
    (<cand> ^predicate-conflict true)
    -->
    (<cand> ^valid false +)
}

sp {match-existing-object*elaborate*candidate-set*candidate
    (state <s> ^name match-existing-object ^candidate-set <set>
          ^object-monitor <o*1>)
    (<o*1> ^object-info <obj-info>)
    -->
    (<set> ^candidate <cand> +)
    (<cand> ^object-info <obj-info> +)
}

sp {match-existing-object*elaborate*candidate-set
    (state <s> ^name match-existing-object ^predicates-to-match <any>)
    -->
    (<s> ^candidate-set <set> +)
}

sp {match-existing-object*elaborate*ignore-predicates
    (state <s> ^name match-existing-object)
    -->
    (<s> ^ignore-predicates <ign> +)
    (<ign> ^predicate handle + ^predicate item-type +
           ^predicate object-instance + ^predicate predicates +
           ^predicate in-smem + ^predicate room1 + ^predicate storage1 +
           ^predicate arm-status + ^predicate object-status +
           ^predicate visible + ^predicate dialog-object +)
}

sp {match-existing-object*apply*matches-object-predicates*report*to*superstate
    (state <s> ^name match-existing-object ^operator <o> ^superstate <ss>)
    (<o> ^name matches-object-predicates ^candidate <c*1>)
    (<c*1> ^object-info <obj-info>)
    -->
    (<ss> ^matches-existing-object <obj-info> +)
}

sp {match-existing-object*propose*matches-object-predicates
    (state <s> ^name match-existing-object ^predicates-to-match <preds>
          ^candidate-set <c*1>)
    (<c*1> ^candidate <cand>)
    (<cand> ^valid true)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name matches-object-predicates + ^candidate <cand> +)
}

sp {match-existing-object*elaborate*predicates-to-match*imagined-obj
    (state <s> ^source-type imagined-obj ^name match-existing-object
          ^source-obj <s*1>)
    (<s*1> ^predicates <preds>)
    -->
    (<s> ^predicates-to-match <preds> +)
}

sp {match-existing-object*elaborate*predicates-to-match*epmem-obj
    (state <s> ^source-type epmem-obj ^name match-existing-object
          ^source-obj <s*1>)
    (<s*1> ^predicates <preds>)
    -->
    (<s> ^predicates-to-match <preds> +)
}

sp {matches-known-object*apply*matches-overlapping-object
    (state <s> ^name match-known-object ^operator <o> ^superstate <ss>)
    (<o> ^name matches-overlapping-object ^overlapping-object <obj-info>)
    -->
    (<ss> ^matches-existing-object <obj-info> +)
}

sp {matches-known-object*propose*matches-overlapping-object
    (state <s> ^name match-known-object ^overlap-results <o*1>)
    (<o*1> ^result <res>)
    (<res> ^overlapper-info <obj-info> ^overlap <val>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name matches-overlapping-object + ^overlapping-object <obj-info> +
           ^overlap <val> +)
}

sp {match-existing-object*apply*overlap-command*debug-perception*report*overlap
    (state <s> ^name match-existing-object ^agent-params <a*1> ^operator <o*1>
          ^overlap-command <o*2>)
    (<a*1> ^debug-perception true)
    (<o*1> ^name overlap-command)
    (<o*2> ^result <res>)
    (<res> ^overlap <val> ^object-b <b> ^object-a <a>)
    -->
    (write |Overlap: | <val> | of | <a> | is contained by | <b> (crlf))
}

sp {match-existing-object*apply*overlap-command*copy-result
    (state <s> ^name match-existing-object ^operator <o*1>
          ^overlap-results <results> ^overlap-command <cmd>)
    (<o*1> ^name overlap-command)
    (<cmd> ^result <res>)
    (<res> ^overlap <val>)
    -->
    (<s> ^overlap-command <cmd> -)
    (<results> ^result <res> +)
}

sp {match-existing-object*propose*overlap-command
    (state <s> ^source-type perception-obj ^name match-existing-object
          ^source-obj <s*1> ^intersect-command <i*1>)
    (<i*1> ^result { <> none <int-id> })
   -{ (<s> ^overlap-results <o*1>)
      (<o*1> ^result <r*1>)
      (<r*1> ^object-b <int-id>)}
    (<s*1> ^id <new-id>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name overlap-command + ^object-a <new-id> + ^object-b <int-id> +)
}

sp {match-existing-object*propose*intersect-command
    (state <s> ^source-type perception-obj ^name match-existing-object
          ^source-obj <s*1>)
   -{ (<s> ^intersect-command <i*1>)
      (<i*1> ^result <r*1>)}
    (<s*1> ^id <perc-id>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name intersect-command + ^object-id <perc-id> +
           ^candidate-set <cand> +)
    (<cand> ^type tag_select + ^a <a*1> + ^tag_name object-source +
           ^tag_value belief +)
    (<a*1> ^type all_nodes +)
}

sp {match-existing-object*elaborate*worst*preference*matches-none
    (state <s> ^name match-existing-object ^operator <o> +)
    (<o> ^name matches-none)
    -->
    (<s> ^operator <o> <)
}

sp {match-existing-object*reject*matches-object-predicates*epmem*has*svs*object
    (state <s> ^source-type epmem-obj ^name match-existing-object
          ^operator <o> +)
    (<o> ^name matches-object-predicates ^candidate <c*1>)
    (<c*1> ^object-info <o*1>)
    (<o*1> ^belief-obj <any>)
    -->
    (<s> ^operator <o> -)
}

sp {match-existing-object*reject*matches-overlapping-object*not*enough*overlap
    (state <s> ^name match-existing-object ^operator <o> +
          ^contained-threshold { > <o*2> <thresh> })
    (<o> ^name matches-overlapping-object ^overlapping-object <o*1>
          ^overlap <o*2>)
    (<o*1> ^status <s*1>)
    (<s*1> ^visible true)
    -->
    (<s> ^operator <o> -)
}

sp {match-existing-object*prefer*matches-overlapping-object*with*more*overlap
    (state <s> ^name match-existing-object ^operator <o2> + ^operator <o1> +)
    (<o2> ^name matches-overlapping-object ^overlap <val2>)
    (<o1> ^name matches-overlapping-object ^overlap { > <val2> <val1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {match-existing-object*prefer*svs-commands*over*matches-overlapping-object
    (state <s> ^name match-existing-object ^operator <o2> + ^operator <o1> +)
    (<o2> ^name matches-overlapping-object)
    (<o1> ^name { << intersect-command overlap-command >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {match-existing-object*prefer*intersect-command*over*overlap-command
    (state <s> ^name match-existing-object ^operator <o2> + ^operator <o1> +)
    (<o2> ^name overlap-command)
    (<o1> ^name intersect-command)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {match-existing-object*elaborate*best*preference*matches-object-handle
    (state <s> ^name match-existing-object ^operator <o> +)
    (<o> ^name matches-object-handle)
    -->
    (<s> ^operator <o> >)
}

sp {match-existing-object*apply*matches-none
    (state <s> ^name match-existing-object ^operator <o*1> ^superstate <ss>)
    (<o*1> ^name matches-none)
    -->
    (<ss> ^matches-existing-object none +)
}

sp {match-existing-object*propose*matches-none
    (state <s> ^name match-existing-object)
    -->
    (<s> ^operator <o> +)
    (<o> ^name matches-none +)
}

sp {match-existing-object*apply*matches-object-handle
    (state <s> ^name match-existing-object ^operator <o> ^superstate <ss>)
    (<o> ^name matches-object-handle ^object-info <obj-info>)
    -->
    (<ss> ^matches-existing-object <obj-info> +)
}

sp {match-existing-object*propose*matches-object-handle
    (state <s> ^name match-existing-object ^source-obj <s*1>
          ^object-monitor <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> ^object-handle <handle>)
    (<s*1> ^handle <handle>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name matches-object-handle + ^object-info <obj-info> +)
}

sp {match-existing-object*elaborate*overlap-result*overlapper-info
    (state <s> ^name match-existing-object ^overlap-results <o*1>
          ^object-monitor <o*2>)
    (<o*2> ^object-info <known-obj-info>)
    (<known-obj-info> ^belief-obj <b*1>)
    (<b*1> ^id <known-bel-id>)
    (<o*1> ^result <res>)
    (<res> ^object-b <known-bel-id>)
    -->
    (<res> ^overlapper-info <known-obj-info> +)
}

sp {match-existing-object*elaborate*overlap-results
    (state <s> ^name match-existing-object)
    -->
    (<s> ^overlap-results <cmd> +)
}

sp {match-existing-object*elaborate*contained-threshold
    (state <s> ^name match-existing-object ^agent-params <a*1>)
    (<a*1> ^contained-threshold <thresh>)
    -->
    (<s> ^contained-threshold <thresh> +)
}

sp {match-existing-object*elaborate*object-info
    (state <s> ^source-type perception-obj ^name match-existing-object
          ^source-obj <obj> ^object-monitor <o*1>)
    (<o*1> ^new-object-info <new-obj-info>)
    (<new-obj-info> ^perception-obj <obj>)
    -->
    (<s> ^object-info <new-obj-info> +)
}

sp {match-existing-object*elaborate*object-monitor*from*top-state
    (state <s> ^name match-existing-object ^top-state <t*1>)
    (<t*1> ^perception-monitor <p*1>)
    (<p*1> ^object-monitor <omon>)
    -->
    (<s> ^object-monitor <omon> +)
}

sp {match-existing-object*elaborate*source*info*from*superoperator
    (state <s> ^name match-existing-object ^superstate <s*1>)
    (<s*1> ^operator <ssop>)
    (<ssop> ^source-obj <obj> ^source-type <type>)
    -->
    (<s> ^source-type <type> + ^source-obj <obj> +)
}

sp {attend-to-new-object*propose*add-object-to-world
    (state <s> ^name attend-to-new-object ^new-object-rep <obj>
          ^source-obj <source> ^source-type <type>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name add-object-to-world + ^source-obj <obj> + ^source-type <type> +
           ^new-object-rep <obj> +)
}

sp {attend-to-new-object*elaborate*create-new-object*smem-obj*perception-obj
    (state <s> ^source-type perception-obj ^name attend-to-new-object
          ^operator <o> + ^matches-smem-object { <> none <lti> }
          ^object-monitor <obj-mon>)
    (<o> ^name create-new-object)
    (<lti> ^handle <handle>)
   -{ (<obj-mon> ^object-info <o*1>)
      (<o*1> ^object-handle <handle>)}
    -->
    (<o> ^smem-obj <lti> +)
}

sp {attend-to-new-object*elaborate*create-new-object*smem-obj*non*perception-obj
    (state <s> ^name attend-to-new-object ^operator <o> +
          ^matches-smem-object { <> none <lti> }
          ^source-type { <> perception-obj <s*1> })
    (<o> ^name create-new-object)
    -->
    (<o> ^smem-obj <lti> +)
}

sp {attend-to-new-object*propose*create-new-object
    (state <s> ^matches-existing-object none -^new-object-rep <n*1>
          ^name attend-to-new-object ^source-obj <source> ^source-type <type>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-new-object + ^source-obj <source> +
           ^source-type <type> +)
}

sp {attend-to-new-object*propose*update-existing-object
    (state <s> ^name attend-to-new-object
          ^matches-existing-object { <> none <obj> } ^source-obj <source>
          ^source-type <type>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name update-existing-object + ^source-obj <source> +
           ^source-type <type> + ^existing-obj <obj> +)
}

sp {attend-to-new-object*propose*match-existing-object
    (state <s> ^name attend-to-new-object -^matches-existing-object <any>
          ^source-obj <source> ^source-type <type>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name match-existing-object + ^source-obj <source> +
           ^source-type <type> +)
}

sp {prefer*match-smem-object*over*create-new-object
    (state <s> ^name attend-to-new-object ^operator <o2> + ^operator <o1> +)
    (<o2> ^name create-new-object)
    (<o1> ^name match-smem-object)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*match-existing*over*match-smem
    (state <s> ^name attend-to-new-object ^operator <o2> + ^operator <o1> +)
    (<o2> ^name match-smem-object)
    (<o1> ^name { << match-existing-object update-existing-object >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {attend-to-new-object*elaborate*perception-object-info
    (state <s> ^source-type perception-obj ^name attend-to-new-object
          ^source-obj <pobj> ^object-monitor <o*1>)
    (<o*1> ^new-object-info <obj-info>)
    (<obj-info> ^perception-obj <pobj>)
    -->
    (<s> ^perception-object-info <obj-info> +)
}

sp {attend-to-new-object*elaborate*object-monitor
    (state <s> ^name attend-to-new-object ^top-state <t*1>)
    (<t*1> ^perception-monitor <p*1>)
    (<p*1> ^object-monitor <obj-mon>)
    -->
    (<s> ^object-monitor <obj-mon> +)
}

sp {attend-to-new-object*elaborate*source*info*from*superoperator
    (state <s> ^name attend-to-new-object ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1>
          ^{ << perception-obj smem-obj epmem-obj imagined-obj >> <type> } <obj>)
    -->
    (<s> ^source-type <type> + ^source-obj <obj> +)
}

sp {check-object-stability*apply*mark-unstable*reset*filters
    (state <s> ^name check-object-stability ^operator <o> ^top-state <t*1>)
    (<o> ^name mark-unstable ^object-info <obj-info>)
    (<obj-info> ^perception-obj <p*1>)
    (<p*1> ^id <id>)
    (<t*1> ^svs <s*1>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^extract <pos> + ^extract <vol> +)
    (<pos> ^type monitor_position + ^a <pa> +)
    (<pa> ^type node + ^id <id> +)
    (<obj-info> ^position-monitor <pos> + ^volume-monitor <vol> +)
    (<vol> ^type monitor_volume + ^a <va> +)
    (<va> ^type node + ^id <id> +)
}

sp {check-object-stability*apply*mark-unstable*remove*filters
    (state <s> ^name check-object-stability ^operator <o> ^top-state <t*1>)
    (<o> ^name mark-unstable ^object-info <obj-info>)
    (<obj-info> ^volume-monitor <old-vol> ^position-monitor <old-pos>
          ^perception-obj <p*1>)
    (<p*1> ^id <id>)
    (<t*1> ^svs <s*1>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^extract <old-pos> - ^extract <old-vol> -)
    (<obj-info> ^position-monitor <old-pos> - ^volume-monitor <old-vol> -)
}

sp {check-object-stability*apply*mark-unstable*reset*timers
    (state <s> ^name check-object-stability ^operator <o> ^agent-params <a*1>
          ^io <i*1>)
    (<o> ^name mark-unstable ^object-info <obj-info>)
    (<obj-info> ^number-checks <num> ^check-stability-time <old-t>)
    (<a*1> ^stability-check-duration <dur>)
    (<i*1> ^input-link <i*2>)
    (<i*2> ^time <t*1>)
    (<t*1> ^seconds <cur-t>)
    -->
    (<obj-info> ^check-stability-time <old-t> -
           ^check-stability-time (+ <cur-t> <dur>) + ^number-checks <num> -
           ^number-checks (+ <num> 1) +)
}

sp {check-object-stability*propose*mark-unstable
    (state <s> ^obj-is-stable false ^name check-object-stability
          ^object-info <obj-info>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name mark-unstable + ^object-info <obj-info> +)
}

sp {check-object-stability*apply*mark-stable*remove*filters
    (state <s> ^name check-object-stability ^operator <o> ^top-state <t*1>)
    (<o> ^name mark-stable ^object-info <obj-info>)
    (<obj-info> ^volume-monitor <old-vol> ^position-monitor <old-pos>
          ^perception-obj <p*1>)
    (<p*1> ^id <id>)
    (<t*1> ^svs <s*1>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^extract <old-pos> - ^extract <old-vol> -)
    (<obj-info> ^position-monitor <old-pos> - ^volume-monitor <old-vol> -)
}

sp {check-object-stability*apply*mark-stable*cleanup*object
    (state <s> ^name check-object-stability ^operator <o>)
    (<o> ^name mark-stable ^object-info <obj-info>)
    (<obj-info> ^number-checks <num> ^check-stability-time <t>)
    -->
    (<obj-info> ^number-checks <num> - ^check-stability-time <t> -)
}

sp {check-object-stability*apply*mark-stable*mark*confirmed
    (state <s> ^name check-object-stability ^operator <o>)
    (<o> ^name mark-stable ^object-info <obj-info>)
    (<obj-info> ^confirmed false)
    -->
    (<obj-info> ^confirmed false - ^confirmed true +)
}

sp {check-object-stability*propose*mark-stable
    (state <s> ^obj-is-stable true ^name check-object-stability
          ^object-info <obj-info>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name mark-stable + ^object-info <obj-info> +)
}

sp {check-object-stability*elaborate*obj-is-stable*false*more-checks
    (state <s> ^name check-object-stability ^max-checks <max>
          ^object-info <o*1> ^{ << stable-pos stable-vol >> <a*1> } false)
    (<o*1> ^number-checks { < <max> <n*1> })
    -->
    (<s> ^obj-is-stable false +)
}

sp {check-object-stability*elaborate*obj-is-stable*true*timeout
    (state <s> ^name check-object-stability ^max-checks <max>
          ^object-info <o*1> ^{ << stable-pos stable-vol >> <a*1> } false)
    (<o*1> ^number-checks { >= <max> <n*1> })
    -->
    (<s> ^obj-is-stable true +)
}

sp {check-object-stability*elaborate*obj-is-stable*true
    (state <s> ^stable-vol true ^stable-pos true ^name check-object-stability)
    -->
    (<s> ^obj-is-stable true +)
}

sp {check-object-stability*elaborate*stable-vol*false*high
    (state <s> ^name check-object-stability ^vol-high-threshold <high>
          ^vol-diff { >= <high> <v*1> })
    -->
    (<s> ^stable-vol false +)
}

sp {check-object-stability*elaborate*stable-vol*false*low
    (state <s> ^name check-object-stability ^vol-low-threshold <low>
          ^vol-diff { <= <low> <v*1> })
    -->
    (<s> ^stable-vol false +)
}

sp {check-object-stability*elaborate*stable-vol*true
    (state <s> ^name check-object-stability ^vol-high-threshold <high>
          ^vol-low-threshold <low> ^vol-diff { < <high> > <low> <v*1> })
    -->
    (<s> ^stable-vol true +)
}

sp {check-object-stability*elaborate*stable-pos*false
    (state <s> ^name check-object-stability ^pos-threshold <t>
          ^pos-diff { >= <t> <p*1> })
    -->
    (<s> ^stable-pos false +)
}

sp {check-object-stability*elaborate*stable-pos*true
    (state <s> ^name check-object-stability ^pos-threshold <t>
          ^pos-diff { < <t> <p*1> })
    -->
    (<s> ^stable-pos true +)
}

sp {check-object-stability*elaborate*vol-diff
    (state <s> ^name check-object-stability ^object-info <o*1>)
    (<o*1> ^volume-monitor <v*1>)
    (<v*1> ^result <r*1>)
    (<r*1> ^record <r*2>)
    (<r*2> ^value <val>)
    -->
    (<s> ^vol-diff <val> +)
}

sp {check-object-stability*elaborate*pos-diff
    (state <s> ^name check-object-stability ^object-info <o*1>)
    (<o*1> ^position-monitor <p*1>)
    (<p*1> ^result <r*1>)
    (<r*1> ^record <r*2>)
    (<r*2> ^value <val>)
    -->
    (<s> ^pos-diff <val> +)
}

sp {check-object-stability*elaborate*thresholds
    (state <s> ^name check-object-stability ^agent-params <params>)
    (<params> ^max-stability-checks <max> ^vol-high-diff-threshold <vht>
          ^vol-low-diff-threshold <vlt> ^pos-diff-threshold <pdt>)
    -->
    (<s> ^pos-threshold <pdt> + ^vol-low-threshold <vlt> +
           ^vol-high-threshold <vht> + ^max-checks <max> +)
}

sp {check-object-stability*elaborate*object-info
    (state <s> ^name check-object-stability ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^object-info <obj-info>)
    -->
    (<s> ^object-info <obj-info> +)
}

sp {anystate*apply*attend-to-scene-change*new-perception-object*create*filters
    (state <s> ^operator <o> ^top-state <t*1>)
    (<o> ^name attend-to-scene-change ^change <change>)
    (<change> ^type new-perception-object ^object-info <obj-info>)
    (<obj-info> ^perception-obj <p*1>)
    (<p*1> ^id <id>)
    (<t*1> ^svs <s*1>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^extract <pos> + ^extract <vol> +)
    (<pos> ^type monitor_position + ^a <pa> +)
    (<pa> ^type node + ^id <id> +)
    (<obj-info> ^position-monitor <pos> + ^volume-monitor <vol> +)
    (<vol> ^type monitor_volume + ^a <va> +)
    (<va> ^type node + ^id <id> +)
}

sp {anystate*apply*attend-to-scene-change*new-perception-object*add*status
    (state <s> ^operator <o> ^agent-params <a*1> ^io <i*1>)
    (<o> ^name attend-to-scene-change ^change <change>)
    (<change> ^type new-perception-object ^object-info <obj-info>)
    (<a*1> ^stability-check-duration <dur>)
    (<i*1> ^input-link <i*2>)
    (<i*2> ^time <t*1>)
    (<t*1> ^seconds <t>)
    -->
    (<obj-info> ^confirmed false + ^check-stability-time (+ <t> <dur>) +
           ^number-checks 0 +)
}

sp {anystate*apply*attend-to-scene-change*monitor*changed-arm-moving-status
    (state <s> ^agent-params <a*1> ^operator <o>)
    (<a*1> ^debug-perception true)
    (<o> ^name attend-to-scene-change ^change <c>)
    (<c> ^type changed-arm-moving-status ^self-info <s*1>)
    (<s*1> ^arm <a*2>)
    (<a*2> ^moving-status <status>)
    -->
    (write |arm moving-status: | <status> (crlf))
}

sp {anystate*apply*attend-to-changed-arm-moving-status*remove*old*moving-status
    (state <s> ^operator <o> ^top-state <t*1>)
    (<o> ^name attend-to-scene-change ^change <c*1> ^change <c*2>)
    (<c*1> ^type changed-arm-moving-status)
    (<c*2> ^self-info <s*1>)
    (<s*1> ^arm <a*1>)
    (<a*1> ^moving-status <cur-status>)
    (<t*1> ^world <w*1>)
    (<w*1> ^robot <r*1>)
    (<r*1> ^arm <arm>)
    (<arm> ^moving-status { <> <cur-status> <old-status> })
    -->
    (<arm> ^moving-status <old-status> -)
}

sp {anystate*apply*attend-to-changed-arm-moving-status*add*current*moving-status
    (state <s> ^operator <o> ^top-state <t*1>)
    (<o> ^name attend-to-scene-change ^change <c*1> ^change <c*2>)
    (<c*1> ^type changed-arm-moving-status)
    (<c*2> ^self-info <s*1>)
    (<s*1> ^arm <a*1>)
    (<a*1> ^moving-status <cur-status>)
    (<t*1> ^world <w*1>)
    (<w*1> ^robot <r*1>)
    (<r*1> ^arm <arm>)
    -->
    (<arm> ^moving-status <cur-status> +)
}

sp {anystate*apply*attend-to-scene-change*monitor*changed-moving-status
    (state <s> ^agent-params <a*1> ^operator <o>)
    (<a*1> ^debug-perception true)
    (<o> ^name attend-to-scene-change ^change <c>)
    (<c> ^type changed-moving-status ^self-info <s*1>)
    (<s*1> ^moving-status <status>)
    -->
    (write |robot moving-status: | <status> (crlf))
}

sp {anystate*apply*attend-to-scene-change*changed-moving-status*remove*old
    (state <s> ^operator <o> ^top-state <t*1>)
    (<o> ^name attend-to-scene-change ^change <c>)
    (<c> ^type changed-moving-status ^self-info <s*1>)
    (<s*1> ^moving-status <cur-state>)
    (<t*1> ^world <w*1>)
    (<w*1> ^robot <robot>)
    (<robot> ^moving-status { <> <cur-state> <old-state> })
    -->
    (<robot> ^moving-status <old-state> -)
}

sp {anystate*apply*attend-to-scene-change*changed-moving-status*add*new
    (state <s> ^operator <o> ^top-state <t*1>)
    (<o> ^name attend-to-scene-change ^change <c>)
    (<c> ^type changed-moving-status ^self-info <s*1>)
    (<s*1> ^moving-status <cur-state>)
    (<t*1> ^world <w*1>)
    (<w*1> ^robot <robot>)
    -->
    (<robot> ^moving-status <cur-state> +)
}

sp {attend-to-scene-change*elaborate*attend-to-change*info
    (state <s> ^name attend-to-scene-change ^scene-change <s*1>
          ^operator <o> +)
    (<o> ^change-type <type>)
    (<s*1> ^{ <> type <att> } <val>)
    -->
    (<o> ^<att> <val> +)
}

sp {attend-to-scene-change*propose*attend-to-change
    (state <s> ^name attend-to-scene-change ^change-info <info>)
    (<info> ^op-name <op-name> ^type <type>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name <op-name> + ^change-type <type> +)
}

sp {anystate*scene-change*attend*preference*80
    (state <s> ^operator <o> +)
    (<o> ^name attend-to-scene-change ^change <c*1>)
    (<c*1> ^type { << missing-object >> <t*1> })
    -->
    (<o> ^preference-order 80 +)
}

sp {anystate*scene-change*attend*preference*100
    (state <s> ^operator <o> +)
    (<o> ^name attend-to-scene-change ^change <c*1>)
    (<c*1>
          ^type { << newly-visible-object newly-not-visible-object new-object-predicate >> <t*1> })
    -->
    (<o> ^preference-order 100 +)
}

sp {anystate*scene-change*attend*preference*120
    (state <s> ^operator <o> +)
    (<o> ^name attend-to-scene-change ^change <c*1>)
    (<c*1> ^type { << moved-object >> <t*1> })
    -->
    (<o> ^preference-order 120 +)
}

sp {anystate*scene-change*attend*preference*140
    (state <s> ^operator <o> +)
    (<o> ^name attend-to-scene-change ^change <c*1>)
    (<c*1> ^type { << stability-timer-expired >> <t*1> })
    -->
    (<o> ^preference-order 140 +)
}

sp {anystate*scene-change*attend*preference*160
    (state <s> ^operator <o> +)
    (<o> ^name attend-to-scene-change ^change <c*1>)
    (<c*1>
          ^type { << changed-moving-status changed-arm-moving-status >> <t*1> })
    -->
    (<o> ^preference-order 160 +)
}

sp {anystate*scene-change*attend*preference*180
    (state <s> ^operator <o> +)
    (<o> ^name attend-to-scene-change ^change <c*1>)
    (<c*1> ^type { << changed-waypoint >> <t*1> })
    -->
    (<o> ^preference-order 180 +)
}

sp {anystate*scene-change*attend*preference*190
    (state <s> ^operator <o> +)
    (<o> ^name attend-to-scene-change ^change <c*1>)
    (<c*1> ^type { << new-perception-object new-object >> <t*1> })
    -->
    (<o> ^preference-order 190 +)
}

sp {anystate*scene-change*attend*preference*200
    (state <s> ^operator <o> +)
    (<o> ^name attend-to-scene-change ^change <c*1>)
    (<c*1>
          ^type { << update-pose delete-object create-belief-object >> <t*1> })
    -->
    (<o> ^preference-order 200 +)
}

sp {anystate*attend-to-scene-change*elaborate*default*preference-order
    (state <s> ^operator <o> +)
    (<o> -^preference-order { > 0 <p*1> } ^name attend-to-scene-change)
    -->
    (<o> ^preference-order 0 +)
}

sp {anystate*attend-to-scene-change*prefer*equal*same*preference-order
    (state <s> ^operator <o2> + ^operator <o1> +)
    (<o2> ^name attend-to-scene-change ^preference-order <pref>)
    (<o1> ^name attend-to-scene-change ^preference-order <pref>)
    -->
    (<s> ^operator <o1> = <o2>)
}

sp {anystate*attend-to-scene-change*prefer*higher*preference-order
    (state <s> ^operator <o2> + ^operator <o1> +)
    (<o2> ^name attend-to-scene-change ^preference-order <p*1>)
    (<o1> ^name attend-to-scene-change ^preference-order { > <p*1> <pref1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {anystate*reject*attend-to-scene-change*moving*object
    (state <s> ^operator <o> +)
    (<o> ^name attend-to-scene-change ^change <chg>)
    (<chg> ^info <i*1> ^object-info <o*1>
          ^type { <> newly-not-visible-object <t*2> }
          ^type { <> newly-visible-object <t*1> })
    (<i*1> ^category object)
    (<o*1> ^wm-obj <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^arm-status { << moving grabbed >> <a*1> })
    -->
    (<s> ^operator <o> -)
}

sp {attend-to-scene-change*elaborate*change-info
    (state <s> ^name attend-to-scene-change ^scene-change <s*1>
          ^top-state <t*1>)
    (<t*1> ^perception-monitor <p*1>)
    (<p*1> ^change-info <c*1>)
    (<c*1> ^change <change-info>)
    (<change-info> ^type <change-type>)
    (<s*1> ^type <change-type>)
    -->
    (<s> ^change-info <change-info> +)
}

sp {attend-to-scene-change*elaborate*scene-change
    (state <s> ^name attend-to-scene-change ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^change <change>)
    -->
    (<s> ^scene-change <change> +)
}

sp {top-state*perception-monitor*predicate-monitor*copy*smem-query*result*as*smem-info
    :o-support
    (state <s> ^superstate nil ^smem-query <query> ^perception-monitor <p*1>)
    (<p*1> ^predicate-monitor <p*2>)
    (<p*2> ^predicate-info <info>)
    (<info> ^predicate-handle <pred-handle>)
    (<query> ^cue <c*1> ^result <res>)
    (<c*1> ^handle <pred-handle>)
    -->
    (<info> ^smem-info <res> +)
}

sp {top-state*perception-monitor*predicate-monitor*elaborate*smem-query*predicate
    (state <s> ^world-usage external ^superstate nil ^perception-monitor <p*1>)
    (<p*1> ^predicate-monitor <p*2>)
    (<p*2> ^predicate-info <info>)
    (<info> -^smem-info <s*1> ^predicate-handle <pred-handle>)
    -->
    (<s> ^smem-query <query> +)
    (<query> ^cue <cue> + ^depth 2 +)
    (<cue> ^handle <pred-handle> +)
}

sp {top-state*perception-monitor*predicate*monitor*object-test*elaborate*match
    (state <s> ^perception-monitor <p*1> ^world <w*1>)
    (<p*1> ^predicate-monitor <p*2>)
    (<p*2> ^predicate-info <pred-info>)
    (<pred-info> ^object-test <test>)
    (<test> ^x <x*1> ^object { <> <obj2> <obj> })
    (<w*1> ^objects <objs>)
    (<x*1> ^result <r*1>)
    (<r*1> ^record <r*2>)
    (<r*2> ^params <p*3>)
    (<p*3> ^b <id>)
    (<objs> ^object <obj2>)
    (<obj2> ^svs-obj <s*1>)
    (<s*1> ^id <id>)
    -->
    (<test> ^match <obj2> +)
}

sp {top-state*perception-monitor*predicate-monitor*object-test*put*on*svs*command
    (state <s> ^perception-monitor <p*1> ^svs <s*1>)
    (<p*1> ^predicate-monitor <p*2>)
    (<p*2> ^predicate-info <pred-info>)
    (<pred-info> ^object-test <test>)
    (<test> ^x <filter>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^extract <filter> +)
    (<filter> ^mark test +)
}

sp {top-state*perception-monitor*predicate-monitor*object-test*connect*z*belief-nodes
    (state <s> ^perception-monitor <p*1>)
    (<p*1> ^predicate-monitor <p*2>)
    (<p*2> ^predicate-info <pred-info>)
    (<pred-info> ^object-test <test>)
    (<test> ^z <z>)
    -->
    (<z> ^b <belief-nodes> +)
    (<belief-nodes> ^type tag_select + ^a <a*1> + ^tag_name object-source +
           ^tag_value belief +)
    (<a*1> ^type all_nodes +)
}

sp {top-state*perception-monitor*predicate-monitor*object-test*connect*yz
    (state <s> ^perception-monitor <p*1>)
    (<p*1> ^predicate-monitor <p*2>)
    (<p*2> ^predicate-info <pred-info>)
    (<pred-info> ^object-test <test>)
    (<test> ^z <z> ^y <y>)
    -->
    (<y> ^b <z> +)
}

sp {top-state*perception-monitor*predicate-monitor*object-test*connect*xy
    (state <s> ^perception-monitor <p*1>)
    (<p*1> ^predicate-monitor <p*2>)
    (<p*2> ^predicate-info <pred-info>)
    (<pred-info> ^object-test <test>)
    (<test> ^y <y> ^x <x>)
    -->
    (<x> ^b <y> +)
}

sp {top-state*perception-monitor*predicate-monitor*object-test*copy*top*bottom
    (state <s> ^perception-monitor <p*1>)
    (<p*1> ^predicate-monitor <p*2>)
    (<p*2> ^predicate-info <pred-info>)
    (<pred-info> ^object-test <test> ^smem-info <s*1>)
    (<s*1> ^relation <r>)
    (<r> ^axis <axis> ^top <top> ^bottom <bot>)
    (<test> ^<axis> <axis-filter>)
    -->
    (<axis-filter> ^bottom <bot> + ^top <top> +)
}

sp {top-state*perception-monitor*predicate-monitor*object-test*copy*relation*types
    (state <s> ^perception-monitor <p*1>)
    (<p*1> ^predicate-monitor <p*2>)
    (<p*2> ^predicate-info <pred-info>)
    (<pred-info> ^object-test <test> ^smem-info <s*1>)
    (<s*1> ^relation <r>)
    (<r> ^axis <axis> ^type <type>)
    (<test> ^<axis> <axis-filter>)
    -->
    (<axis-filter> ^<type> true +)
}

sp {top-state*perception-monitor*predicate-monitor*object-test*elaborate*axis*filters*local
    (state <s> ^superstate nil ^perception-monitor <p*1>)
    (<p*1> ^predicate-monitor <p*2>)
    (<p*2> ^predicate-info <pred-info>)
    (<pred-info> ^smem-info <s*2> ^object-test <test> ^smem-info <s*1>)
    (<s*2> ^reference-frame local)
    (<s*1> ^relation <r>)
    (<r> ^axis <axis>)
    (<test> ^object <o*1>)
    (<o*1> ^svs-obj <s*3>)
    (<s*3> ^id <id>)
    -->
    (<test> ^<axis> <axis-filter> +)
    (<axis-filter> ^type axis_relation_select + ^axis <axis> + ^a <a> +
           ^reference <ref> +)
    (<a> ^type node + ^id <id> + ^base a +)
    (<ref> ^type node + ^id robot +)
}

sp {top-state*perception-monitor*predicate-monitor*object-test*elaborate*axis*filters*global
    (state <s> ^superstate nil ^perception-monitor <p*1>)
    (<p*1> ^predicate-monitor <p*2>)
    (<p*2> ^predicate-info <pred-info>)
   -{ (<pred-info> ^smem-info <s*2>)
      (<s*2> ^reference-frame local)}
    (<pred-info> ^object-test <test> ^smem-info <s*1>)
    (<s*1> ^relation <r>)
    (<r> ^axis <axis>)
    (<test> ^object <o*1>)
    (<o*1> ^svs-obj <s*3>)
    (<s*3> ^id <id>)
    -->
    (<test> ^<axis> <axis-filter> +)
    (<axis-filter> ^type axis_relation_select + ^axis <axis> + ^a <a> +)
    (<a> ^type node + ^id <id> + ^base a +)
}

sp {top-state*perception-monitor*object-monitor*elaborate*change*recheck-occlusion
    (state <s> ^superstate nil ^perception-monitor <perc-mon>)
    (<perc-mon> ^changes <changes> ^object-monitor <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> ^status <s*1>)
    (<s*1> ^occlusion-timer-expired true)
    -->
    (<changes> ^change <change> +)
    (<change> ^type recheck-occlusion + ^object-info <obj-info> +)
}

sp {top-state*perception-monitor*elaborate*change-info*recheck-occlusion
    (state <s> ^superstate nil ^perception-monitor <p*1>)
    (<p*1> ^change-info <info>)
    -->
    (<info> ^change <recheck-occlusion> +)
    (<recheck-occlusion> ^type recheck-occlusion + ^category object +
           ^op-name check-for-occlusion +)
}

sp {top-state*perception-monitor*object-monitor*elaborate*change*grown-object
    (state <s> ^superstate nil ^agent-params <a*1>
          ^perception-monitor <perc-mon> ^world <w*1>)
    (<a*1> ^domain tabletop)
    (<perc-mon> ^changes <changes> ^object-monitor <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> ^differences <diffs>)
    (<diffs> -^growth-wait true ^has-grown true)
    (<w*1> ^robot <r*1>)
    (<r*1> ^arm <a*2>)
    (<a*2> ^moving-status stopped)
    -->
    (<changes> ^change <change> +)
    (<change> ^type grown-object + ^object-info <obj-info> +)
}

sp {top-state*perception-monitor*elaborate*change-info*grown-object
    (state <s> ^superstate nil ^perception-monitor <p*1>)
    (<p*1> ^change-info <info>)
    -->
    (<info> ^change <grown-obj> +)
    (<grown-obj> ^type grown-object + ^category object +
           ^op-name evaluate-grown-object +)
}

sp {top-state*perception-monitor*object-monitor*elaborate*change*shurnken-object
    (state <s> ^superstate nil ^agent-params <a*1>
          ^perception-monitor <perc-mon>)
    (<a*1> ^domain tabletop)
    (<perc-mon> ^changes <changes> ^object-monitor <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> ^differences <d*1> ^status <s*1>)
    (<d*1> ^has-shrunk true)
    (<s*1> ^is-occluded false)
    -->
    (<changes> ^change <change> +)
    (<change> ^type shrunken-object + ^object-info <obj-info> +)
}

sp {top-state*perception-monitor*elaborate*change-info*shrunken-object
    (state <s> ^superstate nil ^perception-monitor <p*1>)
    (<p*1> ^change-info <info>)
    -->
    (<info> ^change <shrunk-obj> +)
    (<shrunk-obj> ^type shrunken-object + ^category object +
           ^op-name evaluate-shrunken-object +)
}

sp {top-state*perception-monitor*object-monitor*elaborate*changes*new-object-predicate*non-visual
    (state <s> ^superstate nil ^perception-monitor <perc-mon>)
    (<perc-mon> ^changes <changes> ^object-monitor <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> ^properties <p*1> ^wm-obj <w*1>)
    (<p*1> ^property-info <prop-info>)
    (<prop-info> -^type visual ^property-handle <prop>
          ^predicate-handle <pred>)
    (<w*1> ^predicates <wm-preds>)
    (<wm-preds> -^<prop> <pred>)
    -->
    (<changes> ^change <change> +)
    (<change> ^type new-object-predicate + ^object-info <obj-info> +
           ^property-handle <prop> + ^predicate-handle <pred> +)
}

sp {top-state*perception-monitor*object-monitor*elaborate*changes*new-object-predicate*visual
    (state <s> ^superstate nil ^perception-monitor <perc-mon>)
    (<perc-mon> ^changes <changes> ^object-monitor <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> ^status <s*1> ^properties <p*1> ^wm-obj <w*1>)
    (<s*1> ^is-occluded false)
    (<p*1> ^property-info <prop-info>)
    (<prop-info> ^type visual ^property-handle <prop> ^predicate-handle <pred>)
    (<w*1> ^predicates <wm-preds>)
    (<wm-preds> -^<prop> <pred>)
    -->
    (<changes> ^change <change> +)
    (<change> ^type new-object-predicate + ^object-info <obj-info> +
           ^property-handle <prop> + ^predicate-handle <pred> +)
}

sp {top-state*perception-monitor*elaborate*change-info*new-object-predicate
    (state <s> ^superstate nil ^perception-monitor <p*1>)
    (<p*1> ^change-info <info>)
    -->
    (<info> ^change <new-obj-pred> +)
    (<new-obj-pred> ^type new-object-predicate + ^category object +
           ^op-name attend-to-new-object-predicate +)
}

sp {top-state*perception-monitor*object-monitor*elaborate*change*missing-object*magicbot
    (state <s> ^superstate nil ^agent-params <a*1>
          ^perception-monitor <perc-mon>)
    (<a*1> ^domain magicbot)
    (<perc-mon> ^changes <changes> ^object-monitor <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> ^status <status>)
    (<status> ^in-view true ^visible false)
    -->
    (<changes> ^change <change> +)
    (<change> ^type missing-object + ^object-info <obj-info> +)
}

sp {top-state*perception-monitor*object-monitor*elaborate*change*missing-object*tabletop
    (state <s> ^superstate nil ^agent-params <a*1>
          ^perception-monitor <perc-mon>)
    (<a*1> ^domain tabletop)
    (<perc-mon> ^changes <changes> ^object-monitor <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> ^status <status>)
    (<status> ^is-occluded false ^visible false)
    -->
    (<changes> ^change <change> +)
    (<change> ^type missing-object + ^object-info <obj-info> +)
}

sp {top-state*perception-monitor*elaborate*change-info*missing-object*magicbot
    (state <s> ^superstate nil ^agent-params <a*1> ^perception-monitor <p*1>)
    (<a*1> ^domain magicbot)
    (<p*1> ^change-info <info>)
    -->
    (<info> ^change <stale-obj> +)
    (<stale-obj> ^type missing-object + ^category object +
           ^op-name attend-to-missing-object +)
}

sp {top-state*perception-monitor*elaborate*change-info*missing-object*tabletop
    (state <s> ^superstate nil ^agent-params <a*1> ^perception-monitor <p*1>)
    (<a*1> ^domain tabletop)
    (<p*1> ^change-info <info>)
    -->
    (<info> ^change <missing-obj> +)
    (<missing-obj> ^type missing-object + ^category object +
           ^op-name attend-to-stale-object +)
}

sp {top-state*perception-monitor*object-monitor*elaborate*change*update-object
    (state <s> ^superstate nil ^perception-monitor <perc-mon>)
    (<perc-mon> ^changes <changes> ^object-monitor <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> ^update-pose true)
    -->
    (<changes> ^change <change> +)
    (<change> ^type update-pose + ^object-info <obj-info> +)
}

sp {top-state*perception-monitor*elaborate*change-info*update-pose
    (state <s> ^superstate nil ^perception-monitor <p*1>)
    (<p*1> ^change-info <info>)
    -->
    (<info> ^change <update-obj> +)
    (<update-obj> ^type update-pose + ^category object +
           ^op-name update-object-pose +)
}

sp {top-state*perception-monitor*object-monitor*elaborate*change*moved-object
    (state <s> ^superstate nil ^perception-monitor <perc-mon>)
    (<perc-mon> ^changes <changes> ^object-monitor <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> ^differences <d*1> ^status <s*1>)
    (<d*1> ^has-moved true)
    (<s*1> ^is-occluded false)
    -->
    (<changes> ^change <change> +)
    (<change> ^type moved-object + ^object-info <obj-info> +)
}

sp {top-state*perception-monitor*elaborate*change-info*moved-object*magicbot
    (state <s> ^superstate nil ^agent-params <a*1> ^perception-monitor <p*1>)
    (<a*1> ^domain magicbot)
    (<p*1> ^change-info <info>)
    -->
    (<info> ^change <moved-object> +)
    (<moved-object> ^type moved-object + ^category object +
           ^op-name update-pose +)
}

sp {top-state*perception-monitor*elaborate*change-info*moved-object*tabletop
    (state <s> ^superstate nil ^agent-params <a*1> ^perception-monitor <p*1>)
    (<a*1> ^domain tabletop)
    (<p*1> ^change-info <info>)
    -->
    (<info> ^change <moved-object> +)
    (<moved-object> ^type moved-object + ^category object +
           ^op-name check-for-occlusion +)
}

sp {top-state*perception-monitor*object-monitor*elaborate*change*delete-object
    (state <s> ^superstate nil ^perception-monitor <perc-mon>)
    (<perc-mon> ^changes <changes> ^object-monitor <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> ^delete-object true)
    -->
    (<changes> ^change <change> +)
    (<change> ^type delete-object + ^object-info <obj-info> +)
}

sp {top-state*perception-monitor*elaborate*change-info*delete-object
    (state <s> ^superstate nil ^perception-monitor <p*1>)
    (<p*1> ^change-info <info>)
    -->
    (<info> ^change <del-obj> +)
    (<del-obj> ^type delete-object + ^category object +
           ^op-name delete-object +)
}

sp {top-state*perception-monitor*object-monitor*elaborate*change*newly-not-visible-object
    (state <s> ^superstate nil ^perception-monitor <perc-mon>)
    (<perc-mon> ^changes <changes> ^object-monitor <o*1>)
    (<o*1> ^object-info <obj-info>)
   -{ (<obj-info> ^wm-obj <w*1>)
      (<w*1> ^predicates <p*1>)
      (<p*1> ^visible false)}
    (<obj-info> ^status <s*1>)
    (<s*1> ^visible false)
    -->
    (<changes> ^change <change> +)
    (<change> ^type newly-not-visible-object + ^object-info <obj-info> +)
}

sp {top-state*perception-monitor*elaborate*change-info*newly-not-visible-object
    (state <s> ^superstate nil ^perception-monitor <p*1>)
    (<p*1> ^change-info <info>)
    -->
    (<info> ^change <newly-not-vis-object> +)
    (<newly-not-vis-object> ^type newly-not-visible-object +
           ^category object + ^op-name attend-to-newly-not-visible-object +)
}

sp {top-state*perception-monitor*object-monitor*elaborate*change*newly-visible-object
    (state <s> ^superstate nil ^perception-monitor <perc-mon>)
    (<perc-mon> ^changes <changes> ^object-monitor <o*1>)
    (<o*1> ^object-info <obj-info>)
   -{ (<obj-info> ^wm-obj <w*1>)
      (<w*1> ^predicates <p*1>)
      (<p*1> ^visible true)}
    (<obj-info> ^status <s*1>)
    (<s*1> ^visible true)
    -->
    (<changes> ^change <change> +)
    (<change> ^type newly-visible-object + ^object-info <obj-info> +)
}

sp {top-state*perception-monitor*elaborate*change-info*newly-visible-object
    (state <s> ^superstate nil ^perception-monitor <p*1>)
    (<p*1> ^change-info <info>)
    -->
    (<info> ^change <newly-vis-object> +)
    (<newly-vis-object> ^type newly-visible-object + ^category object +
           ^op-name attend-to-newly-visible-object +)
}

sp {top-state*perception-monitor*object-monitor*elaborate*change*create-belief-object
    (state <s> ^superstate nil ^perception-monitor <perc-mon>)
    (<perc-mon> ^changes <changes> ^object-monitor <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> -^belief-obj <b*2> ^belief-id <b*1> ^perception-obj <pobj>)
    -->
    (<changes> ^change <change> +)
    (<change> ^type create-belief-object + ^object-info <obj-info> +)
}

sp {top-state*perception-monitor*elaborate*change-info*create-belief-object
    (state <s> ^superstate nil ^perception-monitor <p*1>)
    (<p*1> ^change-info <info>)
    -->
    (<info> ^change <create-belief-obj> +)
    (<create-belief-obj> ^type create-belief-object + ^category object +
           ^op-name create-belief-object +)
}

sp {top-state*perception-monitor*object-monitor*elaborate*change*new-object
    (state <s> ^superstate nil ^perception-monitor <perc-mon>)
    (<perc-mon> ^changes <changes> ^object-monitor <o*1>)
    (<o*1> ^new-object-info <obj-info>)
    (<obj-info> ^confirmed true ^perception-obj <p-obj>)
    -->
    (<changes> ^change <change> +)
    (<change> ^type new-object + ^perception-obj <p-obj> +)
}

sp {top-state*perception-monitor*elaborate*change-info*new-object
    (state <s> ^superstate nil ^perception-monitor <p*1>)
    (<p*1> ^change-info <info>)
    -->
    (<info> ^change <new-obj> +)
    (<new-obj> ^type new-object + ^category object +
           ^op-name attend-to-new-object +)
}

sp {top-state*perception-monitor*object-monitor*elaborate*change*evaluate-new-object
    (state <s> ^superstate nil ^perception-monitor <perc-mon>)
    (<perc-mon> ^changes <changes> ^object-monitor <o*1>)
    (<o*1> ^new-object-info <obj-info>)
    (<obj-info> ^status <s*1>)
    (<s*1> ^stability-timer-expired true)
    -->
    (<changes> ^change <change> +)
    (<change> ^type stability-timer-expired + ^object-info <obj-info> +)
}

sp {top-state*perception-monitor*elaborate*change-info*stability-timer-expired
    (state <s> ^superstate nil ^perception-monitor <p*1>)
    (<p*1> ^change-info <info>)
    -->
    (<info> ^change <stability-timer-expired> +)
    (<stability-timer-expired> ^type stability-timer-expired +
           ^category object + ^op-name check-object-stability +)
}

sp {top-state*perception-monitor*object-monitor*elaborate*change*new-perception-object
    (state <s> ^superstate nil ^perception-monitor <perc-mon>)
    (<perc-mon> ^changes <changes> ^object-monitor <o*1>)
    (<o*1> ^new-object-info <obj-info>)
    (<obj-info> -^confirmed <bool> ^perception-obj <perc-obj>)
    -->
    (<changes> ^change <change> +)
    (<change> ^type new-perception-object + ^object-info <obj-info> +)
}

sp {top-state*perception-monitor*elaborate*change-info*new-perception-object
    (state <s> ^superstate nil ^perception-monitor <p*1>)
    (<p*1> ^change-info <info>)
    -->
    (<info> ^change <new-obj> +)
    (<new-obj> ^type new-perception-object + ^category object +
           ^op-name attend-to-new-perception-object +)
}

sp {top-state*perception-monitor*object-monitor*object-info*property-info*elaborate*predicate-handle
    (state <s> ^superstate nil ^perception-monitor <p*1>)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^<any-type> <a*1>)
    (<a*1> ^properties <p*2>)
    (<p*2> ^property-info <prop-info>)
    (<prop-info> ^hypothesis <h>)
    (<h> ^best true ^lower-threshold <low-thresh>
          ^predicate-handle <pred-handle>)
   -{ (<prop-info> ^hypothesis { <> <h> <h2> })
      (<h2> ^confidence { > <low-thresh> <c*1> })}
    -->
    (<prop-info> ^predicate-handle <pred-handle> +)
}

sp {top-state*perception-monitor*object-monitor*object-info*property-info*elaborate*hypothesis*lower-threshold
    (state <s> ^superstate nil ^perception-monitor <p*1>)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^<any-type> <a*1>)
    (<a*1> ^properties <p*2>)
    (<p*2> ^property-info <prop-info>)
    (<prop-info> ^hypothesis <h>)
    (<h> ^best true ^confidence <conf>)
    -->
    (<h> ^lower-threshold (* <conf> 0.800000) +)
}

sp {top-state*perception-monitor*object-monitor*object-info*property-info*elaborate*hypothesis*best
    (state <s> ^superstate nil ^perception-monitor <p*1>)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^<any-type> <a*1>)
    (<a*1> ^properties <p*2>)
    (<p*2> ^property-info <prop-info>)
    (<prop-info> ^hypothesis <h1>)
    (<h1> ^confidence <best>)
   -{ (<prop-info> ^hypothesis <h*1>)
      (<h*1> ^confidence { > <best> <c*1> })}
    -->
    (<h1> ^best true +)
}

sp {top-state*perception-monitor*object-monitor*object-info*property-info*elaborate*hypothesis
    (state <s> ^superstate nil ^perception-monitor <p*1>)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^<any-type> <a*1>)
    (<a*1> ^properties <p*2>)
    (<p*2> ^property-info <prop-info>)
    (<prop-info> ^input-link-prop <i*1>)
    (<i*1> ^values <v*1>)
    (<v*1> ^<pred-handle> { > 0.100000 <conf> })
    -->
    (<prop-info> ^hypothesis <h> +)
    (<h> ^predicate-handle <pred-handle> + ^confidence <conf> +)
}

sp {top-state*perception-monitor*object-monitor*object-info*elaborate*property-info
    (state <s> ^superstate nil ^perception-monitor <p*1>)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^<any-type> <obj-info>)
    (<obj-info> ^properties <props> ^input-link-obj <i*1>)
    (<i*1> ^property <prop>)
    (<prop> ^property-handle <prop-handle> ^type <type>)
    -->
    (<props> ^property-info <prop-info> +)
    (<prop-info> ^property-handle <prop-handle> + ^type <type> +
           ^input-link-prop <prop> +)
}

sp {top-state*perception-monitor*object-monitor*object-info*elaborate*properties
    (state <s> ^superstate nil ^perception-monitor <p*1>)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^{ << object-info new-object-info >> <a*1> } <obj-info>)
    -->
    (<obj-info> ^properties <props> +)
}

sp {top-state*perception-monitor*object-monitor*object-info*status*elaborate*in-view*false
    (state <s> ^superstate nil ^perception-monitor <p*2>
          ^perception-monitor <p*1>)
    (<p*2> ^robot-view-filter <r*1>)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> ^belief-obj <b*1> ^status <status>)
    (<b*1> ^id <bel-id>)
    (<r*1> ^result <r*2>)
    (<r*2> ^record <r>)
    (<r> ^value false ^params <p*3>)
    (<p*3> ^b <bel-id>)
    -->
    (<status> ^in-view false +)
}

sp {top-state*perception-monitor*object-monitor*object-info*status*elaborate*in-view*true
    (state <s> ^superstate nil ^perception-monitor <p*2>
          ^perception-monitor <p*1>)
    (<p*2> ^robot-view-filter <r*1>)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> ^belief-obj <b*1> ^status <status>)
    (<b*1> ^id <bel-id>)
    (<r*1> ^result <r*2>)
    (<r*2> ^record <r>)
    (<r> ^value true ^params <p*3>)
    (<p*3> ^b <bel-id>)
    -->
    (<status> ^in-view true +)
}

sp {top-state*perception-monitor*object-monitor*object-info*status*elaborate*in-view*true*tabletop*domain
    (state <s> ^superstate nil ^agent-params <a*1> ^perception-monitor <p*1>)
    (<a*1> ^domain tabletop)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> ^status <status>)
    -->
    (<status> ^in-view true +)
}

sp {top-state*perception-monitor*object-monitor*object-info*growth-timer-expired
    (state <s> ^superstate nil ^perception-monitor <p*1> ^io <i*1>)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> ^check-growth-time <c*1> ^status <status>)
    (<i*1> ^input-link <i*2>)
    (<i*2> ^time <t*1>)
    (<t*1> ^seconds { >= <c*1> <t> })
    -->
    (<status> ^growth-timer-expired true +)
}

sp {top-state*perception-monitor*object-monitor*new-object-info*stability-timer-expired
    (state <s> ^superstate nil ^perception-monitor <p*1> ^io <i*1>)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^new-object-info <obj-info>)
    (<obj-info> ^check-stability-time <c*1> ^status <status>)
    (<i*1> ^input-link <i*2>)
    (<i*2> ^time <t*1>)
    (<t*1> ^seconds { >= <c*1> <t> })
    -->
    (<status> ^stability-timer-expired true +)
}

sp {top-state*perception-monitor*object-monitor*object-info*status*elaborate*occlusion-timer-expired*true
    (state <s> ^superstate nil ^perception-monitor <p*1> ^io <i*1>)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> ^status <status> ^check-occlusion-time <c*1>)
    (<status> ^is-occluded true)
    (<i*1> ^input-link <i*2>)
    (<i*2> ^time <t*1>)
    (<t*1> ^seconds { >= <c*1> <t> })
    -->
    (<status> ^occlusion-timer-expired true +)
}

sp {top-state*perception-monitor*object-monitor*object-info*status*elaborate*is-occluded*false
    (state <s> ^superstate nil ^perception-monitor <p*1>)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^object-info <o*2>)
    (<o*2> ^status <status>)
    (<status> -^is-occluded true)
    -->
    (<status> ^is-occluded false +)
}

sp {top-state*perception-monitor*object-monitor*object-info*status*elaborate*visible*false
    (state <s> ^superstate nil ^perception-monitor <p*1>)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> ^status <status>)
    (<status> -^visible true)
    -->
    (<status> ^visible false +)
}

sp {top-state*perception-monitor*object-monitor*object-info*status*elaborate*visible*true*current-location
    (state <s> ^superstate nil ^perception-monitor <p*1> ^io <i*1>)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> ^wm-obj <w*1> ^status <status>)
    (<w*1> ^waypoint <wp-handle>)
    (<i*1> ^input-link <i*2>)
    (<i*2> ^self <s*1>)
    (<s*1> ^current-waypoint <c*1>)
    (<c*1> ^waypoint-handle <wp-handle>)
    -->
    (<status> ^visible true +)
}

sp {top-state*perception-monitor*object-monitor*object-info*status*elaborate*visible*true
    (state <s> ^superstate nil ^perception-monitor <p*1>)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> ^perception-obj <perc-obj> ^status <status>)
    -->
    (<status> ^visible true +)
}

sp {top-state*perception-monitor*object-monitor*object-info*elaborate*status
    (state <s> ^superstate nil ^perception-monitor <p*1>)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^{ << object-info new-object-info >> <a*1> } <obj-info>)
    -->
    (<obj-info> ^status <status> +)
}

sp {top-state*perception-monitor*object-monitor*object-info*differences*elaborate*has-grown
    (state <s> ^superstate nil ^perception-monitor <p*1> ^agent-params <a*1>)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^object-info <o*2>)
    (<o*2> ^differences <diffs>)
    (<diffs> ^vol-diff <v*1>)
    (<a*1> ^vol-high-diff-threshold { < <v*1> <high> })
    -->
    (<diffs> ^has-grown true +)
}

sp {top-state*perception-monitor*object-monitor*object-info*differences*elaborate*has-shrunk
    (state <s> ^superstate nil ^perception-monitor <p*1> ^agent-params <a*1>)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^object-info <o*2>)
    (<o*2> ^differences <diffs>)
    (<diffs> ^vol-diff <v*1>)
    (<a*1> ^vol-low-diff-threshold { > <v*1> <low> })
    -->
    (<diffs> ^has-shrunk true +)
}

sp {top-state*perception-monitor*object-monitor*object-info*differences*elaborate*vol-diff
    (state <s> ^superstate nil ^perception-monitor <p*1>)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^object-info <o*2>)
    (<o*2> ^differences <diffs>)
    (<diffs> ^perception-vol <p*2> ^belief-vol <b*1>)
    (<p*2> ^result <r*3>)
    (<r*3> ^record <r*4>)
    (<b*1> ^result <r*1>)
    (<r*1> ^record <r*2>)
    (<r*4> ^value <perc-vol>)
    (<r*2> ^value <bel-vol>)
    -->
    (<diffs> ^vol-diff (|/| (+ <perc-vol> 0.000000) (+ <bel-vol> 0.000000)) +)
}

sp {top-state*perception-monitor*object-monitor*elaborate*svs-command*compare-volume
    (state <s> ^superstate nil ^perception-monitor <p*1> ^svs <s*1>)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> ^perception-obj <p*2> ^differences <diffs> ^belief-obj <b*1>)
    (<b*1> ^id <bel-id>)
    (<p*2> ^id <perc-id>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^extract <perc-vol> + ^extract <bel-vol> +)
    (<perc-vol> ^type volume + ^a <pa> + ^volume_type scale +)
    (<pa> ^type node + ^id <perc-id> +)
    (<bel-vol> ^type volume + ^a <ba> + ^volume_type scale +)
    (<ba> ^type node + ^id <bel-id> +)
    (<diffs> ^belief-vol <bel-vol> + ^perception-vol <perc-vol> +)
}

sp {top-state*perception-monitor*object-monitor*object-info*differences*elaborate*has-moved
    (state <s> ^superstate nil ^perception-monitor <p*1> ^agent-params <a*1>)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^object-info <o*2>)
    (<o*2> ^differences <diffs>)
    (<diffs> ^pos-diff <p*2>)
    (<a*1> ^pos-diff-threshold { < <p*2> <thresh> })
    -->
    (<diffs> ^has-moved true +)
}

sp {top-state*perception-monitor*object-monitor*object-info*differences*elaborate*pos-diff
    (state <s> ^superstate nil ^perception-monitor <p*1>)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^object-info <o*2>)
    (<o*2> ^differences <diffs>)
    (<diffs> ^compare-position <c*1>)
    (<c*1> ^result <r*1>)
    (<r*1> ^record <r*2>)
    (<r*2> ^value <val>)
    -->
    (<diffs> ^pos-diff <val> +)
}

sp {top-state*perception-monitor*object-monitor*elaborate*svs-command*compare-position*grabbed*magicbot
    (state <s> ^superstate nil ^agent-params <a*1> ^perception-monitor <p*1>
          ^svs <s*1>)
    (<a*1> ^domain magicbot)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> -^perception-obj <p*2> ^differences <diffs> ^wm-obj <w*1>
          ^belief-obj <b*1>)
    (<w*1> ^predicates <p*3>)
    (<p*3> ^arm-status grabbed)
    (<b*1> ^id <bel-id>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^extract <compare> +)
    (<compare> ^type distance + ^a <a> + ^b <b> + ^distance_type centroid +)
    (<a> ^type node + ^id robot +)
    (<b> ^type node + ^id <bel-id> +)
    (<diffs> ^compare-position <compare> +)
}

sp {top-state*perception-monitor*object-monitor*elaborate*svs-command*compare-position
    (state <s> ^superstate nil ^perception-monitor <p*1> ^svs <s*1>)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> ^perception-obj <p*2> ^differences <diffs> ^belief-obj <b*1>)
    (<b*1> ^id <bel-id>)
    (<p*2> ^id <perc-id>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^extract <compare> +)
    (<compare> ^type distance + ^a <a> + ^b <b> + ^distance_type centroid +)
    (<a> ^type node + ^id <perc-id> +)
    (<b> ^type node + ^id <bel-id> +)
    (<diffs> ^compare-position <compare> +)
}

sp {top-state*perception-monitor*object-monitor*object-info*elaborate*differences
    (state <s> ^superstate nil ^perception-monitor <p*1>)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^{ << object-info new-object-info >> <a*1> } <obj-info>)
    -->
    (<obj-info> ^differences <diffs> +)
}

sp {top-state*perception-monitor*object-monitor*object-info*elaborate*input-link-obj
    (state <s> ^superstate nil ^perception-monitor <p*1> ^io <i*1>)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> ^perception-id <perc-id>)
    (<i*1> ^input-link <i*2>)
    (<i*2> ^objects <o*2>)
    (<o*2> ^object <il-obj>)
    (<il-obj> ^object-handle <perc-id>)
    -->
    (<obj-info> ^input-link-obj <il-obj> +)
}

sp {top-state*perception-monitor*object-monitor*object-info*elaborate*perception-obj*internal
    (state <s> ^superstate nil ^perception-monitor <p*2>
          ^perception-monitor <p*1>)
    (<p*2> ^object-monitor <o*2>)
    (<o*2> ^object-info <obj-info2>)
    (<obj-info2> ^perception-obj <perc-obj> ^object-handle <handle2>)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^object-info <obj-info1>)
    (<obj-info1> ^internal-link <handle2> ^object-handle <handle1>)
    -->
    (<obj-info1> ^perception-obj <perc-obj> +)
}

sp {top-state*perception-monitor*object-monitor*object-info*elaborate*perception-obj
    (state <s> ^superstate nil ^perception-monitor <p*1> ^svs <s*1>)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> ^perception-id <perc-id>)
    (<s*1> ^spatial-scene <s*2>)
    (<s*2> ^child <perc-obj>)
    (<perc-obj> ^id <perc-id>)
    -->
    (<obj-info> ^perception-obj <perc-obj> +)
}

sp {top-state*perception-monitor*object-monitor*object-info*elaborate*belief-obj
    (state <s> ^superstate nil ^perception-monitor <p*1> ^svs <s*1>)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> ^belief-id <bel-id>)
    (<s*1> ^spatial-scene <s*2>)
    (<s*2> ^child <belief-obj>)
    (<belief-obj> ^id <bel-id>)
    -->
    (<obj-info> ^belief-obj <belief-obj> +)
}

sp {top-state*perception-monitor*object-monitor*new-object*elaborate*input-link-obj
    (state <s> ^superstate nil ^perception-monitor <p*1> ^io <i*1>)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^new-object-info <obj-info>)
    (<obj-info> ^object-handle <handle>)
    (<i*1> ^input-link <i*2>)
    (<i*2> ^objects <o*2>)
    (<o*2> ^object <il-obj>)
    (<il-obj> ^object-handle <handle>)
    -->
    (<obj-info> ^input-link-obj <il-obj> +)
}

sp {top-state*perception-monitor*object-monitor*elaborate*new-object-info*object-handle
    (state <s> ^superstate nil ^perception-monitor <p*1>)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^new-object-info <obj-info>)
    (<obj-info> ^perception-obj <p*2>)
    (<p*2> ^id <svs-id>)
    -->
    (<obj-info> ^object-handle <svs-id> +)
}

sp {top-state*perception-monitor*object-monitor*elaborate*new-object-info
    (state <s> ^superstate nil ^perception-monitor <p*1> ^svs <s*1>)
    (<p*1> ^object-monitor <obj-mon>)
    (<s*1> ^spatial-scene <s*2>)
    (<s*2> ^child <perc-obj>)
    (<perc-obj> -^id { << arm world eye robot >> <i*1> }
          ^object-source perception)
   -{ (<obj-mon> ^object-info <o*1>)
      (<o*1> ^perception-obj <perc-obj>)}
    -->
    (<obj-mon> ^new-object-info <new-obj-info> +)
    (<new-obj-info> ^perception-obj <perc-obj> +)
}

sp {top-state*perception-monitor*robot-monitor*elaborate*change*new-waypoint
    (state <s> ^top-state <s> ^perception-monitor <p*1> ^world <w*1> ^io <i*1>)
    (<p*1> ^changes <changes>)
    (<w*1> ^robot <robot>)
    (<i*1> ^input-link <i*2>)
    (<i*2> ^self <s*1>)
    (<s*1> ^current-waypoint <c*1>)
    (<c*1> ^waypoint-handle <wp-handle>)
   -{ (<robot> ^current-waypoint <c*2>)
      (<c*2> ^handle <wp-handle>)}
    -->
    (<changes> ^change <change> +)
    (<change> ^type changed-waypoint + ^new-waypoint-handle <wp-handle> +)
}

sp {top-state*perception-monitor*change-info*elaborate*changed-waypoint
    (state <s> ^top-state <s> ^perception-monitor <p*1>)
    (<p*1> ^change-info <info>)
    -->
    (<info> ^change <changed-waypoint> +)
    (<changed-waypoint> ^type changed-waypoint + ^category robot +
           ^op-name attend-to-changed-waypoint +)
}

sp {top-state*perception-monitor*robot-monitor*elaborate*change*changed-moving-status
    (state <s> ^top-state <s> ^perception-monitor <p*1> ^world <w*1> ^io <i*1>)
    (<p*1> ^changes <changes>)
    (<w*1> ^robot <robot>)
    (<i*1> ^input-link <i*2>)
    (<i*2> ^self <self>)
    (<self> ^moving-status <cur-status>)
    (<robot> -^moving-status <cur-status>)
    -->
    (<changes> ^change <change> +)
    (<change> ^type changed-moving-status + ^self-info <self> +)
}

sp {top-state*perception-monitor*change-info*elaborate*changed-moving-status
    (state <s> ^top-state <s> ^perception-monitor <p*1>)
    (<p*1> ^change-info <info>)
    -->
    (<info> ^change <changed-moving-status> +)
    (<changed-moving-status> ^type changed-moving-status + ^category robot +
           ^op-name attend-to-changed-moving-status +)
}

sp {top-state*perception-monitor*robot-monitor*elaborate*change*changed-arm-moving-status
    (state <s> ^top-state <s> ^perception-monitor <p*1> ^world <w*1> ^io <i*1>)
    (<p*1> ^changes <changes>)
    (<w*1> ^robot <r*1>)
    (<r*1> ^arm <arm>)
    (<i*1> ^input-link <i*2>)
    (<i*2> ^self <self>)
    (<self> ^arm <a*1>)
    (<a*1> ^moving-status <cur-status>)
    (<arm> -^moving-status <cur-status>)
    -->
    (<changes> ^change <change> +)
    (<change> ^type changed-arm-moving-status + ^self-info <self> +)
}

sp {top-state*perception-monitor*change-info*elaborate*changed-arm-moving-status
    (state <s> ^top-state <s> ^perception-monitor <p*1>)
    (<p*1> ^change-info <info>)
    -->
    (<info> ^change <changed-arm-moving-status> +)
    (<changed-arm-moving-status> ^type changed-arm-moving-status +
           ^category robot + ^op-name attend-to-changed-arm-moving-status +)
}

sp {topstate*manage-world-state*perception-monitor*elaborate*robot-view-filter
    (state <s> ^superstate nil ^agent-params <a*1> ^perception-monitor <pmon>
          ^svs <s*1>)
    (<a*1> ^domain magicbot)
    (<s*1> ^command <cmd>)
    -->
    (<pmon> ^robot-view-filter <filter> +)
    (<filter> ^type intersect + ^a <robot-view> + ^b <belief-objs> +
           ^intersect_type hull +)
    (<robot-view> ^type node + ^id robot_view +)
    (<belief-objs> ^type tag_select + ^tag_name object-source +
           ^tag_value belief + ^a <all> +)
    (<all> ^type all_nodes +)
    (<cmd> ^extract <filter> +)
}

sp {top-state*perception-monitor*elaborate*change*info
    (state <s> ^superstate nil ^perception-monitor <perc-mon>)
    (<perc-mon> ^change-info <c*2> ^changes <c*1>)
    (<c*2> ^change <info>)
    (<c*1> ^change <change>)
    (<info> ^type <change-type>)
    (<change> ^type <change-type>)
    -->
    (<change> ^info <info> +)
}

sp {top-state*world*object*predicates*elaborate*indicated*pointed
    (state <s> ^superstate nil ^world <w*1> ^io <i*1>)
    (<w*1> ^objects <o*1>)
    (<i*1> ^input-link <i*2>)
    (<i*2> ^pointed-object <h>)
    (<o*1> ^object <obj>)
    (<obj> ^handle <h> ^predicates <preds>)
    -->
    (<preds> ^indicated pointed +)
}

sp {top-state*world*object*predicates*elaborate*modifier1*current1
    (state <s> ^top-state <s> ^world <w*1>)
    (<w*1> ^robot <r*1>)
    (<r*1> ^current-location <loc>)
    (<loc> ^predicates <preds>)
    -->
    (<preds> ^modifier1 current1 +)
}

sp {top-state*world*elaborate*object*svs-obj
    (state <s> ^top-state <s> ^perception-monitor <p*1> ^world <w*1>)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^object-info <obj-info>)
    (<obj-info> ^wm-obj <wm-obj> ^belief-obj <bel-obj>)
    (<w*1> ^objects <objs>)
    -->
    (<wm-obj> ^svs-obj <bel-obj> +)
}

sp {top-state*world*predicates*elaborate*instance*using*linked*object*both
    (state <s> ^superstate nil ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <pred>)
    (<pred> ^instance <i>)
    (<i> ^2 <obj2> ^1 <obj1>)
    (<obj2> ^linked-to <link-obj2>)
    (<obj1> ^linked-to <link-obj1>)
    -->
    (<pred> ^instance <i2> +)
    (<i2> ^1 <link-obj1> + ^2 <link-obj2> +)
}

sp {top-state*world*predicates*elaborate*instance*using*linked*object*2
    (state <s> ^superstate nil ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <pred>)
    (<pred> ^instance <i>)
    (<i> ^2 <obj2> ^1 <obj1>)
    (<obj2> ^linked-to <link-obj2>)
    -->
    (<pred> ^instance <i2> +)
    (<i2> ^1 <obj1> + ^2 <link-obj2> +)
}

sp {top-state*world*predicates*elaborate*instance*using*linked*object*1
    (state <s> ^superstate nil ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <pred>)
    (<pred> ^instance <i>)
    (<i> ^2 <obj2> ^1 <obj1>)
    (<obj1> ^linked-to <link-obj1>)
    -->
    (<pred> ^instance <i2> +)
    (<i2> ^1 <link-obj1> + ^2 <obj2> +)
}

sp {top-state*world*predicates*elaborate*instance*from*predicate-monitor
    (state <s> ^superstate nil ^perception-monitor <p*1> ^world <w*1>)
    (<p*1> ^predicate-monitor <p*2>)
    (<p*2> ^predicate-info <pred-info>)
    (<pred-info> ^object-test <test> ^predicate-handle <pred-handle>)
    (<test> ^match <obj2> ^object <obj1>)
    (<w*1> ^predicates <p*3>)
    (<p*3> ^predicate <pred>)
    (<pred> ^handle <pred-handle>)
    -->
    (<pred> ^instance <args> +)
    (<args> ^1 <obj1> + ^2 <obj2> +)
}

sp {top-state*world*predicates*elaborate*predicate-monitor*object-test*relations
    (state <s> ^superstate nil ^perception-monitor <p*1> ^world <w*1>)
    (<p*1> ^predicate-monitor <p*2>)
    (<p*2> ^predicate-info <pred-info>)
    (<pred-info> ^smem-info <s*1>)
    (<s*1> ^item-type relation)
    (<w*1> ^objects <o*1>)
    (<o*1> ^object <obj>)
    (<obj> ^svs-obj <svs-obj>)
    -->
    (<pred-info> ^object-test <test> +)
    (<test> ^object <obj> +)
}

sp {top-state*world*predicates*elaborate*predicate
    (state <s> ^superstate nil ^perception-monitor <p*1> ^world <w*1>)
    (<p*1> ^predicate-monitor <p*2>)
    (<p*2> ^predicate-info <pred-info>)
    (<pred-info> ^predicate-handle <pred-handle>)
    (<w*1> ^predicates <preds>)
    -->
    (<preds> ^predicate <pred> +)
    (<pred> ^handle <pred-handle> +)
}

sp {top-state*world*robot*elaborate*arm*grabbed
    (state <s> ^superstate nil ^world <w*2> ^world <w*1>)
    (<w*2> ^robot <r*1>)
    (<r*1> ^arm <arm>)
    (<w*1> ^objects <o*1>)
    (<o*1> ^object <obj>)
    (<obj> ^predicates <p*1>)
    (<p*1> ^arm-status grabbed)
    -->
    (<arm> ^grabbed <obj> +)
}

sp {topstate*elaborate*map
    (state <s> ^superstate nil)
    -->
    (<s> ^maps <maps> +)
    (<maps> ^map <building> + ^map <world> +)
    (<world> ^handle world-map + ^waypoint <bwp01> +)
    (<bwp01> ^handle bwp01 + ^x 0 + ^y 0 + ^map <world> +
           ^sub-map <building> +)
    (<building> ^handle bmap1 + ^super-waypoint <bwp01> + ^waypoint <wp01> +
           ^waypoint <wp02> + ^waypoint <wp03> + ^waypoint <wp04> +
           ^waypoint <wp05> + ^waypoint <wp06> + ^waypoint <wp07> +)
    (<wp01> ^handle wp01 + ^handle-int 1 + ^x 5.000000 + ^y 5.000000 +
           ^map <building> + ^edge <e0105> +)
    (<e0105> ^start <wp01> + ^end <wp05> + ^wall-side 1 + ^doorway true +
           ^door_sx 9.200000 + ^door_sy 5.000000 + ^door_ex 10.800000 +
           ^door_ey 5.000000 +)
    (<wp02> ^handle wp02 + ^handle-int 2 + ^x 5.000000 + ^y 25.000000 +
           ^map <building> + ^edge <e0207> +)
    (<e0207> ^start <wp02> + ^end <wp07> + ^wall-side 1 + ^doorway true +
           ^door_sx 9.200000 + ^door_sy 25.000000 + ^door_ex 10.800000 +
           ^door_ey 25.000000 +)
    (<wp03> ^handle wp03 + ^handle-int 3 + ^x 17.000000 + ^y 5.000000 +
           ^map <building> + ^edge <e0305> +)
    (<e0305> ^start <wp03> + ^end <wp05> + ^wall-side 1 + ^doorway true +
           ^door_sx 12.799999 + ^door_sy 4.998726 + ^door_ex 11.200001 +
           ^door_ey 5.001274 +)
    (<wp04> ^handle wp04 + ^handle-int 4 + ^x 17.000000 + ^y 25.000000 +
           ^map <building> + ^edge <e0407> +)
    (<e0407> ^start <wp04> + ^end <wp07> + ^wall-side 1 + ^doorway true +
           ^door_sx 12.799999 + ^door_sy 24.998726 + ^door_ex 11.200001 +
           ^door_ey 25.001274 +)
    (<wp05> ^handle wp05 + ^handle-int 5 + ^x 11.000000 + ^y 5.000000 +
           ^map <building> + ^edge <e0501> + ^edge <e0503> + ^edge <e0506> +)
    (<e0501> ^start <wp05> + ^end <wp01> + ^wall-side -1 + ^doorway true +
           ^door_sx 10.800000 + ^door_sy 5.000000 + ^door_ex 9.200000 +
           ^door_ey 5.000000 +)
    (<e0503> ^start <wp05> + ^end <wp03> + ^wall-side -1 + ^doorway true +
           ^door_sx 11.200001 + ^door_sy 5.001274 + ^door_ex 12.799999 +
           ^door_ey 4.998726 +)
    (<e0506> ^start <wp05> + ^end <wp06> + ^wall-side 1 + ^doorway false +)
    (<wp06> ^handle wp06 + ^handle-int 6 + ^x 11.000000 + ^y 15.000000 +
           ^map <building> + ^edge <e0605> + ^edge <e0607> +)
    (<e0605> ^start <wp06> + ^end <wp05> + ^wall-side -1 + ^doorway false +)
    (<e0607> ^start <wp06> + ^end <wp07> + ^wall-side 1 + ^doorway false +)
    (<wp07> ^handle wp07 + ^handle-int 7 + ^x 11.000000 + ^y 25.000000 +
           ^map <building> + ^edge <e0702> + ^edge <e0704> + ^edge <e0706> +)
    (<e0702> ^start <wp07> + ^end <wp02> + ^wall-side -1 + ^doorway true +
           ^door_sx 10.800000 + ^door_sy 25.000000 + ^door_ex 9.200000 +
           ^door_ey 25.000000 +)
    (<e0704> ^start <wp07> + ^end <wp04> + ^wall-side -1 + ^doorway true +
           ^door_sx 11.200001 + ^door_sy 25.001274 + ^door_ex 12.799999 +
           ^door_ey 24.998726 +)
    (<e0706> ^start <wp07> + ^end <wp06> + ^wall-side -1 + ^doorway false +)
}

sp {top-state*apply*init-agent*create*world-state*tabletop
    (state <s> ^world-usage external ^superstate nil ^agent-params <a*1>
          ^operator <o*1>)
    (<a*1> ^domain tabletop)
    (<o*1> ^name init-agent)
    -->
    (<s> ^world <w> +)
    (<w> ^objects <objs> + ^predicates <preds> + ^robot <rob> +)
    (<rob> ^arm <arm> + ^handle rosie + ^predicates <p*1> +)
    (<p*1> ^name rosie +)
    (<arm> ^state external +)
}

sp {top-state*apply*init-agent*create*world-state*mobile
    (state <s> ^world-usage external ^superstate nil ^agent-params <a*1>
          ^operator <o*1>)
    (<a*1> ^domain magicbot)
    (<o*1> ^name init-agent)
    -->
    (<s> ^world <w> +)
    (<w> ^objects <objs> + ^predicates <preds> + ^robot <rob> +)
    (<rob> ^arm <arm> + ^handle rosie + ^predicates <p*1> +
           ^moving-status stopped +)
    (<p*1> ^name rosie +)
    (<arm> ^state internal +)
}

sp {apply*next-sentence-update-dialog-object-list-saved
    (state <s> ^operator <o*1> ^dialog-object-list <dol>
          ^dialog-object-list-saved { <> <dol> <dols> })
    (<o*1> ^name next-sentence)
    -->
    (<s> ^dialog-object-list-saved <dols> - ^dialog-object-list-saved <dol> +)
}

sp {apply*next-sentence2
    (state <s> ^operator <op> ^interaction <i*1>)
    (<op> ^name next-sentence)
    (<i*1> ^status <stat>)
    (<stat> ^new-message <nm>)
    -->
    (<stat> ^new-message <nm> -)
}

sp {apply*next-sentence
    (state <s> ^terminated-sentence <csn> ^current-sentence-number <csn>
          ^operator <op>)
    (<op> ^name next-sentence ^next-sentence-number <n>)
    -->
    (<s> ^terminated-sentence <csn> - ^current-sentence-number <n> +
           ^current-sentence-number <csn> -)
}

sp {rosie*propose*next-sentence*skip
    (state <s> ^superstate <ss> ^segment <s*1>)
    (<ss> ^world-usage internal ^current-sentence-number <csn>)
    (<s*1> ^input-sentence <i*1>)
    (<i*1> ^skip true)
    -->
    (<ss> ^terminated-sentence <csn> +)
}

sp {rosie*propose*next-sentence
    (state <s> ^terminated-sentence <csn> ^current-sentence-number <csn>
          ^top-state <t*1> ^max-sentence-number { > <csn> <n> })
    (<t*1> ^world-usage internal)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name next-sentence + ^next-sentence-number (+ <csn> 1) +)
}

sp {apply*initialize-rosie*initialize-world*othello
    (state <s> ^top-state <t*1> ^operator <o*1>)
    (<t*1> ^world-usage internal)
    (<o*1> ^name initialize-rosie)
    -->
    (<s> ^world <world> +)
    (<world> ^objects <objects> + ^predicates <predicates> + ^robot <robot> +)
    (<robot> ^handle rosie + ^current-location <loc> + ^item-type object +
           ^arm <a*1> + ^predicates <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objects> ^object <obj0> + ^object <obj1> + ^object <obj2> +
           ^object <obj3> + ^object <obj4> + ^object <obj5> + ^object <obj6> +
           ^object <obj7> + ^object <loc> + ^object <loc1> + ^object <loc2> +
           ^object <loc3> + ^object <loc4> + ^object <loc5> + ^object <loc6> +
           ^object <loc7> + ^object <loc8> + ^object <loc9> +
           ^object <loc10> + ^object <loc11> + ^object <loc12> +
           ^object <loc13> + ^object <loc14> + ^object <loc15> +)
    (<loc> ^handle |\|B0\|| + ^item-type object + ^predicates <ploc> +)
    (<ploc> ^x 1 + ^y 1 + ^category location + ^visible true +)
    (<loc1> ^handle |\|B1\|| + ^item-type object + ^predicates <ploc1> +)
    (<ploc1> ^x 2 + ^y 1 + ^category location + ^visible true +)
    (<loc2> ^handle |\|B2\|| + ^item-type object + ^predicates <ploc2> +)
    (<ploc2> ^x 3 + ^y 1 + ^category location + ^visible true +)
    (<loc3> ^handle |\|B3\|| + ^item-type object + ^predicates <ploc3> +)
    (<ploc3> ^x 4 + ^y 1 + ^category location + ^visible true +)
    (<loc4> ^handle |\|B4\|| + ^item-type object + ^predicates <ploc4> +)
    (<ploc4> ^x 1 + ^y 2 + ^category location + ^visible true +)
    (<loc5> ^handle |\|B5\|| + ^item-type object + ^predicates <ploc5> +)
    (<ploc5> ^x 2 + ^y 2 + ^category location + ^visible true +)
    (<loc6> ^handle |\|B6\|| + ^item-type object + ^predicates <ploc6> +)
    (<ploc6> ^x 3 + ^y 2 + ^category location + ^visible true +)
    (<loc7> ^handle |\|B7\|| + ^item-type object + ^predicates <ploc7> +)
    (<ploc7> ^x 4 + ^y 2 + ^category location + ^visible true +)
    (<loc8> ^handle |\|B8\|| + ^item-type object + ^predicates <ploc8> +)
    (<ploc8> ^x 1 + ^y 3 + ^category location + ^visible true +)
    (<loc9> ^handle |\|B9\|| + ^item-type object + ^predicates <ploc9> +)
    (<ploc9> ^x 2 + ^y 3 + ^category location + ^visible true +)
    (<loc10> ^handle |\|B10\|| + ^item-type object + ^predicates <ploc10> +)
    (<ploc10> ^x 3 + ^y 3 + ^category location + ^visible true +)
    (<loc11> ^handle |\|B11\|| + ^item-type object + ^predicates <ploc11> +)
    (<ploc11> ^x 4 + ^y 3 + ^category location + ^visible true +)
    (<loc12> ^handle |\|B12\|| + ^item-type object + ^predicates <ploc12> +)
    (<ploc12> ^x 1 + ^y 4 + ^category location + ^visible true +)
    (<loc13> ^handle |\|B13\|| + ^item-type object + ^predicates <ploc13> +)
    (<ploc13> ^x 2 + ^y 4 + ^category location + ^visible true +)
    (<loc14> ^handle |\|B14\|| + ^item-type object + ^predicates <ploc14> +)
    (<ploc14> ^x 3 + ^y 4 + ^category location + ^visible true +)
    (<loc15> ^handle |\|B15\|| + ^item-type object + ^predicates <ploc15> +)
    (<ploc15> ^x 4 + ^y 4 + ^category location + ^visible true +)
    (<obj0> ^type object + ^handle self + ^predicates <plot0> +)
    (<plot0> ^type object +)
    (<obj1> ^handle |\|L1\|| + ^predicates <plot1> + ^item-type object +)
    (<plot1> ^category block + ^color red1 + ^visible true + ^movable true +)
    (<obj2> ^handle |\|L2\|| + ^item-type object + ^predicates <plot2> +)
    (<plot2> ^category block + ^color red1 + ^visible true + ^movable true +)
    (<obj3> ^handle |\|L3\|| + ^item-type object + ^predicates <plot3> +)
    (<plot3> ^category block + ^color red1 + ^visible true + ^movable true +)
    (<obj4> ^handle |\|L4\|| + ^predicates <plot4> + ^item-type object +)
    (<plot4> ^category block + ^color blue1 + ^visible true + ^movable true +)
    (<obj5> ^handle |\|L5\|| + ^item-type object + ^predicates <plot5> +)
    (<plot5> ^category block + ^color blue1 + ^visible true + ^movable true +)
    (<obj6> ^handle |\|L6\|| + ^item-type object + ^predicates <plot6> +)
    (<plot6> ^category block + ^color blue1 + ^visible true + ^movable true +)
    (<obj7> ^handle |\|L7\|| + ^predicates <plot7> + ^item-type object +)
    (<plot7> ^category block + ^color red1 + ^visible true + ^movable true +
           ^indicated pointed +)
    (<predicates> ^predicate <on1> + ^predicate <below1> +)
    (<on1> ^handle on1 + ^item-type predicate + ^instance <on-1> +
           ^instance <on-2> + ^instance <on-3> + ^instance <on-4> +
           ^instance <on-5> + ^instance <on-6> +)
    (<on-1> ^1 <obj1> + ^2 <loc9> +)
    (<on-2> ^1 <obj2> + ^2 <loc7> +)
    (<on-3> ^1 <obj4> + ^2 <loc5> +)
    (<on-4> ^1 <obj5> + ^2 <loc6> +)
    (<on-5> ^1 <obj6> + ^2 <loc10> +)
    (<on-6> ^1 <obj3> + ^2 <loc2> +)
    (<below1> ^handle below1 + ^item-type predicate + ^instance <b-1> +
           ^instance <b-2> + ^instance <b-3> + ^instance <b-4> +
           ^instance <b-5> + ^instance <b-6> + ^instance <b-7> +
           ^instance <b-8> + ^instance <b-21> + ^instance <b-22> +
           ^instance <b-23> + ^instance <b-24> + ^instance <b-25> +
           ^instance <b-26> + ^instance <b-27> + ^instance <b-28> +)
    (<b-1> ^2 <obj1> + ^1 <loc1> +)
    (<b-2> ^2 <obj2> + ^1 <loc2> +)
    (<b-3> ^2 <obj4> + ^1 <loc3> +)
    (<b-4> ^2 <obj3> + ^1 <loc4> +)
    (<b-5> ^2 <obj5> + ^1 <loc5> +)
    (<b-6> ^2 <obj1> + ^1 <loc6> +)
    (<b-7> ^2 <obj2> + ^1 <loc7> +)
    (<b-8> ^2 <obj3> + ^1 <loc8> +)
    (<b-21> ^2 <obj1> + ^1 <loc11> +)
    (<b-22> ^2 <obj2> + ^1 <loc12> +)
    (<b-23> ^2 <obj4> + ^1 <loc13> +)
    (<b-24> ^2 <obj3> + ^1 <loc14> +)
    (<b-25> ^2 <obj5> + ^1 <loc15> +)
    (<b-26> ^2 <obj6> + ^1 <loc> +)
    (<b-27> ^2 <obj1> + ^1 <loc10> +)
    (<b-28> ^2 <obj2> + ^1 <loc9> +)
}

sp {apply*wait-for-response*add*next-sentence-number
    (state <s> ^top-state <ts> ^operator <o*1>)
    (<ts> ^game-scripting true ^n-sentence-number <csn>)
    (<o*1> ^name wait-for-response)
    -->
    (<ts> ^n-sentence-number <csn> - ^current-sentence-number <csn> +)
}

sp {apply*wait-for-response*stop*max-sentence
    (state <s> ^operator <o*1> ^top-state <ts>)
    (<o*1> ^name wait-for-response)
    (<ts> ^max-sentence-number <csn>
          ^current-sentence-number { > <csn> <c*1> })
    -->
#    (write (cmd |ctf stats.txt stats|))
#    (write (cmd |ctf statsm.txt statsm|))
#    (write (cmd |ctf statesexp.txt fc game-search*elaborate*other-levels*simulated|))
#    (write (cmd |ctf chunks.txt pfc|))
#    (write (cmd |ctf s1.txt print s1 -d 3|))
    (halt)
}

sp {apply*interpet-message*remove*current-sentence-number
    (state <s> ^top-state <ts> ^operator <o*1>)
    (<ts> ^game-scripting true ^current-sentence-number <csn>)
    (<o*1> ^name interpret-message)
    -->
    (<ts> ^n-sentence-number (+ <csn> 1) + ^current-sentence-number <csn> -)
}

sp {language-comprehension*propose*initialize-rosie
    (state <s> ^name rosie -^world <w*1> ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> !)
    (<op> ^name initialize-rosie +)
}

sp {apply*halt*sync
    (state <s> ^operator <o*1>)
    (<o*1> ^name halt)
    -->
    (<s> ^test yes +)
}

sp {apply*halt*expectation-failures*none
    (state <s> ^operator <o*1> -^expectation-failure <e*1>)
    (<o*1> ^name halt)
    -->
    
}

sp {apply*halt*expectation-failures
    (state <s> ^operator <o*1> ^expectation-failure <csn>)
    (<o*1> ^name halt)
    -->
    
}

sp {apply*halt
    (state <s> ^test yes ^operator <o*1> ^failure-count <fc>
          ^success-count <sc>)
    (<o*1> ^name halt)
    -->
    (halt)
}

sp {rosie*propose*halt
    (state <s> ^name rosie ^max-sentence-number <n> ^terminated-sentence <n>
          ^current-sentence-number <n>)
    -->
    (<s> ^operator <op> + ^operator <op> !)
    (<op> ^name halt +)
}

sp {comprehension*apply*conjuction-processing
    (state <s> ^operator <op> ^segment <s*1>)
    (<op> ^name conjuction-processing ^after-rec <reciever2>
          ^conj-rec <receiver1>)
    (<reciever2> ^lt <l*2> ^structure-type <s-type>)
    (<l*2> ^converts-to <c-type>)
    (<s*1> ^not-merged-assigner <ass1>)
    (<ass1> ^struture-type *unknown* ^parent-receiver <receiver1> ^lt <l*1>)
    (<l*1> ^before <ass2>)
    (<ass2> ^structure-type *unknown*)
    -->
    (<receiver1> ^lt <l*3> + ^structure-type <s-type> + ^delay-merge true -)
    (<l*3> ^converts-to <c-type> +)
    (<ass1> ^structure-type <c-type> + ^structure-type *unknown* - ^lt <l*4> +)
    (<l*4> ^attachment immediately-follow +)
    (<ass2> ^structure-type <c-type> + ^structure-type *unknown* -)
}

sp {comprehension*propose*conjuction-processing
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^not-merged-receiver <receiver1>
          ^not-merged-receiver { <> <receiver1> <receiver2> })
    (<receiver1> ^delay-merge true ^decision-count <after>)
    (<receiver2> ^decision-count { > <after> <d*1> } ^converts-to <c-type>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name conjuction-processing + ^conj-rec <receiver1> +
           ^after-rec <reciever2> +)
}

sp {comprehend*apply*non-process-multiple*remove-referent-home
    (state <s> ^operator <op> ^referent-home <pr>)
    (<op>
          -^name { << process-multiple-groundings dialog-object-list-update >> <n*1> })
    -->
    (<s> ^referent-home <pr> -)
}

sp {comprehend*apply*process-multiple-groundings*not
    (state <s> ^referent-home <pr> ^operator <op>)
   -{ (<pr> ^referent <pr-d> ^referent { <> <pr-d> <pr-g> })
      (<pr-g> ^predicates <p*1>)
      (<p*1> ^status live)
      (<pr-d> ^predicates <p*2>)
      (<p*2> ^visible { << false unknown >> <v*1> })}
    (<op> ^name process-multiple-groundings)
    -->
    (<op> ^not-live-available-with-not-visible true +)
}

sp {comprehension*compare*process-multiple-groundings
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name process-multiple-groundings)
    (<op2>
          ^name { << process-phrase-end process-semantics merge process-missing-assigner clean-up-retrieved-stack comprehend-construction comprehend-word >> <n*1> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehend*propose*process-multiple-groundings
    (state <s> ^multiple-referents true -^processed-multiple true
          ^name comprehension)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-multiple-groundings +)
}

sp {comprehension*elaborate-operator*process-multiple-groundings
    (state <s> ^name comprehension ^referent-home <r*1>)
   -{ (<s> ^referent-home <r*3>)
      (<r*3> ^constraint <c*1>)
      (<c*1> ^multiple true)}
    (<r*1> ^referent <r*2> ^referent { <> <r*2> <obj> })
    -->
    (<s> ^multiple-referents true +)
}

sp {process-multiple-groundings*apply*next-list-item*skip
    (state <s> ^operator <op> ^dialog-object-list <d*1> ^segment <s*1>
          ^object <obj>)
    (<op> ^name next-list-item)
    (<d*1> ^referent <obj>)
    (<s*1> ^last-merge <l*1>)
    (<l*1> ^assigner <a*1>)
    (<a*1> ^parent-receiver <p*1>)
    (<p*1> ^constraint <c*1>)
    (<c*1> ^handle { << original former >> <h*1> })
    -->
    (<s> ^skipped-latter true +)
}

sp {process-multiple-groundings*apply*next-list-item
    (state <s> ^operator <op> ^dialog-object-list <dol>)
    (<op> ^name next-list-item ^item <dol>)
    (<dol> ^next <ndol>)
    -->
    (<s> ^dialog-object-list <dol> - ^dialog-object-list <ndol> +)
}

sp {process-multiple-groundings*propose*next-list-item
    (state <s> ^name process-multiple-groundings
          ^dialog-object-list { <> nil <dol> })
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> <)
    (<op> ^name next-list-item + ^item <dol> +)
}

sp {process-multiple-groundings*apply*detect-match
    (state <s> ^operator <op> ^superstate <ss>)
    (<op> ^name detect-match ^object { <> <obj> <o*1> })
    (<ss> ^referent-home <pr> ^operator <o>)
    (<pr> ^referent <obj>)
    -->
    (<pr> ^referent <obj> -)
}

sp {process-multiple-groundings*propose*detect-match*skipped-latter
    (state <s> ^skipped-latter true ^name process-multiple-groundings
          ^dialog-object-list <d*1> ^segment <s*1> ^object <obj>)
    (<d*1> ^referent <obj>)
    (<obj> -^specifier distinct)
    (<s*1> ^last-merge <l*1>)
    (<l*1> ^assigner <a*1>)
    (<a*1> ^parent-receiver <p*1>)
    (<p*1> ^constraint <c*1>)
    (<c*1> ^handle { << original former >> <h*1> })
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name detect-match + ^object <obj> +)
}

sp {process-multiple-groundings*propose*detect-match
    (state <s> ^name process-multiple-groundings ^dialog-object-list <d*1>
          ^object <obj>)
   -{ (<s> ^segment <s*1>)
      (<s*1> ^last-merge <l*1>)
      (<l*1> ^assigner <a*1>)
      (<a*1> ^parent-receiver <p*1>)
      (<p*1> ^constraint <c*1>)
      (<c*1> ^handle { << original former >> <h*1> })}
    (<d*1> ^referent <obj>)
    (<obj> -^specifier distinct)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name detect-match + ^object <obj> +)
}

sp {process-multiple-groundings*elaborate-operator*processed-multiple
    (state <s> ^dialog-object-list nil ^name process-multiple-groundings
          ^superstate <ss>)
    -->
    (<ss> ^processed-multiple true +)
}

sp {process-multiple-groundings*elaborate-state*substate2
    (state <s> ^name process-multiple-groundings ^segment <s*1>)
    (<s*1> ^dialog-object-list-access <dola>)
    -->
    (<s> ^dialog-object-list <dola> +)
}

sp {process-multiple-groundings*elaborate-state*substate
    (state <s> ^name process-multiple-groundings ^superstate <s*1>)
    (<s*1> ^referent-home <r*1>)
    (<r*1> ^referent <obj>)
    -->
    (<s> ^object <obj> +)
}

sp {apply*tested-referent*add-referent-dialog-object-list-access
    (state <s> ^operator <op> ^tsegment <seg>)
    (<op> ^name dialog-object-list-update ^referent <obj>)
    (<seg> ^dialog-object-list-access <dol>)
    -->
    (<seg> ^dialog-object-list-access <dol> -
           ^dialog-object-list-access <ndol> +)
    (<ndol> ^referent <obj> + ^next <dol> +)
}

sp {apply*tested-referent*add-referent-dialog-object-list
    (state <s> ^operator <op> ^top-state <ts>)
    (<op> ^name dialog-object-list-update ^referent <obj>)
    (<ts> ^dialog-object-list <dol>)
    -->
    (<ts> ^dialog-object-list <dol> - ^dialog-object-list <ndol> +)
    (<ndol> ^referent <obj> + ^next <dol> +)
}

sp {comprehension*compare*dialog-object-list-update
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name dialog-object-list-update)
    (<op2>
          ^name { << process-phrase-end process-semantics merge process-missing-assigner ground-referent ground-new-constraint clean-up-retrieved-stack >> <n*1> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*propose*dialog-object-list-update
    (state <s> ^name comprehension -^name evaluate-operator
          ^referent-home <r*1> ^top-state <t*1>)
    (<r*1> ^referent <obj>)
   -{ (<s> ^referent-home <r*2>)
      (<r*2> ^referent { <> <obj> <r*3> })}
    (<t*1> ^dialog-object-list <dol>)
    (<dol> -^referent <obj>)
    -->
    (<s> ^operator <op> + ^operator <op> >)
    (<op> ^name dialog-object-list-update + ^referent <obj> +)
}

sp {comprehension*elaborate*possible-referent*complement
    (state <s> ^name comprehension ^segment <s*1>)
    (<s*1> ^last-merge <lm>)
    (<lm> ^assigner <a*1>)
    (<a*1> ^parent-receiver <pr>)
   -{ (<pr> ^head <h*1>)
      (<h*1> ^referent <r*1>)}
    (<pr> ^ground-tested <g*1> ^{ << complement complement2 >> <a*2> } <comp>)
    (<comp> ^head <rh>)
    (<rh> ^referent <r*2>)
    -->
    (<s> ^referent-home <rh> +)
}

sp {comprehension*elaborate*possible-referent*head
    (state <s> ^name comprehension ^segment <s*1>)
    (<s*1> ^last-merge <lm>)
    (<lm> ^assigner <a*1>)
    (<a*1> ^parent-receiver <pr>)
    (<pr> ^ground-tested <g*1>
          ^{ << complement complement2 head >> <a*2> } <rh>)
    (<rh> ^referent <r*1>)
    -->
    (<s> ^referent-home <rh> +)
}

sp {comprehension*elaborate*possible-referent*assigner
    (state <s> ^name comprehension ^segment <s*1>)
    (<s*1> ^last-merge <lm>)
    (<lm> ^assigner <a*1>)
    (<a*1> ^parent-receiver <rh>)
    (<rh> ^ground-tested <g*1> ^referent <r*1>)
    -->
    (<s> ^referent-home <rh> +)
}

sp {apply*merge*monitor
    (state <s> ^operator <op>)
    (<op> ^name merge ^assigner <assigner> ^receiver <receiver>)
    (<assigner> ^parent-receiver <wws> ^lt <l*2> ^structure-type <stype>)
    (<receiver> ^lt <l*1>)
    (<l*2> ^syntactic-structure <ss>)
    (<wws> ^current-word <c*1>)
    (<c*1> ^{ << construction spelling >> <a*2> } <word1>)
    (<l*1> ^{ << construction spelling >> <a*1> } <word2>)
    -->
    
}

sp {apply*merge*remove-failed-construction*referent-nil
    (state <s> ^operator <op> ^segment <seg>)
   -{ (<op> ^assigner <a*1>)
      (<a*1> ^lt <l*1>)
      (<l*1> ^referent <r*1>)}
    (<op> ^name merge ^receiver <uri>)
    (<uri> ^failed-grounding <fg>)
    -->
    (<uri> ^failed-grounding <fg> -)
}

sp {apply*merge*remove-processing-result-failure
    (state <s> ^operator <op> ^segment <s*1>)
    (<op> ^name merge)
    (<s*1> ^original-sentence <is>)
    (<is> ^processing-result failure)
    -->
    (<is> ^processing-result failure -)
}

sp {apply*merge*remove-failed-construction
    (state <s> ^segment <seg> ^operator <op>)
    (<seg> ^failed-construction true)
    (<op> ^name merge)
    -->
    (<seg> ^failed-construction true -)
}

sp {apply*merge*remove-stale-assigners*noun
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^assigner <sit>)
    (<sit> ^structure-type N)
    (<seg> ^not-merged-assigner <assigner>)
    (<assigner> ^parent-receiver <sit> ^structure-type { << ADJ D >> <s*1> })
    -->
    (<seg> ^not-merged-assigner <assigner> -)
}

sp {apply*merge*remove-exclusive-assigner
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^assigner <assigner>)
    (<assigner> ^parent-receiver <pr> ^lt <l*1>)
    (<l*1> ^exclusive <x-ass>)
    (<seg> ^not-merged-assigner <uai>)
    (<uai> ^parent-receiver <pr> ^lt <x-ass>)
    -->
    (<seg> ^not-merged-assigner <uai> -)
}

sp {apply*merge*clean-up-retrieved-stack2*duplicate
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^assigner <uai> ^receiver <uri>)
    (<uai> ^parent-receiver <ps>)
    (<seg> ^not-merged-receiver <uri> ^retrieved-stack <rs>)
    (<rs> ^item <ps> ^prior <p>)
    (<p> ^item <uri> ^prior <ppp>)
    -->
    (<rs> ^prior <p> - ^prior <ppp> +)
}

sp {apply*merge*clean-up-retrieved-stack2-5
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^assigner <uai> ^receiver <uri>)
    (<uai> ^parent-receiver <ps>)
    (<seg> ^not-merged-receiver <uri> ^retrieved-stack <rs>)
    (<rs> -^item <ps> ^prior <p>)
    (<p> ^item <uri> ^prior <p2>)
    (<p2> ^item <ps>)
    -->
    (<rs> ^prior <p> - ^prior <p2> +)
}

sp {apply*merge*clean-up-retrieved-stack2
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^assigner <uai> ^receiver <uri>)
    (<uai> ^parent-receiver <ps>)
    (<seg> ^not-merged-receiver <uri> ^retrieved-stack <rs>)
    (<rs> -^item <ps> ^prior <p>)
   -{ (<p> ^prior <p*1>)
      (<p*1> ^item <ps>)}
    (<p> ^item <uri>)
    -->
    (<p> ^item <uri> - ^item <ps> +)
}

sp {apply*merge*clean-up-retrieved-stack1-2
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^assigner <uai> ^receiver <uri>)
    (<uai> ^parent-receiver <ps>)
    (<seg> ^not-merged-receiver <uri> ^retrieved-stack <rs>)
    (<rs> ^item <uri> ^prior <prior>)
    (<prior> ^item <ps>)
    -->
    (<seg> ^retrieved-stack <rs> - ^retrieved-stack <prior> +)
    (<ps> ^merged-with true +)
}

sp {apply*merge*clean-up-retrieved-stack1
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^assigner <uai> ^receiver <uri>)
    (<uai> ^parent-receiver <ps>)
    (<seg> ^not-merged-receiver <uri> ^retrieved-stack <rs>)
   -{ (<rs> ^prior <p*1>)
      (<p*1> ^item <ps>)}
    (<rs> ^item <uri>)
    -->
    (<rs> ^item <uri> - ^item <ps> +)
}

sp {apply*merge*clear-new-word
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^assigner <a*1> ^receiver <receiver>)
    (<a*1> ^lt <lla>)
    (<lla> ^structure-type U)
    (<receiver> ^lt <l*1>)
    (<l*1> ^spelling <uw>)
    (<seg> ^unknown-word <uw>)
    -->
    (<seg> ^unknown-word <uw> -)
}

sp {apply*merge*define-new-verb
    (state <s> ^operator <op> ^segment <seg> ^smem <s*1>)
    (<op> ^name merge ^receiver <receiver> ^assigner <assigner>)
    (<receiver> -^structure-type <s*2> ^lt <lli>)
    (<assigner> ^lt <lla>)
    (<lla> ^predicted-structure-type V ^structure-type U)
    (<lli> ^spelling <spell>)
    (<s*1> ^command <cmd>)
    -->
    (<seg> ^new-verb <lli> +)
}

sp {apply*merge*assign-syntactic-referent-type*name
    (state <s> ^operator <op> ^smem <s*1>)
    (<op> ^name merge ^receiver <receiver> ^assigner <assigner>)
    (<receiver> -^structure-type <s*3> ^lt <lli>)
    (<assigner> ^parent-receiver <pword> ^lt <lla>)
    (<pword> ^structure-type CP ^head <head>)
    (<lla> -^structure-type <s*2>)
    (<head> ^complement <c*1> ^head <h*1>)
    (<c*1> ^head <h*2>)
    (<h*2> ^head <h*3>)
    (<h*3> ^lt <l*2>)
    (<l*2> ^syntactic-referent-type <srt>)
    (<h*1> ^lt <l*1>)
    (<l*1> ^spelling name)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^store <lli> +)
    (<receiver> ^structure-type <srt> +)
    (<lli> ^structure-type <srt> +)
}

sp {apply*merge*assign-syntactic-referent-type-not-name
    (state <s> ^operator <op> ^smem <s*1>)
    (<op> ^name merge ^receiver <receiver> ^assigner <assigner>)
    (<receiver> -^structure-type <s*3> ^lt <lli>)
    (<assigner> ^parent-receiver <pword> ^lt <lla>)
    (<pword> ^structure-type CP ^head <h*1>)
    (<lla> -^structure-type <s*2>)
    (<h*1> ^head <h*2>)
    (<h*2> ^lt <lt>)
    (<lt> -^spelling name ^syntactic-referent-type <srt>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^store <lli> +)
    (<receiver> ^structure-type <srt> +)
    (<lli> ^structure-type <srt> +)
}

sp {apply*merge*constraint*to-the-left-of
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^assigner <assigner> ^receiver <receiver>)
    (<assigner> ^structure-type DP ^parent-receiver <pword>)
    (<pword> ^structure-type P)
    (<receiver> ^complement <com> ^head <h*1>)
    (<com> ^lt <l*1> ^head <h*2>)
    (<h*1> ^lt <lt>)
    (<lt> ^semantic-structure relation ^relation <r*1>)
    (<h*2> ^referent <garbage>)
    (<l*1> ^relation <r*2>)
    (<r*2> ^handle of1)
    (<r*1> ^handle <right-left>)
    -->
    (<seg> ^new-constraint <nc> +)
    (<nc> ^object <pword> + ^constraint <c> +)
    (<pword> ^constraint <c> +)
    (<c> ^relation <srx> +)
    (<srx> ^2 <garbage> + ^handle <right-left> +)
}

sp {apply*merge*constraint*preposition-noun-special*ternary
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^assigner <assigner> ^receiver <receiver>)
    (<assigner> ^structure-type PP ^parent-receiver <pword>)
    (<receiver> ^structure-type PP ^lt <l*1> ^complement <c*1> ^lt <l*2>
          ^head <h*2>)
    (<l*1> ^relation-type ternary)
    (<c*1> ^lt <l*4>)
    (<h*2> ^lt <l*3>)
    (<pword> ^head <h*1> ^structure-type { << D CN >> <s*1> })
    (<h*1> ^lt-referent <ref>)
    (<l*4> ^relation <r*3>)
    (<r*3> ^handle <rh>)
    (<l*3> ^relation <r*2>)
    (<r*2> ^handle <obj>)
    (<l*2> ^relation <r*1>)
    (<r*1> ^handle <sr>)
    -->
    (<ref> ^relation <srx> +)
    (<srx> ^2 <obj> + ^3 <rh> + ^handle <sr> +)
}

sp {apply*merge*constraint*preposition-noun-special
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^assigner <assigner> ^receiver <receiver>)
    (<assigner> ^structure-type PP ^parent-receiver <pword>)
   -{ (<receiver> ^lt <l*1>)
      (<l*1> ^relation-type ternary)}
    (<receiver> ^structure-type PP ^lt <l*2> ^head <h*2>)
    (<h*2> ^lt <l*3>)
    (<pword> ^head <h*1> ^structure-type { << D CN >> <s*1> })
    (<h*1> ^lt-referent <ref>)
    (<l*3> ^relation <r*2>)
    (<r*2> ^handle <obj>)
    (<l*2> ^relation <r*1>)
    (<r*1> ^handle <sr>)
    -->
    (<ref> ^relation <srx> +)
    (<srx> ^2 <obj> + ^handle <sr> +)
}

sp {apply*merge*forward-grounding*to-preposition-verb*ternary
    (state <s> ^operator <op>)
    (<op> ^name merge ^assigner <assigner> ^receiver <receiver>)
    (<assigner> ^parent-receiver <pword>)
    (<receiver> ^lt <l*1> ^complement <c*1> ^lt <l*2> ^head <h*1>
          ^structure-type { << PP CONJP C-ADJ-P >> <s*2> })
    (<l*1> ^relation-type ternary)
    (<pword> ^structure-type { << VP GP >> <s*1> })
    (<c*1> ^referent <cr>)
    (<h*1> ^referent <sg>)
    (<l*2> ^relation <sr>)
    -->
    (<pword> ^<sr> <sg> + ^relation <srr> +)
    (<srr> ^2 <sg> + ^3 <cr> + ^handle <sr> +)
}

sp {apply*merge*forward-grounding*to-preposition-verb*binary
    (state <s> ^operator <op>)
    (<op> ^name merge ^receiver <receiver> ^assigner <assigner>)
   -{ (<receiver> ^lt <l*1>)
      (<l*1> ^relation-type ternary)}
    (<assigner> ^parent-receiver <pword>)
    (<receiver> ^lt <l*2> ^head <h*1>
          ^structure-type { << PP CONJP C-ADJ-P >> <s*2> })
    (<pword> ^structure-type { << VP GP >> <s*1> })
    (<h*1> ^referent <sg>)
    (<l*2> ^relation <sr>)
    -->
    (<pword> ^<sr> <sg> + ^relation <srr> +)
    (<srr> ^2 <sg> + ^handle <sr> +)
}

sp {apply*merge*constraint*RCP*merge*noun
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^receiver <receiver> ^assigner <assigner>)
    (<receiver> ^structure-type RCP
          ^{ << complement predicate >> <a*1> } <comp>)
    (<assigner> ^parent-receiver <pword>)
    (<pword> ^head <h*1> ^structure-type { << D CN >> <s*1> })
    (<h*1> ^lt-referent <ref>)
    (<comp> ^lt <l*1> ^head <h*2>)
    (<h*2> ^lt <l*2>)
    (<l*2> ^relation <r*2>)
    (<r*2> ^handle <head>)
    (<l*1> ^relation <r*1>)
    (<r*1> ^handle <named>)
    -->
    (<ref> ^relation <srx> +)
    (<srx> ^2 <head> + ^handle <named> +)
}

sp {apply*merge*constraint*PP*merge*of*referent*no-lt-referent
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^receiver <receiver> ^assigner <assigner>)
    (<receiver> ^structure-type PP ^lt <l*2> ^head <h*4>)
    (<assigner> ^parent-receiver <pword>)
   -{ (<pword> ^head <h*3>)
      (<h*3> ^lt <lt>)
      (<lt> ^structure-type N ^spelling { << right left >> <s*3> })}
   -{ (<pword> ^head <h*2>)
      (<h*2> ^lt <l*1>)
      (<l*1> ^spelling { << left-noun right-noun >> <s*2> })}
   -{ (<pword> ^head <h*1>)
      (<h*1> ^lt-referent <ref1>)}
    (<pword> ^structure-type { << D CN >> <s*1> })
    (<h*4> ^referent <ref>)
    (<l*2> ^relation <r*1>)
    (<r*1> ^handle of1)
    -->
    (<seg> ^new-constraint <nc> +)
    (<nc> ^object <pword> + ^constraint <c> +)
    (<pword> ^constraint <c> +)
    (<c> ^relation <spr> +)
    (<spr> ^2 <ref> + ^handle of1 +)
}

sp {apply*merge*constraint*PP*merge*of*referent
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^receiver <receiver> ^assigner <assigner>)
    (<receiver> ^structure-type PP ^lt <l*2> ^head <h*4>)
    (<assigner> ^parent-receiver <pword>)
   -{ (<pword> ^head <h*3>)
      (<h*3> ^lt <lt>)
      (<lt> ^structure-type N ^spelling { << right left >> <s*3> })}
   -{ (<pword> ^head <h*2>)
      (<h*2> ^lt <l*1>)
      (<l*1> ^spelling { << left-noun right-noun >> <s*2> })}
    (<pword> ^head <h*1> ^structure-type { << D CN >> <s*1> })
    (<h*1> ^lt-referent <ref1>)
    (<h*4> ^referent <ref>)
    (<l*2> ^relation <r*1>)
    (<r*1> ^handle of1)
    -->
    (<ref1> ^relation <srx> +)
    (<srx> ^2 <ref> + ^handle of1 +)
}

sp {apply*merge*constraint*PP*merge*of
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^receiver <receiver> ^assigner <assigner>)
   -{ (<receiver> ^head <h*4>)
      (<h*4> ^referent <r*2>)}
    (<receiver> ^structure-type PP ^lt <l*1> ^head <h*2>)
    (<assigner> ^parent-receiver <pword>)
    (<h*2> ^head <h*3>)
    (<h*3> ^lt-referent <ref>)
    (<pword> ^head <h*1> ^structure-type { << D CN >> <s*1> })
    (<h*1> ^lt-referent <ref1>)
    (<l*1> ^relation <r*1>)
    (<r*1> ^handle of1)
    -->
    (<ref1> ^relation <srx> +)
    (<srx> ^2 <ref> + ^handle of1 +)
}

sp {apply*merge*constraint*preposition-noun*semantics
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^assigner <assigner> ^receiver <receiver>)
    (<assigner> ^parent-receiver <pword>
          ^structure-type { << PP CONJP C-ADJ-P >> <s*1> })
    (<receiver> ^semantics <s*4>
          ^structure-type { << PP CONJP C-ADJ-P >> <s*3> })
    (<pword> ^structure-type { << D DP CN >> <s*2> })
    (<s*4> ^relation <spr>)
    -->
    (<seg> ^new-constraint <nc> +)
    (<nc> ^object <pword> + ^constraint <c> +)
    (<pword> ^constraint <c> +)
    (<c> ^relation <spr> +)
}

sp {apply*merge*constraint*preposition-noun*ternary
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^receiver <receiver> ^assigner <assigner>)
   -{ (<receiver> ^lt <l*3>)
      (<l*3> ^directional true)}
    (<receiver> ^lt <l*2> ^complement <comp> ^lt <l*4> ^head <head>
          ^structure-type { << PP CONJP C-ADJ-P >> <s*3> })
    (<l*2> ^relation-type ternary)
    (<assigner> ^parent-receiver <pword>
          ^structure-type { << PP CONJP C-ADJ-P >> <s*1> })
   -{ (<pword> ^head <h*1>)
      (<h*1> ^lt <l*1>)
      (<l*1> ^semantic-structure relation)}
    (<pword> ^structure-type { << D DP CN RC >> <s*2> })
    (<comp> ^referent <comp-obj>)
    (<head> ^referent <obj>)
    (<l*4> ^relation <r*1>)
    (<r*1> ^handle <sr>)
    -->
    (<seg> ^new-constraint <nc> +)
    (<nc> ^object <pword> + ^constraint <c> +)
    (<pword> ^constraint <c> +)
    (<c> ^relation <srx> +)
    (<srx> ^2 <obj> + ^3 <comp-obj> + ^handle <sr> +)
}

sp {apply*merge*constraint*preposition-noun*CONJ-C
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^receiver <receiver> ^assigner <assigner>)
   -{ (<receiver> ^lt <l*3>)
      (<l*3> ^directional true)}
   -{ (<receiver> ^lt <l*2>)
      (<l*2> ^relation-type ternary)}
    (<assigner> ^parent-receiver <pword>
          ^structure-type { << CONJ-C-ADJ-P >> <s*1> })
   -{ (<pword> ^head <h*1>)
      (<h*1> ^lt <l*1>)
      (<l*1> ^semantic-structure relation)}
    (<receiver> ^lt <l*4> ^head <h*2>
          ^structure-type { << PP CONJP CONJ-C-ADJ-P >> <s*3> })
    (<h*2> ^head <head>)
    (<pword> ^structure-type { << D DP CN RC >> <s*2> })
    (<head> ^referent <obj>)
    (<l*4> ^relation <r*1>)
    (<r*1> ^handle { <> of1 <sr> })
    -->
    (<seg> ^new-constraint <nc> +)
    (<nc> ^object <pword> + ^constraint <c> +)
    (<pword> ^constraint <c> +)
    (<c> ^relation <srx> +)
    (<srx> ^2 <obj> + ^handle <sr> +)
    (write (crlf) |Add new constraint to | <pword> | relation: | <sr> | object: | <obj>)
}

sp {apply*merge*constraint*preposition-noun
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^receiver <receiver> ^assigner <assigner>)
   -{ (<receiver> ^lt <l*3>)
      (<l*3> ^directional true)}
   -{ (<receiver> ^lt <l*2>)
      (<l*2> ^relation-type ternary)}
    (<assigner> ^parent-receiver <pword>
          ^structure-type { << PP CONJP C-ADJ-P >> <s*1> })
   -{ (<pword> ^head <h*1>)
      (<h*1> ^lt <l*1>)
      (<l*1> ^semantic-structure relation)}
    (<receiver> ^lt <l*4> ^head <head>
          ^structure-type { << PP CONJP C-ADJ-P >> <s*3> })
    (<pword> ^structure-type { << D DP CN RC >> <s*2> })
    (<head> ^referent <obj>)
    (<l*4> ^relation <r*1>)
    (<r*1> ^handle { <> of1 <sr> })
    -->
    (<seg> ^new-constraint <nc> +)
    (<nc> ^object <pword> + ^constraint <c> +)
    (<pword> ^constraint <c> +)
    (<c> ^relation <srx> +)
    (<srx> ^2 <obj> + ^handle <sr> +)
}

sp {apply*merge*constraint*preposition-right-conversion
    (state <s> ^operator <op>)
    (<op> ^name merge ^assigner <assigner> ^receiver <receiver>)
    (<assigner> ^structure-type DP ^parent-receiver <pword>)
    (<receiver> ^structure-type DP ^{ << head noun >> <a*1> } <dp>)
    (<pword> ^lt <pll>)
    (<pll> ^converts-to <ctrs> ^structure-type <st> ^spelling <spell>)
    (<dp> ^lt <xxi> ^head <h*1>)
    (<xxi> ^semantic-structure relation ^relation <sr>)
    (<h*1> ^head <head>)
    (<head> ^referent <sg>)
    -->
    (<pword> ^head <head> + ^lt <new-lli> + ^lt <pll> -)
    (<new-lli> ^relation <sr> + ^semantic-structure relation +
           ^converts-to <ctrs> + ^directional false + ^spelling <spell> +
           ^structure-type <st> +)
}

sp {apply*merge*constraint*features2*singleton-DP
    (state <s> ^operator <op> ^segment <s*1>)
    (<op> ^name merge ^receiver <receiver>)
    (<receiver> ^structure-type DP ^lt-referent <id> -^constraint <id>
          ^lt <l*1>)
    (<l*1> ^singleton-DP true)
    (<s*1> ^not-merged-receiver <receiver>)
    (<id> ^{ << handle name >> <a*1> } { <> category <value> } ^property <pf>)
    (<pf> -^value <v*1> ^{ << handle name >> <a*2> } <name>)
    -->
    (write (crlf) |Add constraint ^| <name> | | <value> | to | <receiver> | from lt:| <id>)
    (<receiver> ^constraint <id> +)
}

sp {apply*merge*constraint*features2
    (state <s> ^operator <op> ^segment <s*1>)
    (<op> ^name merge ^receiver <receiver> ^assigner <assigner>)
   -{ (<receiver> ^lt <l*1>)
      (<l*1> ^singleton-DP true)}
    (<s*1> ^not-merged-receiver <receiver>)
    (<receiver> ^lt-referent <id>)
    (<assigner> ^parent-receiver <pword>)
    (<pword> -^constraint <id>)
    (<id> ^{ << handle name >> <a*1> } { <> category <value> } ^property <pf>)
    (<pf> -^value <v*1> ^{ << handle name >> <a*2> } <name>)
    -->
    (<pword> ^constraint <id> +)
}

sp {apply*merge*constraint*features
    (state <s> ^operator <op> ^segment <s*1>)
    (<op> ^name merge ^assigner <assigner> ^receiver <receiver>)
    (<assigner> ^parent-receiver <pword>)
    (<receiver> ^lt-referent <id>)
    (<pword> -^constraint <id>)
    (<s*1> ^not-merged-receiver <receiver>)
    (<id> ^property <pf>)
    (<pf> ^value <value> ^{ << handle name >> <a*1> } <name>)
    -->
    (<pword> ^constraint <id> +)
}

sp {apply*merge*constraint*features*name
    (state <s> ^operator <op> ^segment <s*1>)
    (<op> ^name merge ^assigner <assigner> ^receiver <receiver>)
    (<assigner> ^parent-receiver <pword>)
    (<receiver> ^lt-referent <id>)
    (<pword> -^constraint <id>)
    (<id> -^property <p*1> ^{ << handle name >> <a*1> } <handle>)
    (<s*1> ^not-merged-receiver <receiver>)
    -->
    (<pword> ^constraint <id> +)
}

sp {apply*merge*constraint*possessive
    (state <s> ^operator <op> ^segment <s*1>)
    (<op> ^name merge ^assigner <assigner>)
    (<assigner> ^parent-receiver <pword>)
    (<pword> ^structure-type POS ^lt <l*1> -^constraint <ref>)
    (<s*1> ^not-merged-assigner <assigner>)
    (<l*1> ^referent <ref>)
    (<ref> ^handle <handle>)
    -->
    (write (crlf) |Add possesive constraint ^handle | <handle> | to | <pword> | from assigner:| <assigner>)
    (<pword> ^constraint <ref> +)
}

sp {apply*merge*push-constraint*clear-ground-tested
    (state <s> ^operator <op> ^segment <s*1>)
    (<op> ^name merge ^assigner <a*1> ^receiver <receiver>)
    (<s*1> ^not-merged-receiver <receiver>)
    (<receiver> ^ground-tested <gt>)
    (<a*1> ^lt <l*1>)
    (<l*1> ^constraint <con>)
    -->
    (<receiver> ^ground-tested <gt> -)
}

sp {apply*merge*push-constraint*receiver-assigner*RCP-D
    (state <s> ^operator <op> ^segment <s*1>)
    (<op> ^name merge ^receiver <receiver> ^assigner <a*1>)
    (<receiver> ^structure-type RCP ^constraint <con>)
    (<s*1> ^not-merged-receiver <receiver>)
    (<a*1> ^parent-receiver <pr>)
   -{ (<pr> ^constraint <c*1>)
      (<c*1> ^handle <handle>)
      (<con> ^handle <handle>)}
    (<pr> -^constraint <con> ^structure-type { << CN D QUANT >> <s*2> })
    -->
    (<pr> ^constraint <con> +)
}

sp {apply*merge*push-constraint*receiver-assigner*DP-RC
    (state <s> ^operator <op> ^segment <s*1>)
    (<op> ^name merge ^assigner <a*1> ^receiver <receiver>)
    (<a*1> ^parent-receiver <pr>)
    (<pr> ^structure-type RC -^constraint <con>)
    (<receiver> ^constraint <con> ^structure-type { << C-ADJ-P DP >> <s*2> })
    (<s*1> ^not-merged-receiver <receiver>)
    -->
    (<pr> ^constraint <con> +)
}

sp {apply*merge*push-constraint
    (state <s> ^operator <op> ^segment <s*1>)
    (<op> ^name merge ^assigner <a*1> ^receiver <receiver>)
    (<s*1> ^not-merged-receiver <receiver>)
    (<a*1> ^lt <l*1>)
    (<l*1> ^constraint <con>)
    (<receiver> -^constraint <con>)
    -->
    (<receiver> ^constraint <con> +)
}

sp {apply*merge*strip-assigners
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^assigner <assigner> ^receiver <receiver>)
    (<assigner> ^lt <l*1>)
    (<l*1> ^strip-assigners true)
    (<seg> ^not-merged-receiver <receiver> ^not-merged-assigner <assigner2>)
    (<assigner2> ^parent-receiver <receiver>)
    -->
    (<seg> ^not-merged-assigner <assigner2> -)
}

sp {apply*merge*relation-value*semantics
    (state <s> ^operator <op>)
    (<op> ^name merge ^assigner <assigner> ^receiver <receiver>)
    (<assigner> ^parent-receiver <pword>)
    (<receiver> ^lt-referent <con> ^semantics <sem>)
    (<sem> ^<att> <relation>)
    (<relation> ^handle by1)
    -->
    (write (crlf) |Inherited relation-source | <relation> | usually for THAT IS.... by|)
    (<sem> ^<att> <relation> -)
    (<con> ^relation <relation> +)
}

sp {apply*merge*relation-value*inherit*2
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^assigner <assigner> ^receiver <receiver>)
    (<assigner> ^parent-receiver <pword>)
    (<pword> ^structure-type CONJ-C-ADJ ^lt <lla>)
    (<seg> ^not-merged-assigner <assigner> ^not-merged-receiver <receiver>)
    (<receiver> ^lt <l*1>)
    (<l*1> ^relation <relation>)
    -->
    (write (crlf) |Inherited relation-source | <relation> | usually for THAT IS.|)
    (<lla> ^relation <relation> +)
}

sp {apply*merge*relation-value
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^assigner <assigner> ^receiver <receiver>)
    (<seg> ^not-merged-assigner <assigner> ^not-merged-receiver <receiver>)
    (<assigner> ^parent-receiver <pword> ^lt <rv>)
    (<receiver> ^lt <l*1>)
    (<pword> ^lt <lla>)
    (<lla> ^relation-source <rv>)
    (<l*1> ^relation <relation>)
    -->
    (<lla> ^relation <relation> +)
}

sp {apply*merge*copy-first-word
    (state <s> ^operator <op> ^segment <s*1>)
    (<op> ^name merge ^assigner <assigner> ^receiver <receiver>)
    (<assigner> ^parent-receiver <pword>)
   -{ (<pword> ^constraint <c*2>)
      (<c*2> ^<att> <val>)}
    (<s*1> ^not-merged-assigner <assigner>)
    (<receiver> ^current-word <c*1>)
    (<c*1> ^first-word true)
    (<pword> ^current-word <wd>)
    -->
    (<pword> ^first-word true +)
    (<wd> ^first-word true +)
}

sp {apply*merge*copy-message-type
    (state <s> ^operator <op>)
    (<op> ^name merge ^assigner <a*1> ^receiver <r*1>)
    (<a*1> ^parent-receiver <pword>)
    (<pword> ^lt <l*2>)
    (<l*2> ^structure-type S)
    (<r*1> ^lt <l*1>)
    (<l*1> ^message-type <ms-type>)
    -->
    (<pword> ^message-type <ms-type> +)
}

sp {apply*merge*copy-message-type*semantics
    (state <s> ^operator <op>)
    (<op> ^name merge ^assigner <a*1> ^receiver <r*1>)
    (<a*1> ^parent-receiver <pword>)
    (<pword> ^lt <l*2> ^semantics <sem2>)
    (<l*2> ^structure-type S)
    (<r*1> ^lt <l*1>)
    (<l*1> ^message-type <ms-type>)
    -->
    (<sem2> ^message-type <ms-type> +)
}

sp {apply*merge*copy-semantics
    (state <s> ^operator <op>)
    (<op> ^name merge ^assigner <ass> ^receiver <r*1>)
   -{ (<ass> ^lt <l*1>)
      (<l*1> ^semantic-structure <s*1>)}
    (<ass> ^parent-receiver <p*1>)
    (<p*1> ^semantics <sem2>)
    (<r*1> ^semantics <sem>)
    (<sem> ^<att> <value>)
    (<value> -^handle by1)
    -->
    (<sem2> ^<att> <value> +)
    (<ass> ^process-semantics <value> +)
}

sp {apply*merge*last-merge
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^assigner <assigner> ^receiver <receiver>)
    (<seg> ^not-merged-assigner <assigner> ^not-merged-receiver <receiver>
          ^last-merge <lm>)
    (<assigner> ^lt <l*1>)
    (<l*1> ^syntactic-structure <stype>)
    -->
    (<seg> ^last-merge <nm> + ^last-merge <lm> -)
    (<nm> ^assigner <assigner> + ^receiver <receiver> +
           ^structure-type <stype> +)
}

sp {apply*merge*remove-unfilled-assigner
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^receiver <receiver>)
    (<seg> ^not-merged-receiver <receiver> ^not-merged-assigner <assigner>)
    (<assigner> ^parent-receiver <receiver>)
    -->
    (<seg> ^not-merged-assigner <assigner> -)
}

sp {apply*merge*conj-predicate
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^assigner <assigner> ^receiver <receiver>)
   -{ (<assigner> ^lt <l*1>)
      (<l*1> ^repeatable true)}
    (<assigner> ^lt <l*2> ^parent-receiver <pword>)
    (<l*2> ^syntactic-structure conj-predicate)
    (<seg> ^not-merged-assigner <assigner> ^not-merged-receiver <receiver>)
    -->
    (<seg> ^not-merged-receiver <receiver> - ^not-merged-assigner <assigner> -
           ^merged-assigner <assigner> +)
    (<assigner> ^merged-receiver <receiver> +)
    (<pword> ^predicate <receiver> +)
}

sp {apply*merge*filler-word*repeatable
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^assigner <assigner> ^receiver <receiver>)
    (<assigner> ^lt <lt>)
    (<lt> ^repeatable true ^syntactic-structure nil)
    (<seg> ^not-merged-assigner <assigner> ^not-merged-receiver <receiver>)
    -->
    (<seg> ^not-merged-receiver <receiver> - ^merged-assigner <assigner> +)
    (<assigner> ^merged-receiver <receiver> +)
}

sp {apply*merge*repeatable
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^assigner <assigner> ^receiver <receiver>)
    (<assigner> ^lt <lt> ^parent-receiver <pword>)
    (<lt> ^repeatable true ^syntactic-structure { <> nil <stype> })
    (<seg> ^not-merged-assigner <assigner> ^not-merged-receiver <receiver>)
    -->
    (<seg> ^not-merged-receiver <receiver> - ^merged-assigner <assigner> +)
    (<assigner> ^merged-receiver <receiver> +)
    (<pword> ^<stype> <receiver> +)
}

sp {apply*merge*filler-word
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^assigner <assigner> ^receiver <receiver>)
   -{ (<assigner> ^lt <l*1>)
      (<l*1> ^repeatable true)}
    (<assigner> ^lt <l*2>)
    (<l*2> ^syntactic-structure nil)
    (<seg> ^not-merged-assigner <assigner> ^not-merged-receiver <receiver>)
    -->
    (<seg> ^not-merged-receiver <receiver> - ^not-merged-assigner <assigner> -
           ^merged-assigner <assigner> +)
    (<assigner> ^merged-receiver <receiver> +)
}

sp {apply*merge
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^assigner <assigner> ^receiver <receiver>)
   -{ (<assigner> ^lt <l*1>)
      (<l*1> ^repeatable true)}
    (<seg> ^not-merged-assigner <assigner> ^not-merged-receiver <receiver>)
    (<assigner> ^parent-receiver <pword> ^lt <l*2>)
    (<l*2>
          ^syntactic-structure { <> nil <> reverse-merge <> conj-predicate <stype> })
    -->
    (<seg> ^not-merged-receiver <receiver> - ^not-merged-assigner <assigner> -
           ^merged-assigner <assigner> +)
    (<assigner> ^merged-receiver <receiver> +)
    (<pword> ^<stype> <receiver> +)
}

sp {apply*retrieve-lti*retrieve-missing-receiver-lt*clean-up
    (state <s> ^operator <o> ^smem <s*1>)
    (<o> ^name retrieve-lti ^lti <lt>)
    (<s*1> ^command <cmd>)
    (<cmd> ^retrieve { <> <lt> <a2> })
    -->
    (<cmd> ^retrieve <a2> -)
}

sp {apply*retrieve-lti*retrieve-missing-receiver-lt
    (state <s> ^operator <op> ^smem <s*1>)
    (<op> ^name retrieve-lti ^lti <lt>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^retrieve <lt> + ^depth 9 +)
}

sp {comprehension*compare*retrieve-lti
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name retrieve-lti)
    (<op2>
          ^name { << process-phrase-end merge comprehend-construction next-word ground-new-constraint >> <n*1> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {propose*retrieve-lti*retrieve-missing-relation
    (state <s> ^segment <s*1>)
    (<s*1> ^comprehension-structure <cs>)
    (<cs> ^{ << not-merged-receiver not-merged-assigner >> <a*1> } <v*1>)
    (<v*1> ^lt <l*1>)
    (<l*1> ^relation <lt>)
    (<lt> -^<att> <a*2>)
    -->
    (<s> ^operator <op> + ^operator <op> > ^operator <op> =)
    (<op> ^name retrieve-lti + ^lti <lt> +)
}

sp {propose*retrieve-lti*retrieve-missing-assinger-head-lt-relation
    (state <s> ^assigner <cs>)
    (<cs> ^merged-receiver <m*1>)
    (<m*1> ^lt <l*1>)
    (<l*1> ^relation <lt>)
    (<lt> -^<att> <a*1>)
    -->
    (<s> ^operator <op> + ^operator <op> > ^operator <op> =)
    (<op> ^name retrieve-lti + ^lti <lt> +)
}

sp {propose*retrieve-lti*retrieve-missing-assinger-id-referent-procedural-lt
    (state <s> ^segment <s*1>)
    (<s*1> ^comprehension-structure <cs>)
    (<cs> ^{ << not-merged-receiver not-merged-assigner >> <a*1> } <v*1>)
    (<v*1> ^lt-referent <l*1>)
    (<l*1> ^procedural <lt>)
    (<lt> -^<att> <a*2>)
    -->
    (<s> ^operator <op> + ^operator <op> > ^operator <op> =)
    (<op> ^name retrieve-lti + ^lti <lt> +)
}

sp {propose*retrieve-lti*retrieve-missing-assinger-id-referent-property-lt
    (state <s> ^segment <s*1>)
    (<s*1> ^comprehension-structure <cs>)
    (<cs> ^{ << not-merged-receiver not-merged-assigner >> <a*1> } <v*1>)
    (<v*1> ^lt-referent <l*1>)
    (<l*1> ^property <lt>)
    (<lt> -^<att> <a*2>)
    -->
    (<s> ^operator <op> + ^operator <op> > ^operator <op> =)
    (<op> ^name retrieve-lti + ^lti <lt> +)
}

sp {propose*retrieve-lti*retrieve-missing-assinger-id-property-lt
    (state <s> ^segment <cs>)
    (<cs> ^{ << not-merged-receiver not-merged-assigner >> <a*1> } <v*1>)
    (<v*1> ^lt <l*1>)
    (<l*1> ^property <lt>)
    (<lt> -^<att> <a*2>)
    -->
    (<s> ^operator <op> + ^operator <op> > ^operator <op> =)
    (<op> ^name retrieve-lti + ^lti <lt> +)
}

sp {propose*retrieve-lti*retrieve-missing-assinger-lt-constraint
    (state <s> ^segment <cs>)
    (<cs> ^{ << not-merged-receiver not-merged-assigner >> <a*1> } <v*1>)
    (<v*1> ^lt <l*1>)
    (<l*1> ^constraint <lt>)
    (<lt> -^<att> <a*2>)
    -->
    (<s> ^operator <op> + ^operator <op> > ^operator <op> =)
    (<op> ^name retrieve-lti + ^lti <lt> +)
}

sp {propose*retrieve-lti*retrieve-missing-assinger-constraint-property-lt
    (state <s> ^segment <cs>)
    (<cs> ^{ << not-merged-receiver not-merged-assigner >> <a*1> } <v*1>)
    (<v*1> ^constraint <c*1>)
    (<c*1> ^property <lt>)
    (<lt> -^<att> <a*2>)
    -->
    (<s> ^operator <op> + ^operator <op> > ^operator <op> =)
    (<op> ^name retrieve-lti + ^lti <lt> +)
}

sp {propose*retrieve-lti*retrieve-missing-assinger-lt
    (state <s> ^segment <cs>)
    (<cs> ^{ << not-merged-receiver not-merged-assigner >> <a*1> } <v*1>)
    (<v*1> ^{ << constraint lt >> <a*2> } <lt>)
    (<lt> -^<att> <a*3>)
    -->
    (<s> ^operator <op> + ^operator <op> > ^operator <op> =)
    (<op> ^name retrieve-lti + ^lti <lt> +)
}

sp {comprehension*propose*record-decision-counts*rule
    :o-support
    (state <s> ^name comprehension ^segment <s*1>)
    (<s*1> ^{ << not-merged-receiver not-merged-assigner >> <a*1> } <nm>)
    (<nm> -^decision-count <d*1>)
    -->
    (<nm> ^decision-count (int (cmd stats |-d|)) +)
}

sp {comprehension*compare*record-decision-counts
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
    (<op2> ^name record-decision-counts)
    (<op1> ^name { << comprehend-word comprehend-construction >> <n*1> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*apply*record-decision-counts
    (state <s> ^operator <op>)
    (<op> ^name record-decision-counts ^not-merged <nm>)
    -->
    (<nm> ^decision-count (int (cmd stats |-d|)) +)
}

sp {comprehension*propose*record-decision-counts*receiver
    (state <s> ^name comprehension ^segment <cs>)
    (<cs> ^not-merged-receiver <na>)
    (<na> -^decision-count <d*1>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name record-decision-counts + ^not-merged <na> +)
}

sp {comprehension*propose*record-decision-counts
    (state <s> ^name comprehension ^segment <cs>)
    (<cs> ^not-merged-assigner <na>)
    (<na> -^decision-count <d*1>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name record-decision-counts + ^not-merged <na> +)
}

sp {comprehension*apply*unmerged-word
    (state <s> ^operator <op>)
    (<op> ^name unmerged-word ^not-merged-receiver <receiver>)
    -->
    (<receiver> ^unmerged-checked true +)
}

sp {comprehension*compare*unmerged-word
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
    (<op2> ^name next-word)
    (<op1> ^name unmerged-word)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*apply*retry-sentence*copy-retry
    (state <s> ^operator <o> ^segment <seg>)
    (<o> ^name retry-sentence ^new-segment <nseg>)
    (<seg> ^retry-sentence <x>)
    -->
    (<nseg> ^retry-receiver <x> +)
}

sp {comprehension*apply*retry-sentence
    (state <s> ^operator <o> ^segment <seg>)
    (<o> ^name retry-sentence ^new-segment <nseg>)
    -->
    (<s> ^segment <seg> - ^segment <nseg> +)
    (<nseg> ^semantics <sss> + ^last-merge <lm> + ^retried-sentence true +)
    (<lm> ^receiver nil + ^assigner nil + ^structure-type none +)
}

sp {comprehension*compare*retry-sentence
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
    (<op2> ^name failed-comprehension)
    (<op1> ^name retry-sentence)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*propose*retry-sentence
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> -^retried-sentence true ^original-sentence <is> ^retry-sentence <x>)
    (<is> -^processed-sentence true)
    -->
    (write |retry-sentence | (crlf))
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name retry-sentence + ^new-segment <nseg> +)
}

sp {comprehension*compare*failed-receiver-no-alternative-structure
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
    (<op2> ^name failed-receiver-no-alternative-structure)
    (<op1> ^name failed-comprehension)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*apply*failed-receiver-no-alternative-structure
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name failed-receiver-no-alternative-structure)
    (<seg> ^original-sentence <cs>)
    -->
    (<cs> ^processing-result failure +)
}

sp {comprehension*propose*failed-receiver-no-alternative-structure
    (state <s> ^name comprehension ^segment <seg>)
   -{ (<seg> ^original-sentence <o*1>)
      (<o*1> ^processing-result failure)}
    (<seg> -^alternative-structure-receiver <asr> ^parse-failed-receiver <nmr>)
   -{ (<nmr> ^lt <l*1>)
      (<l*1> ^alternative-structure <structure-new>)}
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name failed-receiver-no-alternative-structure +)
}

sp {elaborate*state*sentence-102*no
    (state <s> ^current-sentence-number 102 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |no.| +)
    (<w0> ^spelling no + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-101*done
    (state <s> ^current-sentence-number 101 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |done.| +)
    (<w0> ^spelling done + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-100*the-name-of-a-failure-is-enemy-3-in-a-row22
    (state <s> ^current-sentence-number 100 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |the name of a failure is enemy-3-in-a-row22.| +)
    (<w0> ^spelling the + ^next <w1> +)
    (<w1> ^spelling name + ^next <w2> +)
    (<w2> ^spelling of + ^next <w3> +)
    (<w3> ^spelling a + ^next <w4> +)
    (<w4> ^spelling failure + ^next <w5> +)
    (<w5> ^spelling is + ^next <w6> +)
    (<w6> ^spelling enemy-3-in-a-row22 + ^next <w7> +)
    (<w7> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-99*load-fail-tictactoe
    (state <s> ^current-sentence-number 99 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |load fail-tictactoe.| +)
    (<w0> ^spelling load + ^next <w1> +)
    (<w1> ^spelling fail-tictactoe + ^next <w2> +)
    (<w2> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-98*the-name-of-the-goal-is-three-in-a-row22
    (state <s> ^current-sentence-number 98 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |the name of the goal is three-in-a-row22.| +)
    (<w0> ^spelling the + ^next <w1> +)
    (<w1> ^spelling name + ^next <w2> +)
    (<w2> ^spelling of + ^next <w3> +)
    (<w3> ^spelling the + ^next <w4> +)
    (<w4> ^spelling goal + ^next <w5> +)
    (<w5> ^spelling is + ^next <w6> +)
    (<w6> ^spelling three-in-a-row22 + ^next <w7> +)
    (<w7> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-97*load-final-tictactoe
    (state <s> ^current-sentence-number 97 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |load final-tictactoe.| +)
    (<w0> ^spelling load + ^next <w1> +)
    (<w1> ^spelling final-tictactoe + ^next <w2> +)
    (<w2> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-96*you-can-move-a-free-clear-red-block-onto-a-clear-location
    (state <s> ^current-sentence-number 96 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |you can move a free clear red block onto a clear location.| +)
    (<w0> ^spelling you + ^next <w1> +)
    (<w1> ^spelling can + ^next <w2> +)
    (<w2> ^spelling move + ^next <w3> +)
    (<w3> ^spelling a + ^next <w4> +)
    (<w4> ^spelling free + ^next <w5> +)
    (<w5> ^spelling clear + ^next <w6> +)
    (<w6> ^spelling red + ^next <w7> +)
    (<w7> ^spelling block + ^next <w8> +)
    (<w8> ^spelling onto + ^next <w9> +)
    (<w9> ^spelling a + ^next <w10> +)
    (<w10> ^spelling clear + ^next <w11> +)
    (<w11> ^spelling location + ^next <w12> +)
    (<w12> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-95*ok
    (state <s> ^current-sentence-number 95 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |ok.| +)
    (<w0> ^spelling ok + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-94*load-init-tictactoe
    (state <s> ^current-sentence-number 94 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |load init-tictactoe.| +)
    (<w0> ^spelling load + ^next <w1> +)
    (<w1> ^spelling init-tictactoe + ^next <w2> +)
    (<w2> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-93*the-name-of-the-game-is-tic-tac-toe1616
    (state <s> ^current-sentence-number 93 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |the name of the game is tic-tac-toe1616.| +)
    (<w0> ^spelling the + ^next <w1> +)
    (<w1> ^spelling name + ^next <w2> +)
    (<w2> ^spelling of + ^next <w3> +)
    (<w3> ^spelling the + ^next <w4> +)
    (<w4> ^spelling game + ^next <w5> +)
    (<w5> ^spelling is + ^next <w6> +)
    (<w6> ^spelling tic-tac-toe1616 + ^next <w7> +)
    (<w7> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-92*no
    (state <s> ^current-sentence-number 92 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |no.| +)
    (<w0> ^spelling no + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-91*done
    (state <s> ^current-sentence-number 91 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |done.| +)
    (<w0> ^spelling done + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-90*ok
    (state <s> ^current-sentence-number 90 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |ok.| +)
    (<w0> ^spelling ok + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-89*the-goal-is-that-a-small-block-is-on-a-medium-block-and-the-medium-block-is-on-a-large-block-and-the-large-block-is-on-a-blue-location
    (state <s> ^current-sentence-number 89 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |The goal is that a small block is on a medium block and the medium block is on a large block and the large block is on a blue location.| +)
    (<w0> ^spelling the + ^next <w1> +)
    (<w1> ^spelling goal + ^next <w2> +)
    (<w2> ^spelling is + ^next <w3> +)
    (<w3> ^spelling that + ^next <w4> +)
    (<w4> ^spelling a + ^next <w5> +)
    (<w5> ^spelling small + ^next <w6> +)
    (<w6> ^spelling block + ^next <w7> +)
    (<w7> ^spelling is + ^next <w8> +)
    (<w8> ^spelling on + ^next <w9> +)
    (<w9> ^spelling a + ^next <w10> +)
    (<w10> ^spelling medium + ^next <w11> +)
    (<w11> ^spelling block + ^next <w12> +)
    (<w12> ^spelling and + ^next <w13> +)
    (<w13> ^spelling the + ^next <w14> +)
    (<w14> ^spelling medium + ^next <w15> +)
    (<w15> ^spelling block + ^next <w16> +)
    (<w16> ^spelling is + ^next <w17> +)
    (<w17> ^spelling on + ^next <w18> +)
    (<w18> ^spelling a + ^next <w19> +)
    (<w19> ^spelling large + ^next <w20> +)
    (<w20> ^spelling block + ^next <w21> +)
    (<w21> ^spelling and + ^next <w22> +)
    (<w22> ^spelling the + ^next <w23> +)
    (<w23> ^spelling large + ^next <w24> +)
    (<w24> ^spelling block + ^next <w25> +)
    (<w25> ^spelling is + ^next <w26> +)
    (<w26> ^spelling on + ^next <w27> +)
    (<w27> ^spelling a + ^next <w28> +)
    (<w28> ^spelling blue + ^next <w29> +)
    (<w29> ^spelling location + ^next <w30> +)
    (<w30> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-88*load-final-tower3
    (state <s> ^current-sentence-number 88 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |load final-tower3.| +)
    (<w0> ^spelling load + ^next <w1> +)
    (<w1> ^spelling final-tower3 + ^next <w2> +)
    (<w2> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-87*if-the-volume-of-a-block-is-more-than-the-volume-of-an-object-then-the-block-is-larger-than-the-object
    (state <s> ^current-sentence-number 87 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |if the volume of a block is more than the volume of an object then the block is larger than the object.| +)
    (<w0> ^spelling if + ^next <w1> +)
    (<w1> ^spelling the + ^next <w2> +)
    (<w2> ^spelling volume + ^next <w3> +)
    (<w3> ^spelling of + ^next <w4> +)
    (<w4> ^spelling a + ^next <w5> +)
    (<w5> ^spelling block + ^next <w6> +)
    (<w6> ^spelling is + ^next <w7> +)
    (<w7> ^spelling more + ^next <w8> +)
    (<w8> ^spelling than + ^next <w9> +)
    (<w9> ^spelling the + ^next <w10> +)
    (<w10> ^spelling volume + ^next <w11> +)
    (<w11> ^spelling of + ^next <w12> +)
    (<w12> ^spelling an + ^next <w13> +)
    (<w13> ^spelling object + ^next <w14> +)
    (<w14> ^spelling then + ^next <w15> +)
    (<w15> ^spelling the + ^next <w16> +)
    (<w16> ^spelling block + ^next <w17> +)
    (<w17> ^spelling is + ^next <w18> +)
    (<w18> ^spelling larger + ^next <w19> +)
    (<w19> ^spelling than + ^next <w20> +)
    (<w20> ^spelling the + ^next <w21> +)
    (<w21> ^spelling object + ^next <w22> +)
    (<w22> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-86*you-can-move-a-clear-block-onto-a-clear-object-that-is-larger-than-the-block
    (state <s> ^current-sentence-number 86 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |you can move a clear block onto a clear object that is larger than the block.| +)
    (<w0> ^spelling you + ^next <w1> +)
    (<w1> ^spelling can + ^next <w2> +)
    (<w2> ^spelling move + ^next <w3> +)
    (<w3> ^spelling a + ^next <w4> +)
    (<w4> ^spelling clear + ^next <w5> +)
    (<w5> ^spelling block + ^next <w6> +)
    (<w6> ^spelling onto + ^next <w7> +)
    (<w7> ^spelling a + ^next <w8> +)
    (<w8> ^spelling clear + ^next <w9> +)
    (<w9> ^spelling object + ^next <w10> +)
    (<w10> ^spelling that + ^next <w11> +)
    (<w11> ^spelling is + ^next <w12> +)
    (<w12> ^spelling larger + ^next <w13> +)
    (<w13> ^spelling than + ^next <w14> +)
    (<w14> ^spelling the + ^next <w15> +)
    (<w15> ^spelling block + ^next <w16> +)
    (<w16> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-85*the-name-of-an-action-is-stack-block22
    (state <s> ^current-sentence-number 85 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |the name of an action is stack-block22.| +)
    (<w0> ^spelling the + ^next <w1> +)
    (<w1> ^spelling name + ^next <w2> +)
    (<w2> ^spelling of + ^next <w3> +)
    (<w3> ^spelling an + ^next <w4> +)
    (<w4> ^spelling action + ^next <w5> +)
    (<w5> ^spelling is + ^next <w6> +)
    (<w6> ^spelling stack-block22 + ^next <w7> +)
    (<w7> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-84*ok
    (state <s> ^current-sentence-number 84 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |ok.| +)
    (<w0> ^spelling ok + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-83*load-init-tower3
    (state <s> ^current-sentence-number 83 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |load init-tower3.| +)
    (<w0> ^spelling load + ^next <w1> +)
    (<w1> ^spelling init-tower3 + ^next <w2> +)
    (<w2> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-82*the-name-of-the-puzzle-is-tower-of-hanoi-31414
    (state <s> ^current-sentence-number 82 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |The name of the puzzle is tower-of-hanoi-31414.| +)
    (<w0> ^spelling the + ^next <w1> +)
    (<w1> ^spelling name + ^next <w2> +)
    (<w2> ^spelling of + ^next <w3> +)
    (<w3> ^spelling the + ^next <w4> +)
    (<w4> ^spelling puzzle + ^next <w5> +)
    (<w5> ^spelling is + ^next <w6> +)
    (<w6> ^spelling tower-of-hanoi-31414 + ^next <w7> +)
    (<w7> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-81*no
    (state <s> ^current-sentence-number 81 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |no.| +)
    (<w0> ^spelling no + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-80*done
    (state <s> ^current-sentence-number 80 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |done.| +)
    (<w0> ^spelling done + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-79*ok
    (state <s> ^current-sentence-number 79 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |ok.| +)
    (<w0> ^spelling ok + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-78*the-goal-is-that-all-blocks-are-on-a-garbage
    (state <s> ^current-sentence-number 78 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |the goal is that all blocks are on a garbage.| +)
    (<w0> ^spelling the + ^next <w1> +)
    (<w1> ^spelling goal + ^next <w2> +)
    (<w2> ^spelling is + ^next <w3> +)
    (<w3> ^spelling that + ^next <w4> +)
    (<w4> ^spelling all + ^next <w5> +)
    (<w5> ^spelling blocks + ^next <w6> +)
    (<w6> ^spelling are + ^next <w7> +)
    (<w7> ^spelling on + ^next <w8> +)
    (<w8> ^spelling a + ^next <w9> +)
    (<w9> ^spelling garbage + ^next <w10> +)
    (<w10> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-77*load-final-mahjong
    (state <s> ^current-sentence-number 77 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |load final-mahjong.| +)
    (<w0> ^spelling load + ^next <w1> +)
    (<w1> ^spelling final-mahjong + ^next <w2> +)
    (<w2> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-76*if-the-color-of-a-clear-free-block-is-the-color-of-another-clear-free-block-then-you-can-move-the-blocks-onto-a-garbage
    (state <s> ^current-sentence-number 76 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |if the color of a clear free block is the color of another clear free block then you can move the blocks onto a garbage.| +)
    (<w0> ^spelling if + ^next <w1> +)
    (<w1> ^spelling the + ^next <w2> +)
    (<w2> ^spelling color + ^next <w3> +)
    (<w3> ^spelling of + ^next <w4> +)
    (<w4> ^spelling a + ^next <w5> +)
    (<w5> ^spelling clear + ^next <w6> +)
    (<w6> ^spelling free + ^next <w7> +)
    (<w7> ^spelling block + ^next <w8> +)
    (<w8> ^spelling is + ^next <w9> +)
    (<w9> ^spelling the + ^next <w10> +)
    (<w10> ^spelling color + ^next <w11> +)
    (<w11> ^spelling of + ^next <w12> +)
    (<w12> ^spelling another + ^next <w13> +)
    (<w13> ^spelling clear + ^next <w14> +)
    (<w14> ^spelling free + ^next <w15> +)
    (<w15> ^spelling block + ^next <w16> +)
    (<w16> ^spelling then + ^next <w17> +)
    (<w17> ^spelling you + ^next <w18> +)
    (<w18> ^spelling can + ^next <w19> +)
    (<w19> ^spelling move + ^next <w20> +)
    (<w20> ^spelling the + ^next <w21> +)
    (<w21> ^spelling blocks + ^next <w22> +)
    (<w22> ^spelling onto + ^next <w23> +)
    (<w23> ^spelling a + ^next <w24> +)
    (<w24> ^spelling garbage + ^next <w25> +)
    (<w25> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-75*ok
    (state <s> ^current-sentence-number 75 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |ok.| +)
    (<w0> ^spelling ok + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-74*load-init-mahjong
    (state <s> ^current-sentence-number 74 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |load init-mahjong.| +)
    (<w0> ^spelling load + ^next <w1> +)
    (<w1> ^spelling init-mahjong + ^next <w2> +)
    (<w2> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-73*the-name-of-the-puzzle-is-mahjong1212
    (state <s> ^current-sentence-number 73 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |the name of the puzzle is mahjong1212.| +)
    (<w0> ^spelling the + ^next <w1> +)
    (<w1> ^spelling name + ^next <w2> +)
    (<w2> ^spelling of + ^next <w3> +)
    (<w3> ^spelling the + ^next <w4> +)
    (<w4> ^spelling puzzle + ^next <w5> +)
    (<w5> ^spelling is + ^next <w6> +)
    (<w6> ^spelling mahjong1212 + ^next <w7> +)
    (<w7> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-72*no
    (state <s> ^current-sentence-number 72 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |no.| +)
    (<w0> ^spelling no + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-71*done
    (state <s> ^current-sentence-number 71 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |done.| +)
    (<w0> ^spelling done + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-70*ok
    (state <s> ^current-sentence-number 70 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |ok.| +)
    (<w0> ^spelling ok + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-69*the-goal-is-that-a-blue-block-is-on-a-blue-location
    (state <s> ^current-sentence-number 69 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |the goal is that a blue block is on a blue location.| +)
    (<w0> ^spelling the + ^next <w1> +)
    (<w1> ^spelling goal + ^next <w2> +)
    (<w2> ^spelling is + ^next <w3> +)
    (<w3> ^spelling that + ^next <w4> +)
    (<w4> ^spelling a + ^next <w5> +)
    (<w5> ^spelling blue + ^next <w6> +)
    (<w6> ^spelling block + ^next <w7> +)
    (<w7> ^spelling is + ^next <w8> +)
    (<w8> ^spelling on + ^next <w9> +)
    (<w9> ^spelling a + ^next <w10> +)
    (<w10> ^spelling blue + ^next <w11> +)
    (<w11> ^spelling location + ^next <w12> +)
    (<w12> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-68*load-final-maze
    (state <s> ^current-sentence-number 68 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |load final-maze.| +)
    (<w0> ^spelling load + ^next <w1> +)
    (<w1> ^spelling final-maze + ^next <w2> +)
    (<w2> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-67*if-a-blue-block-is-on-a-location-that-is-adjacent-to-a-clear-location-then-you-can-move-the-block-onto-the-clear-location
    (state <s> ^current-sentence-number 67 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |if a blue block is on a location that is adjacent to a clear location then you can move the block onto the clear location.| +)
    (<w0> ^spelling if + ^next <w1> +)
    (<w1> ^spelling a + ^next <w2> +)
    (<w2> ^spelling blue + ^next <w3> +)
    (<w3> ^spelling block + ^next <w4> +)
    (<w4> ^spelling is + ^next <w5> +)
    (<w5> ^spelling on + ^next <w6> +)
    (<w6> ^spelling a + ^next <w7> +)
    (<w7> ^spelling location + ^next <w8> +)
    (<w8> ^spelling that + ^next <w9> +)
    (<w9> ^spelling is + ^next <w10> +)
    (<w10> ^spelling adjacent + ^next <w11> +)
    (<w11> ^spelling to + ^next <w12> +)
    (<w12> ^spelling a + ^next <w13> +)
    (<w13> ^spelling clear + ^next <w14> +)
    (<w14> ^spelling location + ^next <w15> +)
    (<w15> ^spelling then + ^next <w16> +)
    (<w16> ^spelling you + ^next <w17> +)
    (<w17> ^spelling can + ^next <w18> +)
    (<w18> ^spelling move + ^next <w19> +)
    (<w19> ^spelling the + ^next <w20> +)
    (<w20> ^spelling block + ^next <w21> +)
    (<w21> ^spelling onto + ^next <w22> +)
    (<w22> ^spelling the + ^next <w23> +)
    (<w23> ^spelling clear + ^next <w24> +)
    (<w24> ^spelling location + ^next <w25> +)
    (<w25> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-66*ok
    (state <s> ^current-sentence-number 66 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |ok.| +)
    (<w0> ^spelling ok + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-65*load-init-maze
    (state <s> ^current-sentence-number 65 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |load init-maze.| +)
    (<w0> ^spelling load + ^next <w1> +)
    (<w1> ^spelling init-maze + ^next <w2> +)
    (<w2> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-64*the-name-of-the-puzzle-is-simple-maze1010
    (state <s> ^current-sentence-number 64 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |the name of the puzzle is simple-maze1010.| +)
    (<w0> ^spelling the + ^next <w1> +)
    (<w1> ^spelling name + ^next <w2> +)
    (<w2> ^spelling of + ^next <w3> +)
    (<w3> ^spelling the + ^next <w4> +)
    (<w4> ^spelling puzzle + ^next <w5> +)
    (<w5> ^spelling is + ^next <w6> +)
    (<w6> ^spelling simple-maze1010 + ^next <w7> +)
    (<w7> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-63*no
    (state <s> ^current-sentence-number 63 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |no.| +)
    (<w0> ^spelling no + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-62*done
    (state <s> ^current-sentence-number 62 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |done.| +)
    (<w0> ^spelling done + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-61*ok
    (state <s> ^current-sentence-number 61 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |ok.| +)
    (<w0> ^spelling ok + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-60*the-goal-is-that-there-are-eight-matched-locations
    (state <s> ^current-sentence-number 60 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |the goal is that there are eight matched locations.| +)
    (<w0> ^spelling the + ^next <w1> +)
    (<w1> ^spelling goal + ^next <w2> +)
    (<w2> ^spelling is + ^next <w3> +)
    (<w3> ^spelling that + ^next <w4> +)
    (<w4> ^spelling there + ^next <w5> +)
    (<w5> ^spelling are + ^next <w6> +)
    (<w6> ^spelling eight + ^next <w7> +)
    (<w7> ^spelling matched + ^next <w8> +)
    (<w8> ^spelling locations + ^next <w9> +)
    (<w9> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-59*load-final-8puzzle
    (state <s> ^current-sentence-number 59 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |load final-8puzzle.| +)
    (<w0> ^spelling load + ^next <w1> +)
    (<w1> ^spelling final-8puzzle + ^next <w2> +)
    (<w2> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-58*the-name-of-the-action-is-slide-block22
    (state <s> ^current-sentence-number 58 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |the name of the action is slide-block22.| +)
    (<w0> ^spelling the + ^next <w1> +)
    (<w1> ^spelling name + ^next <w2> +)
    (<w2> ^spelling of + ^next <w3> +)
    (<w3> ^spelling the + ^next <w4> +)
    (<w4> ^spelling action + ^next <w5> +)
    (<w5> ^spelling is + ^next <w6> +)
    (<w6> ^spelling slide-block22 + ^next <w7> +)
    (<w7> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-57*ok
    (state <s> ^current-sentence-number 57 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |ok.| +)
    (<w0> ^spelling ok + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-56*load-init-8puzzle
    (state <s> ^current-sentence-number 56 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |load init-8puzzle.| +)
    (<w0> ^spelling load + ^next <w1> +)
    (<w1> ^spelling init-8puzzle + ^next <w2> +)
    (<w2> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-55*the-name-of-the-puzzle-is-eight-puzzle88
    (state <s> ^current-sentence-number 55 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |the name of the puzzle is eight-puzzle88.| +)
    (<w0> ^spelling the + ^next <w1> +)
    (<w1> ^spelling name + ^next <w2> +)
    (<w2> ^spelling of + ^next <w3> +)
    (<w3> ^spelling the + ^next <w4> +)
    (<w4> ^spelling puzzle + ^next <w5> +)
    (<w5> ^spelling is + ^next <w6> +)
    (<w6> ^spelling eight-puzzle88 + ^next <w7> +)
    (<w7> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-54*no
    (state <s> ^current-sentence-number 54 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |no.| +)
    (<w0> ^spelling no + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-53*done
    (state <s> ^current-sentence-number 53 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |done.| +)
    (<w0> ^spelling done + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-52*ok
    (state <s> ^current-sentence-number 52 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |ok.| +)
    (<w0> ^spelling ok + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-51*the-goal-is-that-a-red-block-is-on-a-green-block-and-the-red-block-is-below-an-orange-block
    (state <s> ^current-sentence-number 51 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |The goal is that a red block is on a green block and the red block is below an orange block.| +)
    (<w0> ^spelling the + ^next <w1> +)
    (<w1> ^spelling goal + ^next <w2> +)
    (<w2> ^spelling is + ^next <w3> +)
    (<w3> ^spelling that + ^next <w4> +)
    (<w4> ^spelling a + ^next <w5> +)
    (<w5> ^spelling red + ^next <w6> +)
    (<w6> ^spelling block + ^next <w7> +)
    (<w7> ^spelling is + ^next <w8> +)
    (<w8> ^spelling on + ^next <w9> +)
    (<w9> ^spelling a + ^next <w10> +)
    (<w10> ^spelling green + ^next <w11> +)
    (<w11> ^spelling block + ^next <w12> +)
    (<w12> ^spelling and + ^next <w13> +)
    (<w13> ^spelling the + ^next <w14> +)
    (<w14> ^spelling red + ^next <w15> +)
    (<w15> ^spelling block + ^next <w16> +)
    (<w16> ^spelling is + ^next <w17> +)
    (<w17> ^spelling below + ^next <w18> +)
    (<w18> ^spelling an + ^next <w19> +)
    (<w19> ^spelling orange + ^next <w20> +)
    (<w20> ^spelling block + ^next <w21> +)
    (<w21> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-50*load-final-blocksworld
    (state <s> ^current-sentence-number 50 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |load final-blocksworld.| +)
    (<w0> ^spelling load + ^next <w1> +)
    (<w1> ^spelling final-blocksworld + ^next <w2> +)
    (<w2> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-49*you-can-move-a-clear-block-onto-a-clear-object
    (state <s> ^current-sentence-number 49 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |you can move a clear block onto a clear object.| +)
    (<w0> ^spelling you + ^next <w1> +)
    (<w1> ^spelling can + ^next <w2> +)
    (<w2> ^spelling move + ^next <w3> +)
    (<w3> ^spelling a + ^next <w4> +)
    (<w4> ^spelling clear + ^next <w5> +)
    (<w5> ^spelling block + ^next <w6> +)
    (<w6> ^spelling onto + ^next <w7> +)
    (<w7> ^spelling a + ^next <w8> +)
    (<w8> ^spelling clear + ^next <w9> +)
    (<w9> ^spelling object + ^next <w10> +)
    (<w10> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-48*ok
    (state <s> ^current-sentence-number 48 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |ok.| +)
    (<w0> ^spelling ok + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-47*load-init-blocksworld
    (state <s> ^current-sentence-number 47 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |load init-blocksworld.| +)
    (<w0> ^spelling load + ^next <w1> +)
    (<w1> ^spelling init-blocksworld + ^next <w2> +)
    (<w2> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-46*the-name-of-the-puzzle-is-blocks-world66
    (state <s> ^current-sentence-number 46 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |The name of the puzzle is blocks-world66.| +)
    (<w0> ^spelling the + ^next <w1> +)
    (<w1> ^spelling name + ^next <w2> +)
    (<w2> ^spelling of + ^next <w3> +)
    (<w3> ^spelling the + ^next <w4> +)
    (<w4> ^spelling puzzle + ^next <w5> +)
    (<w5> ^spelling is + ^next <w6> +)
    (<w6> ^spelling blocks-world66 + ^next <w7> +)
    (<w7> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-45*no
    (state <s> ^current-sentence-number 45 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |no.| +)
    (<w0> ^spelling no + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-44*done
    (state <s> ^current-sentence-number 44 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |done.| +)
    (<w0> ^spelling done + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-43*the-name-of-a-failure-is-enemy-3-in-a-row22
    (state <s> ^current-sentence-number 43 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |the name of a failure is enemy-3-in-a-row22.| +)
    (<w0> ^spelling the + ^next <w1> +)
    (<w1> ^spelling name + ^next <w2> +)
    (<w2> ^spelling of + ^next <w3> +)
    (<w3> ^spelling a + ^next <w4> +)
    (<w4> ^spelling failure + ^next <w5> +)
    (<w5> ^spelling is + ^next <w6> +)
    (<w6> ^spelling enemy-3-in-a-row22 + ^next <w7> +)
    (<w7> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-42*load-fail-connect-3
    (state <s> ^current-sentence-number 42 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |load fail-connect-3.| +)
    (<w0> ^spelling load + ^next <w1> +)
    (<w1> ^spelling fail-connect-3 + ^next <w2> +)
    (<w2> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-41*the-name-of-the-goal-is-three-in-a-row22
    (state <s> ^current-sentence-number 41 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |the name of the goal is three-in-a-row22.| +)
    (<w0> ^spelling the + ^next <w1> +)
    (<w1> ^spelling name + ^next <w2> +)
    (<w2> ^spelling of + ^next <w3> +)
    (<w3> ^spelling the + ^next <w4> +)
    (<w4> ^spelling goal + ^next <w5> +)
    (<w5> ^spelling is + ^next <w6> +)
    (<w6> ^spelling three-in-a-row22 + ^next <w7> +)
    (<w7> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-40*load-final-connect-3
    (state <s> ^current-sentence-number 40 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |load final-connect-3.| +)
    (<w0> ^spelling load + ^next <w1> +)
    (<w1> ^spelling final-connect-3 + ^next <w2> +)
    (<w2> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-39*you-can-move-a-free-clear-red-block-onto-a-clear-location
    (state <s> ^current-sentence-number 39 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |you can move a free clear red block onto a clear location.| +)
    (<w0> ^spelling you + ^next <w1> +)
    (<w1> ^spelling can + ^next <w2> +)
    (<w2> ^spelling move + ^next <w3> +)
    (<w3> ^spelling a + ^next <w4> +)
    (<w4> ^spelling free + ^next <w5> +)
    (<w5> ^spelling clear + ^next <w6> +)
    (<w6> ^spelling red + ^next <w7> +)
    (<w7> ^spelling block + ^next <w8> +)
    (<w8> ^spelling onto + ^next <w9> +)
    (<w9> ^spelling a + ^next <w10> +)
    (<w10> ^spelling clear + ^next <w11> +)
    (<w11> ^spelling location + ^next <w12> +)
    (<w12> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-38*the-name-of-an-action-is-place-block22
    (state <s> ^current-sentence-number 38 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |the name of an action is place-block22.| +)
    (<w0> ^spelling the + ^next <w1> +)
    (<w1> ^spelling name + ^next <w2> +)
    (<w2> ^spelling of + ^next <w3> +)
    (<w3> ^spelling an + ^next <w4> +)
    (<w4> ^spelling action + ^next <w5> +)
    (<w5> ^spelling is + ^next <w6> +)
    (<w6> ^spelling place-block22 + ^next <w7> +)
    (<w7> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-37*ok
    (state <s> ^current-sentence-number 37 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |ok.| +)
    (<w0> ^spelling ok + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-36*load-init-connect-3
    (state <s> ^current-sentence-number 36 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |load init-connect-3.| +)
    (<w0> ^spelling load + ^next <w1> +)
    (<w1> ^spelling init-connect-3 + ^next <w2> +)
    (<w2> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-35*the-name-of-the-game-is-connect-all-344
    (state <s> ^current-sentence-number 35 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |the name of the game is connect-all-344.| +)
    (<w0> ^spelling the + ^next <w1> +)
    (<w1> ^spelling name + ^next <w2> +)
    (<w2> ^spelling of + ^next <w3> +)
    (<w3> ^spelling the + ^next <w4> +)
    (<w4> ^spelling game + ^next <w5> +)
    (<w5> ^spelling is + ^next <w6> +)
    (<w6> ^spelling connect-all-344 + ^next <w7> +)
    (<w7> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-34*no
    (state <s> ^current-sentence-number 34 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |no.| +)
    (<w0> ^spelling no + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-33*done
    (state <s> ^current-sentence-number 33 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |done.| +)
    (<w0> ^spelling done + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-32*if-a-location-is-below-a-blue-block-then-it-is-occupied
    (state <s> ^current-sentence-number 32 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |if a location is below a blue block then it is occupied.| +)
    (<w0> ^spelling if + ^next <w1> +)
    (<w1> ^spelling a + ^next <w2> +)
    (<w2> ^spelling location + ^next <w3> +)
    (<w3> ^spelling is + ^next <w4> +)
    (<w4> ^spelling below + ^next <w5> +)
    (<w5> ^spelling a + ^next <w6> +)
    (<w6> ^spelling blue + ^next <w7> +)
    (<w7> ^spelling block + ^next <w8> +)
    (<w8> ^spelling then + ^next <w9> +)
    (<w9> ^spelling it + ^next <w10> +)
    (<w10> ^spelling is + ^next <w11> +)
    (<w11> ^spelling occupied + ^next <w12> +)
    (<w12> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-31*if-three-linear-locations-are-occupied-then-you-lose
    (state <s> ^current-sentence-number 31 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |if three linear locations are occupied then you lose.| +)
    (<w0> ^spelling if + ^next <w1> +)
    (<w1> ^spelling three + ^next <w2> +)
    (<w2> ^spelling linear + ^next <w3> +)
    (<w3> ^spelling locations + ^next <w4> +)
    (<w4> ^spelling are + ^next <w5> +)
    (<w5> ^spelling occupied + ^next <w6> +)
    (<w6> ^spelling then + ^next <w7> +)
    (<w7> ^spelling you + ^next <w8> +)
    (<w8> ^spelling lose + ^next <w9> +)
    (<w9> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-30*ok
    (state <s> ^current-sentence-number 30 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |ok.| +)
    (<w0> ^spelling ok + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-29*the-name-of-a-failure-is-enemy-3-in-a-row22
    (state <s> ^current-sentence-number 29 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |the name of a failure is enemy-3-in-a-row22.| +)
    (<w0> ^spelling the + ^next <w1> +)
    (<w1> ^spelling name + ^next <w2> +)
    (<w2> ^spelling of + ^next <w3> +)
    (<w3> ^spelling a + ^next <w4> +)
    (<w4> ^spelling failure + ^next <w5> +)
    (<w5> ^spelling is + ^next <w6> +)
    (<w6> ^spelling enemy-3-in-a-row22 + ^next <w7> +)
    (<w7> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-28*load-fail-connect-3
    (state <s> ^current-sentence-number 28 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |load fail-connect-3.| +)
    (<w0> ^spelling load + ^next <w1> +)
    (<w1> ^spelling fail-connect-3 + ^next <w2> +)
    (<w2> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-27*if-a-location-is-below-a-red-block-then-it-is-captured
    (state <s> ^current-sentence-number 27 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |if a location is below a red block then it is captured.| +)
    (<w0> ^spelling if + ^next <w1> +)
    (<w1> ^spelling a + ^next <w2> +)
    (<w2> ^spelling location + ^next <w3> +)
    (<w3> ^spelling is + ^next <w4> +)
    (<w4> ^spelling below + ^next <w5> +)
    (<w5> ^spelling a + ^next <w6> +)
    (<w6> ^spelling red + ^next <w7> +)
    (<w7> ^spelling block + ^next <w8> +)
    (<w8> ^spelling then + ^next <w9> +)
    (<w9> ^spelling it + ^next <w10> +)
    (<w10> ^spelling is + ^next <w11> +)
    (<w11> ^spelling captured + ^next <w12> +)
    (<w12> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-26*the-goal-is-that-three-linear-locations-are-captured
    (state <s> ^current-sentence-number 26 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |the goal is that three linear locations are captured.| +)
    (<w0> ^spelling the + ^next <w1> +)
    (<w1> ^spelling goal + ^next <w2> +)
    (<w2> ^spelling is + ^next <w3> +)
    (<w3> ^spelling that + ^next <w4> +)
    (<w4> ^spelling three + ^next <w5> +)
    (<w5> ^spelling linear + ^next <w6> +)
    (<w6> ^spelling locations + ^next <w7> +)
    (<w7> ^spelling are + ^next <w8> +)
    (<w8> ^spelling captured + ^next <w9> +)
    (<w9> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-25*ok
    (state <s> ^current-sentence-number 25 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |ok.| +)
    (<w0> ^spelling ok + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-24*the-name-of-the-goal-is-three-in-a-row22
    (state <s> ^current-sentence-number 24 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |the name of the goal is three-in-a-row22.| +)
    (<w0> ^spelling the + ^next <w1> +)
    (<w1> ^spelling name + ^next <w2> +)
    (<w2> ^spelling of + ^next <w3> +)
    (<w3> ^spelling the + ^next <w4> +)
    (<w4> ^spelling goal + ^next <w5> +)
    (<w5> ^spelling is + ^next <w6> +)
    (<w6> ^spelling three-in-a-row22 + ^next <w7> +)
    (<w7> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-23*if-a-location-is-below-an-object-then-it-is-covered
    (state <s> ^current-sentence-number 23 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |if a location is below an object then it is covered.| +)
    (<w0> ^spelling if + ^next <w1> +)
    (<w1> ^spelling a + ^next <w2> +)
    (<w2> ^spelling location + ^next <w3> +)
    (<w3> ^spelling is + ^next <w4> +)
    (<w4> ^spelling below + ^next <w5> +)
    (<w5> ^spelling an + ^next <w6> +)
    (<w6> ^spelling object + ^next <w7> +)
    (<w7> ^spelling then + ^next <w8> +)
    (<w8> ^spelling it + ^next <w9> +)
    (<w9> ^spelling is + ^next <w10> +)
    (<w10> ^spelling covered + ^next <w11> +)
    (<w11> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-22*you-can-move-a-free-clear-red-block-onto-a-clear-location-that-is-above-a-covered-location
    (state <s> ^current-sentence-number 22 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |you can move a free clear red block onto a clear location that is above a covered location.| +)
    (<w0> ^spelling you + ^next <w1> +)
    (<w1> ^spelling can + ^next <w2> +)
    (<w2> ^spelling move + ^next <w3> +)
    (<w3> ^spelling a + ^next <w4> +)
    (<w4> ^spelling free + ^next <w5> +)
    (<w5> ^spelling clear + ^next <w6> +)
    (<w6> ^spelling red + ^next <w7> +)
    (<w7> ^spelling block + ^next <w8> +)
    (<w8> ^spelling onto + ^next <w9> +)
    (<w9> ^spelling a + ^next <w10> +)
    (<w10> ^spelling clear + ^next <w11> +)
    (<w11> ^spelling location + ^next <w12> +)
    (<w12> ^spelling that + ^next <w13> +)
    (<w13> ^spelling is + ^next <w14> +)
    (<w14> ^spelling above + ^next <w15> +)
    (<w15> ^spelling a + ^next <w16> +)
    (<w16> ^spelling covered + ^next <w17> +)
    (<w17> ^spelling location + ^next <w18> +)
    (<w18> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-21*the-name-of-an-action-is-stack-drop22
    (state <s> ^current-sentence-number 21 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |the name of an action is stack-drop22.| +)
    (<w0> ^spelling the + ^next <w1> +)
    (<w1> ^spelling name + ^next <w2> +)
    (<w2> ^spelling of + ^next <w3> +)
    (<w3> ^spelling an + ^next <w4> +)
    (<w4> ^spelling action + ^next <w5> +)
    (<w5> ^spelling is + ^next <w6> +)
    (<w6> ^spelling stack-drop22 + ^next <w7> +)
    (<w7> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-20*load-final-connect-3
    (state <s> ^current-sentence-number 20 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |load final-connect-3.| +)
    (<w0> ^spelling load + ^next <w1> +)
    (<w1> ^spelling final-connect-3 + ^next <w2> +)
    (<w2> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-19*if-a-block-is-not-on-a-location-then-it-is-free
    (state <s> ^current-sentence-number 19 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |if a block is not on a location then it is free.| +)
    (<w0> ^spelling if + ^next <w1> +)
    (<w1> ^spelling a + ^next <w2> +)
    (<w2> ^spelling block + ^next <w3> +)
    (<w3> ^spelling is + ^next <w4> +)
    (<w4> ^spelling not + ^next <w5> +)
    (<w5> ^spelling on + ^next <w6> +)
    (<w6> ^spelling a + ^next <w7> +)
    (<w7> ^spelling location + ^next <w8> +)
    (<w8> ^spelling then + ^next <w9> +)
    (<w9> ^spelling it + ^next <w10> +)
    (<w10> ^spelling is + ^next <w11> +)
    (<w11> ^spelling free + ^next <w12> +)
    (<w12> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-18*if-a-clear-location-is-not-above-a-location-then-you-can-move-a-free-clear-red-block-onto-the-clear-location
    (state <s> ^current-sentence-number 18 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |if a clear location is not above a location then you can move a free clear red block onto the clear location.| +)
    (<w0> ^spelling if + ^next <w1> +)
    (<w1> ^spelling a + ^next <w2> +)
    (<w2> ^spelling clear + ^next <w3> +)
    (<w3> ^spelling location + ^next <w4> +)
    (<w4> ^spelling is + ^next <w5> +)
    (<w5> ^spelling not + ^next <w6> +)
    (<w6> ^spelling above + ^next <w7> +)
    (<w7> ^spelling a + ^next <w8> +)
    (<w8> ^spelling location + ^next <w9> +)
    (<w9> ^spelling then + ^next <w10> +)
    (<w10> ^spelling you + ^next <w11> +)
    (<w11> ^spelling can + ^next <w12> +)
    (<w12> ^spelling move + ^next <w13> +)
    (<w13> ^spelling a + ^next <w14> +)
    (<w14> ^spelling free + ^next <w15> +)
    (<w15> ^spelling clear + ^next <w16> +)
    (<w16> ^spelling red + ^next <w17> +)
    (<w17> ^spelling block + ^next <w18> +)
    (<w18> ^spelling onto + ^next <w19> +)
    (<w19> ^spelling the + ^next <w20> +)
    (<w20> ^spelling clear + ^next <w21> +)
    (<w21> ^spelling location + ^next <w22> +)
    (<w22> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-17*the-name-of-an-action-is-bottom-drop22
    (state <s> ^current-sentence-number 17 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |the name of an action is bottom-drop22.| +)
    (<w0> ^spelling the + ^next <w1> +)
    (<w1> ^spelling name + ^next <w2> +)
    (<w2> ^spelling of + ^next <w3> +)
    (<w3> ^spelling an + ^next <w4> +)
    (<w4> ^spelling action + ^next <w5> +)
    (<w5> ^spelling is + ^next <w6> +)
    (<w6> ^spelling bottom-drop22 + ^next <w7> +)
    (<w7> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-16*ok
    (state <s> ^current-sentence-number 16 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |ok.| +)
    (<w0> ^spelling ok + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-15*load-init-connect-3
    (state <s> ^current-sentence-number 15 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |load init-connect-3.| +)
    (<w0> ^spelling load + ^next <w1> +)
    (<w1> ^spelling init-connect-3 + ^next <w2> +)
    (<w2> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-14*the-name-of-the-game-is-connect-322
    (state <s> ^current-sentence-number 14 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |the name of the game is connect-322.| +)
    (<w0> ^spelling the + ^next <w1> +)
    (<w1> ^spelling name + ^next <w2> +)
    (<w2> ^spelling of + ^next <w3> +)
    (<w3> ^spelling the + ^next <w4> +)
    (<w4> ^spelling game + ^next <w5> +)
    (<w5> ^spelling is + ^next <w6> +)
    (<w6> ^spelling connect-322 + ^next <w7> +)
    (<w7> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-13*no
    (state <s> ^current-sentence-number 13 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |no.| +)
    (<w0> ^spelling no + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-12*done
    (state <s> ^current-sentence-number 12 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |done.| +)
    (<w0> ^spelling done + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-11*ok
    (state <s> ^current-sentence-number 11 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |ok.| +)
    (<w0> ^spelling ok + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-10*if-the-color-of-a-location-is-the-color-of-the-block-that-is-on-the-location-then-the-location-is-matched
    (state <s> ^current-sentence-number 10 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |if the color of a location is the color of the block that is on the location then the location is matched.| +)
    (<w0> ^spelling if + ^next <w1> +)
    (<w1> ^spelling the + ^next <w2> +)
    (<w2> ^spelling color + ^next <w3> +)
    (<w3> ^spelling of + ^next <w4> +)
    (<w4> ^spelling a + ^next <w5> +)
    (<w5> ^spelling location + ^next <w6> +)
    (<w6> ^spelling is + ^next <w7> +)
    (<w7> ^spelling the + ^next <w8> +)
    (<w8> ^spelling color + ^next <w9> +)
    (<w9> ^spelling of + ^next <w10> +)
    (<w10> ^spelling the + ^next <w11> +)
    (<w11> ^spelling block + ^next <w12> +)
    (<w12> ^spelling that + ^next <w13> +)
    (<w13> ^spelling is + ^next <w14> +)
    (<w14> ^spelling on + ^next <w15> +)
    (<w15> ^spelling the + ^next <w16> +)
    (<w16> ^spelling location + ^next <w17> +)
    (<w17> ^spelling then + ^next <w18> +)
    (<w18> ^spelling the + ^next <w19> +)
    (<w19> ^spelling location + ^next <w20> +)
    (<w20> ^spelling is + ^next <w21> +)
    (<w21> ^spelling matched + ^next <w22> +)
    (<w22> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-9*the-goal-is-that-there-are-five-matched-locations
    (state <s> ^current-sentence-number 9 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |the goal is that there are five matched locations.| +)
    (<w0> ^spelling the + ^next <w1> +)
    (<w1> ^spelling goal + ^next <w2> +)
    (<w2> ^spelling is + ^next <w3> +)
    (<w3> ^spelling that + ^next <w4> +)
    (<w4> ^spelling there + ^next <w5> +)
    (<w5> ^spelling are + ^next <w6> +)
    (<w6> ^spelling five + ^next <w7> +)
    (<w7> ^spelling matched + ^next <w8> +)
    (<w8> ^spelling locations + ^next <w9> +)
    (<w9> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-8*load-final-5puzzle
    (state <s> ^current-sentence-number 8 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |load final-5puzzle.| +)
    (<w0> ^spelling load + ^next <w1> +)
    (<w1> ^spelling final-5puzzle + ^next <w2> +)
    (<w2> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-7*if-a-location-is-not-below-an-object-then-it-is-clear
    (state <s> ^current-sentence-number 7 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |if a location is not below an object then it is clear.| +)
    (<w0> ^spelling if + ^next <w1> +)
    (<w1> ^spelling a + ^next <w2> +)
    (<w2> ^spelling location + ^next <w3> +)
    (<w3> ^spelling is + ^next <w4> +)
    (<w4> ^spelling not + ^next <w5> +)
    (<w5> ^spelling below + ^next <w6> +)
    (<w6> ^spelling an + ^next <w7> +)
    (<w7> ^spelling object + ^next <w8> +)
    (<w8> ^spelling then + ^next <w9> +)
    (<w9> ^spelling it + ^next <w10> +)
    (<w10> ^spelling is + ^next <w11> +)
    (<w11> ^spelling clear + ^next <w12> +)
    (<w12> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-6*if-a-location-is-next-to-an-object-but-it-is-not-diagonal-with-the-object-then-it-is-adjacent-to-the-object
    (state <s> ^current-sentence-number 6 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |if a location is next to an object but it is not diagonal with the object then it is adjacent to the object.| +)
    (<w0> ^spelling if + ^next <w1> +)
    (<w1> ^spelling a + ^next <w2> +)
    (<w2> ^spelling location + ^next <w3> +)
    (<w3> ^spelling is + ^next <w4> +)
    (<w4> ^spelling next + ^next <w5> +)
    (<w5> ^spelling to + ^next <w6> +)
    (<w6> ^spelling an + ^next <w7> +)
    (<w7> ^spelling object + ^next <w8> +)
    (<w8> ^spelling but + ^next <w9> +)
    (<w9> ^spelling it + ^next <w10> +)
    (<w10> ^spelling is + ^next <w11> +)
    (<w11> ^spelling not + ^next <w12> +)
    (<w12> ^spelling diagonal + ^next <w13> +)
    (<w13> ^spelling with + ^next <w14> +)
    (<w14> ^spelling the + ^next <w15> +)
    (<w15> ^spelling object + ^next <w16> +)
    (<w16> ^spelling then + ^next <w17> +)
    (<w17> ^spelling it + ^next <w18> +)
    (<w18> ^spelling is + ^next <w19> +)
    (<w19> ^spelling adjacent + ^next <w20> +)
    (<w20> ^spelling to + ^next <w21> +)
    (<w21> ^spelling the + ^next <w22> +)
    (<w22> ^spelling object + ^next <w23> +)
    (<w23> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-5*if-a-block-is-on-a-location-that-is-adjacent-to-a-clear-location-then-you-can-move-the-block-onto-the-clear-location
    (state <s> ^current-sentence-number 5 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |if a block is on a location that is adjacent to a clear location then you can move the block onto the clear location.| +)
    (<w0> ^spelling if + ^next <w1> +)
    (<w1> ^spelling a + ^next <w2> +)
    (<w2> ^spelling block + ^next <w3> +)
    (<w3> ^spelling is + ^next <w4> +)
    (<w4> ^spelling on + ^next <w5> +)
    (<w5> ^spelling a + ^next <w6> +)
    (<w6> ^spelling location + ^next <w7> +)
    (<w7> ^spelling that + ^next <w8> +)
    (<w8> ^spelling is + ^next <w9> +)
    (<w9> ^spelling adjacent + ^next <w10> +)
    (<w10> ^spelling to + ^next <w11> +)
    (<w11> ^spelling a + ^next <w12> +)
    (<w12> ^spelling clear + ^next <w13> +)
    (<w13> ^spelling location + ^next <w14> +)
    (<w14> ^spelling then + ^next <w15> +)
    (<w15> ^spelling you + ^next <w16> +)
    (<w16> ^spelling can + ^next <w17> +)
    (<w17> ^spelling move + ^next <w18> +)
    (<w18> ^spelling the + ^next <w19> +)
    (<w19> ^spelling block + ^next <w20> +)
    (<w20> ^spelling onto + ^next <w21> +)
    (<w21> ^spelling the + ^next <w22> +)
    (<w22> ^spelling clear + ^next <w23> +)
    (<w23> ^spelling location + ^next <w24> +)
    (<w24> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-4*the-name-of-the-action-is-slide-block22
    (state <s> ^current-sentence-number 4 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |the name of the action is slide-block22.| +)
    (<w0> ^spelling the + ^next <w1> +)
    (<w1> ^spelling name + ^next <w2> +)
    (<w2> ^spelling of + ^next <w3> +)
    (<w3> ^spelling the + ^next <w4> +)
    (<w4> ^spelling action + ^next <w5> +)
    (<w5> ^spelling is + ^next <w6> +)
    (<w6> ^spelling slide-block22 + ^next <w7> +)
    (<w7> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-3*ok
    (state <s> ^current-sentence-number 3 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |ok.| +)
    (<w0> ^spelling ok + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-2*load-init-5puzzle
    (state <s> ^current-sentence-number 2 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |load init-5puzzle.| +)
    (<w0> ^spelling load + ^next <w1> +)
    (<w1> ^spelling init-5puzzle + ^next <w2> +)
    (<w2> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-1*the-name-of-the-puzzle-is-five-puzzle00
    (state <s> ^current-sentence-number 1 ^name rosie ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |the name of the puzzle is five-puzzle00.| +)
    (<w0> ^spelling the + ^next <w1> +)
    (<w1> ^spelling name + ^next <w2> +)
    (<w2> ^spelling of + ^next <w3> +)
    (<w3> ^spelling the + ^next <w4> +)
    (<w4> ^spelling puzzle + ^next <w5> +)
    (<w5> ^spelling is + ^next <w6> +)
    (<w6> ^spelling five-puzzle00 + ^next <w7> +)
    (<w7> ^spelling |.| + ^next nil +)
}

sp {apply*initialize-rosie*sentence-number
    (state <s> ^name rosie ^top-state <t*1> ^operator <o*1>)
    (<t*1> ^world-usage internal)
    (<o*1> ^name initialize-rosie)
    -->
    (<s> ^current-sentence-number 1 + ^max-sentence-number 102 +
           ^game-scripting true +)
}

sp {apply*runaway-word-processing*external
    (state <s> ^top-state <ts> ^operator <o*1> ^segment <seg>)
    (<ts> ^world-usage external)
    (<o*1> ^name runaway-word-processing)
    (<seg> ^decision-count-threshold <thres> ^original-sentence <cs>)
    -->
    (<seg> ^decision-count-threshold <thres> - ^processed-terminator true +)
    (<cs> ^processed-sentence true + ^processing-result failure +)
}

sp {apply*runaway-word-processing*internal
    (state <s> ^top-state <ts> ^operator <o*1> ^segment <seg>)
    (<ts> ^world-usage internal ^failure-count <fc>
          ^current-sentence-number <csn>)
    (<o*1> ^name runaway-word-processing)
    (<seg> ^decision-count-threshold <thres> ^original-sentence <cs>)
    -->
    (<seg> ^decision-count-threshold <thres> - ^processed-terminator true +)
    (<cs> ^processed-sentence true + ^processing-result failure +)
    (<ts> ^terminated-sentence <csn> + ^failure-count <fc> -
           ^failure-count (+ <fc> 1) +)
}

sp {comprehension*propose*runaway-word-processing
    (state <s> ^name comprehension ^top-state <t*1> ^segment <s*2>)
    (<t*1> ^world-usage external)
    (<s*2> ^decision-count-threshold <thres>)
   -{ (<s> ^top-state <t*2>)
      (<t*2> ^io <i*1>)
      (<i*1> ^input-link <i*2>)
      (<i*2> ^time <t*3>)
      (<t*3> ^steps { <= <thres> <s*1> })}
    -->
    (<s> ^operator <op> !)
    (<op> ^name runaway-word-processing +)
}

sp {comprehension*apply*reprocess-unknown-word
    (state <s> ^operator <op> ^smem <s*1>)
    (<op> ^name reprocess-unknown-word ^not-merged-assigner <uai>
          ^not-merged-receiver <uri>)
    (<uri> ^lt <lli>)
    (<lli> -^structure-type <s*2>)
    (<uai> ^structure-type <new>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^store <lli> +)
    (<uri> ^structure-type <new> +)
    (<lli> ^structure-type <new> +)
}

sp {comprehension*propose*reprocess-unknown-word*no-prior-merge
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^last-merge <l*1> ^not-merged-receiver <uri> ^retrieved-stack <r*1>
          ^not-merged-assigner <as1>)
    (<l*1> ^assigner nil)
    (<uri> -^structure-type <s*1> ^lt <lti>)
    (<as1> ^lt <l*2> ^parent-receiver <ps>)
    (<l*2> ^required true)
    (<ps> ^structure-type <sstruct> ^lt <l*3>)
   -{ (<seg> ^not-merged-receiver <n*1>)
      (<n*1> ^structure-type <sstruct>)}
    (<lti> ^possible-assigners <p*1>)
    (<p*1> ^assigner <as1>)
    (<l*3> ^converts-to { <> <sstruct> <nstruct> })
    (<r*1> ^item { <> <uri> <item> })
    (<item> ^structure-type { <> <nstruct> <> <sstruct> <s*2> })
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name reprocess-unknown-word + ^not-merged-receiver <uri> +
           ^not-merged-assigner <as1> +)
}

sp {comprehension*propose*reprocess-unknown-word
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^not-merged-receiver <uri> ^not-merged-assigner <as1>)
    (<uri> -^structure-type <s*1> ^lt <lti>)
   -{ (<lti> ^possible-assigners <p*2>)
      (<seg> ^not-merged-assigner { <> <as1> <as2> })
      (<p*2> ^assigner <as2>)}
    (<lti> ^possible-assigners <p*1>)
    (<p*1> ^assigner <as1>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name reprocess-unknown-word + ^not-merged-receiver <uri> +
           ^not-merged-assigner <as1> +)
}

sp {apply*process-semantics*remove-ungrounded
    (state <s> ^operator <op>)
    (<op> ^name process-semantics ^assigner <ass> ^attribute <att>)
    (<ass> ^parent-receiver <p*1>)
    (<p*1> ^semantics <sem>)
    (<sem> ^<att> <val>)
    (<val> ^ungrounded <x>)
    -->
    (<sem> ^<att> <val> -)
}

sp {apply*process-semantics*simple*item-type*predicate2
    (state <s> ^operator <op>)
    (<op> ^name process-semantics ^value2 <value>
          ^attribute2 { << predicate relation >> <a*1> })
    (<value> -^item-type <i*1>)
    -->
    (<value> ^item-type predicate +)
}

sp {apply*process-semantics*simple*item-type*action
    (state <s> ^operator <op>)
    (<op> ^name process-semantics ^attribute action ^value <value>)
    (<value> -^item-type <i*1>)
    -->
    (<value> ^item-type action +)
}

sp {apply*process-semantics*simple*item-type*predicate
    (state <s> ^operator <op>)
    (<op> -^extra-attribute <of> ^name process-semantics ^attribute predicate
          ^value <value>)
    (<value> -^item-type <i*1>)
    -->
    (<value> ^item-type predicate +)
}

sp {apply*process-semantics*relation*embedded2
    (state <s> ^operator <op> ^assigner <ass>)
    (<op> ^name process-semantics ^attribute relation ^assigner <ass>
          ^value <value>)
    (<ass> ^parent-receiver <pr>)
    (<pr> ^complement <c*1> ^semantics <sem>)
    (<c*1> ^lt <l*1>)
    (<l*1> ^relation <r*1>)
    (<r*1> ^handle named)
    -->
    (<sem> ^predicate <sr2> +)
    (<sr2> ^handle named + ^2 <value> + ^item-type predicate +)
    (<ass> ^processed-semantics <value> +)
}

sp {apply*process-semantics*relation*embedded
    (state <s> ^operator <op> ^assigner <ass>)
    (<op> ^name process-semantics ^attribute relation ^assigner <ass>
          ^value <value>)
    (<ass> ^parent-receiver <p*1>)
    (<p*1> ^semantics <sem>)
    (<value> ^relation <sr>)
    (<sr> -^3 <sg3> ^2 <sg> ^handle <sp>)
    -->
    (<sem> ^predicate <sr2> +)
    (<sr2> ^handle <sp> + ^2 <sg> + ^item-type predicate +)
    (<ass> ^processed-semantics <value> +)
}

sp {apply*process-semantics*relation*other*deeper
    (state <s> ^operator <op> ^assigner <ass>)
    (<op> ^name process-semantics ^assigner <ass> ^relation2 <rel2>
          ^value <sg> ^attribute { <> relation <att> } ^relation <sr>)
    (<ass> ^parent-receiver <p*1>)
    (<p*1> ^semantics <sem>)
    (<sg> ^2 <sg2> ^handle <sghandle>)
    (<sr> ^2 <sg> ^handle <sp>)
    -->
    (write (crlf) | Add to assigner: | <ass> | Semantics: | <sem> | ^predicate | <sp> | (| <sghandle> |)| <sg2>)
    (<sem> ^<att> <sr2> +)
    (<sr2> ^handle <sp> + ^2 <sgx> + ^item-type predicate +)
    (<sgx> ^handle <sghandle> + ^2 <sg2> +)
    (<sg2> ^relation <rel2> +)
    (<ass> ^processed-semantics <sg> +)
}

sp {apply*process-semantics*relation*other*deep2
    (state <s> ^operator <op> ^assigner <ass>)
    (<op> -^relation2 <r*1> ^name process-semantics ^assigner <ass>
          ^attribute { <> relation <att> } ^relation <sr> -^value <sg>)
    (<ass> ^parent-receiver <p*1>)
    (<p*1> ^semantics <sem>)
    (<sr> ^2 <sg> ^handle <sp>)
    (<sg> ^2 <sg2> ^handle <sghandle>)
    -->
    (write (crlf) | Add to assigner: | <ass> | Semantics: | <sem> | ^predicate | <sp> | (| <sghandle> |)| <sg2>)
    (<sem> ^<att> <sr2> +)
    (<sr2> ^handle <sp> + ^2 <sgx> + ^item-type predicate +)
    (<sgx> ^handle <sghandle> + ^2 <sg2> +)
    (<ass> ^processed-semantics <sg> +)
}

sp {apply*process-semantics*relation*other*deep
    (state <s> ^operator <op> ^assigner <ass>)
    (<op> -^relation2 <r*1> ^name process-semantics ^assigner <ass>
          ^value <sg> ^attribute { <> relation <att> } ^relation <sr>)
    (<ass> ^parent-receiver <p*1>)
    (<p*1> ^semantics <sem>)
    (<sg> ^2 <sg2> ^handle <sghandle>)
    (<sr> ^2 <sg> ^handle <sp>)
    -->
    (<sem> ^<att> <sr2> +)
    (<sr2> ^handle <sp> + ^2 <sgx> + ^item-type predicate +)
    (<sgx> ^handle <sghandle> + ^2 <sg2> +)
    (<ass> ^processed-semantics <sg> +)
}

sp {apply*process-semantics*relation*other3
    (state <s> ^operator <op> ^assigner <ass>)
    (<op> -^value <v*1> ^name process-semantics ^assigner <ass>
          ^attribute { <> relation <att> } ^relation <sr>)
    (<ass> ^parent-receiver <p*1>)
    (<p*1> ^semantics <sem>)
    (<sr> ^2 <sg> ^3 <sg3> ^handle <sp>)
    -->
    (<sem> ^<att> <sr2> +)
    (<sr2> ^handle <sp> + ^2 <sg3> + ^item-type predicate +)
    (<ass> ^processed-semantics <sg> +)
}

sp {apply*process-semantics*relation*other
    (state <s> ^operator <op> ^assigner <ass>)
    (<op> -^value <v*1> ^name process-semantics ^assigner <ass>
          ^attribute { <> relation <att> } ^relation <sr>)
    (<ass> ^parent-receiver <p*1>)
    (<p*1> ^semantics <sem>)
    (<sr> ^2 <sg> ^handle <sp>)
   -{ (<sg> ^2 <sg2> ^handle <sghandle>)}
    -->
    (<sem> ^<att> <sr2> +)
    (<sr2> ^handle <sp> + ^2 <sg> + ^item-type predicate +)
    (<ass> ^processed-semantics <sg> +)
}

sp {apply*process-semantics*relation*3
    (state <s> ^operator <op> ^assigner <ass>)
    (<op> ^name process-semantics ^attribute relation ^assigner <ass>
          ^relation <sr>)
    (<ass> ^parent-receiver <p*1>)
    (<p*1> ^semantics <sem>)
    (<sr> ^2 <sg> ^3 <sg3> ^handle <sp>)
    -->
    (<sem> ^predicate <sr2> +)
    (<sr2> ^handle <sp> + ^2 <sg> + ^3 <sg3> + ^item-type predicate +)
    (<ass> ^processed-semantics <sg> +)
}

sp {apply*process-semantics*relation
    (state <s> ^operator <op> ^assigner <ass>)
    (<op> ^name process-semantics ^attribute relation ^assigner <ass>
          ^relation <sr>)
    (<ass> ^parent-receiver <p*1>)
    (<p*1> ^semantics <sem>)
    (<sr> -^3 <v*1> ^2 <sg> ^handle <sp>)
    -->
    (<sem> ^predicate <sr2> +)
    (<sr2> ^handle <sp> + ^2 <sg> + ^item-type predicate +)
    (<ass> ^processed-semantics <sg> +)
}

sp {apply*process-semantics*unknown
    (state <s> ^operator <op>)
    (<op> ^name process-semantics ^extra-attribute <of> ^assigner <ass>
          ^value <value> ^attribute <att>)
    (<ass> ^parent-receiver <p*1>)
    (<p*1> ^semantics <sem>)
    -->
    (<sem> ^<att> <value> +)
    (<value> ^<of> unknown + ^item-type predicate +)
    (<ass> ^processed-semantics <att> +)
}

sp {apply*process-semantics*simple2
    (state <s> ^operator <op>)
    (<op> ^name process-semantics ^value2 <value> ^attribute2 <att>
          ^assigner <ass>)
    (<ass> ^parent-receiver <p*1>)
    (<p*1> ^semantics <sem>)
    -->
    (<sem> ^<att> <value> +)
    (<ass> ^processed-semantics <value> +)
}

sp {apply*process-semantics*simple
    (state <s> ^operator <op>)
    (<op> -^relation <sr> -^extra-attribute <of> ^name process-semantics
          ^assigner <ass> ^value <value> ^attribute { <> relation <att> })
    (<ass> ^parent-receiver <p*1>)
    (<p*1> ^semantics <sem>)
    -->
    (<sem> ^<att> <value> +)
    (<ass> ^processed-semantics <value> +)
}

sp {apply*process-semantics*create-empty*semantics
    (state <s> ^operator <o>)
    (<o> ^name process-semantics ^assigner <a*1>)
    (<a*1> ^parent-receiver <rec>)
    (<rec> -^semantics <sem>)
    -->
    (<rec> ^semantics <sem> +)
}

sp {apply*process-semantics*process-semantics-mark-processed
    (state <s> ^operator <o>)
    (<o> ^name process-semantics ^assigner <ass> ^semantics <sem>)
    -->
    (<ass> ^processed-semantics <sem> +)
}

sp {apply*process-semantics*process-semantics-embed*receiver
    (state <s> ^operator <o>)
    (<o> ^name process-semantics ^embed <embed> ^receiver <mr> ^value <value>
          ^attribute <att>)
    -->
    (<embed> ^<att> <value> +)
    (<mr> ^processed-semantics <value> +)
}

sp {apply*process-semantics*process-semantics-embed
    (state <s> ^operator <o>)
    (<o> ^embed-semantics true ^name process-semantics
          ^embed-structure <embed> ^assigner <ass>)
    (<ass> ^parent-receiver <p*1> ^merged-receiver <m*1>)
    (<p*1> ^semantics <sem>)
    (<m*1> ^semantics <sem2>)
    -->
    (<sem> ^<embed> <sem2> +)
    (<ass> ^processed-semantics *embed* +)
}

sp {apply*process-semantics*process-semantics-copy-structure
    (state <s> ^operator <o>)
    (<o> ^name process-semantics ^copy-semantics <sem2> ^assigner <ass>
          ^copy-structure <att>)
    (<ass> ^merged-receiver <m*1> ^parent-receiver <p*1>)
    (<m*1> ^semantics <sem2>)
    (<p*1> ^semantics <sem>)
    (<sem2> ^<att2> <val>)
    -->
    (<sem> ^<att> <val> +)
    (<ass> ^processed-semantics <sem2> +)
}

sp {apply*process-semantics*process-semantics-copy
    (state <s> ^operator <o>)
    (<o> -^copy-structure <c*1> ^name process-semantics ^copy-semantics <sem2>
          ^assigner <ass>)
    (<ass> ^merged-receiver <m*1> ^parent-receiver <p*1>)
    (<m*1> ^semantics <sem2>)
    (<p*1> ^semantics <sem>)
    (<sem2> ^<att> <val>)
    -->
    (<sem> ^<att> <val> +)
    (<ass> ^processed-semantics <sem2> +)
}

sp {evaluate-operator*reject*process-semantics
    (state <s> ^name evaluate-operator ^operator <op1> +)
    (<op1> ^name process-semantics)
    -->
    (<s> ^operator <op1> -)
}

sp {comprehension*compare*process-semantics*prefer-specific2
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
    (<op2> ^copy-semantics true ^name process-semantics)
    (<op1> -^copy-semantics true ^name process-semantics)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*process-semantics*prefer-specific
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
    (<op2> -^relation <r*2> ^name process-semantics)
    (<op1> ^name process-semantics ^relation <r*1>)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*process-semantics
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name process-semantics)
    (<op2>
          ^name { << process-phrase-end failed-referent-grounding process-missing-assigner merge comprehend-word >> <n*1> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {propose*process-semantics*semantics*relation
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> ^lt <l*1> ^merged-receiver <mre> -^processed-semantics <sg>)
    (<l*1> ^semantic-structure relation)
    (<mre> ^semantics <sem> ^{ << complement head >> <a*1> } <v*1>)
    (<sem> ^of-relation <sg>)
    (<v*1> ^lt <lt>)
    (<lt> ^semantic-structure relation ^<att> <left-of1>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute relation +
           ^relation <sr> +)
    (<sr> ^handle <left-of1> + ^2 <sg> +)
}

sp {propose*process-semantics*use-semantics*already*same-attribute
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> ^merged-receiver <m*1> ^lt <l*1> -^processed-semantics <value>)
    (<m*1> ^semantics <sg>)
   -{ (<sg> -^<att> <a*1>)
      (<ass> ^merged-receiver <m*2>)
      (<m*2> ^semantics <sg>)}
   -{ (<ass> ^lt <l*2>)
      (<l*2> ^semantic-structure { << relation arg1 >> <s*1> })
      (<sg> ^relation <x>)}
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <ss> })
    (<sg> ^<ss> <value>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute <ss> +
           ^value <value> +)
}

sp {propose*process-semantics*use-semantics2
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> ^merged-receiver <m*1> ^lt <l*1> -^processed-semantics <value>)
    (<m*1> ^semantics <sg>)
   -{ (<sg> -^<att> <a*1>)
      (<ass> ^merged-receiver <m*2>)
      (<m*2> ^semantics <sg>)}
   -{ (<ass> ^lt <l*2>)
      (<l*2> ^semantic-structure { << relation arg1 >> <s*1> })
      (<sg> ^relation <x>)}
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <ss> })
    (<sg> -^<ss> <s*2> ^{ << predicate arg1 arg2 >> <a*2> } <value>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute <ss> +
           ^value <value> +)
}

sp {propose*process-semantics*use-semantics
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> ^merged-receiver <m*1> -^processed-semantics <sg> ^lt <l*1>)
    (<m*1> ^semantics <sg>)
   -{ (<ass> ^processed-semantics <p*1>)
      (<sg> ^action <x>)
      (<p*1> ^predicates <x>)}
    (<sg> -^{ << arg1 arg2 predicate >> <a*2> } <v*1> -^<ss> <s*2>)
   -{ (<sg> -^<att> <a*1>)
      (<ass> ^merged-receiver <m*2>)
      (<m*2> ^semantics <sg>)}
   -{ (<ass> ^lt <l*2>)
      (<l*2> ^semantic-structure { << relation arg1 >> <s*1> })
      (<sg> ^relation <x>)}
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <ss> })
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute <ss> +
           ^value <sg> +)
}

sp {propose*process-semantics*embed
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> -^processed-semantics *embed* ^lt <lt> ^merged-receiver <m*1>)
    (<lt> ^semantic-structure *embed* ^embed-structure <embed>)
    (<m*1> ^semantics <sg>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^embed-semantics true +
           ^embed-structure <embed> + ^assigner <ass> +)
}

sp {propose*process-semantics*copy*structure
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> ^lt <l*1> ^merged-receiver <m*1> -^processed-semantics <sg>
          ^lt <l*2>)
    (<l*1> ^semantic-structure *copy*)
    (<m*1> ^semantics <sg>)
   -{ (<sg> -^<att2> <a*1>)
      (<ass> ^merged-receiver <m*2>)
      (<m*2> ^semantics <sg>)}
    (<l*2> ^copy-structure <att>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^copy-semantics <sg> +
           ^copy-structure <att> + ^assigner <ass> +)
}

sp {propose*process-semantics*copy
    (state <s> ^name comprehension ^assigner <ass>)
   -{ (<ass> ^lt <l*2>)
      (<l*2> ^copy-structure <c*1>)}
    (<ass> ^lt <l*1> ^merged-receiver <m*1> -^processed-semantics <sg>)
    (<l*1> ^semantic-structure *copy*)
    (<m*1> ^semantics <sg>)
   -{ (<sg> -^<att> <a*1>)
      (<ass> ^merged-receiver <m*2>)
      (<m*2> ^semantics <sg>)}
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^copy-semantics <sg> + ^assigner <ass> +)
}

sp {propose*process-semantics*adjective*unknown-object-feature
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> ^merged-receiver <mre> -^processed-semantics <lli> ^lt <l*1>)
    (<mre> -^referent <r*1> ^lt <lli>)
    (<lli> -^referent <r*2> ^structure-type ADJ)
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <ss> })
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute <ss> +
           ^value <lli> +)
}

sp {propose*process-semantics*adjective*unknown-name
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> ^merged-receiver <mre> ^lt <l*1> -^processed-semantics <ss>)
    (<mre> -^referent <r*1> ^lt <lli>)
   -{ (<lli> ^referent <r*2>)
      (<r*2> ^handle <pf>)}
    (<lli> ^structure-type ADJ ^object-feature { <> unknown <of> })
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <ss> })
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute <ss> +
           ^value <xx> + ^extra-attribute <of> +)
}

sp {propose*process-semantics*adjective
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> -^processed-semantics <id> ^merged-receiver <mre> ^lt <l*1>)
    (<mre> -^referent <r*1> ^lt <lli>)
    (<lli> ^structure-type ADJ ^object-feature <of>)
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <ss> })
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute <ss> +
           ^value <lli> +)
}

sp {propose*process-semantics*default*adjunct
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> ^merged-receiver <mre> ^lt <l*1> -^processed-semantics <adj>)
    (<mre> -^referent <sg> ^adjunct <a*1>)
    (<a*1> ^lt <l*2>)
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <ss> })
    (<l*2> ^relation <adj>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute adjunct +
           ^value <adj> +)
}

sp {propose*process-semantics*PP-with-left-of-PP
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> ^merged-receiver <mre> ^parent-receiver <p*1> ^lt <l*1>
          -^processed-semantics <obj>)
    (<mre> ^structure-type PP ^lt <l*2> ^head <h*2>)
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <ss> })
    (<h*2> ^referent <obj>)
    (<p*1> ^head <h*1>)
    (<h*1> ^lt <hlli>)
    (<hlli> ^semantic-entity-type relation ^relation <r*1>)
    (<l*2> ^relation <r*2>)
    (<r*2> ^handle of1)
    (<r*1> ^handle <left-of1>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute relation +
           ^relation <sr> +)
    (<sr> ^handle <left-of1> + ^2 <obj> +)
}

sp {propose*process-semantics*PP-with-of-PP-DP
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> ^merged-receiver <mre> ^lt <l*1> -^processed-semantics <sg>)
    (<mre> ^structure-type PP ^head <h*3> ^head <h*1>)
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <ss> })
    (<h*3> ^lt-referent <sg>)
   -{ (<sg> ^property <p*1>)
      (<p*1> ^handle possessive)}
    (<h*1> ^head <h*2>)
    (<h*2> ^lt-referent <l*2>)
    (<l*2> ^handle <minutes>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute <ss> +
           ^relation <sr> +)
    (<sr> ^handle <minutes> + ^2 <sg> +)
}

sp {propose*process-semantics*DP-with-of-DP*referent
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> -^processed-semantics <sg> ^merged-receiver <mre> ^lt <l*1>)
    (<mre> -^referent <r*1> ^structure-type DP ^complement <c*2>
          ^complement <c*1> ^head <h*1>)
    (<c*1> ^lt <l*2>)
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <ss> })
    (<c*2> ^head <head>)
    (<h*1> ^lt-referent <l*3>)
    (<head> ^referent <ref>)
    (<l*3> ^handle <name>)
    (<l*2> ^relation <r*2>)
    (<r*2> ^handle of1)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute <ss> +
           ^relation <sr> + ^value <xx> +)
    (<sr> ^handle of1 + ^2 <xx> +)
    (<xx> ^handle <name> + ^2 <ref> +)
}

sp {propose*process-semantics*DP-with-of-DP
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> -^processed-semantics <sg> ^merged-receiver <mre> ^lt <l*1>)
    (<mre> ^structure-type DP ^complement <c*2> ^complement <c*1> ^head <h*1>)
    (<c*2> ^head <h1>)
    (<h1> -^referent <r*2> ^head <h*2>)
    (<c*1> ^lt <l*2>)
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <ss> })
    (<h*2> ^lt-referent <game>)
    (<h*1> ^lt-referent <l*3>)
    (<l*3> ^handle <name>)
    (<l*2> ^relation <r*1>)
    (<r*1> ^handle of1)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute <ss> +
           ^relation <sr> + ^value <xx> +)
    (<sr> ^handle of1 + ^2 <xx> +)
    (<xx> ^handle <name> + ^2 <game> +)
}

sp {propose*process-semantics*relation*semantics
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> ^lt <l*1> ^merged-receiver <mre> -^processed-semantics <sg>)
    (<l*1> ^semantic-structure relation)
    (<mre> ^head <h*1>)
    (<h*1> ^referent <r*1>)
    (<r*1> ^relation <sg>)
   -{ (<sg> ^2 <v*1>)
      (<v*1> ^predicates <p*2>)
      (<p*2> ^visibility unknown-visible)}
   -{ (<ass> ^processed-semantics <p*1>)
      (<p*1> ^relation <sg>)}
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute predicate +
           ^value <sg> +)
}

sp {propose*process-semantics*relation*head-head-lt-referent*ternary
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> ^merged-receiver <mre> ^lt <l*1> -^processed-semantics <sg>)
   -{ (<mre> ^head <h*3>)
      (<h*3> ^referent <r*2>)}
    (<mre> ^lt <l*3> ^complement <c*1> ^lt <l*2> ^head <h*1>)
    (<l*3> ^relation-type ternary)
    (<l*1> ^semantic-structure relation)
    (<h*1> ^head <h*2>)
    (<h*2> ^lt-referent <sg>)
    (<c*1> ^referent <comp>)
    (<l*2> ^relation <r*1>)
    (<r*1> ^handle <spr>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute relation +
           ^relation <srx> +)
    (<srx> ^handle <spr> + ^2 <sg> + ^3 <comp> +)
}

sp {propose*process-semantics*relation*head-head-lt-referent
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> ^merged-receiver <mre> ^lt <l*1> -^processed-semantics <sg>)
   -{ (<mre> ^head <h*3>)
      (<h*3> ^referent <r*2>)}
   -{ (<mre> ^lt <l*3>)
      (<l*3> ^relation-type ternary)}
    (<l*1> ^semantic-structure relation)
    (<mre> ^lt <l*2> ^head <h*1>)
    (<h*1> ^head <h*2>)
    (<h*2> ^lt-referent <sg>)
    (<l*2> ^relation <r*1>)
    (<r*1> ^handle <spr>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute relation +
           ^relation <srx> +)
    (<srx> ^handle <spr> + ^2 <sg> +)
}

sp {propose*process-semantics*preposition-relation*head*referent*ternary*head-head-lt-referent
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> ^merged-receiver <mre> ^lt <l*1> -^processed-semantics <sg>)
   -{ (<mre> ^head <h*1>)
      (<h*1> ^referent <r*2>)}
    (<mre> ^lt <l*3> ^complement <c*1> ^lt <l*2> ^head <h*2>)
    (<l*3> ^relation-type ternary)
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <ss> })
    (<h*2> ^head <h*3>)
    (<h*3> ^lt-referent <sg>)
    (<c*1> ^referent <comp>)
    (<l*2> ^relation <r*1>)
    (<r*1> ^handle <spr>)
    -->
    (write (crlf) |propose*process-semantics*preposition-relation*head*referent*ternary*head-head-lt-referent - OK|)
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute <ss> +
           ^relation <sp-x> +)
    (<sp-x> ^handle <spr> + ^2 <sg> + ^3 <comp> +)
}

sp {propose*process-semantics*preposition-relation*head-head-complement-lt-referent
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> ^merged-receiver <mre> ^lt <l*1> -^processed-semantics <sg>)
   -{ (<mre> ^lt <l*3>)
      (<l*3> ^relation-type ternary)}
    (<mre> ^head <head> ^lt <l*2>)
    (<head> -^referent <r*2> ^complement <c*1> ^head <h*1>)
    (<c*1> ^constraint <c*2>)
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <ss> })
    (<h*1> ^lt-referent <sg>)
    (<c*2> ^relation <rel>)
    (<rel> -^handle by1)
    (<l*2> ^relation <r*1>)
    (<r*1> ^handle <spr>)
    -->
    (write (crlf) |propose*process-semantics*preposition-relation*head-head-complement-lt-referent - OK|)
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute <ss> +
           ^relation <sp-x> +)
    (<sp-x> ^handle <spr> + ^2 <sg> +)
    (<sg> ^2 <rel> +)
}

sp {propose*process-semantics*preposition-relation*head-head-lt-referent
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> ^merged-receiver <mre> ^lt <l*1> -^processed-semantics <sg>)
   -{ (<mre> ^lt <l*3>)
      (<l*3> ^relation-type ternary)}
    (<mre> ^head <head> ^lt <l*2>)
    (<head> -^complement <c*1> -^referent <r*2> ^head <h*1>)
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <ss> })
    (<h*1> ^lt-referent <sg>)
    (<l*2> ^relation <r*1>)
    (<r*1> ^handle <spr>)
    -->
    (write (crlf) |propose*process-semantics*preposition-relation*head-head-lt-referent - OK|)
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute <ss> +
           ^relation <sp-x> +)
    (<sp-x> ^handle <spr> + ^2 <sg> +)
}

sp {propose*process-semantics*preposition-relation*head*referent*ternary
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> ^merged-receiver <mre> ^lt <l*1> -^processed-semantics <sg>)
    (<mre> ^lt <l*3> ^complement <c*1> ^lt <l*2> ^head <h*1>)
    (<l*3> ^relation-type ternary)
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <ss> })
    (<h*1> ^referent <sg>)
    (<c*1> ^referent <comp>)
    (<l*2> ^relation <r*1>)
    (<r*1> ^handle <spr>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute <ss> +
           ^relation <sp-x> +)
    (<sp-x> ^handle <spr> + ^2 <sg> + ^3 <comp> +)
}

sp {propose*process-semantics*preposition-relation*head*referent
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> ^merged-receiver <mre> ^lt <l*1> -^processed-semantics <sg>)
   -{ (<mre> ^lt <l*3>)
      (<l*3> ^relation-type ternary)}
    (<mre> ^lt <l*2> ^head <h*1>)
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <ss> })
    (<h*1> ^referent <sg>)
    (<l*2> ^relation <r*1>)
    (<r*1> ^handle <spr>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute <ss> +
           ^relation <sp-x> +)
    (<sp-x> ^handle <spr> + ^2 <sg> +)
}

sp {propose*process-semantics*referent2
    (state <s> ^operator <op> + ^assigner <ass>)
    (<op> ^name process-semantics)
    (<ass> ^merged-receiver <mr>)
    (<mr> ^lt-referent2 <sg> ^lt <l*1>)
    (<l*1> ^semantic-structure2 <ss>)
    -->
    (<op> ^attribute2 <ss> + ^value2 <sg> +)
}

sp {propose*process-semantics*receiver*embed
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> ^lt <lt> ^parent-receiver <p*1> ^merged-receiver <mr>)
    (<lt> ^semantic-structure *embed* ^embed-structure <es>)
    (<p*1> ^semantics <s*1>)
    (<mr> ^lt-referent <sg> -^processed-semantics <sg> ^semantics <embed>
          ^lt <l*1>)
    (<s*1> ^<es> <embed>)
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <ss> })
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^receiver <mr> + ^embed <embed> +
           ^attribute <ss> + ^value <sg> +)
}

sp {propose*process-semantics*receiver
    (state <s> ^name comprehension ^assigner <ass>)
   -{ (<ass> ^lt <l*1>)
      (<l*1> ^semantic-structure *embed*)}
    (<ass> ^merged-receiver <mr> -^processed-semantics <sg>)
    (<mr> ^lt-referent <sg> ^lt <l*2>)
    (<l*2> ^semantic-structure { <> *copy* <> *embed* <ss> })
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute <ss> +
           ^value <sg> +)
}

sp {propose*process-semantics*referent-nil*deeper*constraint*referent
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> ^merged-receiver <mre> -^processed-semantics <ref> ^lt <l*1>)
   -{ (<mre> ^complement <c*1>)
      (<c*1> ^head <h*2>)
      (<h*2> ^head <h*3>)
      (<h*3> ^lt-referent <l*4>)}
    (<mre> -^lt-referent <l*3> -^referent <r*1> ^constraint <con> ^head <h*1>)
    (<con> ^referent <ref>)
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <ss> })
    (<h*1> ^lt-referent <l*2>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute <ss> +
           ^value <ref> +)
}

sp {propose*process-semantics*referent-nil*deeper*constraint
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> ^merged-receiver <mre> -^processed-semantics <con> ^lt <l*1>)
   -{ (<mre> ^complement <c*1>)
      (<c*1> ^head <h*2>)
      (<h*2> ^head <h*3>)
      (<h*3> ^lt-referent <l*4>)}
    (<mre> -^lt-referent <l*3> -^referent <r*1> ^constraint <con> ^head <h*1>)
   -{ (<con> ^property <p*1>)
      (<p*1> ^handle possessive)}
    (<con> -^referent <r*2>)
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <ss> })
    (<h*1> ^lt-referent <l*2>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute <ss> +
           ^value <con> +)
}

sp {propose*process-semantics*referent*deeper
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> ^merged-receiver <mre> ^lt <l*1> -^processed-semantics <sg>)
   -{ (<mre> ^complement <c*2>)
      (<c*2> ^head <h*2>)
      (<h*2> ^head <h*3>)
      (<h*3> ^lt-referent <l*3>)}
    (<mre> -^constraint <c*1> -^lt-referent <l*2> -^referent <r*1> ^head <h*1>)
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <ss> })
    (<h*1> ^lt-referent <sg>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute <ss> +
           ^value <sg> +)
}

sp {propose*process-semantics*failed-referent
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> -^processed-semantics <sg> ^merged-receiver <mre> ^lt <l*1>)
    (<mre> -^referent <r*1> ^lt <l*2> ^head <head>)
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <ss> })
    (<head> ^failed-grounding <fg> ^constraint <con>)
    (<l*2> ^relation <rel>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute <ss> +
           ^relation <val> +)
    (<val> ^2 <con> + ^handle <rel> +)
}

sp {propose*process-semantics*referent-type*no-constraint*relation
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> ^merged-receiver <mre> ^lt <l*1> ^lt <l*2>
          -^processed-semantics <rel>)
   -{ (<mre> ^head <h*1>)
      (<h*1> ^referent <r*2>)}
    (<mre> -^lt-referent <l*3> -^referent <r*1> -^constraint <con> ^lt <lli>)
    (<l*1> ^referent-type literal)
    (<l*2> ^semantic-structure { <> *copy* <> *embed* <> relation <ss> })
    (<lli> ^relation <rel>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute <ss> +
           ^value <rel> +)
}

sp {propose*process-semantics*referent*no-constraint*relation
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> ^merged-receiver <mre> ^lt <l*1> -^processed-semantics <rel>)
   -{ (<mre> ^head <h*1>)
      (<h*1> ^referent <r*2>)}
    (<mre> -^lt-referent <l*2> -^referent <r*1> -^semantics <s*1>
          -^constraint <con> ^lt <lli>)
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <> relation <ss> })
    (<lli> ^relation <rel>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute <ss> +
           ^value <rel> +)
}

sp {propose*process-semantics*no-referent*head
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> -^processed-semantics <sg> ^merged-receiver <mre> ^lt <l*1>)
    (<mre> -^referent <r*1> -^lt-referent <l*2> -^constraint <con> ^head <h*1>)
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <ss> })
    (<h*1> ^referent <head>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute <ss> +
           ^value <head> +)
}

sp {propose*process-semantics*no-referent*constraint
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> ^merged-receiver <mre> -^processed-semantics <con> ^lt <l*1>)
    (<mre> -^referent <r*1> -^lt-referent <l*2> ^constraint <con>)
   -{ (<mre> ^head <h*1>)
      (<h*1> ^lt-referent <sg>)}
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <ss> })
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute <ss> +
           ^value <con> +)
}

sp {propose*process-semantics*no-local-referent*lt-referent
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> ^merged-receiver <mre> -^processed-semantics <sg> ^lt <l*1>)
    (<mre> -^referent <r*1> ^lt-referent <sg>)
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <ss> })
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute <ss> +
           ^value <sg> +)
}

sp {prefer*process-semantics*arg1
    (state <s> ^name comprehension ^operator <o2> + ^operator <o1> +)
   -{ (<o2> ^value <v*2>)
      (<v*2> ^relation <r*2>)}
    (<o2> ^name process-semantics ^attribute arg1 ^assigner <ass>)
    (<o1> ^name process-semantics ^attribute arg1 ^assigner <ass> ^value <v*1>)
    (<v*1> ^relation <r*1>)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {propose*process-semantics*referent
    (state <s> ^name comprehension -^deep-complement true ^assigner <ass>)
    (<ass> -^processed-semantics <any> ^merged-receiver <m*1> ^lt <l*1>)
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <ss> })
    (<m*1> ^referent <sg>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute <ss> +
           ^value <sg> +)
}

sp {elaborate*process-semantics*DP-DP
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> ^merged-receiver <mre>)
    (<mre> ^structure-type DP ^complement <c*1> ^head <h*3>)
    (<h*3> ^lt-referent <l*1>)
    (<l*1> ^handle of1)
    (<c*1> ^head <h*1>)
    (<h*1> ^head <h*2>)
    (<h*2> ^lt-referent <sg>)
    -->
    (<s> ^deep-complement true +)
}

sp {elaborate*assigner
    (state <s> ^name comprehension ^segment <s*1>)
    (<s*1> ^merged-assigner <ass>)
    -->
    (<s> ^assigner <ass> +)
}

sp {comprehension*compare*process-phrase-end*prefer-most-recent
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
    (<op2> ^name process-phrase-end ^assigner-parent <a*2>)
    (<op1> ^name process-phrase-end ^assigner-parent <a*1>)
    (<a*2> ^decision-count <d*1>)
    (<a*1> ^decision-count { < <d*1> <dc> })
    -->
    (<s> ^operator <op1> < <op2>)
}

sp {comprehension*compare*process-phrase-end*prefer-merge-before-process-end2
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
    (<op2> ^name merge ^assigner <a*2>)
    (<op1> ^name process-phrase-end ^assigner-parent <ap>)
   -{ (<op2> ^assigner <a*1>)
      (<a*1> ^parent-receiver <ap>)}
    (<a*2> ^lt <l*1>)
    (<l*1> ^required true)
    -->
    (<s> ^operator <op1> < <op2>)
}

sp {comprehension*compare*process-phrase-end*prefer-merge-before-process-end*not
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
   -{ (<op2> ^assigner <a*2>)
      (<a*2> ^lt <l*1>)
      (<l*1> ^required true)}
    (<op2> ^name merge)
    (<op1> ^name process-phrase-end ^assigner-parent <ap>)
   -{ (<op2> ^assigner <a*1>)
      (<a*1> ^parent-receiver <ap>)}
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*process-phrase-end*ground-new-constraint
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
    (<op2> ^name ground-new-constraint)
    (<op1> ^name process-phrase-end)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*process-phrase-end*prefer-merge-before-process-end
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
    (<op2> ^name merge ^assigner <a*1>)
    (<op1> ^name process-phrase-end ^assigner-parent <ap>)
    (<a*1> ^parent-receiver <ap>)
    -->
    (<s> ^operator <op1> < <op2>)
}

sp {apply*process-phrase-end
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name process-phrase-end ^assigner-parent <ps>)
    (<ps> ^lt <l*1> ^structure-type { <> <nstruct> <oldstruct> })
    (<l*1> ^converts-to <nstruct>)
    -->
    (<ps> ^structure-type <nstruct> + ^structure-type <oldstruct> -)
    (<seg> ^not-merged-receiver <ps> +)
}

sp {comprehension*propose*process-phrase-end2
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^not-merged-receiver <ps> ^retrieved-stack <r*1>)
   -{ (<s> ^possible-future-merge <pm2>)
      (<pm2> ^assigner <a*2> ^receiver { <> <ps> <nmr> })
      (<a*2> ^parent-receiver <ps>)}
   -{ (<s> ^possible-merge <pm>)
      (<pm> ^assigner <a*1> ^receiver { <> <ps> <nmr> })
      (<a*1> ^parent-receiver <ps>)}
   -{ (<seg> ^not-merged-assigner <uai>)
      (<uai> ^parent-receiver <ps> ^lt <l*2>)
      (<l*2> ^required true)}
    (<ps> ^lt <l*1> -^structure-type <nstruct>)
    (<l*1> ^converts-to <nstruct>)
    (<r*1> ^item { <> <ps> <item> })
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-phrase-end + ^assigner-parent <ps> +)
}

sp {comprehension*propose*process-phrase-end
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^merged-assigner <p> ^retrieved-stack <r*1>)
    (<p> ^parent-receiver <ps> ^merged-receiver <m*1>)
   -{ (<s> ^possible-future-merge <pm2>)
      (<pm2> ^assigner <a*2> ^receiver { <> <ps> <nmr> })
      (<a*2> ^parent-receiver <ps>)}
   -{ (<s> ^possible-merge <pm>)
      (<pm> ^assigner <a*1> ^receiver { <> <ps> <nmr> })
      (<a*1> ^parent-receiver <ps>)}
   -{ (<seg> ^not-merged-assigner <uai>)
      (<uai> ^parent-receiver <ps> ^lt <l*2>)
      (<l*2> ^required true)}
    (<ps> ^lt <l*1> -^structure-type <nstruct>)
    (<l*1> ^converts-to <nstruct>)
    (<r*1> ^item { <> <ps> <> <m*1> <item> })
    (<item> ^structure-type <s-type>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-phrase-end + ^assigner-parent <ps> +)
}

sp {comprehension*elaborate*possible-future-merge*converts-to-any
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^not-merged-assigner <assigner> ^not-merged-receiver <receiver>)
   -{ (<s> ^possible-future-merge <p*1>)
      (<seg> ^not-merged-assigner <ass2>)
      (<p*1> ^assigner <ass2>)
      (<ass2> ^parent-receiver <pr> ^lt <l*5>)
      (<assigner> ^parent-receiver <pr> ^lt <before>)
      (<l*5> ^before <before>)}
   -{ (<seg> ^merged-assigner <ass3>)
      (<ass3> ^parent-receiver <pr> ^lt <l*4>)
      (<assigner> ^parent-receiver <pr> ^lt <after>)
      (<l*4> ^after <after>)}
   -{ (<assigner> ^lt <l*1>)
      (<l*1> ^lexical-item-spelling <l*2>)}
   -{ (<seg> ^not-possible-merge <npm>)
      (<npm> ^assigner <assigner> ^receiver <receiver>)}
   -{ (<receiver> ^lt <l*9>)
      (<l*9> ^directional <d*4>)
      (<assigner> ^lt <l*8>)
      (<l*8> ^directional { <> <d*4> <x> })}
   -{ (<assigner> ^lt <l*7> ^decision-count <dl-dc2>)
      (<l*7> ^relative-position after)
      (<receiver> ^decision-count { < <dl-dc2> <d*3> })}
   -{ (<assigner> ^lt <l*6> ^decision-count <dl-dc>)
      (<l*6> ^relative-position before)
      (<receiver> ^decision-count { > <dl-dc> <d*2> })}
    (<assigner> -^parent-receiver <receiver>
          ^decision-count { < <d*1> <da-dc> } ^structure-type <stype>)
    (<receiver> ^lt <l*3> ^decision-count <d*1>)
    (<l*3> ^converts-to-any true)
    -->
    (<s> ^possible-future-merge <pm> +)
    (<pm> ^receiver <receiver> + ^assigner <assigner> + ^type normal +)
}

sp {comprehension*elaborate*possible-future-merge*super-converts
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^not-merged-assigner <assigner> ^not-merged-receiver <receiver>)
   -{ (<s> ^possible-future-merge <p*1>)
      (<seg> ^not-merged-assigner <ass2>)
      (<p*1> ^assigner <ass2>)
      (<ass2> ^parent-receiver <pr> ^lt <l*5>)
      (<assigner> ^parent-receiver <pr> ^lt <before>)
      (<l*5> ^before <before>)}
   -{ (<seg> ^merged-assigner <ass3>)
      (<ass3> ^parent-receiver <pr> ^lt <l*4>)
      (<assigner> ^parent-receiver <pr> ^lt <after>)
      (<l*4> ^after <after>)}
   -{ (<assigner> ^lt <l*1>)
      (<l*1> ^lexical-item-spelling <l*2>)}
   -{ (<seg> ^not-possible-merge <npm>)
      (<npm> ^assigner <assigner> ^receiver <receiver>)}
   -{ (<receiver> ^lt <l*9>)
      (<l*9> ^directional <d*4>)
      (<assigner> ^lt <l*8>)
      (<l*8> ^directional { <> <d*4> <x> })}
   -{ (<assigner> ^lt <l*7> ^decision-count <dl-dc2>)
      (<l*7> ^relative-position after)
      (<receiver> ^decision-count { < <dl-dc2> <d*3> })}
   -{ (<assigner> ^lt <l*6> ^decision-count <dl-dc>)
      (<l*6> ^relative-position before)
      (<receiver> ^decision-count { > <dl-dc> <d*2> })}
    (<assigner> -^parent-receiver <receiver>
          ^decision-count { < <d*1> <da-dc> } ^structure-type <stype>)
    (<receiver> ^decision-count <d*1> ^lt <l*3>)
    (<l*3> ^super-converts-to <stype>)
    -->
    (<s> ^possible-future-merge <pm> +)
    (<pm> ^receiver <receiver> + ^assigner <assigner> + ^type normal +)
}

sp {comprehension*elaborate*possible-future-merge
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^not-merged-assigner <assigner> ^not-merged-receiver <receiver>)
   -{ (<s> ^possible-future-merge <p*1>)
      (<seg> ^not-merged-assigner <ass2>)
      (<p*1> ^assigner <ass2>)
      (<ass2> ^parent-receiver <pr> ^lt <l*5>)
      (<assigner> ^parent-receiver <pr> ^lt <before>)
      (<l*5> ^before <before>)}
   -{ (<seg> ^merged-assigner <ass3>)
      (<ass3> ^parent-receiver <pr> ^lt <l*4>)
      (<assigner> ^parent-receiver <pr> ^lt <after>)
      (<l*4> ^after <after>)}
   -{ (<assigner> ^lt <l*1>)
      (<l*1> ^lexical-item-spelling <l*2>)}
   -{ (<seg> ^not-possible-merge <npm>)
      (<npm> ^assigner <assigner> ^receiver <receiver>)}
   -{ (<receiver> ^lt <l*9>)
      (<l*9> ^directional <d*4>)
      (<assigner> ^lt <l*8>)
      (<l*8> ^directional { <> <d*4> <x> })}
   -{ (<assigner> ^lt <l*7> ^decision-count <dl-dc2>)
      (<l*7> ^relative-position after)
      (<receiver> ^decision-count { < <dl-dc2> <d*3> })}
   -{ (<assigner> ^lt <l*6> ^decision-count <dl-dc>)
      (<l*6> ^relative-position before)
      (<receiver> ^decision-count { > <dl-dc> <d*2> })}
    (<assigner> -^parent-receiver <receiver>
          ^decision-count { < <d*1> <da-dc> } ^structure-type <stype>)
    (<receiver> ^decision-count <d*1> ^lt <l*3>)
    (<l*3> ^converts-to <stype>)
    -->
    (<s> ^possible-future-merge <pm> +)
    (<pm> ^receiver <receiver> + ^assigner <assigner> + ^type normal +)
}

sp {comprehension*elaborate*detect*prefered*verb-PP-directional-merge*so*probable*DP-merge
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^not-merged-assigner <assigner1> ^not-merged-receiver <receiver>)
    (<assigner1> ^parent-receiver <pr> ^lt <l*3> ^decision-count <da-dc>)
    (<pr> ^structure-type V ^lt <l*4>)
    (<l*3> ^structure-type PP)
    (<l*4> ^directional { << maybe true >> <d*3> })
    (<receiver> ^lt <l*1> ^decision-count { > <da-dc> <d*1> } ^lt <l*2>)
    (<l*1> ^converts-to PP)
    (<l*2> ^directional { << maybe true >> <d*2> })
    -->
    (<seg> ^probable-merge <npm> +)
    (<npm> ^receiver <receiver> + ^assigner <assigner1> +)
}

sp {comprehension*elaborate*detect*prefered*verb-PP-directional-merge*so*no*DP-merge
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^not-merged-assigner <assigner2> ^not-merged-assigner <assigner1>
          ^not-merged-receiver <receiver>)
    (<assigner2> ^lt <l*5> ^decision-count <d*3>)
    (<l*5> ^structure-type PP)
    (<assigner1> ^parent-receiver <pr> ^lt <l*3>
          ^decision-count { < <d*3> <da-dc> })
    (<pr> ^structure-type V ^lt <l*4>)
    (<l*3> ^structure-type PP)
    (<l*4> ^directional { << true >> <d*2> })
    (<receiver> ^lt <l*1> ^lt <l*2>)
    (<l*1> ^converts-to PP)
    (<l*2> ^directional { << true >> <d*1> })
    -->
    (<seg> ^not-possible-merge <npm> +)
    (<npm> ^receiver <receiver> + ^assigner <assigner2> +)
}

sp {apply*process-missing-assigner*optional*remove
    (state <s> ^segment <seg> ^operator <op>)
   -{ (<s> ^segment <s*1>)
      (<s*1> ^not-merged-receiver <n*1>)
      (<n*1> ^structure-type unknown)}
    (<op> ^name process-missing-assigner ^item <ass1>)
    (<seg> ^not-merged-assigner <ass1>)
    (<ass1> ^lt <l*1> ^parent-receiver <pr> ^structure-type <stype>)
    (<l*1> ^optional true)
    -->
    (<seg> ^not-merged-assigner <ass1> -)
}

sp {comprehension*compare*process-missing-assigner*comprehend
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name process-missing-assigner)
    (<op2> ^name { << process-phrase-end comprehend-word >> <n*1> })
    -->
    (<s> ^operator <op1> < <op2>)
}

sp {comprehension*compare*process-missing-assigner
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name process-missing-assigner)
    (<op2> ^name { << next-word comprehend-construction >> <n*1> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*propose*process-missing-assigner*new
    (state <s> ^name comprehension ^operator <o*1> ^segment <seg>)
    (<o*1> ^name next-word)
    (<seg> ^not-merged-assigner <ass2> ^not-merged-receiver <nmr>
          ^not-merged-assigner { <> <ass2> <ass1> })
   -{ (<ass2> ^lt <l*1>)
      (<l*1> ^required true)}
   -{ (<s> ^possible-future-merge <pm2> ^possible-future-merge <pm>)
      (<pm2> ^assigner <ass2> ^receiver <rec2>)
      (<pm> ^receiver <nmr> ^assigner <a*1>)
      (<a*1> ^parent-receiver <rec2>)}
    (<nmr> ^lt <lt> ^decision-count { > <dc> <d*1> })
    (<lt> ^attachment immediate ^converts-to <new-type>)
   -{ (<seg> ^not-merged-receiver <n*1>)
      (<n*1> ^structure-type <new-type>)}
    (<ass1> ^structure-type <new-type> ^parent-receiver <pr>
          ^decision-count { >= <dc2> <dc> })
    (<ass2> ^parent-receiver <pr> ^decision-count <dc2>
          ^structure-type <stype>)
   -{ (<s> ^possible-future-merge <pfm4>)
      (<pfm4> ^receiver <nmr> ^assigner <ass4>)
      (<ass4> ^structure-type <new-type> ^decision-count { > <dc2> <d*2> })}
    -->
    (<seg> ^not-merged-assigner <ass2> -)
}

sp {comprehension*propose*process-missing-assigner*phrase-end
    (state <s> ^name comprehension ^segment <seg> ^operator <o*1>)
    (<seg> ^not-merged-assigner <ass1>)
    (<ass1> ^lt <lla> ^parent-receiver <ps>)
    (<lla> ^optional true ^structure-type <rst>)
   -{ (<seg> ^not-merged-receiver <n*2>)
      (<n*2> ^lt <l*1>)
      (<l*1> ^converts-to <rst>)}
    (<ps> ^lt <l*2> ^structure-type <nstruct>)
    (<l*2> ^converts-to <nstruct>)
    (<o*1> ^name { << process-phrase-end next-word >> <n*1> })
    -->
    (<seg> ^not-merged-assigner <ass1> -)
}

sp {comprehension*propose*process-missing-assigner*exclusive
    (state <s> ^name comprehension ^operator <o*1> ^segment <seg>)
    (<o*1> ^name next-word)
    (<seg> ^merged-assigner <ma> ^not-merged-assigner <ass1>)
    (<ma> ^parenet-receiver <pr> ^lt <l*1>)
    (<ass1> ^parent-receiver <pr> ^lt <lt-ass1>)
    (<l*1> ^exclusive <lt-ass1>)
    -->
    (<seg> ^not-merged-assigner <ass1> -)
}

sp {comprehension*propose*process-missing-assigner*after
    (state <s> ^name comprehension ^operator <o*1> ^segment <seg>)
    (<o*1> ^name next-word)
    (<seg> ^not-merged-assigner <ass1> ^not-merged-assigner <ass2>
          ^not-merged-receiver <n*1>)
    (<ass1> -^failed merge ^parent-receiver <pr> ^lt <l*1>
          ^structure-type <stype>)
    (<ass2> ^parent-receiver <pr> ^lt <ass-after>)
    (<l*1> ^after <ass-after>)
    (<n*1> ^structure-type <stype>)
    -->
    (<seg> ^not-merged-assigner <ass1> -)
}

sp {comprehension*propose*process-missing-assigner*after*x
    (state <s> ^name comprehension ^operator <o*1> ^segment <seg>)
    (<o*1> ^name next-word)
    (<seg> ^not-merged-assigner <ass2>
          ^not-merged-assigner { <> <ass2> <ass1> } ^not-merged-receiver <nmr>)
   -{ (<ass2> ^lt <l*3>)
      (<l*3> ^required true)}
    (<ass2> ^parent-receiver <pr> ^lt <ass-after>
          -^decision-count { > <dc> <d*2> }
          ^structure-type { <> <until-pp> <stype> })
    (<ass1> ^parent-receiver <pr> ^structure-type <until-pp>
          ^decision-count <d*1> ^lt <l*2>)
   -{ (<seg> ^not-merged-receiver <n*1>)
      (<n*1> ^structure-type <until-pp>)}
    (<l*2> ^after <ass-after>)
    (<nmr> ^decision-count { > <d*1> <dc> } ^lt <l*1>)
    (<l*1> ^converts-to <until-pp>)
    -->
    (<seg> ^not-merged-assigner <ass2> -)
}

sp {comprehension*propose*process-missing-assigner*before*x
    (state <s> ^name comprehension ^operator <o*1> ^segment <seg>)
    (<o*1> ^name next-word)
    (<seg> ^not-merged-assigner <ass2>
          ^not-merged-assigner { <> <ass2> <ass1> } ^not-merged-receiver <nmr>)
   -{ (<ass2> ^lt <l*3>)
      (<l*3> ^required true)}
    (<ass2> ^parent-receiver <pr> ^lt <l*2> -^decision-count { > <dc> <d*2> }
          ^structure-type { <> <until-pp> <> CP <> IF-CLAUSE <stype> })
    (<ass1> ^parent-receiver <pr> ^structure-type <until-pp> ^lt <ass-before>
          ^decision-count <d*1>)
   -{ (<seg> ^not-merged-receiver <n*1>)
      (<n*1> ^structure-type <until-pp>)}
   -{ (<seg> ^not-merged-assigner { <> <ass1> <> <ass2> <ass3> })
      (<ass3> ^parent-receiver <pr> ^structure-type <until-pp> ^lt <l*4>)
      (<l*4> ^before <ass-before>)}
    (<l*2> ^before <ass-before>)
    (<nmr> ^decision-count { > <d*1> <dc> } ^lt <l*1>)
    (<l*1> ^converts-to <until-pp>)
    -->
    (<seg> ^not-merged-assigner <ass2> -)
}

sp {comprehension*propose*process-missing-assigner*before-already-merged
    (state <s> ^name comprehension ^operator <o*1> ^segment <seg>)
    (<o*1> ^name next-word)
    (<seg> ^not-merged-assigner <ass1> ^merged-assigner <nma>)
    (<ass1> -^failed merge ^parent-receiver <pr> ^lt <l*1>
          ^structure-type <stype>)
    (<nma> ^parent-receiver <pr> ^lt <ass-before>)
    (<l*1> ^before <ass-before>)
    -->
    (<seg> ^not-merged-assigner <ass1> -)
}

sp {comprehension*propose*process-missing-assigner*before
    (state <s> ^name comprehension ^operator <o*1> ^segment <seg>)
    (<o*1> ^name next-word)
    (<seg> ^not-merged-assigner <ass1>)
    (<ass1> -^failed merge ^structure-type <stype> ^parent-receiver <pr>
          ^lt <l*1>)
   -{ (<seg> ^not-merged-receiver <n*1>)
      (<n*1> ^structure-type <stype>)}
    (<l*1> ^before <ass-before>)
    (<ass-before> -^optional true)
   -{ (<seg> ^not-merged-assigner <nma>)
      (<nma> ^parent-receiver <pr> ^lt <ass-before>)}
    -->
    (<seg> ^not-merged-assigner <ass1> -)
}

sp {apply*no-viable-groundings--restart-parse*reset-semantics
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name no-viable-groundings--restart-parse)
    (<seg> ^input-sentence <is> ^original-sentence <os> ^current-word <cw>)
    -->
    (<seg> ^input-sentence <is> - ^input-sentence <os> + ^current-word <cw> -
           ^current-word <os> +)
}

sp {apply*no-viable-groundings--restart-parse*reset-current-word-input-sentence
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name no-viable-groundings--restart-parse)
    (<seg> ^last-merge <lm> ^semantics <sem> ^input-sentence <is>
          ^original-sentence <os> ^current-word <cw>)
    -->
    (<seg> ^input-sentence <is> - ^input-sentence <os> + ^current-word <cw> -
           ^current-word <os> + ^semantics <sem> - ^semantics <nsem> +
           ^last-merge <lm> - ^last-merge <nlm> +)
    (<nlm> ^receiver <as1> + ^assigner <as1> + ^structure-type CP +)
}

sp {apply*no-viable-groundings--restart-parse*remove-receiver-list
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name no-viable-groundings--restart-parse)
    (<seg> ^receiver-list <as>)
    -->
    (<seg> ^receiver-list <as> -)
}

sp {apply*no-viable-groundings--restart-parse*remove-assigners
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name no-viable-groundings--restart-parse)
    (<seg> ^not-merged-assigner <uri>)
    -->
    (<seg> ^not-merged-assigner <uri> -)
}

sp {apply*no-viable-groundings--restart-parse*remove-receivers
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name no-viable-groundings--restart-parse)
    (<seg> ^not-merged-receiver <uri>)
    -->
    (<seg> ^not-merged-receiver <uri> -)
}

sp {comprehension*apply*next-word*clean-up-multiple
    (state <s> ^processed-multiple true ^operator <o*1>)
    (<o*1> ^name next-word)
    -->
    (<s> ^processed-multiple true +)
}

sp {comprehension*apply*next-word*clean-up-failure
    (state <s> ^segment <seg> ^operator <o*1>)
    (<seg> ^failed-construction true)
    (<o*1> ^name next-word)
    -->
    (<seg> ^failed-construction true -)
}

sp {comprehension*apply*next-word*nil*missing-question-mark
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name next-word)
    (<seg> ^not-merged-assigner <n*1> ^input-sentence <i>
          ^current-word <old-w> ^prior-word <pw>)
    (<n*1> ^structure-type QT)
    (<i> -^spelling { << |?| |!| |.| >> <s*1> } ^next nil)
    -->
    (<i> ^next <next> +)
    (<next> ^spelling |?| + ^next nil +)
    (<seg> ^input-sentence <i> - ^input-sentence <next> +
           ^current-word <next> + ^current-word <old-w> - ^prior-word <pw> -
           ^prior-word <old-w> +)
}

sp {comprehension*apply*next-word*nil*missing-period
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name next-word)
    (<seg> ^not-merged-assigner <n*1> ^input-sentence <i>
          ^current-word <old-w> ^prior-word <pw>)
    (<n*1> ^structure-type T)
    (<i> -^spelling { << |?| |!| |.| >> <s*1> } ^next nil)
    -->
    (<i> ^next <next> +)
    (<next> ^spelling |.| + ^next nil +)
    (<seg> ^input-sentence <i> - ^input-sentence <next> +
           ^current-word <next> + ^current-word <old-w> - ^prior-word <pw> -
           ^prior-word <old-w> +)
}

sp {comprehension*apply*next-word*mark-first-word
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name next-word)
    (<seg> ^current-word <c*1> ^input-sentence <i*1>)
    (<c*1> ^spelling *)
    (<i*1> ^next <n>)
    -->
    (<n> ^first-word true +)
}

sp {comprehension*apply*next-word*end-of-sentence-failure*unknown-word*internal
    (state <s> ^top-state <t*1> ^operator <o*1> ^segment <seg>)
    (<t*1> ^world-usage internal)
    (<o*1> ^name next-word)
    (<seg> ^input-sentence <i> ^original-sentence <cs> ^current-word <old-w>
          ^prior-word <pw> ^unknown-word <uw>)
    (<i> ^next nil ^spelling { << |?| |!| |.| >> <s*1> })
    -->
    
}

sp {comprehension*apply*next-word*end-of-sentence-failure*unknown-word*external
    (state <s> ^top-state <t*1> ^operator <o*1> ^segment <seg>
          ^top-state <t*2>)
    (<t*1> ^world-usage external)
    (<o*1> ^name next-word)
    (<seg> ^input-sentence <i> ^original-sentence <cs> ^current-word <old-w>
          ^prior-word <pw> ^unknown-word <uw>)
    (<i> ^next nil ^spelling { << |?| |!| |.| >> <s*1> })
    (<t*2> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^failure <is> +)
    (<is> ^type unknown-word + ^word <uw> +)
}

sp {comprehension*apply*next-word*end-of-sentence-failure*internal
    (state <s> ^top-state <ts> ^operator <o*1> ^segment <seg>)
    (<ts> ^world-usage internal)
    (<o*1> ^name next-word)
    (<seg> ^input-sentence <i> ^semantics <sem> ^original-sentence <o*2>
          ^original-sentence <cs> ^current-word <old-w> ^prior-word <pw>)
    (<i> ^next nil ^spelling { << |?| |!| |.| >> <s*1> })
    (<o*2> ^complete-sentence <os>)
    -->
    (<seg> ^parse-failed-end-of-sentence true +)
}

sp {comprehension*apply*next-word*end-of-sentence-failure*external
    (state <s> ^top-state <ts> ^operator <o*1> ^segment <seg> ^top-state <t*1>)
    (<ts> ^world-usage external ^io <i*2>)
    (<o*1> ^name next-word)
    (<seg> ^input-sentence <i> ^original-sentence <cs> ^current-word <old-w>
          ^prior-word <pw>)
    (<i> ^next nil ^spelling { << |?| |!| |.| >> <s*1> })
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    (<i*2> ^input-link <i*3>)
    (<i*3> ^language <l*1>)
    (<l*1> ^sentence <sentence>)
    -->
    (<cs> ^processing-result failure + ^processed-sentence true +)
    (<status> ^failure <f*1> +)
    (<f*1> ^type failed-to-interpret-message +)
}

sp {comprehension*apply*next-word*no-prior
    (state <s> ^segment <seg> ^operator <o*1>)
    (<seg> -^prior-word <pw> ^input-sentence <i> ^current-word <old-w>)
    (<o*1> ^name next-word)
    (<i> ^next <n>)
    -->
    (<seg> ^input-sentence <i> - ^input-sentence <n> + ^current-word <n> +
           ^current-word <old-w> - ^prior-word <old-w> +)
}

sp {comprehension*apply*next-word
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name next-word)
    (<seg> ^input-sentence <i> ^current-word <old-w> ^prior-word <pw>)
    (<i> ^next { <> nil <n> })
    -->
    (<seg> ^input-sentence <i> - ^input-sentence <n> + ^current-word <n> +
           ^current-word <old-w> - ^prior-word <pw> - ^prior-word <old-w> +)
}

sp {comprehension*apply*next-word*decision-count-threshold
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name next-word)
    (<seg> ^decision-count-threshold <dct>)
    -->
    (<seg> ^decision-count-threshold <dct> -
           ^decision-count-threshold (+ 300 (int (cmd stats |-d|))) +)
}

sp {comprehension*apply*next-word*decision-count-threshold*initial
    (state <s> ^segment <seg> ^operator <o*1>)
    (<seg> -^decision-count-threshold <d*1>)
    (<o*1> ^name next-word)
    -->
    (<seg> ^decision-count-threshold (+ 300 (int (cmd stats |-d|))) +)
}

sp {comprehension*propose*next-word
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^input-sentence <sent> ^current-word <cw>)
    (<sent> -^processing-result failure ^spelling <s*1>)
    (<cw> ^processed true)
    -->
    (<s> ^operator <o> + ^operator <o> = ^operator <o> <)
    (<o> ^name next-word +)
}

sp {comprehension*compare*merge*prefer*probable
    (state <s> ^name comprehension ^operator <op2> +
          ^operator { <> <op2> <op1> } + ^segment <seg>)
    (<op2> ^name merge ^receiver <rec1> ^assigner <ass2>)
    (<op1> ^name merge ^receiver <rec1> ^assigner { <> <ass2> <ass1> })
   -{ (<seg> ^probable-merge <npm2>)
      (<npm2> ^assigner <ass1> ^receiver { <> <rec1> <r*2> })}
    (<seg> ^probable-merge <npm>)
    (<npm> ^assigner <ass2> ^receiver { <> <rec1> <r*1> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*merge*prefer*predicate
    (state <s> ^name comprehension ^operator <op2> +
          ^operator { <> <op2> <op1> } +)
    (<op2> ^name merge ^assigner <ass2> ^receiver { <> <rec1> <rec2> })
    (<op1> ^name merge ^receiver <rec1> ^assigner { <> <ass2> <ass1> })
    (<ass2> ^parent-receiver <rec1> ^lt <l*2>)
    (<l*2> ^syntactic-structure predicate)
    (<ass1> ^lt <l*1>)
    (<l*1> ^syntactic-structure head)
    -->
    (<s> ^operator <op1> < <op2>)
}

sp {comprehension*compare*merge*prefer*most-recent*first-word*prefer
    (state <s> ^name comprehension ^operator <op2> +
          ^operator { <> <op2> <op1> } +)
   -{ (<op2> ^receiver <r*2>)
      (<r*2> ^current-word <c*2>)
      (<c*2> ^first-word true)}
    (<op2> ^name merge)
    (<op1> ^name merge ^receiver <r*1>)
    (<r*1> ^current-word <c*1>)
    (<c*1> ^first-word true)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*merge*prefer*attachment-immediate*follow
    (state <s> ^name comprehension ^operator <op2> +
          ^operator { <> <op2> <op1> } +)
    (<op2> ^name merge ^receiver <rec> ^assigner <ass2>)
    (<op1> ^name merge ^receiver <rec> ^assigner <ass1>)
    (<ass2> ^decision-count <d*1>)
    (<ass1> ^lt <l*1> ^decision-count { > <d*1> <dc> })
    (<l*1> ^attachment immediately-follow)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*merge*prefer*most-recent*attachment-immediate
    (state <s> ^name comprehension ^operator <op2> +
          ^operator { <> <op2> <op1> } +)
    (<op2> ^name merge ^receiver <rec> ^assigner <ass2>)
    (<op1> ^name merge ^assigner <ass1> ^receiver <rec>)
   -{ (<ass1> ^lt <l*1>)
      (<l*1> ^required true)}
    (<rec> ^lt <l*2>)
    (<l*2> ^attachment immediate)
    (<ass1> ^decision-count <dc>)
    (<ass2> ^decision-count { > <dc> <d*1> })
    -->
    (<s> ^operator <op1> < <op2>)
}

sp {comprehension*compare*merge*prefer*most-recent*PP-shared-parent-receiver
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
    (<op2> ^name merge ^receiver <rec> ^assigner <ass2>)
    (<rec> ^structure-type PP)
    (<op1> ^receiver <rec> ^name merge ^assigner <ass1>)
    (<ass2> ^parent-receiver <pr> ^decision-count <dc> ^lt <ltass2>)
    (<ass1> ^parent-receiver <pr> ^decision-count <dc> ^lt <lt1>)
    (<ltass2> -^{ << after before >> <a*2> } <lt1>)
    (<lt1> -^{ << after before >> <a*1> } <ltass2>)
    -->
    (<s> ^operator <op2> = <op1>)
}

sp {comprehension*compare*merge*prefer*most-recent*not-pp*before2
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
    (<op2> ^name merge ^receiver <rec> ^assigner <ass2>)
    (<rec> -^structure-type PP)
    (<op1> ^receiver <rec> ^name merge ^assigner <ass1>)
    (<ass2> ^parent-receiver <pr> ^decision-count <d*1> ^lt <ltass2>)
    (<ass1> ^parent-receiver <pr> ^decision-count { < <d*1> <dc> } ^lt <lt1>)
    (<lt1> ^before <ltass2>)
    -->
    (<s> ^operator <op2> -)
}

sp {comprehension*compare*merge*prefer*most-recent*not-pp*before
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
    (<op2> ^name merge ^receiver <rec> ^parent-receiver <pr> ^assigner <ass2>)
    (<rec> -^structure-type PP)
    (<op1> ^receiver <rec> ^name merge ^assigner <ass1>)
    (<ass1> ^parent-receiver <pr> ^lt <lt1> ^decision-count <dc>)
    (<lt1> ^required true ^before <ltass2>)
    (<ltass2> ^optional true)
    (<ass2> ^lt <ltass2> ^decision-count <dc>)
    -->
    (<s> ^operator <op2> -)
}

sp {comprehension*compare*merge*prefer*most-recent*not-pp2
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
    (<op2> ^name merge ^receiver <rec> ^assigner <ass2>)
   -{ (<rec> ^lt <l*1>)
      (<l*1> ^attachment immediate)}
    (<rec> -^structure-type PP)
    (<op1> ^receiver <rec> ^name merge ^assigner <ass1>)
    (<ass2> ^decision-count <d*1> ^lt <ltass2>)
    (<ass1> ^decision-count { < <d*1> <dc> } ^lt <lt1>)
    (<lt1> -^before <ltass2>)
    -->
    (<s> ^operator <op1> -)
}

sp {comprehension*compare*merge*prefer*most-recent*same-parent-receiver2
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
    (<op2> ^name merge ^assigner <ass2> ^receiver <r*1>)
    (<op1> ^name merge ^assigner <ass1> ^receiver { <> <r*1> <rec> })
    (<ass2> ^parent-receiver <ps> ^lt <l*1> ^structure-type <bt>)
    (<ass1> ^parent-receiver <ps> ^lt <ltass1>)
    (<l*1> ^after <ltass1>)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*merge*prefer*most-recent*same-parent-receiver
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
    (<op2> ^name merge ^assigner <ass2> ^receiver <r*1>)
    (<op1> ^name merge ^assigner <ass1> ^receiver { <> <r*1> <rec> })
    (<ass2> ^parent-receiver <ps> ^lt <ltass2> ^structure-type <bt>)
    (<ass1> ^parent-receiver <ps> ^lt <l*1>)
    (<l*1> ^before <ltass2>)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*merge*prefer*first*same-receiver
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
    (<op2> ^name merge ^receiver <rec> ^assigner <ass2>)
    (<op1> ^name merge ^receiver <rec> ^assigner <ass1>)
    (<ass2> ^parent-receiver <ps> ^lt <ltass2> ^structure-type <bt>)
    (<ass1> ^parent-receiver <ps> ^lt <l*1>)
    (<l*1> ^before <ltass2>)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*merge*prefer*directional-verb-convert
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
   -{ (<op2> ^assigner <a*2>)
      (<a*2> ^parent-receiver <p*2>)
      (<p*2> ^structure-type { << V VP G GP >> <s*2> })}
    (<op2> ^name merge ^receiver <r1>)
    (<r1> ^structure-type PP ^lt <l*1>)
    (<l*1> ^directional true)
    (<op1> ^receiver <r1> ^name merge ^assigner <a*1>)
    (<a*1> ^parent-receiver <p*1>)
    (<p*1> ^structure-type { << UV V VP G GP >> <s*1> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*merge*prefer*directional-verb
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
   -{ (<op2> ^assigner <a*2>)
      (<a*2> ^parent-receiver <p*2>)
      (<p*2> ^structure-type { << V VP G GP >> <s*2> })}
    (<op2> ^name merge ^receiver <r1>)
    (<r1> ^structure-type PP ^lt <l*1>)
    (<l*1> ^directional true)
    (<op1> ^receiver <r1> ^name merge ^assigner <a*1>)
    (<a*1> ^parent-receiver <p*1>)
    (<p*1> ^structure-type { << V VP G GP >> <s*1> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*merge*avoid-terminator
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
   -{ (<op2> ^assigner <a*2>)
      (<a*2> ^syntactic-type terminator)}
    (<op2> ^name merge)
    (<op1> ^name merge ^assigner <a*1>)
    (<a*1> ^syntactic-type terminator)
    -->
    (<s> ^operator <op1> < <op2>)
}

sp {comprehension*compare*merge*indifferent-different-receiver
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
    (<op2> ^name merge ^receiver <r*1>)
    (<op1> ^name merge ^receiver { <> <r*1> <receiver> })
    -->
    (<s> ^operator <op1> = <op2>)
}

sp {comprehension*compare*merge*terminate*next-word
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name merge)
    (<op2>
          ^name { << next-word next-retrieved-stack termination-processing >> <n*1> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*merge*comprehend-word*process-missing-assigner
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name merge)
    (<op2> ^name { << failed-comprehension process-missing-assigner >> <n*1> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*merge*comprehend-word
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
    (<op2> ^name comprehend-word)
    (<op1> ^name merge)
    -->
    (<s> ^operator <op1> < <op2>)
}

sp {comprehension*compare*merge*prefer-lexical
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
    (<op2> ^name merge ^type lexical)
    (<op1> ^name merge ^type normal)
    -->
    (<s> ^operator <op1> < <op2>)
}

sp {comprehension*compare*merge*prefer-directional-maybe
    (state <s> ^name comprehension ^operator <op1> +)
    (<op1> ^name merge ^assigner <assigner> ^receiver <receiver>)
    (<assigner> ^parent-receiver <p*1>)
    (<p*1> ^lt <l*1>)
    (<l*1> ^directional true)
    (<receiver> ^lt <l*2>)
    (<l*2> ^directional maybe)
    -->
    (<s> ^operator <op1> >)
}

sp {comprehension*reject*possible-merge*exclusive-earlier
    (state <s> ^name comprehension ^operator <op1> +
          ^possible-future-merge <pm>)
    (<op1> ^name merge ^receiver <receiver>
          ^assigner { <> <assigner2> <assigner> })
   -{ (<receiver> ^lt <l*1>)
      (<l*1> ^attachment immediate)}
    (<pm> ^receiver <receiver2> ^assigner <assigner2>)
   -{ (<s> ^possible-future-merge { <> <pm> <pfm> })
      (<pfm> ^receiver <receiver2>)}
    (<receiver2> ^decision-count <d*1>)
    (<receiver> ^decision-count { > <d*1> <dc> })
    (<assigner2> ^parent-receiver <pr> ^lt <lt2>)
    (<assigner> ^parent-receiver <pr> ^lt <l*2>)
    (<l*2> ^exclusive <lt2>)
    -->
    (<s> ^operator <op1> -)
}

sp {comprehension*reject*merge*left-noun
    (state <s> ^name comprehension ^operator <op1> +)
   -{ (<op1> ^receiver <r*1>)
      (<r*1> ^lt <l*2>)
      (<l*2> ^spelling of)}
    (<op1> ^name merge ^assigner <a*1>)
    (<a*1> ^parent-receiver <p*1>)
    (<p*1> ^head <h*1>)
    (<h*1> ^lt <l*1>)
    (<l*1> ^spelling { << left-noun right-noun >> <s*1> })
    -->
    (<s> ^operator <op1> -)
}

sp {comprehension*reject*merge*for-failed-grounding
    (state <s> ^name comprehension ^operator <op1> + ^segment <seg>)
    (<op1> ^name merge ^assigner <ur> ^receiver <ai>)
    (<ur> ^parent-receiver <p*1>)
    (<ai> ^structure-type <pos> ^relation <sr>)
    (<p*1> ^referent <lg>)
    (<seg> ^failed-grounding <fg>)
    (<fg> ^lost-grounding <lg> ^structure-type <pos> ^receiver-word <rw>
          ^relation <sr>)
    -->
    (<s> ^operator <op1> -)
}

sp {comprehension*reject*possible-merge
    (state <s> ^name comprehension ^operator <op1> + ^segment <s*1>)
    (<op1> ^name merge ^assigner <assigner> ^receiver <receiver>)
   -{ (<s> ^possible-merge <pm>)
      (<pm> ^receiver <receiver> ^assigner { <> <assigner> <a*1> })}
    (<assigner> ^lt <lt>)
    (<lt> -^required true)
    (<s*1> ^not-merged-assigner <nma>)
    (<nma> ^lt <ass2>)
    (<ass2> ^required true ^before <lt>)
    -->
    (<s> ^operator <op1> -)
}

sp {comprehension*propose*merge
    (state <s> ^name comprehension ^possible-merge <pm>)
    (<pm> ^assigner <assigner> ^receiver <receiver> ^type <type>)
    -->
    (<s> ^operator <op> +)
    (<op> ^name merge + ^receiver <receiver> + ^assigner <assigner> +
           ^type <type> +)
}

sp {comprehension*elaborate*possible-merge*lexical-item*match*required*any
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^not-merged-assigner <assigner> ^not-merged-receiver <receiver>)
   -{ (<seg> ^not-merged-assigner <nma>)
      (<nma> ^parent-receiver <pr> ^lt <after>)
      (<assigner> ^parent-receiver <pr> ^lt <l*3>)
      (<l*3> ^after <after>)}
    (<assigner> ^structure-type ANY -^parent-receiver <receiver> ^lt <l*1>)
   -{ (<receiver> ^lt <l*7>)
      (<l*7> ^directional <d*3>)
      (<assigner> ^lt <l*6>)
      (<l*6> ^directional { <> <d*3> <x> })}
   -{ (<assigner> ^lt <l*5> ^decision-count <dl-dc>)
      (<l*5> ^relative-position after)
      (<receiver> ^decision-count { < <dl-dc> <d*2> })}
   -{ (<assigner> ^lt <l*4> ^decision-count <dl-dc>)
      (<l*4> ^relative-position before)
      (<receiver> ^decision-count { > <dl-dc> <d*1> })}
   -{ (<assigner> ^parent-receiver <parent>)
      (<receiver> ^{ << DP GP VP PP CP CONJP >> <a*1> } <parent>)}
    (<receiver> -^dont-merge true ^lt <l*2> ^structure-type <stype>)
    (<l*1> ^lexical-item-spelling <lex-item-spell>)
    (<l*2> ^spelling <lex-item-spell>)
    -->
    (<s> ^possible-merge <pm> +)
    (<pm> ^receiver <receiver> + ^assigner <assigner> + ^type lexical +)
}

sp {comprehension*elaborate*possible-merge*any
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^not-merged-assigner <assigner> ^not-merged-receiver <receiver>)
   -{ (<seg> ^not-merged-assigner <nma>)
      (<nma> ^parent-receiver <pr> ^lt <after>)
      (<assigner> ^parent-receiver <pr> ^lt <l*3>)
      (<l*3> ^after <after>)}
   -{ (<assigner> ^lt <l*1>)
      (<l*1> ^lexical-item-spelling <l*2>)}
    (<assigner> ^structure-type ANY -^parent-receiver <receiver> ^lt <lt>)
   -{ (<receiver> ^lt <l*7>)
      (<l*7> ^directional <d*3>)
      (<assigner> ^lt <l*6>)
      (<l*6> ^directional { <> <d*3> <x> })}
   -{ (<assigner> ^lt <l*5> ^decision-count <dl-dc2>)
      (<l*5> ^relative-position after)
      (<receiver> ^decision-count { < <dl-dc2> <d*2> })}
   -{ (<assigner> ^lt <l*4> ^decision-count <dl-dc>)
      (<l*4> ^relative-position before)
      (<receiver> ^decision-count { > <dl-dc> <d*1> })}
    (<receiver> -^dont-merge true ^structure-type <stype>)
    -->
    (<s> ^possible-merge <pm> +)
    (<pm> ^receiver <receiver> + ^assigner <assigner> + ^type normal +)
}

sp {comprehension*elaborate*possible-merge*lexical-item*match*required*unknown
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^not-merged-assigner <assigner> ^not-merged-receiver <receiver>)
   -{ (<seg> ^not-merged-assigner <nma>)
      (<nma> ^parent-receiver <pr> ^lt <after>)
      (<assigner> ^parent-receiver <pr> ^lt <l*3>)
      (<l*3> ^after <after>)}
    (<assigner> ^structure-type U -^parent-receiver <receiver> ^lt <l*1>)
   -{ (<assigner> ^lt <l*5> ^decision-count <dl-dc>)
      (<l*5> ^relative-position after)
      (<receiver> ^decision-count { < <dl-dc> <d*2> })}
   -{ (<assigner> ^lt <l*4> ^decision-count <dl-dc>)
      (<l*4> ^relative-position before)
      (<receiver> ^decision-count { > <dl-dc> <d*1> })}
   -{ (<assigner> ^parent-receiver <parent>)
      (<receiver> ^{ << DP VP PP CP CONJP >> <a*1> } <parent>)}
    (<receiver> -^dont-merge true -^structure-type <s*1> ^lt <l*2>)
    (<l*1> ^lexical-item-spelling <lex-item-spell>)
    (<l*2> ^spelling <lex-item-spell>)
    -->
    (<s> ^possible-merge <pm> +)
    (<pm> ^receiver <receiver> + ^assigner <assigner> + ^type lexical +)
}

sp {comprehension*elaborate*possible-merge*unknown
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^not-merged-assigner <assigner> ^not-merged-receiver <receiver>)
   -{ (<seg> ^not-merged-assigner <nma>)
      (<nma> ^parent-receiver <pr> ^lt <after>)
      (<assigner> ^parent-receiver <pr> ^lt <l*3>)
      (<l*3> ^after <after>)}
   -{ (<assigner> ^lt <l*1>)
      (<l*1> ^lexical-item-spelling <l*2>)}
    (<assigner> ^structure-type U -^parent-receiver <receiver>)
   -{ (<assigner> ^lt <l*5> ^decision-count <dl-dc2>)
      (<l*5> ^relative-position after)
      (<receiver> ^decision-count { < <dl-dc2> <d*2> })}
   -{ (<assigner> ^lt <l*4> ^decision-count <dl-dc>)
      (<l*4> ^relative-position before)
      (<receiver> ^decision-count { > <dl-dc> <d*1> })}
    (<receiver> -^dont-merge true -^structure-type <s*1>)
    -->
    (<s> ^possible-merge <pm> +)
    (<pm> ^receiver <receiver> + ^assigner <assigner> + ^type normal +)
}

sp {comprehension*elaborate*possible-merge*lexical-item*match*required
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^not-merged-assigner <assigner> ^not-merged-receiver <receiver>)
   -{ (<seg> ^not-merged-assigner <nma>)
      (<nma> ^parent-receiver <pr> ^lt <after>)
      (<assigner> ^parent-receiver <pr> ^lt <l*3>)
      (<l*3> ^after <after>)}
   -{ (<receiver> ^lt <l*7>)
      (<l*7> ^directional <d*3>)
      (<assigner> ^lt <l*6>)
      (<l*6> ^directional { <> <d*3> <x> })}
   -{ (<assigner> ^lt <l*5> ^decision-count <dl-dc>)
      (<l*5> ^relative-position after)
      (<receiver> ^decision-count { < <dl-dc> <d*2> })}
   -{ (<assigner> ^lt <l*4> ^decision-count <dl-dc>)
      (<l*4> ^relative-position before)
      (<receiver> ^decision-count { > <dl-dc> <d*1> })}
   -{ (<assigner> ^parent-receiver <parent>)
      (<receiver> ^{ << DP GP VP PP CP CONJP >> <a*1> } <parent>)}
    (<assigner> -^parent-receiver <receiver> ^structure-type <stype> ^lt <l*1>)
    (<receiver> -^dont-merge true ^structure-type <stype> ^lt <l*2>)
    (<l*1> ^lexical-item-spelling <lex-item-spell>)
    (<l*2> ^spelling <lex-item-spell>)
    -->
    (<s> ^possible-merge <pm> +)
    (<pm> ^receiver <receiver> + ^assigner <assigner> + ^type lexical +)
}

sp {comprehension*elaborate*possible-merge*directional-maybe
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^not-merged-assigner <assigner> ^not-merged-receiver <receiver>)
   -{ (<seg> ^not-merged-assigner <nma>)
      (<nma> ^parent-receiver <pr> ^lt <after>)
      (<assigner> ^parent-receiver <pr> ^lt <l*3>)
      (<l*3> ^after <after>)}
   -{ (<assigner> ^lt <l*1>)
      (<l*1> ^lexical-item-spelling <l*2>)}
   -{ (<assigner> ^lt <l*5> ^decision-count <dl-dc2>)
      (<l*5> ^relative-position after)
      (<receiver> ^decision-count { < <dl-dc2> <d*2> })}
   -{ (<assigner> ^lt <l*4> ^decision-count <dl-dc>)
      (<l*4> ^relative-position before)
      (<receiver> ^decision-count { > <dl-dc> <d*1> })}
    (<assigner> -^parent-receiver <receiver> ^structure-type <stype> ^lt <lt>)
    (<receiver> -^dont-merge true ^lt <l*6> ^structure-type <stype>)
    (<l*6> ^directional maybe)
    -->
    (<s> ^possible-merge <pm> +)
    (<pm> ^receiver <receiver> + ^assigner <assigner> + ^type normal +)
    (write (crlf) |Possible Merge (directional maybe): | <stype>)
}

sp {comprehension*elaborate*possible-merge
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^not-merged-assigner <assigner> ^not-merged-receiver <receiver>)
   -{ (<seg> ^not-merged-assigner <nma>)
      (<nma> ^parent-receiver <pr> ^lt <after>)
      (<assigner> ^parent-receiver <pr> ^lt <l*3>)
      (<l*3> ^after <after>)}
    (<assigner> -^dont-merge true -^parent-receiver <receiver>
          ^structure-type <stype> ^lt <lt>)
   -{ (<assigner> ^lt <l*1>)
      (<l*1> ^lexical-item-spelling <l*2>)}
   -{ (<receiver> ^lt <l*7>)
      (<l*7> ^directional <d*3>)
      (<assigner> ^lt <l*6>)
      (<l*6> ^directional { <> <d*3> <x> })}
   -{ (<assigner> ^lt <l*5> ^decision-count <dl-dc2>)
      (<l*5> ^relative-position after)
      (<receiver> ^decision-count { < <dl-dc2> <d*2> })}
   -{ (<assigner> ^lt <l*4> ^decision-count <dl-dc>)
      (<l*4> ^relative-position before)
      (<receiver> ^decision-count { > <dl-dc> <d*1> })}
    (<receiver> -^dont-merge true ^structure-type <stype>)
    -->
    (<s> ^possible-merge <pm> +)
    (<pm> ^receiver <receiver> + ^assigner <assigner> + ^type normal +)
}

sp {comprehension*elaborate*dont-merge-if-required-literal-before
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^not-merged-assigner <assigner2>
          ^not-merged-assigner { <> <assigner2> <assigner> })
    (<assigner2> ^lt <lt2> ^parent-receiver <pr>)
    (<lt2> ^required true ^lexical-item-spelling <l*1> ^before <lt>)
    (<assigner> ^parent-receiver <pr> ^lt <lt>)
    -->
    (<assigner> ^dont-merge true +)
}

sp {comprehension*elaborate*delay-possible-merge
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^not-merged-receiver <receiver1>
          ^not-merged-receiver { <> <receiver1> <receiver2> })
    (<receiver1> ^delay-merge true ^decision-count <after>)
    (<receiver2> ^decision-count { < <after> <d*1> })
    -->
    (<receiver2> ^dont-merge true +)
}

sp {comprehension*apply*failure-end-of-sentence2
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name failure-end-of-sentence2)
    (<seg> ^original-sentence <os>)
    -->
    (<os> ^processing-result failure +)
}

sp {comprehension*propose*failure-end-of-sentence2
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> -^retry <r*2> -^retry-sentence <r*1>
          ^parse-failed-end-of-sentence true ^semantics <s*1>
          ^not-merged-receiver <nmr>)
   -{ (<seg> ^original-sentence <o*1>)
      (<o*1> ^processing-result failure)}
    (<s*1> ^interaction-status <i*1>)
    (<i*1> ^failure <f*1>)
    (<f*1> ^type unknown-word)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name failure-end-of-sentence2 +)
}

sp {comprehension*apply*failure-end-of-sentence*retried*failure2
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name failure-end-of-sentence)
    (<seg> ^retried <x> ^alternative-structure-receiver <x> ^semantics <sem>
          ^original-sentence <os> ^current-word <c*1>)
    (<c*1> ^spelling <spell>)
    -->
    (<os> ^processing-result failure +)
    (<sem> ^interaction-status <i*1> +)
    (<i*1> ^failure <is> +)
    (<is> ^type failed-to-interpret-message + ^word <spell> +)
}

sp {comprehension*apply*failure-end-of-sentence*retried*failure
    (state <s> ^segment <seg> ^operator <o*1>)
    (<seg> -^alternative-structure-receiver <a*1> ^retried <r*1>
          ^semantics <sem> ^original-sentence <os> ^current-word <c*1>)
    (<o*1> ^name failure-end-of-sentence)
    (<c*1> ^spelling <spell>)
    -->
    (<os> ^processing-result failure +)
    (<sem> ^interaction-status <i*1> +)
    (<i*1> ^failure <is> +)
    (<is> ^type failed-to-interpret-message + ^word <spell> +)
}

sp {comprehension*apply*failure-end-of-sentence*unknown-word
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name failure-end-of-sentence)
    (<seg> ^semantics <sem> ^original-sentence <os> ^unknown-word <spell>)
    -->
    (<os> ^processing-result failure +)
    (<sem> ^interaction-status <i*1> +)
    (<i*1> ^failure <is> +)
    (<is> ^type failed-to-interpret-message + ^word <spell> +)
}

sp {comprehension*apply*failure-end-of-sentence
    (state <s> ^segment <seg> ^operator <o*1>)
    (<seg> -^unknown-word <u*1> -^alternative-structure-receiver <a*3>
          ^semantics <sem> ^original-sentence <os> ^current-word <c*1>)
   -{ (<seg> ^merged-receiver <m*1>)
      (<m*1> ^lt <l*2>)
      (<l*2> ^alternative-structure <a*2>)}
   -{ (<seg> ^not-merged-receiver <n*1>)
      (<n*1> ^lt <l*1>)
      (<l*1> ^alternative-structure <a*1>)}
    (<o*1> ^name failure-end-of-sentence)
    (<c*1> ^spelling <spell>)
    -->
    (<os> ^processing-result failure +)
    (<sem> ^interaction-status <i*1> +)
    (<i*1> ^failure <is> +)
    (<is> ^type failed-to-interpret-message + ^word <spell> +)
}

sp {comprehension*apply*failure-end-of-sentence*saved-alternative*retried
    (state <s> ^segment <seg> ^operator <o*1>)
    (<seg> -^unknown-word <u*1> ^retried <asr>
          ^alternative-structure-receiver <asr>)
    (<o*1> ^name failure-end-of-sentence)
    -->
    (<seg> ^retry-sentence <asr> +)
    (<asr> ^retried true +)
}

sp {comprehension*apply*failure-end-of-sentence*saved-alternative
    (state <s> ^segment <seg> ^operator <o*1>)
    (<seg> -^unknown-word <u*1> ^alternative-structure-receiver <asr>)
   -{ (<seg> ^not-merged-receiver <n*1>)
      (<n*1> ^lt <l*1>)
      (<l*1> ^alternative-structure <structure-new>)}
    (<o*1> ^name failure-end-of-sentence)
    -->
    (<seg> ^retry-sentence <asr> +)
}

sp {comprehension*apply*failure-end-of-sentence*retry
    (state <s> ^segment <seg> ^operator <o*1>)
    (<seg> -^unknown-word <u*1> -^retried <r*1> ^not-merged-receiver <nmr>
          -^retry-sentence <nmr>)
    (<o*1> ^name failure-end-of-sentence)
    (<nmr> ^lt <l*1>)
    (<l*1> ^alternative-structure <structure-new>)
    -->
    (<seg> ^retry <nmr> +)
}

sp {comprehension*propose*failure-end-of-sentence
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> -^retry <r*2> -^retry-sentence <r*1>
          ^parse-failed-end-of-sentence true ^not-merged-receiver <nmr>)
   -{ (<seg> ^original-sentence <o*1>)
      (<o*1> ^processing-result failure)}
   -{ (<seg> ^semantics <s*1>)
      (<s*1> ^interaction-status <i*1>)
      (<i*1> ^failure <f*1>)
      (<f*1> ^type unknown-word)}
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name failure-end-of-sentence +)
}

sp {comprehension*elaborate*failed-referent-grounding*semantics
    (state <s> ^operator <op>)
    (<op> ^name failed-referent-grounding ^semantics <is> ^value <v*1>
          ^attribute <ss>)
    (<v*1> ^failed-constraint <f*1>)
    (<f*1> ^constraint <c>)
    -->
    (<is> ^<ss> <c> +)
}

sp {comprehension*apply*failed-referent-grounding
    (state <s> ^operator <op>)
    (<op> ^name failed-referent-grounding ^semantics <semantics> ^value <fg>
          ^attribute <ss>)
    -->
    (<semantics> ^interaction-status <i*1> +)
    (<i*1> ^failure <is> +)
    (<is> ^type index-object-failure + ^target-object <fg> +)
}

sp {comprehension*apply*failed-receiver-alternative-structure*sentence
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name failed-receiver-alternative-structure
          ^not-merged-assigner <nma> ^not-merged-receiver <nmr>)
    (<seg> ^alternative-structure-receiver <nmr>)
    (<nmr> ^lt <lt>)
    (<lt> ^alternative-structure <structure-new>
          ^structure-type <structure-old>)
    -->
    (<seg> ^retry-sentence <nmr> +)
}

sp {comprehension*apply*failed-receiver-alternative-structure
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name failed-receiver-alternative-structure
          ^not-merged-receiver <nmr>)
    (<nmr> ^lt <lt>)
    (<lt> ^alternative-structure <structure-new>
          ^structure-type <structure-old>)
    -->
    (<seg> ^retry <nmr> +)
}

sp {comprehension*compare*failed-receiver-alternative-structure*prefer-most-recent2
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
    (<op2> ^name failed-receiver-alternative-structure
          ^not-merged-assigner <n*6> ^not-merged-receiver <n*5>
          ^not-merged-receiver <n*4>)
    (<op1> ^name failed-receiver-alternative-structure
          ^not-merged-assigner <n*3> ^not-merged-receiver <n*2>
          ^not-merged-receiver <n*1>)
    (<n*6> ^lt <l*4>)
    (<n*3> ^lt <l*2>)
    (<n*5> ^lt <l*3>)
    (<l*3> ^alternative-structure <structure2>)
    (<l*4> ^structure-type <structure2>)
    (<n*4> ^decision-count <dc>)
    (<n*2> ^lt <l*1>)
    (<l*1> ^alternative-structure <structure1>)
    (<l*2> ^structure-type <structure1>)
    (<n*1> ^decision-count { > <dc> <d*1> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*failed-receiver-alternative-structure*prefer-matched-type
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
    (<op2> ^name failed-receiver-alternative-structure)
    (<op1> ^name failed-receiver-alternative-structure
          ^not-merged-assigner <n*4> ^not-merged-receiver <n*3>)
    (<n*4> ^lt <l*4>)
    (<l*4> ^structure-type <structure>)
   -{ (<op2> ^not-merged-assigner <n*2> ^not-merged-receiver <n*1>)
      (<n*2> ^lt <l*2>)
      (<l*2> ^structure-type <structure>)
      (<n*1> ^lt <l*1>)
      (<l*1> ^alternative-structure <structure>)}
    (<n*3> ^lt <l*3>)
    (<l*3> ^alternative-structure <structure>)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*propose*failed-receiver-alternative-structure2
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> -^retried-sentence true -^retried <r*1>
          ^parse-failed-receiver <nmr> -^retry-sentence <nmr>
          ^alternative-structure-receiver <asr> -^retry-sentence <asr>
          ^not-merged-assigner <nma>)
   -{ (<nmr> ^lt <l*1>)
      (<l*1> ^alternative-structure <structure-new>)}
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name failed-receiver-alternative-structure +
           ^not-merged-receiver <asr> + ^not-merged-assigner <nma> +)
}

sp {comprehension*propose*failed-assigner-alternative-structure
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> -^retried-sentence true -^retried <r*1>
          ^alternative-structure-receiver <nmr> -^retry-sentence <nmr>
          ^parse-failed-assigner <nma>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name failed-receiver-alternative-structure +
           ^not-merged-receiver <nmr> + ^not-merged-assigner <nma> +)
}

sp {comprehension*compare*failed-receiver-alternative-structure
    (state <s> ^operator <op2> + ^operator <op> +)
    (<op2> ^name failed-comprehension)
    (<op> ^name failed-receiver-alternative-structure)
    -->
    (<s> ^operator <op> > <op2>)
}

sp {comprehension*propose*failed-receiver-alternative-structure
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> -^retried-sentence true -^retried <r*1>
          ^parse-failed-receiver <nmr> -^retry-sentence <nmr>
          ^not-merged-assigner <nma>)
    (<nmr> ^lt <l*1>)
    (<l*1> ^alternative-structure <structure-new>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name failed-receiver-alternative-structure +
           ^not-merged-receiver <nmr> + ^not-merged-assigner <nma> +)
}

sp {apply*failed-comprehension-interaction-status
    (state <s> ^operator <o*1> ^segment <s*1> ^top-state <t*1>)
    (<o*1> ^name failed-comprehension)
    (<s*1> ^semantics <sem>)
    (<sem> ^interaction-status <i*2>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    (<i*2> ^<att> <value>)
    -->
    (<status> ^<att> <value> +)
}

sp {apply*failed-comprehension2
    (state <s> ^name comprehension ^operator <o*1> ^segment <s*1>
          ^top-state <t*1>)
    (<o*1> ^name failed-comprehension)
    (<s*1> ^semantics <sem>)
    (<sem> ^message-type <message>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^new-message <sem> +)
}

sp {apply*failed-comprehension*external
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name failed-comprehension)
    (<seg> ^original-sentence <os>)
    -->
    (<os> ^processed-sentence true + ^processing-result failure +)
}

sp {comprehension*apply*failed-comprehension*new-word
    (state <s> ^name comprehension ^operator <op> ^segment <seg>)
    (<op> ^name failed-comprehension)
    (<seg> ^semantics <sem> ^original-sentence <is>)
    (<sem> ^interaction-status <i*1>)
    (<i*1> ^type unknown-word)
    -->
    (<sem> ^message-type unknown-word +)
}

sp {comprehension*apply*failed-comprehension*no-new-word
    (state <s> ^name comprehension ^operator <op> ^segment <seg>)
    (<op> ^name failed-comprehension)
    (<seg> ^semantics <sem> ^original-sentence <is>)
    (<sem> ^interaction-status <status>)
   -{ (<status> ^failure <f*1>)
      (<f*1> ^type unknown-word)}
    -->
    (<sem> ^message-type failed-comprehension +)
    (<status> ^failure <f*2> +)
    (<f*2> ^type unknown-word +)
}

sp {comprehension*apply*failed-comprehension*failed-parse
    (state <s> ^name comprehension ^operator <op> ^segment <seg>)
    (<op> ^name failed-comprehension)
    (<seg> ^semantics <sem> ^original-sentence <is>)
    (<sem> -^interaction-status <i*1>)
    -->
    (<sem> ^interaction-status <i*2> +)
    (<i*2> ^failure <f*1> +)
    (<f*1> ^type failed-to-interpret-message +)
}

sp {comprehension*apply*failed-comprehension*external*remove-old-message-type
    (state <s> ^name comprehension ^operator <op> ^segment <s*1>)
    (<op> ^name failed-comprehension)
    (<s*1> ^semantics <sem>)
    (<sem> -^message-type { << failed-comprehension unknown-word >> <m*1> }
          ^message-type <mes>)
    -->
    (<sem> ^message-type <mes> -)
}

sp {comprehension*propose*failed-comprehension2
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^retried-sentence true
          ^{ << parse-failed-receiver parse-failed-assigner >> <a*1> } <v*1>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name failed-comprehension +)
}

sp {comprehension*propose*failed-comprehension
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^original-sentence <is>)
    (<is> -^processed-sentence true ^processing-result failure)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name failed-comprehension +)
}

sp {comprehension*apply*clean-up-retrieved-stack
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name clean-up-retrieved-stack)
    (<seg> ^retrieved-stack <rs>)
    (<rs> ^prior <p> ^item <x>)
    (<p> ^item <x>)
    -->
    (<seg> ^retrieved-stack <rs> - ^retrieved-stack <p> +)
}

sp {comprehension*propose*clean-up-retrieved-stack
    (state <s> ^name comprehension ^segment <s*1>)
    (<s*1> ^retrieved-stack <rs>)
    (<rs> ^prior <p*1> ^item <x>)
    (<p*1> ^item <x>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name clean-up-retrieved-stack +)
}

sp {termination-processing*apply*create-new-verb2*996
    (state <s> ^operator <op> ^top-state <t*1>)
    (<op> ^name create-new-verb2 ^word <nv>)
    (<nv> ^spelling <nw>)
    (<t*1> ^smem <s*1>)
    (<s*1> ^command <cmd>)
    -->
    (<s> ^new-verb <nv> + ^checked <nw> +)
    (<cmd> ^store <nv> +)
    (<nv> ^new-action true +)
}

sp {termination-processing*propose*create-new-verb*named-action
    (state <s> ^name termination-processing -^new-verb <nv> ^segment <s*1>)
   -{ (<s> ^top-state <t*2>)
      (<t*2> ^dialog-context <d*1>)}
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^game-scripting <g*1>)}
    (<s*1> ^semantics <sem>)
    (<sem> ^message-type object-description ^arg1 <arg1> ^predicate <pred>)
    (<arg1> ^handle of1 ^2 <arg2>)
    (<arg2> ^handle name1 ^2 <two>)
    (<two> ^handle action)
    (<pred> ^word-structure <ws> ^handle <handle>)
    (<ws> ^spelling <spell>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name create-new-verb2 + ^word <ws> +)
}

sp {termination-processing*apply*create-new-verb*moveable*arg2*995
    (state <s> ^operator <op> ^segment <s*2> ^top-state <t*1>)
    (<op> ^name create-new-verb ^verb <nv> ^action <action>)
    (<nv> ^spelling <nw>)
    (<s*2> ^semantics <sem>)
    (<sem> -^arg1 <a*1> ^arg2 <a*2>)
    (<t*1> ^smem <s*1>)
    (<s*1> ^command <cmd>)
    -->
    (<s> ^new-verb <nv> + ^checked <nw> +)
    (<cmd> ^store <nv> +)
    (<nv> ^new-action true +)
}

sp {termination-processing*apply*create-new-verb*moveable*arg1*999
    (state <s> ^operator <op> ^segment <s*2> ^top-state <t*1>)
    (<op> ^name create-new-verb ^verb <nv> ^action <action>)
    (<nv> ^spelling <nw>)
    (<s*2> ^semantics <sem>)
    (<sem> ^arg2 <a*2> ^arg1 <a*1>)
    (<action> ^handle <name>)
    (<t*1> ^smem <s*1>)
    (<s*1> ^command <cmd>)
    -->
    (<s> ^new-verb <nv> + ^checked <nw> +)
    (<cmd> ^store <nv> +)
    (<nv> ^new-action true +)
}

sp {termination-processing*apply*create-new-verb*moveable*arg1*998
    (state <s> ^operator <op> ^segment <s*2> ^top-state <t*1>)
    (<op> ^name create-new-verb ^verb <nv> ^action <action>)
    (<nv> ^spelling <nw>)
    (<s*2> ^semantics <sem>)
    (<sem> -^arg2 <a*2> ^arg1 <a*1>)
    (<action> ^handle <name>)
    (<t*1> ^smem <s*1>)
    (<s*1> ^command <cmd>)
    -->
    (<s> ^new-verb <nv> + ^checked <nw> +)
    (<cmd> ^store <nv> +)
    (<nv> ^new-action true +)
}

sp {termination-processing*propose*create-new-verb
    (state <s> ^name termination-processing ^quiescence t ^segment <s*2>
          ^segment <s*1> -^new-verb <nv>)
    (<s*2> ^semantics <sem>)
    (<sem> ^message-type new-verb ^action <action>)
    (<s*1> ^new-verb <nv>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name create-new-verb + ^action <action> + ^verb <nv> +)
}

sp {termination-processing*apply*detect-used-but-unknown-word
    (state <s> ^operator <op> ^segment <s*1>)
    (<op> ^name detect-used-but-unknown-word ^unknown-word <word>)
    (<s*1> ^semantics <sem>)
    -->
    (<s> ^checked <word> +)
    (<sem> ^interaction-status <i*1> +)
    (<i*1> ^failure <fail> +)
    (<fail> ^type unknown-word + ^word <word> +)
}

sp {termination-processing*compare*detect-used-but-unknown-word2
    (state <s> ^name termination-processing ^operator <op2> +
          ^operator <op1> +)
    (<op2> ^name create-new-verb)
    (<op1> ^name detect-used-but-unknown-word)
    -->
    (<s> ^operator <op1> < <op2>)
}

sp {termination-processing*compare*detect-used-but-unknown-word
    (state <s> ^name termination-processing ^operator <op2> +
          ^operator <op1> +)
    (<op2> ^name create-new-adjective)
    (<op1> ^name detect-used-but-unknown-word)
    -->
    (<s> ^operator <op1> < <op2>)
}

sp {termination-processing*propose*detect-used-but-unknown-word2
    (state <s> ^name termination-processing ^quiescence t ^segment <s*1>
          -^checked <word>)
    (<s*1> ^unknown-word <word>)
   -{ (<s> ^segment <s*2>)
      (<s*2> ^semantics <s*3>)
      (<s*3> ^interaction-status <i*1>)
      (<i*1> ^failure <f*1>)
      (<f*1> ^word <word>)}
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name detect-used-but-unknown-word + ^unknown-word <word> +)
}

sp {termination-processing*propose*detect-used-but-unknown-word
    (state <s> ^name termination-processing ^quiescence t ^segment <s*1>
          -^checked <word>)
    (<s*1> ^semantics <s*2>)
    (<s*2> ^<arg> <uw>)
    (<uw> -^new-action true -^structure-type <s*5> ^spelling <word>)
   -{ (<s> ^segment <s*3>)
      (<s*3> ^semantics <s*4>)
      (<s*4> ^interaction-status <i*1>)
      (<i*1> ^failure <f*1>)
      (<f*1> ^word <word>)}
   -{ (<s> ^new-verb <n*1>)
      (<n*1> ^spelling <word>)}
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name detect-used-but-unknown-word + ^unknown-word <word> +)
}

sp {termination-processing*apply*remove-interaction-status
    (state <s> ^operator <op> ^segment <s*1>)
    (<op> ^name create-new-adjective)
    (<s*1> ^semantics <sem>)
    (<sem> ^interaction-status <status>)
    (<status> ^failure <failure>)
    (<failure> ^type { << unknown-word index-word-failure >> <t*1> })
    -->
    (<sem> ^interaction-status <status> -)
    (<status> ^failure <failure> -)
}

sp {termination-processing*apply*create-new-adjective
    (state <s> ^operator <op> ^top-state <ss>)
    (<op> ^name create-new-adjective ^structure-type <type> ^word <nw>
          ^item-type <item>)
    (<nw> ^referent <ref> ^spelling <dd>)
    (<ss> ^smem <s*1>)
    (<s*1> ^command <cmd>)
    -->
    (<s> ^checked <dd> +)
    (<cmd> ^store <nw> + ^store <ref> +)
    (<nw> ^structure-type <type> +)
    (<ref> ^item-type <item> +)
}

sp {termination-processing*propose*create-new-noun*not-shape
    (state <s> ^name termination-processing ^quiescence t ^segment <s*1>
          -^stored-message <sem>)
    (<s*1> ^semantics <sem>)
    (<sem> ^message-type adjective-definition ^arg1 <a*1> ^property <p*1>)
    (<a*1> ^word-structure <nw>)
    (<nw> -^structure-type <s*2>)
    (<p*1>
          ^handle { <> predicate <> relation <> action <> color <> size <> shape <h*1> })
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name create-new-adjective + ^word <nw> + ^structure-type N +
           ^item-type concept +)
}

sp {termination-processing*propose*create-new-noun*shape
    (state <s> ^name termination-processing ^quiescence t ^segment <s*1>
          -^stored-message <sem>)
    (<s*1> ^semantics <sem>)
    (<sem> ^message-type adjective-definition ^arg1 <a*1> ^property <p*1>)
    (<a*1> ^word-structure <nw>)
    (<nw> -^structure-type <s*2>)
    (<p*1> ^handle shape)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name create-new-adjective + ^word <nw> + ^structure-type N +
           ^item-type object +)
}

sp {termination-processing*propose*create-new-relation
    (state <s> ^name termination-processing ^quiescence t ^segment <s*1>
          -^stored-message <sem>)
    (<s*1> ^semantics <sem>)
    (<sem> ^message-type adjective-definition ^arg1 <a*1> ^property <p*1>)
    (<a*1> ^word-structure <nw>)
    (<nw> -^structure-type <s*2>)
    (<p*1> ^handle { << relation predicate >> <h*1> })
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name create-new-adjective + ^word <nw> + ^structure-type P +
           ^item-type predicate +)
}

sp {termination-processing*propose*create-new-adjective-verb
    (state <s> ^name termination-processing ^quiescence t ^segment <s*1>
          -^stored-message <sem>)
    (<s*1> ^semantics <sem>)
    (<sem> ^message-type adjective-definition ^arg1 <a*1> ^property <p*1>)
    (<a*1> ^word-structure <nw>)
    (<nw> -^structure-type <s*2>)
    (<p*1> ^handle action)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name create-new-adjective + ^word <nw> + ^structure-type V +
           ^item-type action +)
}

sp {termination-processing*propose*create-new-adjective
    (state <s> ^name termination-processing ^quiescence t ^segment <s*1>
          -^stored-message <sem>)
    (<s*1> ^semantics <sem>)
    (<sem> ^message-type adjective-definition ^arg1 <a*1> ^property <p*1>)
    (<a*1> ^word-structure <nw>)
    (<nw> -^structure-type <s*2>)
    (<p*1> ^handle { << color size >> <h*1> })
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name create-new-adjective + ^word <nw> + ^structure-type ADJ +
           ^item-type predicate +)
}

sp {apply*check-expectation-interaction-status
    (state <s> ^name termination-processing -^failed-assigner <f*2>
          -^failed-receiver <f*1> ^segment <seg> ^operator <o*1>
          ^top-state <t*1>)
    (<seg> ^checked-expectation true ^semantics <sem>)
    (<o*1> ^name check-expectation)
    (<sem> ^interaction-status <i*2>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    (<i*2> ^<att> <value>)
    -->
    (<status> ^<att> <value> +)
}

sp {apply*check-expectation*new-message
    (state <s> ^name termination-processing -^failed-assigner <f*2>
          -^failed-receiver <f*1> ^segment <seg> ^operator <o*1>
          ^top-state <t*1>)
    (<seg> ^checked-expectation true ^semantics <sem>)
    (<o*1> ^name check-expectation)
    (<sem> ^message-type <ms-type>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^new-message <sem> +)
}

sp {check-failure*apply*check-expectation*failure
    (state <s> ^segment <seg> -^failed-assigner <f*2> -^failed-receiver <f*1>
          ^top-state <t*1> ^operator <o*1> ^top-state <ts>)
    (<seg> ^failed-expectation true)
    (<t*1> ^world-usage internal)
    (<o*1> ^name check-expectation)
    (<ts> ^current-sentence-number <csn>)
    -->
    (<ts> ^expectation-failure <csn> +)
}

sp {check-failure*apply*check-expectation*done
    (state <s> ^segment <seg> -^failed-assigner <f*2> -^failed-receiver <f*1>
          ^top-state <t*1> ^operator <o*1> ^top-state <ts>)
    (<seg> ^checked-expectation true)
    (<t*1> ^world-usage internal)
    (<o*1> ^name check-expectation)
    (<ts> ^success-count <sc> ^current-sentence-number <csn>)
    -->
    (<seg> ^processed-terminator true +)
    (<ts> ^terminated-sentence <csn> + ^success-count <sc> -
           ^success-count (+ <sc> 1) +)
}

sp {check-failure*apply*check-expectation
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name check-expectation)
    -->
    (<seg> ^checked-expectation true +)
}

sp {check-failure*apply*check-expectation*l3-identifier-fail
    (state <s> ^segment <seg> -^failed-assigner <f*2> -^failed-receiver <f*1>
          ^top-state <t*1> ^operator <o*1>)
    (<seg> ^original-sentence <o*2> ^expected <expected> ^semantics <sem>)
    (<o*2> ^processed-sentence true)
    (<t*1> ^world-usage internal)
    (<o*1> ^name check-expectation)
    (<expected> ^<attr1> <a*1>)
    (<a*1> ^<attr2> <a*2>)
    (<a*2> ^<attr3> { <=> <s> <a*3> })
   -{ (<sem> ^<attr1> <a*4>)
      (<a*4> ^<attr2> <a*5>)
      (<a*5> ^<attr3> { <=> <s> <a*6> })}
    -->
    (<seg> ^failed-expectation true +)
}

sp {check-failure*apply*check-expectation*l3-constant-fail
    (state <s> ^segment <seg> -^failed-assigner <f*2> -^failed-receiver <f*1>
          ^top-state <t*1> ^operator <o*1>)
    (<seg> ^original-sentence <o*2> ^expected <expected> ^semantics <sem>)
    (<o*2> ^processed-sentence true)
    (<t*1> ^world-usage internal)
    (<o*1> ^name check-expectation)
    (<sem> ^<attr1> <a*3>)
    (<expected> ^<attr1> <a*1>)
    (<a*3> ^<attr2> <a*4>)
    (<a*1> ^<attr2> <expected3>)
    (<a*4> ^<attr3> <a*5>)
    (<expected3> -^<attr3> { <=> <s> <a*2> } ^<attr3> <value>)
   -{ (<sem> ^<attr1> <a*6>)
      (<a*6> ^<attr2> <a*7>)
      (<a*7> ^<attr3> <value>)}
    -->
    (<seg> ^failed-expectation true +)
}

sp {check-failure*apply*check-expectation*l3-attribute-missing
    (state <s> ^segment <seg> -^failed-assigner <f*2> -^failed-receiver <f*1>
          ^top-state <t*1> ^operator <o*1>)
    (<seg> ^original-sentence <o*2> ^expected <expected> ^semantics <sem>)
    (<o*2> ^processed-sentence true)
    (<t*1> ^world-usage internal)
    (<o*1> ^name check-expectation)
    (<expected> ^<attr1> <a*1>)
    (<a*1> ^<attr2> <a*2>)
    (<a*2> ^<attr3> <a*3>)
   -{ (<sem> ^<attr1> <a*4>)
      (<a*4> ^<attr2> <a*5>)
      (<a*5> ^<attr3> <a*6>)}
    -->
    (<seg> ^checked-expectation true + ^failed-expectation true +)
}

sp {check-failure*apply*check-expectation*l2-identifier-fail
    (state <s> ^segment <seg> -^failed-assigner <f*2> -^failed-receiver <f*1>
          ^top-state <t*1> ^operator <o*1>)
    (<seg> ^original-sentence <o*2> ^expected <expected> ^semantics <sem>)
    (<o*2> ^processed-sentence true)
    (<t*1> ^world-usage internal)
    (<o*1> ^name check-expectation)
    (<expected> ^<attr1> <a*1>)
    (<a*1> ^<attr2> { <=> <s> <value> })
   -{ (<sem> ^<attr1> <a*2>)
      (<a*2> ^<attr2> { <=> <s> <a*3> })}
    -->
    (<seg> ^failed-expectation true +)
}

sp {check-failure*apply*check-expectation*l2-constant-fail
    (state <s> ^segment <seg> -^failed-assigner <f*2> -^failed-receiver <f*1>
          ^top-state <t*1> ^operator <o*1>)
    (<seg> ^original-sentence <o*2> ^expected <expected> ^semantics <sem>)
    (<o*2> ^processed-sentence true)
    (<t*1> ^world-usage internal)
    (<o*1> ^name check-expectation)
    (<expected> ^<attr1> <expected2>)
    (<expected2> ^<attr2> <value> -^<attr2> { <=> <s> <a*2> })
   -{ (<sem> ^<attr1> <a*1>)
      (<a*1> ^<attr2> <value>)}
    -->
    (<seg> ^failed-expectation true +)
}

sp {check-failure*apply*check-expectation*l2-attribute-missing
    (state <s> ^segment <seg> -^failed-assigner <f*2> -^failed-receiver <f*1>
          ^top-state <t*1> ^operator <o*1>)
    (<seg> ^original-sentence <o*2> ^expected <e*1> ^semantics <sem>)
    (<o*2> ^processed-sentence true)
    (<t*1> ^world-usage internal)
    (<o*1> ^name check-expectation)
    (<e*1> ^<attr1> <a*1>)
    (<a*1> ^<attr2> <a*2>)
   -{ (<sem> ^<attr1> <a*3>)
      (<a*3> ^<attr2> <a*4>)}
    -->
    (<seg> ^failed-expectation true +)
}

sp {check-failure*apply*check-expectation*l1-identifier-fail
    (state <s> ^segment <seg> -^failed-assigner <f*2> -^failed-receiver <f*1>
          ^top-state <t*1> ^operator <o*1>)
    (<seg> ^original-sentence <o*2> ^expected <expected> ^semantics <sem>)
    (<o*2> ^processed-sentence true)
    (<t*1> ^world-usage internal)
    (<o*1> ^name check-expectation)
    (<expected> ^<attr> { <=> <s> <a*1> })
    (<sem> -^<attr> { <=> <s> <a*2> })
    -->
    (<seg> ^failed-expectation true +)
}

sp {check-failure*apply*check-expectation*l1-constant-fail
    (state <s> ^segment <seg> -^failed-assigner <f*2> -^failed-receiver <f*1>
          ^top-state <t*1> ^operator <o*1>)
    (<seg> ^original-sentence <o*2> ^expected <expected> ^semantics <sem>)
    (<o*2> ^processed-sentence true)
    (<t*1> ^world-usage internal)
    (<o*1> ^name check-expectation)
    (<sem> ^<attr> <a*2> -^<attr> <value>)
    (<expected> -^<attr> { <=> <s> <a*1> } ^<attr> <value>)
    -->
    (<seg> ^failed-expectation true +)
}

sp {check-failure*apply*check-expectation*l1-attribute-missing
    (state <s> ^segment <seg> -^failed-assigner <f*2> -^failed-receiver <f*1>
          ^top-state <t*1> ^operator <o*1>)
    (<seg> ^original-sentence <o*2> ^expected <e*1>)
    (<o*2> ^processed-sentence true)
    (<t*1> ^world-usage internal)
    (<o*1> ^name check-expectation)
    (<e*1> ^<attr> <a*1>)
   -{ (<seg> ^semantics <s*1>)
      (<s*1> ^<attr> <a*2>)}
    -->
    (<seg> ^failed-expectation true +)
}

sp {check-failure*apply*check-expectation*no-expectation
    (state <s> ^segment <seg> -^failed-assigner <f*2> -^failed-receiver <f*1>
          ^top-state <t*1> ^operator <o*1> ^top-state <ts>)
    (<seg> -^expected <e*1>)
    (<t*1> ^world-usage internal)
    (<o*1> ^name check-expectation)
    (<ts> ^success-count <sc> ^current-sentence-number <csn>)
    -->
    (<seg> ^processed-terminator true +)
    (<ts> ^terminated-sentence <csn> + ^success-count <sc> -
           ^success-count (+ <sc> 1) +)
}

sp {check-failure*apply*check-expectation*expectation-nil
    (state <s> ^segment <seg> -^failed-assigner <f*2> -^failed-receiver <f*1>
          ^top-state <t*1> ^operator <o*1> ^top-state <ts>)
    (<seg> ^expected nil)
    (<t*1> ^world-usage internal)
    (<o*1> ^name check-expectation)
    (<ts> ^success-count <sc> ^current-sentence-number <csn>)
    -->
    (<seg> ^processed-terminator true +)
    (<ts> ^terminated-sentence <csn> + ^success-count <sc> -
           ^success-count (+ <sc> 1) +)
}

sp {check-failure*propose*check-expectation
    (state <s> ^checked-not-merged-assigners true
          ^checked-not-merged-receivers true ^name termination-processing
          ^superstate <s*1>)
    (<s*1> ^segment <seg>)
    (<seg> -^processed-terminator true -^parse-failed-assigner <p*2>
          -^parse-failed-receiver <p*1> ^original-sentence <o*1>)
    (<o*1> ^processed-sentence true)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name check-expectation +)
}

sp {apply*check-not-merged-receivers2
    (state <s> ^operator <o*1> ^segment <s*1>)
    (<o*1> ^name check-not-merged-receivers)
    (<s*1> ^not-merged-receiver <item>)
    (<item> ^lt <lt>)
    (<lt> ^structure-type { <> C <> CP <> S <s*2> }
          ^{ << construction spelling >> <a*1> } { <> * <spell> })
    -->
    (<s> ^failed-receiver <item> + ^checked-not-merged-receivers true +)
}

sp {apply*check-not-merged-receivers
    (state <s> ^operator <o*1>)
   -{ (<s> ^segment <s*1>)
      (<s*1> ^not-merged-receiver <n*1>)
      (<n*1> ^lt <l*1>)
      (<l*1> ^structure-type { <> CP <> C <> S <s*2> })}
    (<o*1> ^name check-not-merged-receivers)
    -->
    (<s> ^checked-not-merged-receivers true +)
}

sp {termination-processing*propose*check-not-merged-receivers
    (state <s> ^checked-not-merged-assigners true
          -^checked-not-merged-receivers true ^name termination-processing)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name check-not-merged-receivers +)
}

sp {apply*check-not-merged-assigners-neither
    (state <s> ^operator <op> ^segment <sp>)
    (<op> ^name check-not-merged-assigners)
    (<sp> ^not-merged-assigner <item>)
    (<item> ^lt <lla> ^structure-type <pos>)
    (<lla> -^optional true -^required true)
    -->
    (<s> ^checked-not-merged-assigners true +)
}

sp {apply*check-not-merged-assigners-required
    (state <s> ^operator <op> ^segment <sp>)
    (<op> ^name check-not-merged-assigners)
    (<sp> ^not-merged-assigner <item>)
    (<item> ^lt <l*1> ^structure-type <pos>)
    (<l*1> ^required true)
    -->
    (<s> ^failed-assigner <item> + ^checked-not-merged-assigners true +)
}

sp {apply*check-not-merged-assigners-optional
    (state <s> ^operator <op> ^segment <sp>)
    (<op> ^name check-not-merged-assigners)
    (<sp> ^not-merged-assigner <item>)
    (<item> ^lt <l*2> ^parent-receiver <p*1> ^structure-type <stype>)
    (<l*2> ^optional true)
    (<p*1> ^lt <l*1>)
    (<l*1> ^{ << construction spelling >> <a*1> } <spelling>)
    -->
    (<s> ^checked-not-merged-assigners true +)
}

sp {apply*check-not-merged-assigners
    (state <s> ^segment <ss> ^operator <op>)
    (<ss> -^not-merged-assigner <item>)
    (<op> ^name check-not-merged-assigners)
    -->
    (<s> ^checked-not-merged-assigners true +)
}

sp {termination-processing*propose*check-not-merged-assigners
    (state <s> ^name termination-processing
          -^checked-not-merged-assigners true)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name check-not-merged-assigners +)
}

sp {apply*check-failure*new-message
    (state <s> ^segment <s*1> -^failed-assigner <f*2> -^failed-receiver <f*1>
          ^operator <o*1> ^top-state <t*2>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^parser-testing true)}
    (<o*1> ^name check-failure)
    (<s*1> ^semantics <sem>)
    (<sem> ^message-type <ms-type>)
    (<t*2> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^new-message <sem> +)
}

sp {apply*check-failure*success*internal
    (state <s> ^segment <sp> -^failed-assigner <f*2> -^failed-receiver <f*1>
          ^top-state <t*1> ^operator <op> ^top-state <ts>)
    (<t*1> ^parser-testing true)
    (<op> ^name check-failure)
    (<sp> ^original-sentence <cs>)
    (<ts> ^success-count <sc>)
    -->
    (<cs> ^processed-sentence true + ^processing-result success +)
}

sp {apply*check-failure*success
    (state <s> ^segment <sp> -^failed-assigner <f*2> -^failed-receiver <f*1>
          ^operator <o*1> ^top-state <t*2>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^parser-testing true)}
    (<o*1> ^name check-failure)
    (<sp> ^semantics <s*1> ^original-sentence <cs>)
    (<s*1> ^message-type <mt>)
    (<t*2> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^performed <p*1> +)
    (<p*1> ^dialog-event <de> +)
    (<de> ^type process-sentence + ^originator agent +)
    (<sp> ^processed-terminator true +)
    (<cs> ^processed-sentence true + ^processing-result success +)
}

sp {apply*check-failure*failure*retry*assigner
    (state <s> ^operator <o*1> ^failed-assigner <item> ^segment <seg>)
    (<o*1> ^name check-failure)
    (<seg> ^original-sentence <os>)
    -->
    (<seg> ^parse-failed-assigner <item> +)
    (<os> ^processing-result failure +)
}

sp {apply*check-failure*failure*retry*receiver
    (state <s> ^operator <o*1> ^failed-receiver <item> ^segment <seg>)
    (<o*1> ^name check-failure)
    -->
    (<seg> ^parse-failed-receiver <item> +)
}

sp {apply*check-failure*monitor*no-number
    (state <s> ^name termination-processing ^operator <o*1> ^segment <seg>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^current-sentence-number <csn>)}
    (<o*1> ^name check-failure)
    (<seg> ^semantics <sem> ^original-sentence <o*2>)
    (<o*2> ^complete-sentence <os>)
    -->
    
}

sp {apply*check-failure*monitor*to-file
    (state <s> ^name termination-processing ^top-state <t*1> ^operator <o*1>
          ^segment <seg>)
    (<t*1> ^create-trace-file true)
    (<o*1> ^name check-failure)
    (<seg> ^semantics <sem> ^original-sentence <os>)
    -->
    (cmd command-to-file |-a| |rosie-sentence-processing.trace| echo =======================================)
    (cmd command-to-file |-a| |rosie-sentence-processing.trace| print <os>)
    (cmd command-to-file |-a| |rosie-sentence-processing.trace| print |-d| 3 <sem>)
}

sp {apply*check-failure*monitor
    (state <s> ^name termination-processing ^operator <o*1> ^segment <seg>
          ^top-state <t*1>)
    (<o*1> ^name check-failure)
    (<seg> ^semantics <sem> ^original-sentence <o*2>)
    (<o*2> ^complete-sentence <os>)
    (<t*1> ^current-sentence-number <csn>)
    -->
    
}

sp {termination-processing*propose*check-failure
    (state <s> ^checked-not-merged-assigners true
          ^checked-not-merged-receivers true ^name termination-processing
          ^superstate <s*1>)
    (<s*1> ^segment <seg>)
   -{ (<seg> ^original-sentence <o*1>)
      (<o*1> ^processed-sentence true)}
    (<seg> -^processed-terminator true -^parse-failed-assigner <p*2>
          -^parse-failed-receiver <p*1>)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name check-failure +)
}

sp {comprehension*compare*termination-processing
    (state <s> ^operator <op2> + ^operator <op1> +)
    (<op2> ^name comprehend-construction)
    (<op1> ^name termination-processing)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {apply*termination-processing*message-type*st
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name termination-processing)
    (<seg> ^not-merged-receiver <rec> ^semantics <sem>)
    (<rec> ^structure-type S ^message-type <ms-type>)
    -->
    (<sem> ^message-type <ms-type> +)
}

sp {apply*termination-processing*semantics*sentence
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name termination-processing)
    (<seg> ^semantics <sem> ^not-merged-receiver <uri>)
    (<uri> ^lt <l*1> ^sentence <s*1>)
    (<l*1> ^structure-type S)
    (<s*1> ^semantics <sem2>)
    (<sem2> ^<att> <val>)
    -->
    (<sem> ^<att> <val> +)
}

sp {apply*termination-processing*semantics
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name termination-processing)
    (<seg> ^semantics <sem> ^not-merged-receiver <uri>)
    (<uri> ^lt <l*1> ^semantics <sem2>)
    (<l*1> ^structure-type S)
    (<sem2> ^<att> <val>)
    -->
    (<sem> ^<att> <val> +)
}

sp {apply*termination-processing*message-type
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name termination-processing)
    (<seg> ^semantics <sem> ^not-merged-receiver <n*1>)
    (<n*1> ^lt <lt>)
    (<lt> ^structure-type S ^message-type <ms-type>)
    -->
    (<sem> ^message-type <ms-type> +)
}

sp {comprehension*propose*termination-processing
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> -^parse-failed-assigner <p*3> -^parse-failed-receiver <p*2>
          -^processed-terminator <p*1> ^not-merged-receiver <ua>)
    (<ua> ^terminator <term>)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name termination-processing +)
}

sp {ground-referent*apply*finish-ground-referent
    (state <s> ^quiescence t ^operator <op> ^segment <s*1> ^superstate <s*2>)
    (<op> ^name finish-ground-referent)
    (<s*1> ^last-merge <l*1>)
    (<l*1> ^assigner <a*1>)
    (<a*1> ^parent-receiver <as>)
    (<s*2> ^operator <so>)
    (<so> ^parameter <p> ^{ << double-constraints constraints >> <a*2> } <c>)
    -->
    (<as> ^ground-tested <p> +)
}

sp {propose*finish-ground-referent
    (state <s> ^name ground-referent)
   -{ (<s> ^candidate-set <c*1>)
      (<c*1> ^proto-referent <p*1>)
      (<p*1> ^object <obj>)
     -{ (<s> ^constraints <c*2>)
        (<c*2> ^referent <obj>)}}
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name finish-ground-referent +)
}

sp {ground-referent*apply*create-hypothetical*location
    (state <s> ^constraint <ref> ^operator <o*1> ^top-state <t*1>)
   -{ (<ref> ^visibility not-visible ^predicates <p*1>)}
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<o*1> ^name create-hypothetical)
    (<ref> ^item-type <item-type> ^handle <handle> ^property <prop>)
    (<t*1> ^dialog-world <d*1>)
    (<d*1> ^objects <objs>)
    (<prop> ^handle { << location name >> <h*1> })
    -->
    (<s> ^proto-referent <ref2> +)
    (<objs> ^object <ref2> +)
    (<ref2> ^handle <handle> + ^property <prop> + ^item-type <item-type> +
           ^visibility not-visible + ^predicates <pred> +)
    (<pred> ^dialog-object true + ^category object +)
    (write (crlf) |Hypothetical referent. Creating ^visibility not-visible object:| <ref2>)
}

sp {ground-referent*apply*create-hypothetical*category
    (state <s> ^constraint <con> ^operator <o*1> ^top-state <t*1>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<o*1> ^name create-hypothetical)
    (<con> ^handle <cat> ^property <p*1>)
    (<t*1> ^dialog-world <d*1>)
    (<d*1> ^objects <objs>)
    (<p*1> ^handle category)
    -->
    (<s> ^proto-referent <pr> +)
    (<objs> ^object <pr> +)
    (<pr> ^predicates <pred> + ^handle (make-constant-symbol new-object-id) +
           ^item-type <cat> +)
    (<pred> ^visibility not-visible + ^dialog-object true + ^category <cat> +)
    (write (crlf) |Hypothetical referent. Creating ^visibility not-visible object:| <pr>)
}

sp {ground-referent*apply*create-hypothetical
    (state <s> ^top-state <t*1> ^operator <o*1>)
   -{ (<s> ^constraint <c*1>)
      (<c*1> ^property <p*1>)
      (<p*1> ^handle { << name location category >> <h*1> })}
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<o*1> ^name create-hypothetical)
    (<t*1> ^dialog-world <d*1>)
    (<d*1> ^objects <objs>)
    -->
    (<s> ^proto-referent <pr> +)
    (<objs> ^object <pr> +)
    (<pr> ^predicates <pred> + ^handle (make-constant-symbol new-object-id) +
           ^item-type object +)
    (<pred> ^visibility not-visible + ^dialog-object true + ^category object +)
    (write (crlf) |Hypothetical referent. Creating ^visibility not-visible object:| <pr>)
}

sp {ground-referent*compare*create-hypothetical
    (state <s> ^name ground-referent ^operator <op1> + ^operator <op2> +)
    (<op1> ^name create-hypothetical)
    (<op2>
          ^name { << index-object-properties index-scene-objects index-scene-relation >> <n*1> })
    -->
    (<s> ^operator <op1> < <op2>)
}

sp {ground-referent*compare*create-hypothetical*failed-grounding
    (state <s> ^name ground-referent ^operator <op2> + ^operator <op1> +)
    (<op2> ^name failed-grounding)
    (<op1> ^name create-hypothetical)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {ground-referent*propose*create-hypothetical
    (state <s> ^name ground-referent-x ^segment <s*2> ^proto-referents <p*1>)
   -{ (<s> ^constraint-lt <c*1>)
      (<c*1> ^specifier { << it personal >> <s*1> })}
    (<s*2> ^hypothetical true)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name create-hypothetical +)
}

sp {ground-referent*apply*index-semantic-memory*smem*fail*no-change
    (state <ss> ^impasse no-change ^superstate <s>)
    (<s> ^operator <o*1> ^superstate <s*1>)
    (<o*1> ^name index-semantic-memory)
    (<s*1> ^operator <so>)
    -->
    (<s> ^failed-semantic-retrieval true + ^indexed-semantic-memory true +)
}

sp {ground-referent*apply*index-semantic-memory*smem*fail
    (state <s> ^operator <o*1> ^smem <smem> ^superstate <s*1>)
    (<o*1> ^name index-semantic-memory)
    (<smem> ^result <r*1>)
    (<r*1> ^failure <t>)
    (<s*1> ^operator <so>)
    -->
    (write (crlf) |No lexical item found in semantic memory.|)
    (<s> ^failed-semantic-retrieval true + ^indexed-semantic-memory true +)
}

sp {ground-referent*apply*index-semantic-memory*smem*success
    (state <s> ^operator <o*1> ^constraints <cons> ^smem <smem>
          ^superstate <s*1>)
    (<o*1> ^name index-semantic-memory)
    (<smem> ^result <r*1> ^command <com>)
    (<r*1> ^retrieved <rli>)
    (<com> ^query <q>)
    (<s*1> ^operator <so>)
    (<so> ^parameter <p> ^{ << double-constraints constraints >> <a*1> } <c>)
    -->
    (<s> ^indexed-semantic-memory true +)
    (<cons> ^referent <rli> +)
    (<c> ^ground-tested <p> +)
    (<com> ^query <q> - ^depth 9 -)
    (write (crlf) |Found referent in smem: | <rli>)
}

sp {ground-referent*apply*index-semantic-memory*smem
    (state <s> ^operator <op> ^smem <s*1>
          ^{ << sm-proto-referent proto-referent >> <a*1> } <ref>)
    (<op> ^name index-semantic-memory)
    (<s*1> ^command <com>)
    (<ref> ^predicates-copied true ^predicates <pred>)
    -->
    (<com> ^query <pred> + ^depth 9 +)
}

sp {ground-referent*apply*index-semantic-memory*location-name
    (state <s> ^constraint <con> ^operator <o*1>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<o*1> ^name index-semantic-memory)
    (<con> ^item-type <item-type> ^property <prop>)
    (<prop> ^handle { << location name >> <h*1> })
    -->
    (<s> ^sm-proto-referent <pr> +)
    (<pr> ^predicates <pred> +)
    (<pred> ^item-type object + ^object-instance true +)
}

sp {ground-referent*apply*index-semantic-memory*not-cat-loc-name
    (state <s> ^operator <o*1>)
   -{ (<s> ^constraint <c*1>)
      (<c*1> ^property <p*1>)
      (<p*1> ^handle { << name location category >> <h*1> })}
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<o*1> ^name index-semantic-memory)
    -->
    (<s> ^sm-proto-referent <pr> +)
    (<pr> ^predicates <pred> + ^item-type object +)
    (<pred> ^object-instance true + ^item-type object +)
}

sp {ground-referent*compare*index-semantic-memory
    (state <s> ^name ground-referent ^operator <op2> + ^operator <op1> +)
    (<op2> ^name failed-grounding)
    (<op1> ^name index-semantic-memory)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {ground-referent*propose*index-semantic-memory
    (state <s> ^proto-referents none -^indexed-semantic-memory true
          ^name ground-referent ^quiescence t ^constraint-lt <c*1>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<c*1> ^specifier definite)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name index-semantic-memory +)
}

sp {ground-referent*apply*index-dialog-properties*succeeds
    (state <s> ^operator <o> ^candidate-set <cs>)
    (<o> ^name index-dialog-properties ^property-constraint <pc>)
    (<cs> ^proto-referent <pr>)
    (<pr> ^object <o*1>)
    (<o*1> ^predicates <p*1>)
    (<p*1> ^dialog-object true)
    -->
    (<pr> ^passes <pc> +)
    (<cs> ^success-tested <pc> +)
}

sp {ground-referent*apply*index-dialog-properties*violates
    (state <s> ^operator <o> ^candidate-set <cs>)
    (<o> ^name index-dialog-properties ^property-constraint <pc>)
    (<cs> ^proto-referent <pr>)
   -{ (<pr> ^object <o*1>)
      (<o*1> ^predicates <p*1>)
      (<p*1> ^dialog-object true)}
    -->
    (<pr> ^violates <pc> +)
    (<cs> ^fail-tested <pc> +)
}

sp {ground-referent*propose*index-dialog-properties
    (state <s> ^name ground-referent ^candidate-set <cs>
          ^property-constraint <pc>)
    (<cs> ^generated-candidates true -^satisfied-property <pc>)
    (<pc> ^property grammatical-property)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name index-dialog-properties + ^property-constraint <pc> +)
}

sp {ground-referent*apply*index-object-multiple
    (state <s> ^operator <op> ^candidate-set <cs>)
    (<op> ^name index-object-multiple)
    (<cs> ^proto-referent <pr>)
   -{ (<pr> ^object <o*1>)
      (<o*1> ^predicates <p*1>)
      (<p*1> ^multiple true)}
    -->
    (<cs> ^proto-referent <pr> -)
    (<s> ^processed-multiple <pr> +)
}

sp {ground-referent*compare*index-object-properties
    (state <s> ^name ground-referent ^operator <op1> + ^operator <op2> +)
    (<op1> ^name index-object-multiple)
    (<op2> ^name { <> index-object-multiple <n*1> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {ground-referent*propose*index-object-multiple
    (state <s> ^name ground-referent ^constraint <con> ^candidate-set <cs>
          -^processed-mulitple <pr>)
    (<con> ^multiple true)
    (<cs> ^generated-candidates true ^proto-referent <pr>
          ^proto-referent <p*1>)
   -{ (<pr> ^object <o*2>)
      (<o*2> ^predicates <p*3>)
      (<p*3> ^multiple true)}
    (<p*1> ^object <o*1>)
    (<o*1> ^predicates <p*2>)
    (<p*2> ^multiple true)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name index-object-multiple +)
}

sp {ground-referent*compare*prefer-real-to-not-visible
    (state <s> ^name ground-referent ^operator <op2> + ^operator <op1> +)
    (<op2> ^name tested-referent)
    (<op1> ^name prefer-real-to-not-visible)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehend*apply*process-multiple-groundings
    (state <s> ^operator <op> ^candidate-set <cs>)
    (<op> ^name prefer-real-to-not-visible)
    (<cs> ^proto-referent <pr2>)
    (<pr2> ^object <pr-d>)
   -{ (<pr-d> ^predicates <p*2>)
      (<p*2> ^status live)}
    (<pr-d> ^predicates <p*1>)
    (<p*1> ^visible { << false unknown >> <v*1> })
    -->
    (<cs> ^proto-referent <pr2> -)
}

sp {ground-referent*apply*quantifier3
    (state <s> ^superstate <s*2> ^operator <op>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<op> ^name quantifier ^quantifier <quant>)
    (<s*2> ^operator <o*1>)
    (<o*1> ^{ << double-constraints constraints >> <a*1> } <v*1>)
    (<v*1> ^constraint <con>)
    (<con> -^multiple true ^handle <obj-type>)
    (<quant> -^handle <obj-type>)
    -->
    (<s> ^proto-referent <pr> +)
    (<pr> ^predicates <pred> + ^handle (make-constant-symbol new-object-id) +
           ^item-type <obj-type> +)
    (<pred> ^quantified <quant> + ^visibility unknown-visible +
           ^dialog-object true + ^category <obj-type> +)
}

sp {ground-referent*apply*quantifier2
    (state <s> ^superstate <s*2> ^operator <op>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<op> ^name quantifier ^quantifier <quant>)
    (<s*2> ^operator <o*1>)
    (<o*1> ^{ << double-constraints constraints >> <a*1> } <v*1>)
    (<v*1> ^constraint <con>)
    (<con> ^handle <obj-type> ^property <p*1>)
    (<p*1> ^handle category)
    -->
    (<s> ^proto-referent <pr> +)
    (<pr> ^predicates <pred> + ^handle (make-constant-symbol new-object-id) +
           ^item-type <obj-type> +)
    (<pred> ^quantified <quant> + ^visibility unknown-visible +
           ^dialog-object true + ^category <obj-type> +)
}

sp {ground-referent*apply*quantifier
    (state <s> ^operator <op>)
   -{ (<s> ^superstate <s*2>)
      (<s*2> ^operator <o*1>)
      (<o*1> ^{ << double-constraints constraints >> <a*1> } <v*1>)
      (<v*1> ^constraint <con>)
      (<con> ^handle <obj-type> ^property <p*1>)
      (<p*1> ^handle category)}
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<op> ^name quantifier ^quantifier <quant>)
    -->
    (<s> ^proto-referent <pr> +)
    (<pr> ^predicates <pred> + ^handle (make-constant-symbol new-object-id) +
           ^item-type object +)
    (<pred> ^quantified <quant> + ^visibility unknown-visible +
           ^dialog-object true + ^category object +)
}

sp {ground-referent*propose*quantifier
    (state <s> ^name ground-referent ^quiescence t ^constraints <c*1>)
    (<c*1> ^quantifier <q*1>)
    (<q*1> ^lt-referent <quant>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name quantifier + ^quantifier <quant> +)
}

sp {ground-referent*apply*process-plural
    (state <s> ^proto-referents one ^operator <o*1>)
    (<o*1> ^name process-plural)
    -->
    (<s> ^proto-referents one - ^proto-referents none +)
}

sp {ground-referent*propose*process-plural
    (state <s> ^proto-referents one ^constraint-processing-finished true
          ^name ground-referent ^constraint <c*1>)
    (<c*1> ^multiple true)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-plural +)
}

sp {ground-referent*apply*non-visual-referent
    (state <s> ^operator <op> ^referent <r>)
    (<op> ^name non-visual-referent ^constraints <cs>)
    (<r> ^<prop> <p*1>)
    -->
    (<cs> ^referent <r> + ^ground-tested <cs> +)
}

sp {ground-referent*apply*non-visual-referent*copy-constraint
    (state <s> ^operator <op> ^referent <r>)
    (<op> ^name non-visual-referent ^constraints <c*1>)
    (<c*1> ^constraint <c>)
    (<c> ^handle <value> ^property <p*1>)
    (<p*1> ^{ << name handle >> <a*1> } <prop>)
    -->
    (<r> ^<prop> <value> +)
}

sp {ground-referent*apply*non-visual-referent*referent
    (state <s> ^operator <op>)
    (<op> ^name non-visual-referent)
    -->
    (<s> ^referent <r> +)
}

sp {ground-referent*propose*non-visual-referent
    (state <s> ^name ground-referent ^constraint-lt <cl> ^superstate <s*1>)
    (<cl> -^demonstrative true -^specifier { << personal it >> <s*2> })
    (<s*1> ^operator <o*1>)
    (<o*1> ^constraints <cs>)
   -{ (<cs> ^constraint <c*2>)
      (<c*2> ^relation <rel>)
      (<rel> ^2 <item>)
      (<item> ^item-type object)}
   -{ (<cs> ^constraint <c*1>)
      (<c*1> ^property <p*1>)
      (<p*1> ^type visual)}
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name non-visual-referent + ^constraints <cs> +)
}

sp {ground-referent*apply*failed-grounding*evaluate-operator
    (state <s> ^quiescence t ^superstate <ss> ^operator <o*1>)
    (<ss> ^name evaluate-operator ^superstate <sss>)
    (<sss> ^operator <o*2>)
    (<o*2> ^evaluation <e>)
    (<o*1>
          ^name { << create-hypothetical quantifier failed-grounding >> <n*1> })
    -->
    (<e> ^final-referent-count 0 +)
}

sp {apply*failed-grounding*remove-current-referent
    (state <s> ^quiescence t ^constraints <cs> -^proto-referent <obj>
          ^superstate <s*1> ^operator <o*1>)
    (<cs> ^referent <obj>)
    (<s*1> ^operator <so>)
    (<so> ^parameter <p> ^{ << double-constraints constraints >> <a*1> } <cs>)
    (<o*1>
          ^name { << create-hypothetical quantifier failed-grounding >> <n*1> })
    -->
    (<cs> ^referent <obj> -)
}

sp {ground-referent*apply*failed-grounding*finish3
    (state <s> ^quiescence t ^proto-referent <ref> ^segment <ss>
          ^top-state <t*1> ^operator <o*1>)
    (<ref> ^predicates-copied true)
    (<ss> ^dialog-object-list-access <dol>)
    (<t*1> ^dialog-world <d*1>)
    (<d*1> ^objects <objs>)
    (<o*1>
          ^name { << create-hypothetical quantifier failed-grounding >> <n*1> })
    -->
    (<ss> ^dialog-object-list-access <dol> -
           ^dialog-object-list-access <ndol> +)
    (<objs> ^object <ref> +)
    (<ndol> ^referent <ref> + ^next <dol> +)
}

sp {ground-referent*apply*failed-grounding*finish2
    (state <s> ^quiescence t ^proto-referent <ref> ^top-state <t*1>
          ^top-state <ts> ^operator <o*1>)
    (<ref> ^predicates-copied true)
    (<t*1> ^dialog-world <d*1>)
    (<d*1> ^objects <objs>)
    (<ts> ^dialog-object-list <dol>)
    (<o*1>
          ^name { << create-hypothetical quantifier failed-grounding >> <n*1> })
    -->
    (<ts> ^dialog-object-list <dol> - ^dialog-object-list <ndol> +)
    (<objs> ^object <ref> +)
    (<ndol> ^referent <ref> + ^next <dol> +)
}

sp {ground-referent*apply*failed-grounding*finish
    (state <s> ^quiescence t ^proto-referent <ref> ^superstate <s*1>
          ^operator <o*1>)
    (<ref> ^predicates-copied true)
    (<s*1> ^operator <o*2>)
    (<o*1>
          ^name { << create-hypothetical quantifier failed-grounding >> <n*1> })
    (<o*2> ^{ << double-constraints constraints >> <a*1> } <c>)
    -->
    (<c> ^ground-tested <c> + ^referent <ref> +)
}

sp {ground-referent*apply*failed-grounding*copy-specifier-distinct
    (state <s> ^proto-referent <pr> ^constraint-lt <c*1> ^operator <o*1>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<c*1> ^specifier distinct)
    (<o*1> ^name failed-grounding)
    -->
    (<pr> ^specifier distinct +)
}

sp {ground-referent*apply*failed-grounding*copy-possessive-flag
    (state <s> ^proto-referent <pr> ^candidate-set <c*2> ^operator <o*1>)
   -{ (<s> ^constraint-lt <c*1>)
      (<c*1> ^specifier indefinite)}
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<c*2> ^possessive true)
    (<o*1> ^name failed-grounding)
    -->
    (<pr> ^possessive true +)
}

sp {ground-referent*apply*failed-grounding*relation2
    (state <s> ^proto-referent <pr> ^constraints <c*1> ^operator <o*1>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<c*1> ^complement <comp>)
   -{ (<comp> ^lt <l*1>)
      (<l*1> ^directional true)}
    (<comp> ^lt <l*2> ^head <h*1>)
    (<h*1> ^referent <ref>)
    (<o*1>
          ^name { << create-hypothetical quantifier failed-grounding index-semantic-memory >> <n*1> })
    (<l*2> ^relation <r*1>)
    (<r*1> ^handle <arg>)
   -{ (<s> ^superstate <s*2>)
      (<s*2> ^operator <o*2>)
      (<o*2> ^{ << double-constraints constraints >> <a*1> } <v*1>)
      (<v*1> ^constraint <c*2>)
      (<c*2> ^relation <value>)
      (<value> ^2 <ref> ^handle <arg>)}
    -->
    (<pr> ^predicates-copied true + ^relation <rel> +)
    (<rel> ^2 <ref> + ^handle <arg> +)
}

sp {ground-referent*apply*failed-grounding*relation*multiple-constraint
    (state <s> ^proto-referent <pr> ^superstate <s*2> ^operator <o*1>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<s*2> ^operator <o*2>)
    (<o*1>
          ^name { << create-hypothetical quantifier failed-grounding index-semantic-memory >> <n*1> })
    (<o*2> ^{ << double-constraints constraints >> <a*1> } <v*1>)
    (<v*1> ^constraint <constraint>)
    (<constraint> ^handle <h*1> ^relation <value>)
    -->
    (<pr> ^predicates-copied true + ^predicates <constraint> +)
    (write (crlf) |Add predicates and relation structure: | <constraint>)
}

sp {ground-referent*apply*failed-grounding*relation
    (state <s> ^superstate <s*2> ^operator <o*1>
          ^{ << sm-proto-referent proto-referent >> <a*1> } <pr>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<s*2> ^operator <o*2>)
    (<o*1>
          ^name { << create-hypothetical quantifier failed-grounding index-semantic-memory >> <n*1> })
    (<o*2> ^{ << double-constraints constraints >> <a*2> } <v*1>)
    (<v*1> ^constraint <constraint>)
    (<constraint> -^handle <h*1> ^relation <value>)
    -->
    (<pr> ^predicates-copied true + ^relation <value> +)
}

sp {ground-referent*apply*failed-grounding*property45
    (state <s> ^proto-referent <pr> ^superstate <s*2> ^operator <o*1>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<s*2> ^operator <so>)
    (<so> ^constraint-count 1
          ^{ << double-constraints constraints >> <a*1> } <v*1>)
    (<o*1>
          ^name { << create-hypothetical quantifier failed-grounding index-semantic-memory >> <n*1> })
    (<v*1> ^constraint <constraint>)
   -{ (<s> ^constraints <c*1>)
      (<c*1> ^quantifier <q*1>)
      (<q*1> ^lt-referent <constraint>)}
   -{ (<pr> ^predicates <p*3>)
      (<constraint>
            ^{ << movable category number quantity type multiple >> <prop> } <value>)}
   -{ (<constraint> ^referent <r*1> ^property <p*1>)
      (<r*1> ^handle <value>)
      (<p*1> ^{ << name handle >> <a*2> } <prop>)}
    (<constraint> ^handle <h*1> ^property <p*2>)
    (<p*2> ^handle name)
    -->
    (<pr> ^predicates-copied true +)
}

sp {ground-referent*apply*failed-grounding*property4
    (state <s> ^superstate <s*2> ^operator <o*1>
          ^{ << sm-proto-referent proto-referent >> <a*1> } <pr>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<s*2> ^operator <o*2>)
    (<o*1>
          ^name { << create-hypothetical quantifier failed-grounding index-semantic-memory >> <n*1> })
    (<o*2> ^{ << double-constraints constraints >> <a*2> } <v*1>)
    (<v*1> ^constraint <constraint>)
   -{ (<s> ^constraints <c*1>)
      (<c*1> ^quantifier <q*1>)
      (<q*1> ^lt-referent <constraint>)}
   -{ (<constraint> ^handle <value> ^property <p*3>)
      (<p*3> ^{ << name handle >> <a*4> } { <> category <prop> })}
   -{ (<constraint> ^referent <r*1> ^property <p*1>)
      (<r*1> ^handle <value>)
      (<p*1> ^{ << name handle >> <a*3> } <prop>)}
    (<constraint> ^handle <h*1>)
   -{ (<pr> ^predicates <p*2>)
      (<constraint>
            ^{ << movable category number quantity type multiple >> <prop> } <value>)}
    -->
    (<pr> ^predicates-copied true +)
}

sp {ground-referent*apply*failed-grounding*property3
    (state <s> ^superstate <s*2> ^operator <o*1>
          ^{ << sm-proto-referent proto-referent >> <a*1> } <pr>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<s*2> ^operator <o*2>)
    (<o*1>
          ^name { << create-hypothetical quantifier failed-grounding index-semantic-memory >> <n*1> })
    (<o*2> ^{ << double-constraints constraints >> <a*2> } <v*1>)
    (<v*1> ^constraint <constraint>)
    (<constraint>
          -^{ << movable category type number quantity multiple handle >> <a*4> } <v*2>)
   -{ (<constraint> ^referent <r*1> ^property <p*1>)
      (<r*1> ^handle <value>)
      (<p*1> ^{ << name handle >> <a*3> } <prop>)}
    -->
    (<pr> ^predicates-copied true +)
}

sp {ground-referent*apply*failed-grounding*property2
    (state <s> ^superstate <s*2> ^operator <o*1>
          ^{ << sm-proto-referent proto-referent >> <a*1> } <pr>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<s*2> ^operator <o*2>)
    (<o*1>
          ^name { << create-hypothetical quantifier failed-grounding index-semantic-memory >> <n*1> })
    (<o*2> ^{ << double-constraints constraints >> <a*2> } <v*1>)
    (<v*1> ^constraint <c*1>)
    (<pr> ^predicates <pred>)
    (<c*1>
          ^{ << movable category number quantity type multiple >> <prop> } <value>)
    -->
    (<pr> ^predicates-copied true +)
    (<pred> ^<prop> <value> +)
}

sp {ground-referent*apply*failed-grounding*property17
    (state <s> ^superstate <s*2> ^operator <o*1>
          ^{ << sm-proto-referent proto-referent >> <a*1> } <pr>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<s*2> ^operator <o*2>)
    (<o*1>
          ^name { << create-hypothetical quantifier failed-grounding index-semantic-memory >> <n*1> })
    (<o*2> ^{ << double-constraints constraints >> <a*2> } <v*1>)
    (<v*1> ^constraint <constraint>)
   -{ (<constraint> ^property <p*1>)
      (<p*1> ^handle { << property >> <h*1> })}
    (<constraint> -^item-type { << predicate property >> <i*1> }
          -^{ << movable category number quantity type multiple >> <a*3> } <x>
          ^handle <value>)
    (<pr> ^predicates <pred>)
    (<pred> ^category <value>)
    -->
    (<pr> ^predicates-copied true +)
}

sp {ground-referent*apply*failed-grounding*property16-2*modi*property
    (state <s> ^proto-referent <pr> ^superstate <s*3> ^superstate <s*2>
          ^operator <o*1>)
    (<pr> -^predicates-copied true ^predicates <pred>
          -^{ << handle name >> <a*3> } <value>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<s*3> ^operator <o*3>)
    (<s*2> ^operator <o*2>)
    (<o*1>
          ^name { << create-hypothetical quantifier failed-grounding >> <n*1> })
    (<o*3> ^{ << double-constraints constraints >> <a*2> } <v*2>)
    (<v*2> ^constraint <constraint2>)
    (<o*2> ^{ << double-constraints constraints >> <a*1> } <v*1>)
    (<v*1> ^constraint { <> <constraint2> <constraint> })
    (<constraint> -^relation <r*1>
          -^item-type { << predicate property >> <i*1> } ^modifier true
          ^handle { <> all <> some <> many <> your <> one <value> })
   -{ (<constraint> ^property <p*1>)
      (<p*1> ^handle { << property shape >> <h*1> })}
    (<pred> -^category <value>)
    (<constraint2> ^property <value2>)
    (<value2> ^handle property)
    -->
    (<pr> ^predicates-copied true +)
    (<pred> ^property-modifier <constraint> +)
    (<constraint> ^modifying <constraint2> +)
    (write (crlf) |Add predicate 16-mod-property: | <pred> | ^property-modifier | <constraint>)
}

sp {ground-referent*apply*failed-grounding*property16-2*modi*relation
    (state <s> ^proto-referent <pr> ^superstate <s*3> ^superstate <s*2>
          ^operator <o*1>)
    (<pr> -^predicates-copied true ^predicates <pred>
          -^{ << handle name >> <a*3> } <value>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<s*3> ^operator <o*3>)
    (<s*2> ^operator <o*2>)
    (<o*1>
          ^name { << create-hypothetical quantifier failed-grounding >> <n*1> })
    (<o*3> ^{ << double-constraints constraints >> <a*2> } <v*2>)
    (<v*2> ^constraint <constraint2>)
    (<o*2> ^{ << double-constraints constraints >> <a*1> } <v*1>)
    (<v*1> ^constraint { <> <constraint2> <constraint> })
    (<constraint> -^relation <r*1>
          -^item-type { << predicate property >> <i*1> } ^modifier true
          ^handle { <> all <> some <> many <> your <> one <value> })
   -{ (<constraint> ^property <p*1>)
      (<p*1> ^handle { << property shape >> <h*1> })}
    (<pred> -^category <value>)
    (<constraint2> ^relation <value2>)
    -->
    (<pr> ^predicates-copied true +)
    (<value2> ^predicates <constraint> +)
    (write (crlf) |Add predicate 16-mod: | <value2> | ^property | <constraint>)
}

sp {ground-referent*apply*failed-grounding*property16
    (state <s> ^proto-referent <pr> ^superstate <s*2> ^operator <o*1>)
    (<pr> -^predicates-copied true ^predicates <pred>
          -^{ << handle name >> <a*2> } <value>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<s*2> ^operator <o*2>)
    (<o*1>
          ^name { << create-hypothetical quantifier failed-grounding >> <n*1> })
    (<o*2> ^{ << double-constraints constraints >> <a*1> } <v*1>)
    (<v*1> ^constraint <constraint>)
    (<constraint> -^modifier true -^relation <r*1>
          -^item-type { << predicate property >> <i*1> }
          ^handle { <> all <> some <> many <> your <> one <value> })
   -{ (<constraint> ^property <p*1>)
      (<p*1> ^handle { << property shape >> <h*1> })}
    (<pred> -^category <value>)
    -->
    (<pr> ^predicates-copied true +)
    (<pred> ^handle <value> +)
}

sp {ground-referent*apply*failed-grounding*property15
    (state <s> ^superstate <s*2> ^operator <o*1>
          ^{ << sm-proto-referent proto-referent >> <a*1> } <pr>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<s*2> ^operator <o*2>)
    (<o*1>
          ^name { << create-hypothetical quantifier failed-grounding index-semantic-memory >> <n*1> })
    (<o*2> ^{ << double-constraints constraints >> <a*2> } <v*1>)
    (<v*1> ^constraint <constraint>)
    (<constraint> ^referent <ref>)
    (<ref> -^property <p*1> ^handle <value>)
    (<pr> -^{ << handle name >> <a*3> } <value> ^predicates <pred>)
    -->
    (<pr> ^predicates-copied true +)
    (<pred> ^handle <value> +)
}

sp {ground-referent*apply*failed-grounding*property1
    (state <s> ^superstate <s*2> ^operator <o*1>
          ^{ << sm-proto-referent proto-referent >> <a*1> } <pr>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<s*2> ^operator <o*2>)
    (<o*1>
          ^name { << create-hypothetical quantifier failed-grounding index-semantic-memory >> <n*1> })
    (<o*2> ^{ << double-constraints constraints >> <a*2> } <v*1>)
    (<v*1> ^constraint <constraint>)
    (<constraint> ^referent <ref>)
    (<ref> ^handle <value> ^property <p*1>)
    (<pr> -^{ << handle name >> <a*4> } <value> ^predicates <pred>)
    (<p*1> ^{ << name handle >> <a*3> } <prop>)
    -->
    (<pr> ^predicates-copied true +)
    (<pred> ^<prop> <value> +)
}

sp {ground-referent*apply*failed-grounding*property
    (state <s> ^superstate <s*2> ^operator <o*1>
          ^{ << sm-proto-referent proto-referent >> <a*1> } <pr>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<s*2> ^operator <o*2>)
    (<o*1>
          ^name { << create-hypothetical quantifier failed-grounding index-semantic-memory >> <n*1> })
    (<o*2> ^{ << double-constraints constraints >> <a*2> } <v*1>)
    (<v*1> ^constraint <constraint>)
    (<constraint> ^handle <value> ^property <p*1>)
    (<pr> -^{ << handle name category >> <a*4> } <value> ^predicates <pred>)
    (<p*1> ^{ << name handle >> <a*3> } { <> category <prop> })
    (<pred> -^<prop> <p*2>)
    -->
    (<pr> ^predicates-copied true +)
    (<pred> ^<prop> <value> +)
}

sp {ground-referent*apply*failed-grounding*indefinite*category
    (state <s> ^constraint-lt <c*1> ^operator <o*1> ^top-state <t*1>
          ^superstate <s*2>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<c*1> ^specifier indefinite)
    (<o*1> ^name failed-grounding)
    (<t*1> ^dialog-world <d*1>)
    (<d*1> ^objects <objs>)
    (<s*2> ^operator <o*2>)
    (<o*2> ^{ << double-constraints constraints >> <a*1> } <v*1>)
    (<v*1> ^constraint <con>)
    (<con> ^handle <obj-type> ^property <p*1>)
    (<p*1> ^handle category)
    -->
    (<s> ^proto-referent <pr> +)
    (<pr> ^predicates <pred> + ^handle (make-constant-symbol new-object-id) +
           ^item-type object +)
    (<pred> ^dialog-object true + ^visible false + ^category <obj-type> +)
}

sp {ground-referent*apply*failed-grounding*indefinite*non-category
    (state <s> ^constraint-lt <c*1> ^operator <o*1> ^top-state <t*1>)
   -{ (<s> ^superstate <s*2>)
      (<s*2> ^operator <o*2>)
      (<o*2> ^{ << double-constraints constraints >> <a*1> } <v*1>)
      (<v*1> ^constraint <c*2>)
      (<c*2> ^property <p*1>)
      (<p*1> ^handle category)}
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<c*1> ^specifier indefinite)
    (<o*1> ^name failed-grounding)
    (<t*1> ^dialog-world <d*1>)
    (<d*1> ^objects <objs>)
    -->
    (<s> ^proto-referent <pr> +)
    (<pr> ^predicates <pred> + ^handle (make-constant-symbol new-object-id) +
           ^item-type object +)
    (<pred> ^visible false + ^dialog-object true + ^category object +)
}

sp {ground-referent*apply*failed-grounding*location2
    (state <s> ^constraint <ref> ^operator <o*1> ^top-state <t*1>)
   -{ (<s> ^constraint-lt <c*1>)
      (<c*1> ^specifier indefinite)}
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<ref> ^predicates <p*2> ^property <p*1>)
    (<p*2> ^visible false)
    (<o*1> ^name failed-grounding)
    (<t*1> ^dialog-world <d*1>)
    (<d*1> ^objects <objs>)
    (<p*1> ^handle { << location name >> <h*1> })
    -->
    (<s> ^proto-referent <ref> +)
}

sp {ground-referent*apply*failed-grounding*location
    (state <s> ^constraint <ref> ^operator <o*1> ^top-state <t*1>)
   -{ (<s> ^constraint-lt <c*1>)
      (<c*1> ^specifier indefinite)}
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<ref> ^predicates <p*1> ^item-type <item-type> ^handle <handle>
          ^property <prop>)
    (<p*1> ^visible true)
    (<o*1> ^name failed-grounding)
    (<t*1> ^dialog-world <d*1>)
    (<d*1> ^objects <objs>)
    (<prop> ^handle { << location name >> <h*1> })
    -->
    (<s> ^proto-referent <ref2> +)
    (<ref2> ^handle <handle> + ^property <prop> + ^item-type <item-type> +
           ^predicates <pred> +)
    (<pred> ^dialog-object true + ^visible false + ^category object +)
}

sp {ground-referent*apply*failed-grounding*category
    (state <s> ^constraint <con> ^operator <o*1> ^top-state <t*1>)
   -{ (<s> ^constraint-lt <c*1>)
      (<c*1> ^specifier indefinite)}
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<o*1> ^name failed-grounding)
    (<con> ^handle <cat> ^property <p*1>)
    (<t*1> ^dialog-world <d*1>)
    (<d*1> ^objects <objs>)
    (<p*1> ^handle category)
    -->
    (<s> ^proto-referent <pr> +)
    (<pr> ^predicates <pred> + ^handle (make-constant-symbol new-object-id) +
           ^item-type object +)
    (<pred> ^visible false + ^dialog-object true + ^category <cat> +)
}

sp {ground-referent*apply*failed-grounding
    (state <s> ^top-state <t*1> ^operator <o*1>)
   -{ (<s> ^constraint <c*2>)
      (<c*2> ^property <p*1>)
      (<p*1> ^handle { << name location category >> <h*1> })}
   -{ (<s> ^constraint-lt <c*1>)
      (<c*1> ^specifier indefinite)}
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<o*1> ^name failed-grounding)
    (<t*1> ^dialog-world <d*1>)
    (<d*1> ^objects <objs>)
    -->
    (<s> ^proto-referent <pr> +)
    (<pr> ^predicates <pred> + ^handle (make-constant-symbol new-object-id) +
           ^item-type object +)
    (<pred> ^visibility not-visible + ^dialog-object true + ^category object +)
}

sp {ground-referent*propose*failed-grounding
    (state <s> ^proto-referents none ^name ground-referent)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name failed-grounding +)
}

sp {apply*tested-referent*monitor*fail*remove-current-referent
    (state <s> ^operator <o*1> ^constraints <cs> ^superstate <s*1>)
    (<o*1> ^name tested-referent)
    (<cs> ^referent <obj>)
   -{ (<s> ^candidate-set <c*1>)
      (<c*1> ^proto-referent <p*1>)
      (<p*1> ^object <obj>)}
    (<s*1> ^operator <so>)
    (<so> ^parameter <p> ^{ << double-constraints constraints >> <a*1> } <cs>)
    -->
    (<cs> ^referent <obj> -)
}

sp {apply*tested-referent*copy-proto-referent*no-multiple
    (state <s> ^operator <o> ^constraints <cons>)
    (<o> ^name tested-referent ^proto-referent <p*1>)
    (<p*1> ^object <obj>)
    -->
    (<cons> ^referent <obj> +)
}

sp {apply*tested-referent*monitor
    (state <s> ^operator <o>)
    (<o> ^name tested-referent ^proto-referent <p*1>)
    (<p*1> ^object <obj>)
    (<obj> ^handle <id>)
    -->
    
}

sp {apply*tested-referent
    (state <s> ^superstate <s*1> ^operator <o*1>)
   -{ (<s> ^candidate-set <c*1>)
      (<c*1> ^proto-referent <p*1>)
      (<p*1> ^object <obj>)
     -{ (<s> ^constraints <c*2>)
        (<c*2> ^referent <obj>)}}
    (<o*1> ^name tested-referent)
    (<s*1> ^operator <so>)
    (<so> ^parameter <p> ^{ << double-constraints constraints >> <a*1> } <c>)
    -->
    (<c> ^ground-tested <p> +)
}

sp {ground-referent*propose*tested-referent
    (state <s> ^name ground-referent ^candidate-set <c*1>)
    (<c*1> ^proto-referent <p>)
    (<p> ^constraint-count 0 ^object <r>)
   -{ (<s> ^constraints <c*2>)
      (<c*2> ^referent <r>)}
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name tested-referent + ^proto-referent <p> +)
}

sp {ground-referent*apply*index-scene-objects*demonstrative*create*candidates*failure
    (state <s> ^candidate-set <cand> ^operator <o> ^superstate <s*1>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^world <w*1>)
      (<w*1> ^{ << robot objects >> <a*1> } <v*1>)
      (<v*1> ^object <obj>)
      (<obj> ^predicates <p*1>)
      (<p*1> ^indicated pointed)}
    (<o> ^specifier demonstrative ^name index-scene-objects)
    (<s*1> ^operator <so>)
    (<so> ^constraints <c> ^parameter <p>)
    -->
    (<c> ^failed-grounding <p> +)
    (<cand> ^generated-candidates true +)
}

sp {ground-referent*apply*index-scene-objects*demonstrative*create*candidates
    (state <s> ^operator <o> ^constraint-count <cc> ^candidate-set <cand>
          ^top-state <t*1>)
    (<o> ^specifier demonstrative ^name index-scene-objects)
    (<t*1> ^world <w*1>)
    (<w*1> ^{ << robot objects >> <a*1> } <v*1>)
    (<v*1> ^object <obj>)
    (<obj> ^predicates <p*1>)
    (<p*1> ^indicated pointed)
    -->
    (<cand> ^proto-referent <pr> +)
    (<pr> ^constraint-count <cc> + ^object <obj> +)
}

sp {ground-referent*apply*index-scene-objects*create*candidates*parallel
    (state <s> ^operator <o> ^constraint-count <cc> ^candidate-set <cand>)
    (<o> ^name index-scene-objects)
    -->
    (<cand> ^generated-candidates true +)
}

sp {ground-referent*apply*index-scene-objects*create*candidate*indefinite
    (state <s> ^operator <o> ^constraint-count <cc> ^candidate-set <cand>)
    (<o> ^specifier indefinite ^name index-scene-objects)
    -->
    (<cand> ^proto-referent <pr> +)
    (<pr> ^constraint-count <cc> +)
}

sp {ground-referent*apply*index-scene-objects*create*candidates*dialog*it*failed
    (state <s> ^constraint-count <cc> ^operator <o> ^candidate-set <cand>
          ^superstate <s*1>)
   -{ (<s> ^segment <s*5>)
      (<s*5> ^dialog-object-list-access <d*2>)
      (<d*2> ^next <n*1>)
      (<n*1> ^referent <r*2>)
      (<r*2> ^predicates <p*3>)
      (<p*3> ^category { << block object >> <c*2> })}
   -{ (<s> ^segment <s*4>)
      (<s*4> ^dialog-object-list-access <d*1>)
      (<d*1> ^referent <r*1>)
      (<r*1> ^predicates <p*2>)
      (<p*2> ^category { << block object >> <c*1> })}
   -{ (<s> ^segment <s*2>)
      (<s*2> ^merged-assigner <m*1>)
      (<m*1> ^parent-receiver <p*1>)
      (<p*1> ^semantics <s*3>)
      (<s*3> ^{ << agent arg1 >> <a*1> } <obj>)}
    (<o> ^specifier it ^name index-scene-objects)
    (<s*1> ^operator <so>)
    (<so> ^constraints <c> ^parameter <p>)
    -->
    (<c> ^ground-tested <p> +)
}

sp {ground-referent*apply*index-scene-objects*create*candidates*dialog*it*next*predicate
    (state <s> ^operator <o> ^constraint-count <cc> ^candidate-set <cand>
          ^segment <s*2> ^segment <s*1> -^possible-it <obj>)
    (<o> ^specifier it ^name index-scene-objects)
    (<s*2> ^dialog-object-list-access <d*2>)
    (<s*1> ^dialog-object-list-access <d*1>)
    (<d*1> ^referent <r*1>)
    (<r*1> ^predicates <p*1>)
    (<p*1> ^category location)
    (<d*2> ^next <n*1>)
    (<n*1> ^referent <obj>)
   -{ (<obj> ^property <p*3>)
      (<p*3> ^handle category)}
    (<obj> ^predicates <p*2>)
    (<p*2> ^category { << block object >> <c*1> })
    -->
    (<cand> ^proto-referent <pr> +)
    (<pr> ^constraint-count <cc> + ^object <obj> +)
}

sp {ground-referent*apply*index-scene-objects*create*candidates*dialog*it*next
    (state <s> ^operator <o> ^constraint-count <cc> ^candidate-set <cand>
          ^segment <s*2> ^segment <s*1> -^possible-it <obj>)
    (<o> ^specifier it ^name index-scene-objects)
    (<s*2> ^dialog-object-list-access <d*2>)
    (<s*1> ^dialog-object-list-access <d*1>)
    (<d*1> ^referent <r*1>)
    (<r*1> ^predicates <p*1>)
    (<p*1> ^category { << location location1 >> <c*1> })
    (<d*2> ^next <n*1>)
    (<n*1> ^referent <obj>)
    (<obj> ^property <p*2>)
    (<p*2> ^handle category)
    -->
    (<cand> ^proto-referent <pr> +)
    (<pr> ^constraint-count <cc> + ^object <obj> +)
}

sp {ground-referent*apply*index-scene-objects*create*candidates*dialog*it*predicate
    (state <s> ^constraint-count <cc> -^possible-it <p*1> ^operator <o>
          ^candidate-set <cand> ^segment <s*1>)
    (<o> ^specifier it ^name index-scene-objects)
    (<s*1> ^dialog-object-list-access <d*1>)
    (<d*1> ^referent <obj>)
    (<obj> ^predicates <p*2>)
    (<p*2> ^category { <> concept <> location <> location1 <c*1> })
    -->
    (<cand> ^proto-referent <pr> +)
    (<pr> ^constraint-count <cc> + ^object <obj> +)
}

sp {ground-referent*apply*index-scene-objects*create*candidates*dialog*it
    (state <s> ^constraint-count <cc> -^possible-it <p*1> ^operator <o>
          ^candidate-set <cand> ^segment <s*1>)
    (<o> ^specifier it ^name index-scene-objects)
    (<s*1> ^dialog-object-list-access <d*1>)
    (<d*1> ^referent <obj>)
    (<obj> ^property <p*2>)
    (<p*2> ^handle category)
    -->
    (<cand> ^proto-referent <pr> +)
    (<pr> ^constraint-count <cc> + ^object <obj> +)
}

sp {ground-referent*apply*index-scene-objects*create*candidates*dialog*it*arg1
    (state <s> ^operator <o> ^possible-it <obj> ^constraint-count <cc>
          ^candidate-set <cand>)
    (<o> ^specifier it ^name index-scene-objects)
    -->
    (<cand> ^proto-referent <pr> +)
    (<pr> ^constraint-count <cc> + ^object <obj> +)
}

sp {ground-referent*apply*index-scene-objects*it-agent-subclause
    (state <s> ^name ground-referent ^segment <seg>)
    (<seg> ^not-merged-assigner <ma>)
    (<ma> ^parent-receiver <p*1>)
    (<p*1> ^semantics <s*1>)
    (<s*1> ^{ << arg1 agent >> <a*1> } <obj>)
   -{ (<seg> ^merged-assigner { < <ma> <ma2> })
      (<ma2> ^parent-receiver <p*2>)
      (<p*2> ^semantics <s*2>)
      (<s*2> ^{ << arg1 agent >> <a*2> } <obj>)}
    (<obj> ^predicates <p*3>)
    (<p*3> ^category <c*1>)
    -->
    (<s> ^possible-it <obj> +)
}

sp {ground-referent*apply*index-scene-objects*subclause-it-arg1-2
    (state <s> ^name ground-referent ^segment <seg>)
    (<seg> ^merged-assigner <ma>)
    (<ma> ^parent-receiver <p*2>)
    (<p*2> ^semantics <s*2>)
    (<s*2> ^if-subclause <i*1>)
    (<i*1> ^{ << arg1 agent >> <a*2> } <obj>)
   -{ (<seg> ^merged-assigner { < <ma> <ma2> })
      (<ma2> ^parent-receiver <p*3>)
      (<p*3> ^semantics <s*3>)
      (<s*3> ^{ << arg1 agent >> <a*3> } <obj>)}
   -{ (<ma> ^parent-receiver <p*1>)
      (<p*1> ^semantics <s*1>)
      (<s*1> ^{ << arg1 agent >> <a*1> } <obj>)}
    (<obj> ^object-instance true ^handle <h*1>)
    -->
    (<s> ^possible-it <obj> +)
}

sp {ground-referent*apply*index-scene-objects*subclause-it-arg1
    (state <s> ^name ground-referent ^segment <seg>)
    (<seg> ^merged-assigner <ma>)
    (<ma> ^parent-receiver <p*2>)
    (<p*2> ^semantics <s*2>)
    (<s*2> ^if-subclause <i*1>)
    (<i*1> ^{ << arg1 agent >> <a*2> } <obj>)
   -{ (<seg> ^merged-assigner { < <ma> <ma2> })
      (<ma2> ^parent-receiver <p*3>)
      (<p*3> ^semantics <s*3>)
      (<s*3> ^{ << arg1 agent >> <a*3> } <obj>)}
   -{ (<ma> ^parent-receiver <p*1>)
      (<p*1> ^semantics <s*1>)
      (<s*1> ^{ << arg1 agent >> <a*1> } <obj>)}
    (<obj> ^predicates <p*4>)
    (<p*4> ^category <c*1>)
    -->
    (<s> ^possible-it <obj> +)
}

sp {ground-referent*apply*index-scene-objects*it-arg1
    (state <s> ^name ground-referent ^segment <seg>)
    (<seg> ^merged-assigner <ma>)
    (<ma> ^parent-receiver <p*1>)
    (<p*1> ^semantics <s*1>)
    (<s*1> ^{ << arg1 agent >> <a*1> } <obj>)
   -{ (<seg> ^merged-assigner { < <ma> <ma2> })
      (<ma2> ^parent-receiver <p*2>)
      (<p*2> ^semantics <s*2>)
      (<s*2> ^{ << arg1 agent >> <a*2> } <obj>)}
    (<obj> ^predicates <p*3>)
    (<p*3> ^category <c*1>)
    -->
    (<s> ^possible-it <obj> +)
}

sp {ground-referent*apply*index-scene-objects*create*candidates*dialog
    (state <s> ^operator <o> ^constraint-count <cc> ^candidate-set <cand>
          ^top-state <t*1>)
    (<o> -^possessive true -^specifier distinct ^name index-scene-objects
          ^specifier { << definite universal >> <s*1> })
    (<t*1> ^dialog-world <d*1>)
    (<d*1> ^objects <o*1>)
    (<o*1> ^object <obj>)
   -{ (<s> ^constraint-lt <c*1>)
      (<c*1> ^number singular)
      (<obj> ^predicates <p*1>)
      (<p*1> ^multiple true)}
    (<obj> -^dialog-ignore true)
    -->
    (<cand> ^proto-referent <pr> +)
    (<pr> ^constraint-count <cc> + ^object <obj> +)
}

sp {ground-referent*apply*index-scene-objects*create*object*possessive
    (state <s> ^operator <o> ^constraint-count <cc> ^candidate-set <cand>)
    (<o> ^possessive true ^name index-scene-objects
          ^specifier { << definite universal >> <s*1> })
    -->
    (<cand> ^proto-referent none + ^possessive true +)
}

sp {ground-referent*apply*index-scene-objects*create*candidates
    (state <s> ^constraint-count <cc> ^operator <o> ^candidate-set <cand>
          ^top-state <t*1>)
   -{ (<s> ^segment <s*1>)
      (<s*1> ^hypothetical true)}
    (<o> -^possessive true ^name index-scene-objects
          ^specifier { << definite universal >> <s*2> })
    (<t*1> ^world <w*1>)
    (<w*1> ^objects <o*1>)
    (<o*1> ^object <obj>)
    -->
    (<cand> ^proto-referent <pr> +)
    (<pr> ^constraint-count <cc> + ^object <obj> +)
}

sp {ground-referent*apply*index-scene-objects*personal*create*robot
    (state <s> ^operator <o> ^constraint-count <cc> ^candidate-set <cand>
          ^top-state <t*1>)
    (<o> ^specifier personal ^name index-scene-objects)
    (<t*1> ^world <w*1>)
    (<w*1> ^robot <obj>)
    -->
    (<cand> ^proto-referent <pr> +)
    (<pr> ^constraint-count <cc> + ^object <obj> +)
}

sp {ground-referent*propose*index-scene-object*possessive
    (state <s> ^name ground-referent ^constraint-lt <c*1> ^operator <op> +)
    (<c*1> ^possessive true)
    (<op> ^name index-scene-objects)
    -->
    (<op> ^possessive true +)
}

sp {ground-referent*propose*index-scene-object*multiple
    (state <s> ^name ground-referent ^constraint <c*1> ^operator <op> +)
    (<c*1> ^multiple true)
    (<op> ^name index-scene-objects)
    -->
    (<op> ^multiple true +)
}

sp {ground-referent*propose*index-scene-object*no-specifier
    (state <s> ^name ground-referent ^constraint-lt <lli>
          ^candidate-set <cand>)
    (<lli> -^specifier <s*1> -^demonstrative true)
    (<cand> -^generated-candidates true)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name index-scene-objects + ^specifier definite +)
}

sp {ground-referent*propose*index-scene-object*demonstrative
    (state <s> ^name ground-referent ^constraint-lt <lli>
          ^candidate-set <cand>)
    (<lli> ^demonstrative true)
    (<cand> -^generated-candidates true)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name index-scene-objects + ^specifier demonstrative +)
}

sp {ground-referent*propose*index-scene-object
    (state <s> ^name ground-referent ^constraint-lt <lli>
          ^candidate-set <cand>)
    (<lli> -^demonstrative true ^specifier <specifier>)
    (<cand> -^generated-candidates true)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name index-scene-objects + ^specifier <specifier> +)
}

sp {ground-referent*apply*index-object-scene-relation*remove-violated
    (state <s> ^operator <o> ^candidate-set <cs>)
    (<o> ^name index-object-scene-relation ^relation-constraint <pc>)
    (<cs> ^proto-referent <pr>)
    (<pr> ^violates <pc>)
    -->
    (<cs> ^proto-referent <pr> -)
}

sp {ground-referent*apply*index-object-scene-relationmark*satisfied
    (state <s> ^operator <o> ^candidate-set <c*1>)
    (<o> ^name index-object-scene-relation ^relation-constraint <pc>)
    (<c*1> ^proto-referent <pr>)
    (<pr> ^passes <pc> ^constraint-count <cc>)
    -->
    (<pr> ^constraint-count <cc> - ^constraint-count (- <cc> 1) +)
}

sp {ground-referent*apply*index-object-scene-relation*mark*checked*failed
    (state <s> ^operator <o> ^candidate-set <cs>)
    (<o> ^name index-object-scene-relation ^relation-constraint <pc>)
    (<cs> -^success-tested <pc> ^fail-tested <pc>)
    -->
    (<cs> ^satisfied-property <pc> +)
}

sp {ground-referent*apply*index-object-scene-relation*mark*checked
    (state <s> ^operator <o> ^candidate-set <cs>)
    (<o> ^name index-object-scene-relation ^relation-constraint <pc>)
    (<cs> ^success-tested <pc>)
    -->
    (<cs> ^satisfied-property <pc> +)
}

sp {apply*index-object-scene-relation*passes
    (state <s> ^operator <op> ^candidate-set <cs> ^top-state <t*1>)
    (<op> ^name index-object-scene-relation ^relation-constraint <rc>)
    (<cs> ^proto-referent <pr>)
    (<rc> ^2 <r-2> ^handle <sr>)
    (<t*1> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <wsr>)
    (<wsr> ^handle <sr> ^instance <pwsr>)
    (<pwsr> ^2 <r-2> ^1 <r-1>)
    (<pr> ^object <r-1>)
    -->
    (<pr> ^passes <rc> +)
    (<cs> ^success-tested <rc> +)
}

sp {ground-referent*apply*index-object-scene-relation*violates
    (state <s> ^operator <o> ^candidate-set <cs>)
    (<o> ^name index-object-scene-relation ^relation-constraint <rc>)
    (<cs> ^proto-referent <pr>)
    (<rc> ^2 <r-2> ^handle <sr>)
    (<pr> ^object <r-1>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^world <w*1>)
      (<w*1> ^predicates <p*1>)
      (<p*1> ^predicate <wsr>)
      (<wsr> ^handle <sr> ^instance <pwsr>)
      (<pwsr> ^2 <r-2> ^1 <r-1>)}
    -->
    (<pr> ^violates <rc> +)
    (<cs> ^fail-tested <rc> +)
}

sp {ground-referent*propose*index-scene-relation
    (state <s> ^name ground-referent ^candidate-set <cs> ^constraint <c*1>)
    (<cs> ^generated-candidates true -^satisfied-property <r>)
    (<c*1> ^relation <r>)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name index-object-scene-relation + ^relation-constraint <r> +)
}

sp {ground-referent*apply*index-object-properties*remove-violated
    (state <s> ^candidate-set <cs> ^operator <o>)
    (<cs> ^proto-referent <pr>)
    (<pr> ^violates <pc>)
    (<o> ^property-constraint <pc>
          ^name { << index-object-properties index-dialog-properties >> <n*1> })
    -->
    (<cs> ^proto-referent <pr> -)
}

sp {ground-referent*apply*index-object-properties*mark*satisfied
    (state <s> ^candidate-set <c*1> ^operator <o>)
    (<c*1> ^proto-referent <pr>)
    (<pr> ^passes <pc> ^constraint-count <cc>)
    (<o> ^property-constraint <pc>
          ^name { << index-object-properties index-dialog-properties >> <n*1> })
    -->
    (<pr> ^constraint-count <cc> - ^constraint-count (- <cc> 1) +)
}

sp {ground-referent*apply*index-object-properties*mark*checked*failed
    (state <s> ^candidate-set <cs> ^operator <o>)
    (<cs> ^fail-tested <pc> -^success-tested <pc>)
    (<o> ^property-constraint <pc>
          ^name { << index-object-properties index-dialog-properties >> <n*1> })
    -->
    (<cs> ^satisfied-property <pc> +)
}

sp {ground-referent*apply*index-object-properties*mark*checked
    (state <s> ^candidate-set <cs> ^operator <o>)
    (<cs> ^success-tested <pc>)
    (<o> ^property-constraint <pc>
          ^name { << index-object-properties index-dialog-properties >> <n*1> })
    -->
    (<cs> ^satisfied-property <pc> +)
}

sp {ground-referent*apply*index-object-properties*passes*named
    (state <s> ^operator <o> ^candidate-set <cs>)
    (<o> ^name index-object-properties ^property-constraint <pc>)
    (<cs> ^proto-referent <pr>)
    (<pc> ^value <prop-val>)
    (<pr> ^object <o*1>)
    (<o*1> ^handle <prop-val>)
    -->
    (<pr> ^passes <pc> +)
    (<cs> ^success-tested <pc> +)
}

sp {ground-referent*apply*index-object-properties*passes
    (state <s> ^operator <o> ^candidate-set <cs>)
    (<o> ^name index-object-properties ^property-constraint <pc>)
    (<cs> ^proto-referent <pr>)
    (<pc> ^value <prop-val> ^property <prop-name>)
    (<pr> ^object <o*1>)
    (<o*1> ^predicates <p*1>)
    (<p*1> ^<prop-name> <prop-val>)
    -->
    (<pr> ^passes <pc> +)
    (<cs> ^success-tested <pc> +)
}

sp {ground-referent*apply*index-object-properties*violates
    (state <s> ^operator <o> ^candidate-set <cs>)
    (<o> ^name index-object-properties ^property-constraint <pc>)
    (<cs> ^proto-referent <pr>)
    (<pc> ^value <prop-val> ^property { <> generic <prop-name> })
    (<pr> ^object <obj>)
    (<obj> -^handle <prop-val> ^predicates <preds>)
   -{ (<pc> ^value <p-value>)
      (<preds> ^<prop-name> <p-value>)}
    (<preds> -^<prop-name> <prop-val>)
    -->
    (<pr> ^violates <pc> +)
    (<cs> ^fail-tested <pc> +)
}

sp {ground-referent*compare*index-object-properties2
    (state <s> ^name ground-referent ^operator <op2> + ^operator <op1> +)
    (<op2> ^name index-object-properties ^property-constraint <p*2>)
    (<op1> ^name index-object-properties ^property-constraint <p*1>)
    (<p*2> ^value <v*1>)
    (<p*1> ^value { > <v*1> <pc> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {ground-referent*propose*index-object-properties
    (state <s> ^name ground-referent ^property-constraint <pc>
          ^candidate-set <cs>)
    (<pc> -^property grammatical-property)
    (<cs> -^satisfied-property <pc> ^generated-candidates true)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name index-object-properties + ^property-constraint <pc> +)
}

sp {ground-referent*elaborate*no-proto-referents*multiple
    (state <s> ^name ground-referent -^proto-referents none
          ^candidate-set <cs>)
   -{ (<cs> ^proto-referent <p*1>)
      (<p*1> ^object <obj>)
     -{ (<cs> ^proto-referent <p*2>)
        (<p*2> ^object { <> <obj> <o*1> })}}
    (<cs> ^generated-candidates true)
    -->
    (<s> ^proto-referents multiple +)
}

sp {ground-referent*elaborate*no-proto-referents*one
    (state <s> ^name ground-referent ^candidate-set <cs>)
    (<cs> ^generated-candidates true ^proto-referent <p*1>)
    (<p*1> ^object <obj>)
   -{ (<cs> ^proto-referent <p*2>)
      (<p*2> ^object { <> <obj> <o*1> })}
    -->
    (<s> ^proto-referents one +)
}

sp {ground-referent*elaborate*proto-referents*none
    (state <s> ^name ground-referent ^candidate-set <cs>)
   -{ (<cs> ^proto-referent <p*1>)
      (<p*1> ^object <obj>)}
    (<cs> ^generated-candidates true)
    -->
    (<s> ^proto-referents none +)
}

sp {ground-referent*elaborate*constraint-processing-finished
    (state <s> ^name ground-referent ^candidate-set <c*1>)
    (<c*1> ^proto-referent <p*1>)
    (<p*1> ^constraint-count 0)
    -->
    (<s> ^constraint-processing-finished true +)
}

sp {ground-referent*elaborate*substate4
    (state <s> ^name ground-referent ^constraint <con>)
    (<con> ^{ << movable category type >> <type> } <value>)
    -->
    (<s> ^property-constraint <pc> +)
    (<pc> ^property <type> + ^value <value> +)
}

sp {ground-referent*elaborate*substate3
    (state <s> ^name ground-referent ^constraint <con>)
    (<con> ^property <p>)
    (<p> ^handle <property> ^value <value>)
    -->
    (<s> ^property-constraint <pc> +)
    (<pc> ^property <property> + ^value <value> +)
}

sp {ground-referent*elaborate*substate2*subcategory
    (state <s> ^name ground-referent ^property-constraint <pc>
          ^constraint <con>)
    (<con> ^handle <value> ^subcategory <s*1> ^property <prop>)
    (<pc> ^value <value> ^property <property>)
    (<s*1> ^handle <x>)
    (<prop> ^{ << name handle >> <a*1> } <property>)
    -->
    (<pc> ^value <x> +)
}

sp {ground-referent*elaborate*substate2
    (state <s> ^name ground-referent ^constraint <con>)
    (<con> ^handle <value> ^property <prop>)
    (<prop> ^{ << name handle >> <a*1> } <property>)
    -->
    (<s> ^property-constraint <pc> +)
    (<pc> ^property <property> + ^value <value> +)
}

sp {ground-referent*elaborate*substate1
    (state <s> ^name ground-referent ^constraint <con>)
    (<con> ^referent <r*1>)
    (<r*1> ^handle <value>)
    -->
    (<s> ^property-constraint <pc> +)
    (<pc> ^property handle + ^value <value> +)
}

sp {ground-referent*elaborate*substate0
    (state <s> ^name ground-referent ^constraint <con>)
    (<con> ^name <value> ^property <p*1>)
    (<p*1> ^name <name>)
    -->
    (<s> ^property-constraint <pc> +)
    (<pc> ^property <name> + ^value <value> +)
}

sp {ground-referent*elaborate*substate*constraint
    (state <s> ^name ground-referent ^superstate <s*1>)
    (<s*1> ^operator <so>)
    (<so> ^name ground-referent ^constraints <c*1>)
    (<c*1> ^constraint <con>)
    -->
    (<s> ^constraint <con> +)
}

sp {ground-referent*constraint-lt2
    (state <s> ^name ground-referent ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^name ground-referent ^double-constraints <d*1>)
    (<d*1> ^lt <x>)
    -->
    (<s> ^constraint-lt <x> +)
}

sp {ground-referent*constraint-lt
    (state <s> ^name ground-referent ^constraints <c*1>)
    (<c*1> ^lt <x>)
    -->
    (<s> ^constraint-lt <x> +)
}

sp {ground-referent*elaborate*substate*constraints
    (state <s> ^name ground-referent ^superstate <s*1>)
    (<s*1> ^operator <so>)
    (<so> ^name ground-referent ^constraints <cons>)
    -->
    (<s> ^constraints <cons> +)
}

sp {ground-referent*elaborate*substate*count
    (state <s> ^name ground-referent ^superstate <s*1>)
    (<s*1> ^operator <so>)
    (<so> ^name ground-referent ^constraint-count <cc>)
    -->
    (<s> ^constraint-count <cc> + ^candidate-set <cs> +)
}

sp {comprehension*apply*ground-referent*zero-constraints
    (state <s> ^name comprehension ^operator <op1>)
    (<op1> ^constraint-count 0 ^name ground-referent ^parameter <p>
          ^{ << double-constraints constraints >> <a*1> } <c>)
   -{ (<p> ^lt <l*2>)
      (<l*2> ^demonstrative <d*1>)}
   -{ (<p> ^lt <l*1>)
      (<l*1> ^specifier { << it personal >> <s*1> })}
    -->
    (<c> ^failed-grounding <p> + ^ground-tested <p> +)
    (<p> ^failed-constraint <c> +)
}

sp {comprehension*elaborate*ground-referent*count-constraints*lots
    (state <s> ^name comprehension ^operator <op1> +)
    (<op1> ^name ground-referent ^constraints <con>)
    (<con> ^constraint <c6> ^constraint { < <c6> <c5> }
          ^constraint { < <c5> < <c6> <c4> }
          ^constraint { < <c4> < <c5> < <c6> <c3> }
          ^constraint { < <c3> < <c4> < <c5> < <c6> <c2> }
          ^constraint { < <c2> < <c3> < <c4> < <c5> < <c6> <c1> })
    -->
    (<op1> ^constraint-count 6 +)
}

sp {comprehension*elaborate*ground-referent*count-constraints*5
    (state <s> ^name comprehension ^operator <op1> +)
    (<op1> ^name ground-referent ^constraints <con>)
    (<con> ^constraint <c5> ^constraint { < <c5> <c4> }
          ^constraint { < <c4> < <c5> <c3> }
          ^constraint { < <c3> < <c4> < <c5> <c2> }
          ^constraint { < <c2> < <c3> < <c4> < <c5> <c1> }
          -^constraint { <> <c1> <> <c2> <> <c3> <> <c4> <> <c5> <c*1> })
    -->
    (<op1> ^constraint-count 5 +)
}

sp {comprehension*elaborate*ground-referent*count-constraints*4
    (state <s> ^name comprehension ^operator <op1> +)
    (<op1> ^name ground-referent ^constraints <con>)
    (<con> ^constraint <c4> ^constraint { < <c4> <c3> }
          ^constraint { < <c3> < <c4> <c2> }
          ^constraint { < <c2> < <c3> < <c4> <c1> }
          -^constraint { <> <c1> <> <c2> <> <c3> <> <c4> <c*1> })
    -->
    (<op1> ^constraint-count 4 +)
}

sp {comprehension*elaborate*ground-referent*count-constraints*3
    (state <s> ^name comprehension ^operator <op1> +)
    (<op1> ^name ground-referent ^constraints <con>)
    (<con> ^constraint <c3> ^constraint { < <c3> <c2> }
          ^constraint { < <c2> < <c3> <c1> }
          -^constraint { <> <c1> <> <c2> <> <c3> <c*1> })
    -->
    (<op1> ^constraint-count 3 +)
}

sp {comprehension*elaborate*ground-referent*count-constraints*2
    (state <s> ^name comprehension ^operator <op1> +)
    (<op1> ^name ground-referent ^constraints <con>)
    (<con> ^constraint <c2> ^constraint { < <c2> <c1> }
          -^constraint { <> <c1> <> <c2> <c*1> })
    -->
    (<op1> ^constraint-count 2 +)
}

sp {comprehension*elaborate*ground-referent*count-constraints*1
    (state <s> ^name comprehension ^operator <op1> +)
    (<op1> ^name ground-referent ^constraints <con>)
    (<con> ^constraint <c1> -^constraint { <> <c1> <c*1> })
    -->
    (<op1> ^constraint-count 1 +)
}

sp {comprehension*elaborate*ground-referent*count-constraints*0
    (state <s> ^name comprehension ^operator <op1> +)
    (<op1> ^name ground-referent ^constraints <con>)
    (<con> -^constraint <c*1>)
    -->
    (<op1> ^constraint-count 0 +)
}

sp {comprehension*compare*ground-referent*process-semantics
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name ground-referent)
    (<op2> ^name { << ground-new-constraint process-semantics >> <n*1> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*ground-referent*merge*not
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
    (<op2> ^name merge ^assigner <ass>)
    (<op1> ^name ground-referent ^constraints <c*1>)
    (<c*1> ^structure-type DP)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*ground-referent*merge*literal
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
    (<op2> ^name merge ^assigner <ass>)
    (<ass> ^structure-type DP ^lt <l*1>)
    (<l*1> ^referent-type literal)
    (<op1> ^name ground-referent ^constraints <c*1>)
    (<c*1> ^structure-type DP)
    -->
    (<s> ^operator <op1> -)
}

sp {comprehension*compare*ground-referent*merge
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
    (<op2> ^name merge ^assigner <ass>)
    (<ass> ^structure-type DP ^lt <l*1>)
    (<l*1> ^referent nil)
    (<op1> ^name ground-referent ^constraints <c*1>)
    (<c*1> ^structure-type DP)
    -->
    (<s> ^operator <op1> < <op2>)
}

sp {comprehension*compare*ground-referent
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
    (<op2> ^name process-phrase-end)
    (<op1> ^name ground-referent)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*elaborate-operator*ground-referent
    (state <s> ^name comprehension ^operator <o> +)
    (<o> ^name ground-referent ^double-constraints <d*1> ^constraints <con>)
    (<d*1> ^constraint <x>)
    -->
    (<con> ^constraint <x> +)
}

sp {comprehension*elaborate-operator*ground-referent*parameter-complement
    (state <s> ^name comprehension ^operator <o> +)
    (<o> ^name ground-referent ^constraints <con> ^parameter <p*1>)
    (<p*1> ^complement <c*1>)
    (<c*1> ^constraint <x>)
    -->
    (<con> ^constraint <x> +)
}

sp {comprehension*elaborate-operator*ground-referent*parameter-constraint
    (state <s> ^name comprehension ^operator <o> +)
    (<o> ^name ground-referent ^constraints <con> ^parameter <p*1>)
    (<p*1> ^constraint <x>)
    (<x> ^relation <r*1>)
    -->
    (<con> ^constraint <x> +)
}

sp {comprehension*elaborate-operator*ground-referent*lt
    (state <s> ^name comprehension ^operator <o> +)
    (<o> ^name ground-referent ^constraints <con>)
    (<con> ^lt <l*1>)
    (<l*1> ^constraint <x>)
    -->
    (<con> ^constraint <x> +)
}

sp {comprehension*propose*ground-referent*push*complement3
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^new-constraint <n*1> ^last-merge <lm>)
    (<lm> ^assigner <as> ^receiver <r1>)
    (<as> ^structure-type PP ^parent-receiver <obj>)
    (<obj> -^referent <r*1> ^{ << complement complement2 >> <a*1> } <c2>
          -^ground-tested <head>)
    (<r1> ^structure-type PP)
    (<n*1> ^object <obj>)
    (<c2> ^head <head>)
   -{ (<head> ^constraint <c*1>)
      (<c*1> ^property <p*1>)
      (<p*1> ^type conceptual)}
    (<head> ^structure-type DP)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name ground-referent + ^constraints <obj> + ^parameter <head> +)
}

sp {comprehension*propose*ground-referent*push*complement2
    (state <s> ^name comprehension ^segment <s*1>)
    (<s*1> ^last-merge <lm>)
    (<lm> ^receiver <r1> ^assigner <as>)
    (<r1> ^structure-type PP -^ground-tested <head>)
    (<as> ^parent-receiver <a1> ^structure-type <s*2>)
    (<a1> ^{ << complement complement2 >> <a*1> } <c2> -^ground-tested <head>)
    (<c2> ^head <head>)
   -{ (<head> ^ground-tested <head2> ^head <head2>)}
   -{ (<head> ^head <h*1>)
      (<h*1> ^lt <l*1>)
      (<l*1> ^semantic-entity-type relation)}
    (<head> -^ground-tested <head> ^structure-type DP)
   -{ (<head> ^constraint <c*1>)
      (<c*1> ^property <p*1>)
      (<p*1> ^type conceptual)}
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name ground-referent + ^constraints <cons> +
           ^double-constraints <c2> + ^double-constraints <head> +
           ^parameter <head> +)
}

sp {comprehension*propose*ground-referent*push*complement
    (state <s> ^name comprehension ^segment <s*1>)
    (<s*1> ^last-merge <lm>)
    (<lm> ^assigner <as> ^receiver <r1>)
    (<as> ^parent-receiver <a1> ^structure-type <s*2>)
    (<a1> ^complement <head> -^ground-tested <head>)
   -{ (<head> ^ground-tested <head2> ^head <head2>)}
    (<head> -^ground-tested <head> ^structure-type { << THIS THAT DP >> <st> })
   -{ (<head> ^constraint <c*1>)
      (<c*1> ^property <p*1>)
      (<p*1> ^type conceptual)}
    (<r1> -^ground-tested <head> ^structure-type <st>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name ground-referent + ^constraints <head> + ^parameter <head> +)
}

sp {comprehension*propose*ground-referent*push*head
    (state <s> ^name comprehension ^segment <s*1>)
    (<s*1> ^last-merge <lm>)
    (<lm> ^assigner <as> ^receiver <r1>)
   -{ (<as> ^lt <l*1>)
      (<l*1> ^referent-type literal)}
    (<as> ^parent-receiver <a1> ^structure-type <s*2>)
    (<a1> ^head <head> -^ground-tested <head>)
    (<head> -^ground-tested <g*1> ^structure-type { << THIS THAT DP >> <st> })
   -{ (<head> ^constraint <c*1>)
      (<c*1> ^property <p*1>)
      (<p*1> ^type conceptual)}
    (<r1> -^ground-tested <head> ^structure-type <st>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name ground-referent + ^constraints <head> + ^parameter <head> +)
}

sp {comprehension*propose*ground-referent
    (state <s> ^name comprehension ^segment <s*1>)
    (<s*1> ^last-merge <lm>)
    (<lm> ^assigner <as> ^receiver { <> <a1> <r1> })
   -{ (<as> ^lt <l*1>)
      (<l*1> ^referent-type literal)}
    (<as> ^parent-receiver <a1> ^structure-type <s*2>)
    (<a1> -^ground-tested <a1> ^structure-type DP -^ground-tested <r1>)
   -{ (<a1> ^constraint <c*1>)
      (<c*1> ^property <p*2>)
      (<p*2> ^type conceptual)}
   -{ (<r1> ^lt-referent <l*2>)
      (<l*2> ^property <p*1>)
      (<p*1> ^type conceptual)}
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name ground-referent + ^constraints <a1> + ^parameter <r1> +)
}

sp {apply*ground-new-constraint*referent-nil
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name ground-new-constraint ^constraint <nc>)
    (<seg> ^new-constraint <nc> ^last-merge <l*1> ^semantics <sem>)
    (<nc> ^constraint <c*1> ^object <pword>)
    (<l*1> ^receiver <lmr>)
    (<c*1> ^relation <rel>)
    (<rel> ^lt <l*2> ^head <h*2>)
    (<h*2> ^head <h*3>)
    (<h*3> ^lt-referent <r-2>)
    (<l*2> ^relation <r>)
    (<pword> ^head <h*1>)
    (<h*1> ^lt-referent <sv>)
    -->
    (<seg> ^new-constraint <nc> -)
    (<pword> ^ground-tested <nc> + ^ground-tested <lmr> +)
    (<sem> ^relation <rx> +)
    (<rx> ^entity1 <sv> + ^relation <r> + ^entity2 <r-2> +)
}

sp {apply*ground-new-constraint*remove-no-referent3
    (state <s> ^operator <op> ^segment <seg> ^top-state <t*1>)
    (<op> ^name ground-new-constraint ^constraint <nc>)
    (<seg> ^new-constraint <nc> ^last-merge <l*1>)
    (<nc> ^constraint <c> ^object <pword>)
    (<l*1> ^receiver <lmr>)
    (<t*1> ^world <w>)
    (<c> ^relation <spr>)
    (<spr> ^2 <r-2> ^handle <sr>)
   -{ (<w> ^predicates <p*1>)
      (<p*1> ^predicate <wsr>)
      (<wsr> ^handle <sr> ^instance <pwsr>)
      (<pwsr> ^2 <r-2> ^1 <r-1>)}
    (<pword> -^referent <r-1>)
    -->
    (<seg> ^new-constraint <nc> -)
    (<pword> ^ground-tested <nc> + ^ground-tested <lmr> +)
}

sp {apply*ground-new-constraint*remove-no-referent2
    (state <s> ^operator <op> ^segment <seg> ^top-state <t*1>)
    (<op> ^name ground-new-constraint ^constraint <nc>)
    (<seg> ^new-constraint <nc> ^last-merge <l*1>)
    (<nc> ^constraint <c> ^object <pword>)
    (<l*1> ^receiver <lmr>)
    (<t*1> ^world <w>)
    (<c> ^relation <spr>)
    (<spr> ^2 <r-2> ^handle <sr>)
    (<pword> ^referent <r-1>)
   -{ (<w> ^predicates <p*1>)
      (<p*1> ^predicate <wsr>)
      (<wsr> ^handle <sr> ^instance <pwsr>)
      (<pwsr> ^2 <r-2> ^1 <r-1>)}
    -->
    (<seg> ^new-constraint <nc> -)
    (<pword> ^ground-tested <nc> + ^ground-tested <lmr> +)
}

sp {apply*ground-new-constraint*remove-no-referent
    (state <s> ^operator <op> ^segment <seg> ^top-state <t*1>)
    (<op> ^name ground-new-constraint ^constraint <nc>)
    (<seg> ^new-constraint <nc> ^last-merge <l*1>)
    (<nc> ^constraint <c> ^object <pword>)
    (<l*1> ^receiver <lmr>)
    (<t*1> ^world <w>)
    (<w> ^predicates <p*1>)
    (<p*1> ^predicate <wsr>)
    (<wsr> ^instance <pwsr> ^handle <sr>)
    (<pwsr> ^2 <r-2> ^1 <r-1>)
    (<c> ^relation <spr>)
    (<spr> ^2 <r-2> ^handle <sr>)
    (<pword> -^referent <r-1>)
    -->
    (<seg> ^new-constraint <nc> -)
    (<pword> ^ground-tested <nc> + ^ground-tested <lmr> +)
}

sp {apply*ground-new-constraint*failure*V
    (state <s> ^operator <op> ^segment <seg> ^top-state <t*1>)
    (<op> ^name ground-new-constraint ^constraint <nc>)
    (<seg> ^new-constraint <nc>)
    (<nc> ^constraint <c> ^object <o*1>)
    (<t*1> ^world <w>)
    (<c> ^relation <spr>)
    (<spr> ^2 <r-2> ^handle <sr>)
    (<o*1> ^PP <P*1>)
    (<P*1> ^DP <pword>)
    (<pword> ^referent <r-1> ^spelling <spelling>)
   -{ (<w> ^predicates <p*2>)
      (<p*2> ^predicate <wsr>)
      (<wsr> ^handle <sr> ^instance <pwsr>)
      (<pwsr> ^2 <r-2> ^1 <r-1>)}
    -->
    (<seg> ^new-constraint <nc> -)
    (<pword> ^ground-tested <nc> + ^failed-constraint <f*1> +
           ^failed-grounding <fg> + ^referent <ref> -)
    (<f*1> ^object <r-1> +)
    (<fg> ^assigner-word <spelling> + ^structure-type P + ^relation <sr> +
           ^lost-grounding <r-1> +)
}

sp {apply*ground-new-constraint*dialog-object
    (state <s> ^operator <op> ^segment <seg> ^top-state <t*1>)
    (<op> ^name ground-new-constraint ^constraint <nc>)
    (<seg> ^new-constraint <nc>)
    (<nc> ^constraint <c> ^object <pword>)
    (<t*1> ^world <w>)
    (<c> ^relation <spr>)
    (<spr> ^2 <r-2> ^handle <sr>)
    (<r-2> ^predicates <p*1>)
    (<p*1> ^dialog-object true)
    (<pword> ^lt <l*1> ^referent <r-1>)
    (<l*1> ^spelling <spelling>)
    -->
    (<seg> ^new-constraint <nc> -)
    (<pword> ^ground-tested <nc> +)
    (<r-1> ^relation <spr> +)
}

sp {apply*ground-new-constraint*failure
    (state <s> ^operator <op> ^segment <seg> ^top-state <t*1>)
    (<op> ^name ground-new-constraint ^constraint <nc>)
    (<seg> ^new-constraint <nc>)
    (<nc> ^constraint <c> ^object <pword>)
    (<t*1> ^world <w>)
    (<c> ^relation <spr>)
    (<spr> ^2 <r-2> ^handle <sr>)
   -{ (<r-2> ^predicates <p*2>)
      (<p*2> ^dialog-object true)}
    (<pword> ^referent <r-1> ^lt <l*1>)
   -{ (<w> ^predicates <p*1>)
      (<p*1> ^predicate <wsr>)
      (<wsr> ^handle <sr> ^instance <pwsr>)
      (<pwsr> ^2 <r-2> ^1 <r-1>)}
    (<l*1> ^spelling <spelling>)
    -->
    (<seg> ^new-constraint <nc> -)
    (<pword> ^ground-tested <nc> + ^failed-constraint <fc> +
           ^failed-grounding <fg> + ^referent <obj1> -)
    (<fc> ^constraint <c> + ^object <r-1> +)
    (<fg> ^assigner-word <spelling> + ^structure-type P + ^relation <sr> +
           ^lost-grounding <r-1> +)
}

sp {apply*ground-new-constraint*removed-semantics-failed
    (state <s> ^operator <op> ^segment <seg> ^top-state <t*1>)
    (<op> ^name ground-new-constraint ^constraint <nc>)
    (<seg> ^new-constraint <nc> ^semantics <sem>)
    (<nc> ^constraint <c> ^object <pword>)
    (<t*1> ^world <w>)
    (<c> ^relation <spr>)
    (<spr> ^2 <r-2> ^handle <sr>)
    (<sem> ^<anything> <r-1>)
   -{ (<w> ^predicates <p*1>)
      (<p*1> ^predicate <wsr>)
      (<wsr> ^handle <sr> ^instance <pwsr>)
      (<pwsr> ^2 <r-2> ^1 <r-1>)}
    (<pword> ^referent <r-1>)
    -->
    (<sem> ^<anything> <x> -)
}

sp {apply*ground-new-constraint*removed-failed
    (state <s> ^operator <op> ^segment <s*1> ^segment <s*2> ^top-state <t*1>)
    (<op> ^name ground-new-constraint ^constraint <nc>)
    (<s*1> ^new-constraint <nc>)
    (<nc> ^constraint <c> ^object <obj>)
    (<s*2> ^not-merged-receiver <rec>)
    (<rec> ^complement <obj> ^semantics <sem>)
    (<obj> ^referent <r-1>)
    (<t*1> ^world <w>)
    (<sem> ^object <r-1>)
    (<c> ^relation <spr>)
    (<spr> ^2 <r-2> ^handle <sr>)
   -{ (<w> ^predicates <p*1>)
      (<p*1> ^predicate <wsr>)
      (<wsr> ^handle <sr> ^instance <pwsr>)
      (<pwsr> ^2 <r-2> ^1 <r-1>)}
    -->
    (<sem> ^object <object> -)
    (<obj> ^referent <object> - ^failed-constraint <fc> +)
    (<fc> ^constraint <c> + ^object <r-1> +)
}

sp {apply*ground-new-constraint*success
    (state <s> ^operator <op> ^segment <seg> ^top-state <t*1>)
    (<op> ^name ground-new-constraint ^constraint <nc>)
    (<seg> ^new-constraint <nc>)
    (<nc> ^constraint <c> ^object <pword>)
    (<t*1> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <wsr>)
    (<wsr> ^instance <pwsr> ^handle <sr>)
    (<pwsr> ^2 <r-2> ^1 <r-1>)
    (<c> ^relation <spr>)
    (<spr> ^2 <r-2> ^handle <sr>)
    (<pword> ^referent <r-1>)
    -->
    (<seg> ^new-constraint <nc> -)
    (<pword> ^ground-tested <nc> +)
}

sp {comprehension*propose*ground-new-constraint
    (state <s> ^name comprehension ^segment <s*1>)
    (<s*1> ^new-constraint <nc>)
   -{ (<nc> ^constraint <c*2>)
      (<c*2> ^relation <r*1>)
      (<r*1> ^2 <v*1>)
      (<v*1> ^property <p*1>)
      (<p*1> ^handle concept)}
    (<nc> ^constraint <c*1> ^object <obj>)
    (<c*1> ^relation <rel>)
    (<obj> -^ground-tested <nc> ^referent <x>)
    (<x> -^relation <rel>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name ground-new-constraint + ^constraint <nc> +)
}

sp {comprehend-word*apply*process-string
    (state <s> ^operator <o> ^comprehension-structure <cs>)
    (<o> ^name process-string ^current-word <cw> ^spell <x>)
    (<cw> ^quoted true)
    -->
    (<cs> ^not-merged-receiver <item> +)
    (<s> ^receiver-created <item> + ^created-receiver true +
           ^retrieved-lexical-item <item> +)
    (<item> ^current-word <cw> + ^lt-referent <ref> + ^structure-type DP +
           ^lt <id> + ^semantics <sem> +)
    (<id> ^structure-type DP + ^spelling <x> + ^referent <ref> +)
    (<ref> ^handle (make-constant-symbol string-object-handle) +
           ^sentence <x> +)
}

sp {comprehend-word*propose*process-string
    (state <s> ^name comprehend-word -^single-word true
          -^failed-single-word-retrieval true -^retrieved-lexical-item <r*1>
          ^segment <seg>)
    (<seg> ^current-word <cw>)
    (<cw> ^quoted true ^spelling <spell>)
    -->
    (<s> ^operator <op> + ^operator <op> > ^operator <op> =)
    (<op> ^name process-string + ^spell <spell> + ^current-word <cw> +)
}

sp {apply*return-receiver
    (state <s> ^operator <o*1> ^comprehension-structure <c*1> ^segment <seg>)
    (<o*1> ^name return-receiver)
    (<c*1> ^not-merged-receiver <item>)
    -->
    (<seg> ^not-merged-receiver <item> +)
}

sp {elaborate*detect-created-not-merged-receiver
    (state <s> ^operator <o*1>
          ^name { << comprehend-word comprehend-construction >> <n*1> })
    (<o*1> ^name return-receiver)
    -->
    (<s> ^created-receiver true +)
}

sp {comprehend-word*compare*return-receiver2
    (state <s> ^operator <op2> + ^operator <op1> +
          ^name { << comprehend-word comprehend-construction >> <n*1> })
    (<op2> ^name retrieve-semantic-substructure)
    (<op1> ^name return-receiver)
    -->
    (<s> ^operator <op1> < <op2>)
}

sp {comprehend-word*compare*return-receiver
    (state <s> ^operator <op1> +
          ^name { << comprehend-word comprehend-construction >> <n*1> }
          ^operator <op2> +)
    (<op1> ^name return-receiver)
    (<op2> ^name { << retry-create-receiver create-receiver >> <n*2> })
    -->
    (<s> ^operator <op1> < <op2>)
}

sp {comprehend-word*apply*add-to-perception-monitor*complete
    (state <s> ^name comprehend-word ^operator <o> ^top-state <t*1>)
    (<o> ^name add-to-perception-monitor ^relation-handle <rhandle>
          ^retrieved <ri>)
    (<t*1> ^perception-monitor <p*1>)
    (<p*1> ^predicate-monitor <pm>)
    (<pm> ^predicate-info <p*2>)
    (<p*2> ^predicate-handle <rhandle>)
    -->
    (<s> ^added-to-monitor true +)
}

sp {comprehend-word*apply*add-to-perception-monitor
    (state <s> ^name comprehend-word ^operator <o> ^top-state <t*1>)
    (<o> ^name add-to-perception-monitor ^relation-handle <rhandle>
          ^retrieved <ri>)
    (<t*1> ^perception-monitor <p*1>)
    (<p*1> ^predicate-monitor <pm>)
   -{ (<pm> ^predicate-info <p*2>)
      (<p*2> ^predicate-handle <rhandle>)}
    -->
    (<pm> ^predicate-info <pi> +)
    (<pi> ^predicate-handle <rhandle> + ^smem-info <ri> +)
}

sp {comprehend-word*propose*add-to-perception-monitor*linear
    (state <s> ^name comprehend-word -^added-to-monitor true
          -^failed-retrieval true ^current-word <c*1>
          ^retrieved-lexical-item <r*1>)
   -{ (<s> ^segment <s*1>)
      (<s*1> ^retry <r*2>)}
   -{ (<s> ^top-state <t*2>)
      (<t*2> ^world-usage internal)}
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^game-scripting true)}
    (<c*1> ^spelling linear)
    (<r*1> ^referent <ri>)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name add-to-perception-monitor + ^relation-handle linear +
           ^retrieved <ri> +)
}

sp {comprehend-word*propose*add-to-perception-monitor
    (state <s> ^name comprehend-word -^added-to-monitor true
          -^failed-retrieval true ^retrieved-lexical-item <r*1>
          ^current-word <cw>)
   -{ (<s> ^segment <s*1>)
      (<s*1> ^retry <r*2>)}
   -{ (<s> ^top-state <t*2>)
      (<t*2> ^world-usage internal)}
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^game-scripting true)}
    (<r*1> ^relation <ri>)
    (<ri> -^handle of1 ^type relation ^handle <rhandle>)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name add-to-perception-monitor + ^relation-handle <rhandle> +
           ^retrieved <ri> +)
}

sp {comprehend-word*apply*process-single-word*quoted
    (state <s> ^operator <o> ^comprehension-structure <cs>)
    (<o> ^name process-single-word ^current-word <cw> ^spell <x>)
    (<cw> ^quoted true)
    -->
    (<cs> ^not-merged-receiver <item> +)
    (<s> ^receiver-created <item> + ^created-receiver true +
           ^retrieved-lexical-item <item> +)
    (<item> ^current-word <cw> + ^lt-referent <ref> + ^structure-type CP +
           ^lt <id> + ^semantics <sem> +)
    (<id> ^structure-type CP + ^spelling <x> + ^message-type quoted-sentence +
           ^semantic-structure arg1 + ^referent <ref> +)
    (<ref> ^handle (make-constant-symbol string-object-handle) +
           ^sentence <x> +)
}

sp {comprehend-word*apply*process-single-word*fail
    (state <s> ^operator <o*1> ^segment <seg> ^smem <s*2> ^superstate <s*1>)
    (<o*1> ^name process-single-word)
    (<seg> ^semantics <sem> ^original-sentence <os>)
    (<s*2> ^result <r*1>)
    (<r*1> ^failure <t>)
    (<s*1> ^operator <so>)
    -->
    (<s> ^failed-single-word-retrieval true + ^failed-retrieval true +)
    (<sem> ^interaction-status <i*1> + ^message-type failed-comprehension +)
    (<i*1> ^failure <f*1> +)
    (<f*1> ^type failed-to-interpret-message +)
    (<os> ^processed-sentence true + ^processing-result failure +)
}

sp {comprehend-word*apply*process-single-word*success
    (state <s> ^operator <o*1> ^comprehension-structure <cs> ^smem <smem>)
    (<o*1> ^name process-single-word)
    (<smem> ^result <r*1> ^command <c>)
    (<r*1> ^retrieved <rli>)
    (<rli> ^spelling-single-word <x>)
    (<c> ^query <q>)
    (<q> ^spelling-single-word <x>)
    -->
    (<c> ^query <q> - ^depth 9 -)
    (<cs> ^retrieved-lexical-item <rli> +)
}

sp {comprehend-word*apply*process-single-word
    (state <s> ^operator <o> ^smem <s*1>)
   -{ (<o> ^current-word <c*1>)
      (<c*1> ^quoted true)}
    (<o> ^name process-single-word ^spell <x>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^query <q> + ^depth 9 +)
    (<q> ^spelling-single-word <x> +)
}

sp {comprehend-word*propose*process-single-wordx
    (state <s> ^single-word true -^failed-single-word-retrieval true
          -^retrieved-lexical-item <r*1> ^name comprehend-word ^segment <seg>)
    (<seg> ^current-word <cw>)
    (<cw> ^spelling <spell>)
    -->
    (<s> ^operator <op> + ^operator <op> > ^operator <op> =)
    (<op> ^name process-single-word + ^spell <spell> + ^current-word <cw> +)
}

sp {comprehend-word*elaborate*single-wordx
    (state <s> ^name comprehend-word ^segment <seg>)
    (<seg> ^prior-word <p*1> ^current-word <cw>)
    (<p*1> ^spelling *)
    (<cw> ^next <n*1> ^spelling <spell>)
    (<n*1> ^spelling |.|)
    -->
    (<s> ^single-word true +)
}

sp {apply*retry-create-receiver*create-item*delete*retrieved-lexical-item
    (state <s> ^retrieved-lexical-item <id> -^name comprehend-construction
          ^operator <op> ^segment <seg> ^comprehension-structure <cs>
          ^current-word <cw>)
    (<id> -^constraint <c*1> ^structure-type <stype>)
    (<op> ^name retry-create-receiver ^retry <retry>)
    (<retry> ^structure-type <stype> ^lt <old-id>)
    (<seg> ^retry <retry>)
    -->
    (<s> ^retrieved-lexical-item <id> -)
}

sp {apply*retry-create-receiver*create-item*parse-failed-receiver
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name retry-create-receiver)
    (<seg> ^parse-failed-receiver <pfr>)
    -->
    (<seg> ^parse-failed-receiver <pfr> - ^parse-failed-end-of-sentence true -)
}

sp {apply*retry-create-receiver*create-item
    (state <s> ^retrieved-lexical-item <id> -^name comprehend-construction
          ^operator <op> ^segment <seg> ^comprehension-structure <cs>
          ^current-word <cw>)
    (<id> -^constraint <c*1> ^structure-type { <> <old-type> <stype> })
    (<op> ^name retry-create-receiver ^retry <retry>)
    (<seg> ^retry <retry>)
    (<retry> ^lt <old-id> ^structure-type <old-type>)
    -->
    (<seg> ^retry <retry> - ^parse-failed-end-of-sentence true -
           ^retried <retry> +)
    (<cw> ^processed true +)
    (<retry> ^lt <id> + ^lt <old-id> - ^structure-type <stype> +
           ^structure-type <old-type> -)
}

sp {comprehend-word*compare*retry-create-receiver
    (state <s> ^operator <op1> +
          ^name { << comprehend-word comprehend-construction >> <n*1> }
          ^operator <op2> +)
    (<op1> ^name retry-create-receiver)
    (<op2>
          ^name { << retrieve-semantic-substructure remove-stale-receiver retrieve-semantic-substructure >> <n*2> })
    -->
    (<s> ^operator <op1> < <op2>)
}

sp {comprehend-word*propose*retry-create-receiver
    (state <s> ^retrieved-lexical-item <id> ^current-word <cw> ^segment <seg>
          ^name { << comprehend-word comprehend-construction >> <n*1> })
   -{ (<s> ^comprehension-structure <c*1>)
      (<c*1> ^not-merged-receiver <uri>)
      (<uri> ^lt <id> ^current-word <cw>)}
    (<seg> ^retry <retry>)
    (<retry> -^lt <id>)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name retry-create-receiver + ^retry <retry> +)
}

sp {comprehend-word*apply*retry-smem-lexical-retrieval*fail
    (state <s> ^operator <o*1> ^smem <smem> ^superstate <s*1>)
    (<o*1> ^name retry-smem-lexical-retrieval)
    (<smem> ^result <r*1>)
    (<r*1> ^failure <t>)
    (<s*1> ^operator <so>)
    -->
    (<s> ^failed-retrieval true +)
}

sp {comprehend-word*apply*retry-smem-lexical-retrieval*success*monitor
    (state <s> ^operator <o*1> ^smem <smem>)
    (<o*1> ^name retry-smem-lexical-retrieval)
    (<smem> ^result <r*1> ^command <c>)
    (<r*1> ^retrieved <rli>)
    (<c> ^query <q>)
    (<q> ^spelling <x>)
    -->
    (<s> ^retry-success true +)
}

sp {comprehend-word*apply*retry-smem-lexical-retrieval*success
    (state <s> ^operator <o*1> ^comprehension-structure <cs> ^smem <smem>)
    (<o*1> ^name retry-smem-lexical-retrieval)
    (<smem> ^result <r*1> ^command <c>)
    (<r*1> ^retrieved <rli>)
    (<c> ^query <q>)
    -->
    (<c> ^query <q> -)
    (<s> ^retrieved-lexical-item <rli> +)
    (<cs> ^retrieved-lexical-item <rli> +)
}

sp {comprehend-word*apply*retry-smem-lexical-retrieval*sentence2
    (state <s> ^operator <o> ^segment <s*1> ^smem <s*2>)
    (<o> ^name retry-smem-lexical-retrieval ^retry-receiver <rec> ^word <w*1>)
    (<s*1> ^retried <rec>)
    (<rec> ^lt <l*1>)
    (<l*1> ^structure-type <as>)
    (<w*1> ^spelling <x>)
    (<s*2> ^command <cmd>)
    -->
    (<cmd> ^query <q> +)
    (<q> ^spelling <x> + ^structure-type <as> +)
}

sp {comprehend-word*apply*retry-smem-lexical-retrieval*sentence
    (state <s> ^operator <o> ^smem <s*2>)
    (<o> ^name retry-smem-lexical-retrieval ^retry-receiver <rec> ^word <w*1>)
   -{ (<s> ^segment <s*1>)
      (<s*1> ^retried <rec>)}
    (<rec> ^lt <l*1>)
    (<l*1> ^alternative-structure <as>)
    (<w*1> ^spelling <x>)
    (<s*2> ^command <cmd>)
    -->
    (<cmd> ^query <q> +)
    (<q> ^spelling <x> + ^structure-type <as> +)
}

sp {comprehend-word*propose*retry-smem-lexical-retrieval*sentence
    (state <s> ^current-word <cw> -^failed-retrieval true -^retry-success true
          ^segment <seg>
          ^name { << comprehend-word comprehend-construction >> <n*1> })
    (<cw> ^spelling <spell>)
   -{ (<seg> ^retry-receiver <r>)
      (<r> ^retried true ^lt <l*2>)
      (<l*2> ^spelling <spell>)}
    (<seg> ^retry-receiver <retry>)
    (<retry> ^lt <l*1>)
    (<l*1> ^spelling <spell>)
    -->
    (<s> ^operator <o> + ^operator <o> = ^operator <o> >)
    (<o> ^name retry-smem-lexical-retrieval + ^word <cw> +
           ^retry-receiver <retry> +)
}

sp {comprehend-word*apply*retry-smem-lexical-retrieval
    (state <s> ^operator <o> ^smem <s*1>)
    (<o> ^name retry-smem-lexical-retrieval ^retry <r*1> ^word <w*1>)
    (<r*1> ^lt <l*1>)
    (<l*1> ^alternative-structure <as>)
    (<w*1> ^spelling <x>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^query <q> +)
    (<q> ^spelling <x> + ^structure-type <as> +)
}

sp {comprehend-word*propose*retry-smem-lexical-retrieval
    (state <s> ^current-word <cw> -^failed-retrieval true -^retry-success true
          ^segment <seg>
          ^name { << comprehend-word comprehend-construction >> <n*1> })
    (<seg> -^retried-sentence true ^retry <retry>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name retry-smem-lexical-retrieval + ^word <cw> + ^retry <retry> +)
}

sp {comprehend-word*apply*smem-lexical-retrieval-proprogate-first-word
    (state <s> ^operator <o> ^comprehension-structure <cs> ^segment <seg>
          ^smem <s*1>)
    (<o> ^prior-word-stale true ^name smem-lexical-retrieval-cw-pw)
    (<seg> ^prior-word <pw>)
    (<pw> ^first-word true ^spelling <pick>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <rli>)
    (<rli> ^prior-word <pick>)
    -->
    (<cs> ^first-word true +)
}

sp {comprehend-word*apply*smem-lexical-retrieval-receiver-prior-word-stale
    (state <s> ^operator <o> ^comprehension-structure <cs> ^segment <seg>
          ^smem <s*1>)
    (<o> ^prior-word-stale true ^prior-word <pw>)
    (<seg> ^retrieved-stack <r*2> ^not-merged-receiver <uai>)
    (<r*2> ^item <uai>)
    (<uai> ^lt <lt>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <rli>)
    (<rli> -^consumes-prior-word false ^prior-word <pw>)
    -->
    (<cs> ^remove-receiver <uai> +)
}

sp {comprehend-word*apply*smem-lexical-retrieval-assigner-prior-word-stale
    (state <s> ^operator <o> ^comprehension-structure <cs> ^segment <seg>
          ^smem <s*1>)
    (<o> ^prior-word-stale true ^prior-word <pw>)
    (<seg> ^retrieved-stack <r*2> ^not-merged-assigner <uai>)
    (<uai> ^parent-receiver <prior-receiver> ^current-word <c*1> ^lt <lt>)
    (<r*2> ^item <prior-receiver>)
    (<c*1> ^spelling <pw>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <rli>)
    (<rli> -^consumes-prior-word false ^prior-word <pw>)
    -->
    (<seg> ^not-merged-assigner <uai> -)
}

sp {comprehend-word*apply*smem-lexical-retrieval-cw-pw*success
    (state <s> ^comprehension-structure <cs> ^smem <smem> ^operator <o*1>)
    (<smem> ^result <r*1> ^command <c>)
    (<r*1> ^retrieved <rli>)
    (<rli> ^current-word <cw> ^prior-word <pw>)
    (<c> ^query <q>)
    (<q> ^current-word <cw> ^prior-word <pw>)
    (<o*1>
          ^name { << smem-lexical-retrieval-cw-pw smem-lexical-retrieval-cw-pw-type >> <n*1> })
    -->
    (<c> ^query <q> - ^depth 9 -)
    (<cs> ^retrieved-lexical-item <rli> +)
}

sp {comprehend-word*apply*smem-lexical-retrieval-cw-pw*success*monitor
    (state <s> ^operator <o*1> ^smem <smem>)
    (<o*1> ^name smem-lexical-retrieval-cw-pw)
    (<smem> ^result <r*1> ^command <c>)
    (<r*1> ^retrieved <r*2>)
    (<r*2> ^spelling <x>)
    (<c> ^query <q>)
    (<q> ^current-word <cw> ^prior-word <pw>)
    -->
    
}

sp {comprehend-construction*apply*smem-lexical-retrieval-cw-pw
    (state <s> ^smem <s*1> ^operator <o>)
    (<s*1> ^command <cmd>)
    (<o> ^current-word <up> ^prior-word <pick>
          ^name { << smem-lexical-retrieval-cw-pw smem-lexical-retrieval-cw-pw-type >> <n*1> })
    -->
    (<cmd> ^query <x> + ^depth 9 +)
    (<x> ^current-word <up> + ^prior-word <pick> +)
}

sp {comprehend-word*compare*smem-lexical-retrieval-cw-pw*smem-lexical-retrieval-cw-pw-type
    (state <s> ^name comprehend-word ^operator <op2> + ^operator <op1> +)
    (<op2> ^name smem-lexical-retrieval-cw-pw-type)
    (<op1> ^name smem-lexical-retrieval-cw-pw)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehend-word*compare*smem-lexical-retrieval-cw-pw*smem-lexical-retrieval
    (state <s> ^name comprehend-word ^operator <op2> + ^operator <op1> +)
    (<op2> ^name smem-lexical-retrieval)
    (<op1>
          ^name { << smem-lexical-retrieval-cw-pw smem-lexical-retrieval-cw-pw-type >> <n*1> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehend-word*propose*smem-lexical-retrieval-cw-pw-type*reject
    (state <s> ^name comprehend-word -^retrieved-lexical-item <r*1>
          ^segment <seg> ^operator <o> + ^failed-retrieval <fr>
          ^current-word <c*1>)
   -{ (<s> ^comprehension-structure <c*2>)
      (<c*2> ^retrieved-lexical-item <r*2>)}
    (<seg> -^retry <r*4> ^retrieved-stack <r*3>)
    (<o> ^name smem-lexical-retrieval-cw-pw-type ^current-word <up>
          ^prior-word <pick-type>)
    (<fr> ^current-word <up> ^prior-word <pick-type>)
    (<c*1> ^spelling <up>)
    (<r*3> ^item <i*1>)
    (<i*1> ^lt <l*1>)
    (<l*1> ^structure-type <pick-type>)
    -->
    (<s> ^operator <o> -)
}

sp {comprehend-word*propose*smem-lexical-retrieval-cw-pw-type
    (state <s> ^failed-operator smem-lexical-retrieval-cw-pw
          -^retrieved-lexical-item <r*1> ^name comprehend-word ^segment <seg>
          ^current-word <c*1>)
   -{ (<s> ^comprehension-structure <c*2>)
      (<c*2> ^retrieved-lexical-item <r*2>)}
    (<seg> -^retry <r*4> ^retrieved-stack <r*3>)
    (<c*1> ^spelling <up>)
    (<r*3> ^item <i*1>)
    (<i*1> ^lt <lt>)
    (<lt> ^structure-type <pick-type>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-lexical-retrieval-cw-pw-type + ^current-word <up> +
           ^prior-word <pick-type> +)
}

sp {comprehend-word*propose*smem-lexical-retrieval-cw-pw*reject2
    (state <s> ^name comprehend-word -^retrieved-lexical-item <r*1>
          ^operator <o> + ^failed-retrieval <fr> ^current-word <c*1>
          ^segment <seg>)
   -{ (<s> ^comprehension-structure <c*2>)
      (<c*2> ^retrieved-lexical-item <r*3>)}
   -{ (<s> ^segment <s*1>)
      (<s*1> ^retry <r*2>)}
    (<o> ^prior-word-stale true ^name smem-lexical-retrieval-cw-pw
          ^current-word <up> ^prior-word <pick>)
    (<fr> ^current-word <up> ^prior-word <pick>)
    (<c*1> ^spelling <up>)
    (<seg> ^retrieved-stack <r*4>)
    (<r*4> ^item <i*1>)
    (<i*1> ^lt <l*1>)
    (<l*1> ^spelling <pick>)
    -->
    (<s> ^operator <o> -)
}

sp {comprehend-word*propose*smem-lexical-retrieval-cw-pw*reject
    (state <s> ^name comprehend-word -^retrieved-lexical-item <r*1>
          ^operator <o> + ^failed-retrieval <fr> ^current-word <c*1>
          ^segment <seg>)
   -{ (<s> ^comprehension-structure <c*2>)
      (<c*2> ^retrieved-lexical-item <r*3>)}
   -{ (<s> ^segment <s*1>)
      (<s*1> ^retry <r*2>)}
    (<o> ^prior-word-stale true ^name smem-lexical-retrieval-cw-pw
          ^current-word <up> ^prior-word <pick>)
    (<fr> ^current-word <up> ^prior-word <pick>)
    (<c*1> ^spelling <up>)
    (<seg> ^prior-word <p*1>)
    (<p*1> ^spelling <pick>)
    -->
    (<s> ^operator <o> -)
}

sp {comprehend-word*propose*smem-lexical-retrieval-cw-pw2
    (state <s> ^name comprehend-word -^retrieved-lexical-item <r*1>
          ^current-word <c*1> ^segment <seg>)
   -{ (<s> ^comprehension-structure <c*2>)
      (<c*2> ^retrieved-lexical-item <r*3>)}
   -{ (<s> ^segment <s*1>)
      (<s*1> ^retry <r*2>)}
    (<c*1> ^spelling <up>)
    (<seg> ^retrieved-stack <r*4>)
    (<r*4> ^item <item>)
    (<item> -^merged-with true ^lt <l*1>)
    (<l*1> ^spelling <pick>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-lexical-retrieval-cw-pw + ^current-word <up> +
           ^prior-word <pick> + ^prior-word-stale true +)
}

sp {comprehend-word*propose*smem-lexical-retrieval-cw-pw
    (state <s> ^name comprehend-word -^retrieved-lexical-item <r*1>
          ^current-word <c*1> ^segment <seg>)
   -{ (<s> ^comprehension-structure <c*2>)
      (<c*2> ^retrieved-lexical-item <r*3>)}
   -{ (<s> ^segment <s*1>)
      (<s*1> ^retry <r*2>)}
    (<c*1> ^spelling <up>)
    (<seg> ^prior-word <p*1>)
    (<p*1> ^spelling <pick>)
   -{ (<seg> ^retrieved-stack <r*4>)
      (<r*4> ^item <i*1>)
      (<i*1> ^lt <l*1>)
      (<l*1> ^spelling <pick>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-lexical-retrieval-cw-pw + ^current-word <up> +
           ^prior-word <pick> + ^prior-word-stale true +)
}

sp {comprehend-word*apply*smem-lexical-retrieval*fail
    (state <s> ^operator <o*1> ^smem <smem> ^superstate <s*1>)
    (<o*1> ^name smem-lexical-retrieval)
    (<smem> ^result <r*1>)
    (<r*1> ^failure <t>)
    (<s*1> ^operator <so>)
    -->
    (<s> ^failed-retrieval true +)
}

sp {comprehend-word*apply*smem-lexical-retrieval*success
    (state <s> ^comprehension-structure <cs> ^smem <smem> ^operator <o*1>)
    (<smem> ^result <r*1> ^command <c>)
    (<r*1> ^retrieved <rli>)
    (<rli> ^spelling <x>)
    (<c> ^query <q>)
    (<q> ^spelling <x>)
    (<o*1>
          ^name { << smem-lexical-retrieval smem-lexical-retrieval-cw-pw-type >> <n*1> })
    -->
    (<c> ^query <q> - ^depth 9 -)
    (<cs> ^retrieved-lexical-item <rli> +)
}

sp {comprehend-word*apply*smem-lexical-retrieval*first-word
    (state <s> ^operator <o> ^smem <s*1>)
    (<o> ^name smem-lexical-retrieval ^word <word>)
    (<word> ^first-word true ^spelling <x>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^query <q> + ^depth 9 +)
    (<q> ^spelling <x> +)
}

sp {comprehend-word*apply*smem-lexical-retrieval*not-first-word
    (state <s> ^operator <o> ^smem <s*1>)
    (<o> ^name smem-lexical-retrieval ^word <word>)
    (<word> -^first-word true ^spelling <x>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^query <q> + ^depth 9 +)
    (<q> ^spelling <x> +)
}

sp {comprehend-word*propose*smem-lexical-retrieval2
    (state <s> ^current-word <cw> -^failed-retrieval true
          -^retrieved-lexical-item <r*1>
          -^failed-operator smem-lexical-retrieval-cw-pw-type ^segment <seg>
          ^name { << comprehend-word comprehend-construction >> <n*1> })
   -{ (<s> ^retrieved-stack <r*4>)
      (<r*4> ^item <i*1>)
      (<i*1> ^lt <l*1>)
      (<l*1> ^structure-type <pick-type>)}
   -{ (<s> ^segment <s*1>)
      (<s*1> ^retry <r*3>)}
   -{ (<s> ^comprehension-structure <c*1>)
      (<c*1> ^retrieved-lexical-item <r*2>)}
   -{ (<seg> ^prior-word <p*1>)
      (<p*1> ^spelling *)
      (<cw> ^next <n*2>)
      (<n*2> ^spelling |.|)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-lexical-retrieval + ^word <cw> +)
}

sp {comprehend-word*propose*smem-lexical-retrieval
    (state <s> ^current-word <cw> -^failed-retrieval true
          -^retrieved-lexical-item <r*1> ^segment <seg>
          ^name { << comprehend-word comprehend-construction >> <n*1> })
   -{ (<s> ^segment <s*1>)
      (<s*1> ^retry <r*3>)}
   -{ (<s> ^comprehension-structure <c*1>)
      (<c*1> ^retrieved-lexical-item <r*2>)}
   -{ (<seg> ^prior-word <p*1>)
      (<p*1> ^spelling *)
      (<cw> ^next <n*2>)
      (<n*2> ^spelling |.|)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-lexical-retrieval + ^word <cw> +)
}

sp {comprehension*prefer*failed-comprehension*over*process-phrase-end
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
    (<op2> ^name process-phrase-end)
    (<op1> ^name failed-comprehension)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {apply*process-new-word*clean-up
    (state <s> ^operator <op> ^smem <s*1>)
    (<op> ^name process-new-word ^word <cw>)
    (<s*1> ^command <cmd>)
    (<cmd> ^query <q>)
    -->
    (<cmd> ^query <q> -)
}

sp {apply*process-new-word*mark-on-segment
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name process-new-word ^spell <spell> ^handle <name>)
    (<seg> ^current-word <cw>)
    -->
    (<seg> ^unknown-word <spell> +)
}

sp {apply*process-new-word*failure*external
    (state <s> ^top-state <t*1> ^operator <op> ^segment <seg>)
    (<t*1> ^world-usage external)
    (<op> ^fail true ^name process-new-word ^spell <spell> ^handle <name>)
    (<seg> ^semantics <sem> ^original-sentence <cs> ^current-word <cw>)
    -->
    (<s> ^store-concept <nw> + ^store-concept <ref> +)
    (<nw> ^spelling <spell> + ^referent <ref> +)
    (<ref> ^handle <name> + ^word-structure <nw> +)
    (<cw> ^processed true +)
    (<sem> ^interaction-status <i*1> +)
    (<i*1> ^new-message <is> +)
    (<is> ^type unknown-word + ^word <spell> +)
    (<cs> ^processing-result failure +)
}

sp {apply*process-new-word*failure*internal
    (state <s> ^top-state <ts> ^operator <op> ^segment <seg>)
    (<ts> ^world-usage internal)
    (<op> ^fail true ^name process-new-word ^spell <spell> ^handle <name>)
    (<seg> ^semantics <sem> ^original-sentence <cs> ^current-word <cw>)
    -->
    (<s> ^store-concept <nw> + ^store-concept <ref> +)
    (<nw> ^spelling <spell> + ^referent <ref> +)
    (<ref> ^handle <name> + ^word-structure <nw> +)
    (<cw> ^processed true +)
    (<sem> ^interaction-status <i*1> +)
    (<i*1> ^new-message <is> +)
    (<is> ^type unknown-word + ^word <spell> +)
    (<cs> ^processing-result failure +)
}

sp {apply*process-new-word*assign*U
    (state <s> ^operator <op> ^comprehension-structure <cs> ^smem <s*1>)
    (<op> ^name process-new-word ^type U ^spell <spell> ^handle <name>)
    (<s*1> ^command <cmd>)
    -->
    (<cs> ^retrieved-lexical-item <nw> +)
    (<s> ^store-concept <nw> + ^store-concept <ref> + ^new-word true +
           ^retrieved-lexical-item <nw> +)
    (<nw> ^spelling <spell> + ^referent <ref> +)
    (<ref> ^handle <name> + ^word-structure <nw> +)
}

sp {apply*process-new-word*assign
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name process-new-word ^spell <spell> ^handle <name>
          ^type { <> U <st> })
    (<seg> ^semantics <sem> ^original-sentence <cs> ^current-word <cw>)
    -->
    (<s> ^store-concept <nw> + ^store-concept <ref> +)
    (<nw> ^spelling <spell> + ^referent <ref> +)
    (<ref> ^handle <name> + ^word-structure <nw> +)
    (<cw> ^processed true +)
    (<sem> ^interaction-status <i*1> +)
    (<i*1> ^new-message <is> +)
    (<is> ^type unknown-word + ^word <spell> +)
    (<cs> ^processing-result failure +)
}

sp {comprehend-word*compare*process-new-word*prefer-most-recent-unknown
    (state <s> ^name comprehend-word ^operator <op2> +
          ^operator { <> <op2> <op1> } +)
    (<op2> ^name process-new-word ^assigner <ass2>)
    (<ass2> ^structure-type U ^decision-count <d*1>)
    (<op1> ^name process-new-word ^assigner <ass1>)
    (<ass1> ^structure-type U ^decision-count { > <d*1> <n> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehend-word*reject*process-new-word*reject-failure-if-shallow-U
    (state <s> ^name comprehend-word ^operator <op1> + ^segment <seg>)
    (<op1> ^name process-new-word ^type U ^assigner <a*1>)
    (<a*1> ^parent-receiver <pr>)
    (<seg> ^not-merged-assigner <ass3>
          ^not-merged-assigner { <> <ass3> <ass2> } ^not-merged-receiver <nmr>)
    (<ass3> ^parent-receiver <pr> ^structure-type DP)
    (<ass2> ^structure-type N ^parent-receiver <nmr>)
    (<nmr> ^structure-type D)
    -->
    (<s> ^operator <op1> -)
}

sp {comprehend-word*reject*process-new-word*reject-failure-if-U
    (state <s> ^name comprehend-word ^operator <op2> + ^operator <op1> +
          ^segment <s*1>)
    (<op2> ^name process-new-word ^type U)
    (<op1> ^fail true ^name process-new-word)
    (<s*1> ^not-merged-assigner <n*1>)
    (<n*1> ^structure-type U)
    -->
    (<s> ^operator <op1> < <op2>)
}

sp {comprehend-word*propose*process-new-word*U
    (state <s> ^failed-retrieval true -^failed-new-word true
          ^name comprehend-word ^quiescence t ^segment <seg>)
    (<seg> ^not-merged-assigner <ass> ^current-word <cw>)
    (<ass> ^structure-type U)
    (<cw> ^spelling <spell>)
   -{ (<s> ^retrieved-lexical-item <r*1>)
      (<r*1> ^spelling <spell>)}
    -->
    (<s> ^operator <op> +)
    (<op> ^name process-new-word + ^type U + ^spell <spell> +
           ^handle (make-constant-symbol <spell>) +)
}

sp {comprehend-word*propose*process-new-word*single-primitive-assigner*guess
    (state <s> ^failed-retrieval true -^failed-new-word true
          ^name comprehend-word ^quiescence t ^segment <seg>
          ^current-word <cw>)
    (<seg> -^retry-sentence <r*2> ^not-merged-assigner <ass>)
   -{ (<seg> ^not-merged-assigner { <> <ass> <ass2> })
      (<ass2> ^structure-type { << V ADJ N ADV PN U >> <s*1> })}
    (<cw> ^spelling <spell>)
   -{ (<s> ^retrieved-lexical-item <r*1>)
      (<r*1> ^spelling <spell>)}
    (<ass> ^structure-type { << V ADJ N ADV PN >> <st> })
    -->
    (<s> ^operator <op> +)
    (<op> ^name process-new-word + ^type <st> + ^spell <spell> +
           ^handle (make-constant-symbol <spell>) +)
}

sp {comprehend-word*propose*process-new-word*multiple-non-U-primitive-assigner*fail
    (state <s> ^failed-retrieval true -^failed-new-word true
          ^name comprehend-word ^quiescence t ^segment <seg>)
   -{ (<seg> ^not-merged-assigner <n*1>)
      (<n*1> ^structure-type U)}
    (<seg> ^not-merged-assigner <ass2> ^not-merged-assigner { > <ass2> <ass> }
          ^current-word <cw>)
    (<cw> ^spelling <spell>)
   -{ (<s> ^retrieved-lexical-item <r*1>)
      (<r*1> ^spelling <spell>)}
    (<ass2> ^structure-type { << V ADJ N ADV PN >> <s*2> })
    (<ass> ^structure-type { << V ADJ N ADV PN >> <s*1> })
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name process-new-word + ^spell <spell> + ^fail true +
           ^handle (make-constant-symbol <spell>) +)
}

sp {comprehend-word*propose*process-new-word*no-primitive-assigner*unknown
    (state <s> ^failed-retrieval true -^failed-new-word true
          ^name comprehend-word ^quiescence t ^segment <seg>)
   -{ (<seg> ^not-merged-assigner <ass2>)
      (<ass2> ^structure-type { << V ADJ N ADV PN U >> <s*1> })}
    (<seg> ^current-word <c*1>)
    (<c*1> ^spelling <spell>)
   -{ (<s> ^retrieved-lexical-item <r*1>)
      (<r*1> ^spelling <spell>)}
    -->
    (<s> ^operator <op> +)
    (<op> ^name process-new-word + ^type U + ^fail true + ^spell <spell> +
           ^handle (make-constant-symbol <spell>) +)
}

sp {apply*finish-comprehend*construction
    (state <s> ^created-receiver true ^name comprehend-construction
          ^operator <op> ^prior-item <p-item> ^current-item <c-item>
          ^comprehension-structure <cs> ^segment <ss>)
    (<op> ^name finish-comprehend)
    (<cs> ^retrieved-lexical-item <cw>)
    -->
    (<ss> ^comprehension-structure <cs> + ^construction-comprehended <cc> +)
    (<cc> ^current-item <c-item> + ^prior-item <p-item> +)
    (<cs> ^processed true +)
    (<cw> ^processed true +)
}

sp {apply*finish-comprehend
    (state <s> ^created-receiver true ^name comprehend-word ^operator <op>
          ^comprehension-structure <cs> ^current-word <cw> ^segment <ss>)
    (<op> ^name finish-comprehend)
    -->
    (<ss> ^comprehension-structure <cs> +)
    (<cs> ^processed true +)
    (<cw> ^processed true +)
}

sp {comprehend-word*compare*finish-comprehend*better
    (state <s> ^name comprehend-word ^operator <op2> + ^operator <op1> +)
    (<op2>
          ^name { << smem-lexical-retrieval-cw-pw smem-lexical-retrieval-cw-pw-type >> <n*2> })
    (<op1> ^name { << return-receiver finish-comprehend >> <n*1> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehend-word*compare*finish-comprehend
    (state <s> ^operator <op1> +
          ^name { << comprehend-word comprehend-construction >> <n*1> }
          ^operator <op2> +)
    (<op1> ^name finish-comprehend)
    (<op2>
          ^name { << remove-stale-receiver process-new-word create-assigner create-receiver remove-stale-assigner >> <n*2> })
    -->
    (<s> ^operator <op1> < <op2>)
}

sp {comprehend-word*propose*finish-comprehend*new-word
    (state <s> ^new-word true
          ^name { << comprehend-word comprehend-construction >> <n*1> })
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> <)
    (<op> ^name finish-comprehend +)
}

sp {comprehend-word*propose*finish-comprehend*success
    (state <s> ^created-receiver true ^retrievals <m> ^created-assigners <n>
          ^name { << comprehend-word comprehend-construction >> <n*1> })
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> <)
    (<op> ^name finish-comprehend +)
}

sp {apply*create-receiver*create-item*finish*referent
    (state <s> ^operator <op> ^comprehension-structure <c*1>)
    (<op> ^name create-receiver ^item <item>)
    (<c*1> ^not-merged-receiver <item>)
    (<item> ^lt-referent <l*1>)
    -->
    (<s> ^receiver-created <item> +)
}

sp {apply*create-receiver*create-item*finish*no-referent
    (state <s> ^operator <op> ^comprehension-structure <c*1>)
    (<op> ^name create-receiver ^item <item>)
    (<c*1> ^not-merged-receiver <item>)
    (<item> ^lt <lt>)
    (<lt> -^referent <r*1>)
    -->
    (<s> ^receiver-created <item> +)
}

sp {apply*create-receiver*copy*first-word-true
    (state <s> ^current-word <c*1> -^name comprehend-construction
          ^operator <op>)
    (<c*1> ^first-word true)
    (<op> ^name create-receiver ^item <item>)
    -->
    (<item> ^first-word true +)
}

sp {apply*create-receiver*copy-constraint
    (state <s> ^comprehension-structure <c*1>
          ^name { << comprehend-word comprehend-construction >> <n*1> })
    (<c*1> ^not-merged-receiver <item>)
    (<item> ^lt <l*1>)
    (<l*1> ^constraint <stype>)
    -->
    (<item> ^constraint <stype> +)
}

sp {apply*create-receiver*copy-structure-type
    (state <s> ^comprehension-structure <c*1>
          ^name { << comprehend-word comprehend-construction >> <n*1> })
    (<c*1> ^not-merged-receiver <item>)
    (<item> ^lt <l*1>)
    (<l*1> ^structure-type <stype>)
    -->
    (<item> ^structure-type <stype> +)
}

sp {apply*create-receiver*create-item*construction*none
    (state <s> ^name comprehend-construction ^operator <op>
          ^retrieved-lexical-item <id> ^comprehension-structure <cs>
          ^current-word <cw>)
    (<op> ^name create-receiver ^item <item>)
    (<cs> ^remove-receiver <r*1>)
    (<r*1> ^decision-count <dc>)
   -{ (<cs> ^remove-receiver <r*2>)
      (<r*2> ^decision-count { < <dc> <d*1> })}
    -->
    (<s> ^created-receiver true +)
    (<cs> ^not-merged-receiver <item> +)
    (<item> ^current-word <cw> + ^lt <id> + ^decision-count <dc> +)
}

sp {apply*create-receiver*create-item*construction
    (state <s> ^name comprehend-construction ^comprehension-structure <cs>
          ^operator <op> ^retrieved-lexical-item <id> ^current-word <cw>)
    (<cs> -^remove-receiver <r*1>)
    (<op> ^name create-receiver ^item <item>)
    -->
    (<s> ^created-receiver true +)
    (<cs> ^not-merged-receiver <item> +)
    (<item> ^current-word <cw> + ^lt <id> +)
}

sp {apply*create-receiver*create-item*copy-lt*referent2*substructure
    (state <s> ^operator <op> ^comprehension-structure <c*1>)
    (<op> ^name create-receiver ^item <item>)
    (<c*1> ^not-merged-receiver <item>)
    (<item> ^lt-referent2 <ref2> ^lt <l*1>)
    (<l*1> ^referent2 <ref>)
    (<ref> ^<att> <value>)
    -->
    (<ref2> ^<att> <value> +)
}

sp {apply*create-receiver*create-item*copy-lt*referent*substructure
    (state <s> ^operator <op> ^comprehension-structure <c*1>)
    (<op> ^name create-receiver ^item <item>)
    (<c*1> ^not-merged-receiver <item>)
    (<item> ^lt-referent <ref2> ^lt <l*1>)
    (<l*1> ^referent <ref>)
    (<ref> ^<att> <value>)
    -->
    (<ref2> ^<att> <value> +)
}

sp {apply*create-receiver*create-item*copy-lt*referent2
    (state <s> ^operator <op> ^comprehension-structure <c*1>)
    (<op> ^name create-receiver ^item <item>)
    (<c*1> ^not-merged-receiver <item>)
    (<item> ^lt <l*1>)
    (<l*1> ^referent2 <ref>)
    -->
    (<item> ^lt-referent2 <nref> +)
}

sp {apply*create-receiver*create-item*copy-lt*referent
    (state <s> ^operator <op> ^comprehension-structure <c*1>)
    (<op> ^name create-receiver ^item <item>)
    (<c*1> ^not-merged-receiver <item>)
    (<item> ^lt <l*1>)
    (<l*1> ^referent <ref>)
    -->
    (<item> ^lt-referent <nref> +)
}

sp {apply*create-receiver*create-item*super-type*finish
    (state <s> ^operator <op> ^comprehension-structure <c*1>)
    (<op> ^name create-receiver ^item <item>)
    (<c*1> ^not-merged-receiver <item>)
    (<item> ^proto-lt <plt> ^super-type <st>)
    (<plt> ^copied yes)
    -->
    (<item> ^lt <plt> +)
}

sp {apply*create-receiver*create-item*super-type*copy-can-be-part-of
    (state <s> ^operator <op> ^retrieved-lexical-item <id>
          ^comprehension-structure <c*1>)
    (<op> ^name create-receiver ^item <item>)
    (<c*1> ^not-merged-receiver <item>)
    (<item> ^proto-lt <proto>)
    (<id>
          ^{ << attachment can-be-part-of constraint relation referent referent2 quantity semantic-structure semantic-structure2 directional directional-maybe alternative-structure number tense possessive specifier >> <att> } <cbpo>)
    -->
    (<proto> ^<att> <cbpo> +)
}

sp {apply*create-receiver*create-item*super-type*copy-lt
    (state <s> ^operator <op> ^comprehension-structure <c*1>)
    (<op> ^name create-receiver ^item <item>)
    (<c*1> ^not-merged-receiver <item>)
    (<item> ^proto-lt <plt> ^super-type <st>)
    (<st> ^<att> <val>)
    -->
    (<plt> ^<att> <val> + ^copied yes +)
}

sp {apply*create-receiver*create-item*super-type
    (state <s> ^retrieved-lexical-item <id> -^name comprehend-construction
          ^operator <op> ^comprehension-structure <cs> ^current-word <cw>)
    (<op> ^name create-receiver ^item <item>)
    (<id> ^super-type <st> ^spelling <spell>)
    -->
    (<s> ^created-receiver true +)
    (<cs> ^not-merged-receiver <item> +)
    (<item> ^current-word <cw> + ^original-id <id> + ^super-type <st> +
           ^proto-lt <proto-lt> + ^semantics <sem> +)
    (<proto-lt> ^spelling <spell> +)
}

sp {apply*create-receiver*mark-hypothetical
    (state <s> ^retrieved-lexical-item <id> ^operator <op> ^current-word <cw>
          ^segment <seg>)
    (<id> ^hypothetical true)
    (<op> ^name create-receiver ^item <item>)
    -->
    (<seg> ^hypothetical true +)
}

sp {apply*create-receiver*create-item
    (state <s> ^retrieved-lexical-item <id> -^name comprehend-construction
          ^operator <op> ^comprehension-structure <cs> ^current-word <cw>)
    (<id> -^super-type <s*1>)
    (<op> ^name create-receiver ^item <item>)
    -->
    (<s> ^created-receiver true +)
    (<cs> ^not-merged-receiver <item> +)
    (<item> ^current-word <cw> + ^lt <id> + ^semantics <sem> +)
}

sp {comprehend-word*compare*create-receiver2
    (state <s> ^operator <op1> +
          ^name { << comprehend-word comprehend-construction >> <n*1> }
          ^operator <op2> +)
    (<op1> ^name create-receiver)
    (<op2> ^name { << remove-stale-receiver >> <n*2> })
    -->
    (<s> ^operator <op1> < <op2>)
}

sp {comprehend-word*compare*elaborations
    (state <s> ^name comprehend-word ^operator <op2> + ^operator <op1> +)
    (<op2> ^name create-receiver)
    (<op1> ^feature super-type ^name retrieve-semantic-substructure)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehend-word*compare*create-receiver
    (state <s> ^operator <op2> + ^operator <op1> +
          ^name { << comprehend-word comprehend-construction >> <n*1> })
    (<op2> -^feature super-type ^name retrieve-semantic-substructure)
    (<op1> ^name create-receiver)
    -->
    (<s> ^operator <op1> < <op2>)
}

sp {comprehend-word*propose*create-receiver*alternative-structure
    (<ss> -^retry <r*1>)
    (state <s> ^quiescence t ^current-word <cw> ^retrieved-lexical-item <id>
          ^name { << comprehend-word comprehend-construction >> <n*1> })
   -{ (<s> ^receiver-created <uri> ^comprehension-structure <c*1>)
      (<uri> ^current-word <cw>)
      (<c*1> ^not-merged-receiver <uri>)}
    (<id> ^alternative-structure <a*1>)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name create-receiver + ^item <item> +)
}

sp {comprehend-word*propose*create-receiver
    (state <s> ^retrieved-lexical-item <id> ^current-word <cw>
          ^superstate <ss>
          ^name { << comprehend-word comprehend-construction >> <n*1> })
    (<id> -^alternative-structure <a*1>)
   -{ (<s> ^receiver-created <uri> ^comprehension-structure <c*1>)
      (<uri> ^current-word <cw>)
      (<c*1> ^not-merged-receiver <uri>)}
    (<ss> -^retry <r*1>)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name create-receiver + ^item <item> +)
}

sp {apply*create-assigner*create-item*use-old-time
    (state <s> ^name comprehend-construction ^operator <op>
          ^created-assigners <cax> ^comprehension-structure <cs>
          ^current-word <cw>)
    (<op> ^name create-assigner ^parent-receiver <r-item> ^lt <lt>)
    (<cs> ^remove-assigner <r*1>)
    (<r*1> ^decision-count <dc>)
   -{ (<cs> ^remove-assigner <r*2>)
      (<r*2> ^decision-count { < <dc> <d*1> })}
    (<lt> ^structure-type <stype>)
    -->
    (<s> ^created-assigners <cax> - ^created-assigners (+ 1 <cax>) +)
    (<cs> ^not-merged-assigner <new-assigner> +)
    (<new-assigner> ^current-word <cw> + ^lt <lt> +
           ^parent-receiver <r-item> + ^structure-type <stype> +
           ^decision-count <dc> +)
}

sp {apply*create-assigner*create-item*no-remove
    (state <s> ^name comprehend-construction ^comprehension-structure <cs>
          ^operator <op> ^created-assigners <cax> ^current-word <cw>)
    (<cs> -^remove-assigner <r*1>)
    (<op> ^name create-assigner ^parent-receiver <r-item> ^lt <lt>)
    (<lt> ^structure-type <stype>)
    -->
    (<s> ^created-assigners <cax> - ^created-assigners (+ 1 <cax>) +)
    (<cs> ^not-merged-assigner <new-assigner> +)
    (<new-assigner> ^current-word <cw> + ^lt <lt> +
           ^parent-receiver <r-item> + ^structure-type <stype> +)
}

sp {apply*create-assigner*create-item
    (state <s> ^created-assigners <cax> -^name comprehend-construction
          ^operator <op> ^comprehension-structure <cs> ^current-word <cw>)
    (<op> ^name create-assigner ^parent-receiver <r-item> ^lt <lt>)
    (<lt> ^structure-type <stype>)
    -->
    (<s> ^created-assigners <cax> - ^created-assigners (+ 1 <cax>) +)
    (<cs> ^not-merged-assigner <new-assigner> +)
    (<new-assigner> ^current-word <cw> + ^lt <lt> +
           ^parent-receiver <r-item> + ^structure-type <stype> +)
}

sp {comprehend-word*propose*create-assigner*super-type
    (state <s> ^retrieved-lexical-item <r*1> ^comprehension-structure <c*1>
          ^current-word <cw>
          ^name { << comprehend-word comprehend-construction >> <n*1> })
    (<r*1> ^super-type <super-t>)
    (<c*1> ^not-merged-receiver <r-item>)
    (<r-item> ^super-type <super-t> ^current-word <cw>)
    (<super-t> ^assigners <id>)
   -{ (<s> ^comprehension-structure <c*2>)
      (<c*2> ^not-merged-assigner <item>)
      (<item> ^parent-receiver <r-item> ^lt <id> ^current-word <cw>)}
    (<id> ^structure-type <stype>)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name create-assigner + ^lt <id> + ^parent-receiver <r-item> +)
}

sp {comprehend-word*propose*create-assigner
    (state <s> ^retrieved-lexical-item <a-lt> ^comprehension-structure <c*1>
          ^current-word <cw>
          ^name { << comprehend-word comprehend-construction >> <n*1> })
    (<a-lt> -^super-type <s*1> ^assigners <id>)
    (<c*1> ^not-merged-receiver <r-item>)
    (<r-item> ^lt <a-lt> ^current-word <cw>)
   -{ (<s> ^comprehension-structure <c*2>)
      (<c*2> ^not-merged-assigner <item>)
      (<item> ^parent-receiver <r-item> ^lt <id> ^current-word <cw>)}
    (<id> ^structure-type <stype>)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name create-assigner + ^lt <id> + ^parent-receiver <r-item> +)
}

sp {comprehend-word*expand-structure*retrieved-lexical-item
    (state <s> ^comprehension-structure <c*1>
          ^name { << comprehend-word comprehend-construction >> <n*1> })
    (<c*1> ^retrieved-lexical-item <x>)
    -->
    (<s> ^retrieved-lexical-item <x> +)
}

sp {comprehend-word*elaborate*substate2
    (state <s> ^name comprehend-word -^name comprehend-construction)
    -->
    (<s> ^comprehension-structure <cs> +)
    (<cs> ^type word +)
}

sp {comprehend-word*elaborate*substate
    (state <s> ^name comprehend-word -^name comprehend-construction
          ^superstate <s*1>)
    (<s*1> ^operator <so>)
    (<so> ^name comprehend-word ^current-word <cw>)
    -->
    (<s> ^current-word <cw> + ^created-assigners 0 + ^retrievals 0 +)
}

sp {comprehension*compare*comprehend-word
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
    (<op2> ^name process-phrase-end)
    (<op1> ^name comprehend-word)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {apply*comprehend-word*skip-*
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name comprehend-word)
    (<seg> ^current-word <cw>)
    (<cw> ^spelling *)
    -->
    (<seg> ^comprehension-structure <cs> +)
    (<cw> ^processed true +)
    (<cs> ^processed true +)
}

sp {comprehension*propose*comprehend-word*retry
    (state <s> ^name comprehension ^segment <s*1>)
    (<s*1> ^retry <retry>)
    (<retry> ^current-word <cw>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name comprehend-word + ^current-word <cw> + ^retry <retry> +)
}

sp {comprehension*propose*comprehend-word
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^current-word <cw>)
    (<cw> -^processed true)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name comprehend-word + ^current-word <cw> +)
}

sp {comprehend-word*apply*smem-construction-retrieval*failure-complete*ooth
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^failed-retrieval <fr> ^prior-item <p-item> ^current-item <c-item>
          ^comprehension-structure <cs> ^segment <seg>)
    (<fr> ^prior-word-first false ^current-word U ^prior-word U)
    (<p-item> -^structure-type <pick-type>)
    (<c-item> -^structure-type <up-type>)
    -->
    (<seg> ^comprehension-structure <cs> +)
    (<cs> ^processed true + ^failed true +)
}

sp {comprehend-word*apply*smem-construction-retrieval*failure-complete*unknown-prior
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^failed-retrieval <fr> ^prior-item <p-item> ^current-item <c-item>
          ^comprehension-structure <cs> ^segment <seg>)
    (<fr> ^prior-word-first false ^prior-word U ^current-word <up-type>)
    (<p-item> -^structure-type <s*1>)
    (<c-item> ^structure-type <up-type>)
    -->
    (<seg> ^comprehension-structure <cs> +)
    (<cs> ^processed true + ^failed true +)
}

sp {comprehend-word*apply*smem-construction-retrieval*failure-complete*unknown-current
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^failed-retrieval <fr> ^current-item <c-item> ^prior-item <p-item>
          ^comprehension-structure <cs> ^segment <seg>)
    (<fr> ^current-word U ^prior-word <pick-type>)
    (<c-item> -^structure-type <s*1>)
    (<p-item> ^structure-type <pick-type>)
    -->
    (<seg> ^comprehension-structure <cs> +)
    (<cs> ^processed true + ^failed true +)
}

sp {comprehend-word*apply*smem-construction-retrieval*failure-complete2
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^failed-retrieval <fr> ^prior-item <p-item> ^current-item <c-item>
          ^comprehension-structure <cs> ^segment <seg>)
    (<fr> ^prior-word-first true ^prior-word <pick-type>
          ^current-word <up-type>)
    (<p-item> ^current-word <c*1> ^structure-type <pick-type>)
    (<c*1> ^first-word true)
    (<c-item> ^structure-type <up-type>)
    -->
    (<seg> ^comprehension-structure <cs> +)
    (<cs> ^processed true + ^failed true +)
}

sp {comprehend-word*apply*smem-construction-retrieval*failure-complete
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^failed-retrieval <fr> ^prior-item <p-item> ^current-item <c-item>
          ^comprehension-structure <cs> ^segment <seg>)
    (<fr> ^prior-word-first false ^prior-word <pick-type>
          ^current-word <up-type>)
   -{ (<p-item> ^current-word <c*1>)
      (<c*1> ^first-word true)}
    (<p-item> ^structure-type <pick-type>)
    (<c-item> ^structure-type <up-type>)
    -->
    (<seg> ^comprehension-structure <cs> +)
    (<cs> ^processed true + ^failed true +)
}

sp {comprehend-word*apply*smem-construction-retrieval*fail
    (state <s> ^smem <smem> ^superstate <s*1> ^operator <o*1>)
    (<smem> ^result <r*1> ^command <cmd>)
    (<r*1> ^failure <t>)
    (<cmd> ^query <query>)
    (<o*1>
          ^name { << smem-construction-retrieval smem-lexical-retrieval-cw-pw smem-lexical-retrieval-cw-pw-type >> <opname> })
    (<s*1> ^operator <so>)
    -->
    (<s> ^failed-retrieval <query> + ^failed-operator <opname> +)
    (<cmd> ^query <query> - ^depth 9 -)
}

sp {comprehend-construction*apply*smem-construction-retrieval*success*words-from-constructions
    (state <s> ^operator <o> ^comprehension-structure <cs> ^smem <smem>)
    (<o> ^name smem-construction-retrieval ^words <words>)
    (<smem> ^result <r*1> ^command <c>)
    (<r*1> ^retrieved <rli>)
    (<rli> ^construction <sp>)
    (<c> ^query <q>)
    -->
    (<cs> ^words <words> +)
}

sp {comprehend-construction*apply*smem-construction-retrieval*success*construction
    (state <s> ^operator <o*1> ^comprehension-structure <cs> ^smem <smem>)
    (<o*1> ^name smem-construction-retrieval)
    (<smem> ^result <r*1> ^command <c>)
    (<r*1> ^retrieved <rli>)
    (<rli> ^construction <sp> ^current-word <up> ^prior-word <pick>)
    (<c> ^query <q>)
    (<q> ^current-word <up> ^prior-word <pick>)
    -->
    (<c> ^query <q> - ^depth 9 -)
    (<cs> ^retrieved-lexical-item <rli> + ^successful-query <q> +)
}

sp {comprehend-construction*apply*smem-construction-retrieval*success
    (state <s> ^operator <o*1> ^comprehension-structure <cs> ^smem <smem>)
    (<o*1> ^name smem-construction-retrieval)
    (<smem> ^result <r*1> ^command <c>)
    (<r*1> ^retrieved <rli>)
    (<rli> ^current-word <up> ^prior-word <pick> ^spelling <sp>)
    (<c> ^query <q>)
    (<q> ^current-word <up> ^prior-word <pick>)
    -->
    (<c> ^query <q> - ^depth 9 -)
    (<cs> ^retrieved-lexical-item <rli> + ^successful-query <q> +)
}

sp {comprehend-construction*apply*smem-construction-retrieval*receiver
    (state <s> ^operator <o> ^smem <s*1>)
    (<o> ^prior-word-first false ^name smem-construction-retrieval
          ^prior-structure <pick> ^current-structure <up>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^query <x> + ^depth 9 +)
    (<x> ^current-word <up> + ^prior-word <pick> + ^prior-word-first false +)
}

sp {comprehend-construction*apply*smem-construction-retrieval*receiver*first-word-true
    (state <s> ^operator <o> ^smem <s*1>)
    (<o> ^prior-word-first true ^name smem-construction-retrieval
          ^prior-structure <pick> ^current-structure <up>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^query <x> + ^depth 9 +)
    (<x> ^current-word <up> + ^prior-word <pick> + ^prior-word-first true +)
}

sp {comprehend-construction*compare*smem-construction-retrieval
    (state <s> ^name comprehend-construction ^operator <op2> +
          ^operator <op1> +)
    (<op2> ^name smem-construction-retrieval ^priority <p*1>)
    (<op1> ^name smem-construction-retrieval ^priority { < <p*1> <p> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehend-construction*propose*smem-construction-retrieval*structure-type-structure-type*both-unknown
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^prior-item <p-item> ^current-item <c-item>)
   -{ (<s> ^failed-retrieval <fr2>)
      (<fr2> ^prior-word-first false ^current-word U ^prior-word U)}
   -{ (<s> ^comprehension-structure <c*1>)
      (<c*1> ^retrieved-lexical-item <r*2>)}
   -{ (<p-item> ^current-word <c*2>)
      (<c*2> ^first-word true)}
    (<p-item> -^structure-type <s*2>)
    (<c-item> -^structure-type <s*1>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-construction-retrieval + ^current-structure U +
           ^prior-structure U + ^prior-word-first false + ^priority 8 +)
}

sp {comprehend-construction*propose*smem-construction-retrieval*structure-type-structure-type*current-unknown*missing
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^prior-item <p-item> ^current-item <c-item>)
   -{ (<s> ^comprehension-structure <c*1>)
      (<c*1> ^retrieved-lexical-item <r*2>)}
   -{ (<p-item> ^current-word <c*2>)
      (<c*2> ^first-word true)}
    (<c-item> -^structure-type <s*1>)
    (<p-item> ^structure-type <pick-type>)
   -{ (<s> ^failed-retrieval <fr2>)
      (<fr2> ^prior-word-first false ^current-word U ^prior-word <pick-type>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-construction-retrieval + ^current-structure U +
           ^prior-structure <pick-type> + ^prior-word-first false +
           ^priority 8 +)
}

sp {comprehend-construction*propose*smem-construction-retrieval*structure-type-structure-type*current-unknown
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^prior-item <p-item> ^current-item <c-item>)
   -{ (<s> ^comprehension-structure <c*1>)
      (<c*1> ^retrieved-lexical-item <r*2>)}
   -{ (<p-item> ^current-word <c*2>)
      (<c*2> ^first-word true)}
    (<c-item> ^structure-type U)
    (<p-item> ^structure-type <pick-type>)
   -{ (<s> ^failed-retrieval <fr2>)
      (<fr2> ^prior-word-first false ^current-word U ^prior-word <pick-type>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-construction-retrieval + ^current-structure U +
           ^prior-structure <pick-type> + ^prior-word-first false +
           ^priority 8 +)
}

sp {comprehend-construction*propose*smem-construction-retrieval*structure-type-structure-type*prior-unknown
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^prior-item <p-item> ^current-item <c-item>)
   -{ (<s> ^comprehension-structure <c*1>)
      (<c*1> ^retrieved-lexical-item <r*2>)}
   -{ (<p-item> ^current-word <c*2>)
      (<c*2> ^first-word true)}
    (<p-item> -^structure-type <s*1>)
    (<c-item> ^structure-type <up-type>)
   -{ (<s> ^failed-retrieval <fr2>)
      (<fr2> ^prior-word-first false ^current-word <up-type> ^prior-word U)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-construction-retrieval + ^current-structure <up-type> +
           ^prior-structure U + ^prior-word-first false + ^priority 8 +)
}

sp {comprehend-construction*propose*smem-construction-retrieval*structure-type-structure-type
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^prior-item <p-item> ^current-item <c-item>)
   -{ (<s> ^comprehension-structure <c*1>)
      (<c*1> ^retrieved-lexical-item <r*2>)}
   -{ (<p-item> ^current-word <c*2>)
      (<c*2> ^first-word true)}
    (<p-item> ^structure-type <pick-type>)
    (<c-item> ^structure-type <up-type>)
   -{ (<s> ^failed-retrieval <fr2>)
      (<fr2> ^prior-word-first false ^current-word <up-type>
            ^prior-word <pick-type>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-construction-retrieval + ^current-structure <up-type> +
           ^prior-structure <pick-type> + ^prior-word-first false +
           ^priority 8 +)
}

sp {comprehend-construction*propose*smem-construction-retrieval*structure-type-structure-type*prior-word-first*both-Unknown
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^prior-item <p-item> ^current-item <c-item>)
   -{ (<s> ^failed-retrieval <fr2>)
      (<fr2> ^prior-word-first true ^current-word U ^prior-word U)}
   -{ (<s> ^comprehension-structure <c*1>)
      (<c*1> ^retrieved-lexical-item <r*2>)}
    (<p-item> -^structure-type <s*2> ^current-word <c*2>)
    (<c-item> -^structure-type <s*1>)
    (<c*2> ^first-word true)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-construction-retrieval + ^current-structure U +
           ^prior-structure U + ^prior-word-first true + ^priority 7 +)
}

sp {comprehend-construction*propose*smem-construction-retrieval*structure-type-structure-type*prior-word-first*current-Unknown
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^current-item <c-item> ^prior-item <p-item>)
   -{ (<s> ^comprehension-structure <c*1>)
      (<c*1> ^retrieved-lexical-item <r*2>)}
    (<c-item> -^structure-type <s*1>)
    (<p-item> ^current-word <c*2> ^structure-type <pick-type>)
    (<c*2> ^first-word true)
   -{ (<s> ^failed-retrieval <fr2>)
      (<fr2> ^prior-word-first true ^current-word U ^prior-word <pick-type>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-construction-retrieval + ^current-structure U +
           ^prior-structure <pick-type> + ^prior-word-first true +
           ^priority 7 +)
}

sp {comprehend-construction*propose*smem-construction-retrieval*structure-type-structure-type*prior-word-first*unknown*prior
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^prior-item <p-item> ^current-item <c-item>)
   -{ (<s> ^comprehension-structure <c*1>)
      (<c*1> ^retrieved-lexical-item <r*2>)}
    (<p-item> -^structure-type <s*1> ^current-word <c*2>)
    (<c*2> ^first-word true)
    (<c-item> ^structure-type <up-type>)
   -{ (<s> ^failed-retrieval <fr2>)
      (<fr2> ^prior-word-first true ^current-word <up-type> ^prior-word U)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-construction-retrieval + ^current-structure <up-type> +
           ^prior-structure U + ^prior-word-first true + ^priority 7 +)
}

sp {comprehend-construction*propose*smem-construction-retrieval*structure-type-structure-type*prior-word-first
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^prior-item <p-item> ^current-item <c-item>)
   -{ (<s> ^comprehension-structure <c*1>)
      (<c*1> ^retrieved-lexical-item <r*2>)}
    (<p-item> ^current-word <c*2> ^structure-type <pick-type>)
    (<c*2> ^first-word true)
    (<c-item> ^structure-type <up-type>)
   -{ (<s> ^failed-retrieval <fr2>)
      (<fr2> ^prior-word-first true ^current-word <up-type>
            ^prior-word <pick-type>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-construction-retrieval + ^current-structure <up-type> +
           ^prior-structure <pick-type> + ^prior-word-first true +
           ^priority 7 +)
}

sp {comprehend-construction*propose*smem-construction-retrieval*structure-type-word*unknown
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^prior-item <p-item> ^current-item <c-item> ^segment <s*1>)
   -{ (<s> ^comprehension-structure <c*1>)
      (<c*1> ^retrieved-lexical-item <r*2>)}
   -{ (<p-item> ^current-word <c*2>)
      (<c*2> ^first-word true)}
    (<c-item> -^structure-type <s*2>)
    (<p-item> ^lt <lli>)
    (<lli> ^spelling <pick-word>)
   -{ (<s> ^failed-retrieval <fr2>)
      (<fr2> ^prior-word-first false ^current-word U ^prior-word <pick-word>)}
    (<s*1> ^retrieved-stack <rs>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-construction-retrieval + ^current-structure U +
           ^prior-structure <pick-word> + ^prior-word-first false +
           ^words prior-word + ^priority 6 +)
}

sp {comprehend-construction*propose*smem-construction-retrieval*structure-type-word
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^prior-item <p-item> ^current-item <c-item> ^segment <s*1>)
   -{ (<s> ^comprehension-structure <c*1>)
      (<c*1> ^retrieved-lexical-item <r*2>)}
   -{ (<p-item> ^current-word <c*2>)
      (<c*2> ^first-word true)}
    (<p-item> ^lt <lli>)
    (<c-item> ^structure-type <up-type>)
    (<lli> ^spelling <pick-word>)
   -{ (<s> ^failed-retrieval <fr2>)
      (<fr2> ^prior-word-first false ^current-word <up-type>
            ^prior-word <pick-word>)}
    (<s*1> ^retrieved-stack <rs>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-construction-retrieval + ^current-structure <up-type> +
           ^prior-structure <pick-word> + ^prior-word-first false +
           ^words prior-word + ^priority 6 +)
}

sp {comprehend-construction*propose*smem-construction-retrieval*structure-type-word*first*unknown
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^current-item <c-item> ^prior-item <p-item> ^segment <s*1>)
   -{ (<s> ^comprehension-structure <c*1>)
      (<c*1> ^retrieved-lexical-item <r*2>)}
    (<c-item> -^structure-type <s*2>)
    (<p-item> ^current-word <c*2> ^lt <lli>)
    (<c*2> ^first-word true)
    (<lli> ^spelling <pick-word>)
   -{ (<s> ^failed-retrieval <fr2>)
      (<fr2> ^prior-word-first true ^current-word U ^prior-word <pick-word>)}
    (<s*1> ^retrieved-stack <rs>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-construction-retrieval + ^current-structure U +
           ^prior-structure <pick-word> + ^prior-word-first true +
           ^words prior-word + ^priority 5 +)
}

sp {comprehend-construction*propose*smem-construction-retrieval*structure-type-word*first
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^prior-item <p-item> ^current-item <c-item> ^segment <s*1>)
   -{ (<s> ^comprehension-structure <c*1>)
      (<c*1> ^retrieved-lexical-item <r*2>)}
    (<p-item> ^current-word <c*2> ^lt <lli>)
    (<c*2> ^first-word true)
    (<c-item> ^structure-type <up-type>)
    (<lli> ^spelling <pick-word>)
   -{ (<s> ^failed-retrieval <fr2>)
      (<fr2> ^prior-word-first true ^current-word <up-type>
            ^prior-word <pick-word>)}
    (<s*1> ^retrieved-stack <rs>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-construction-retrieval + ^current-structure <up-type> +
           ^prior-structure <pick-word> + ^prior-word-first true +
           ^words prior-word + ^priority 5 +)
}

sp {comprehend-construction*propose*smem-construction-retrieval*structure-word-not-phrase*unknown
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^prior-item <p-item> ^current-item <c-item> ^segment <s*1>)
   -{ (<s> ^comprehension-structure <c*1>)
      (<c*1> ^retrieved-lexical-item <r*2>)}
   -{ (<p-item> ^current-word <c*3>)
      (<c*3> ^first-word true)}
    (<p-item> -^structure-type <s*2>)
   -{ (<p-item> ^lt <l*1>)
      (<l*1> ^converts-to <c*2>)}
    (<c-item> ^lt <lli>)
    (<lli> ^spelling <up-word>)
   -{ (<s> ^failed-retrieval <fr2>)
      (<fr2> ^prior-word-first false ^current-word <up-word> ^prior-word U)}
    (<s*1> ^retrieved-stack <rs>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-construction-retrieval + ^current-structure <up-word> +
           ^prior-structure U + ^words current-word +
           ^prior-word-first false + ^priority 4 +)
}

sp {comprehend-construction*propose*smem-construction-retrieval*structure-word-not-phrase
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^prior-item <p-item> ^current-item <c-item> ^segment <s*1>)
   -{ (<s> ^comprehension-structure <c*1>)
      (<c*1> ^retrieved-lexical-item <r*2>)}
   -{ (<p-item> ^current-word <c*3>)
      (<c*3> ^first-word true)}
   -{ (<p-item> ^lt <l*1>)
      (<l*1> ^converts-to <c*2>)}
    (<c-item> ^lt <lli>)
    (<p-item> ^structure-type <pick-type>)
    (<lli> ^spelling <up-word>)
   -{ (<s> ^failed-retrieval <fr2>)
      (<fr2> ^prior-word-first false ^current-word <up-word>
            ^prior-word <pick-type>)}
    (<s*1> ^retrieved-stack <rs>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-construction-retrieval + ^current-structure <up-word> +
           ^prior-structure <pick-type> + ^words current-word +
           ^prior-word-first false + ^priority 4 +)
}

sp {comprehend-construction*propose*smem-construction-retrieval*structure-word-not-phrase*first-word*unknown-type
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^prior-item <p-item> ^current-item <c-item> ^segment <s*1>)
   -{ (<s> ^comprehension-structure <c*1>)
      (<c*1> ^retrieved-lexical-item <r*2>)}
    (<p-item> -^structure-type <s*2> ^current-word <c*3>)
   -{ (<p-item> ^lt <l*1>)
      (<l*1> ^converts-to <c*2>)}
    (<c*3> ^first-word true)
    (<c-item> ^lt <lli>)
    (<lli> ^spelling <up-word>)
   -{ (<s> ^failed-retrieval <fr2>)
      (<fr2> ^prior-word-first true ^current-word <up-word> ^prior-word U)}
    (<s*1> ^retrieved-stack <rs>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-construction-retrieval + ^current-structure <up-word> +
           ^prior-structure U + ^words current-word + ^prior-word-first true +
           ^priority 3 +)
}

sp {comprehend-construction*propose*smem-construction-retrieval*structure-word-not-phrase*first-word
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^prior-item <p-item> ^current-item <c-item> ^segment <s*1>)
   -{ (<s> ^comprehension-structure <c*1>)
      (<c*1> ^retrieved-lexical-item <r*2>)}
   -{ (<p-item> ^lt <l*1>)
      (<l*1> ^converts-to <c*2>)}
    (<p-item> ^current-word <c*3> ^structure-type <pick-type>)
    (<c*3> ^first-word true)
    (<c-item> ^lt <lli>)
    (<lli> ^spelling <up-word>)
   -{ (<s> ^failed-retrieval <fr2>)
      (<fr2> ^prior-word-first true ^current-word <up-word>
            ^prior-word <pick-type>)}
    (<s*1> ^retrieved-stack <rs>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-construction-retrieval + ^current-structure <up-word> +
           ^prior-structure <pick-type> + ^words current-word +
           ^prior-word-first true + ^priority 3 +)
}

sp {comprehend-construction*propose*smem-construction-retrieval*structure-word-phrase
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^prior-item <p-item> ^current-item <c-item> ^segment <s*1>)
   -{ (<s> ^comprehension-structure <c*1>)
      (<c*1> ^retrieved-lexical-item <r*2>)}
   -{ (<p-item> ^current-word <c*2>)
      (<c*2> ^first-word true)}
    (<p-item> ^lt <l*1> ^structure-type <pick-type>)
    (<l*1> ^converts-to <pick-type>)
    (<c-item> ^lt <lli>)
    (<lli> ^spelling <up-word>)
   -{ (<s> ^failed-retrieval <fr2>)
      (<fr2> ^prior-word-first false ^current-word <up-word>
            ^prior-word <pick-type>)}
    (<s*1> ^retrieved-stack <rs>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-construction-retrieval + ^current-structure <up-word> +
           ^prior-structure <pick-type> + ^words current-word +
           ^prior-word-first false + ^priority 2 +)
}

sp {comprehend-construction*propose*smem-construction-retrieval*structure-word-phrase*first-word
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^prior-item <p-item> ^current-item <c-item> ^segment <s*1>)
   -{ (<s> ^comprehension-structure <c*1>)
      (<c*1> ^retrieved-lexical-item <r*2>)}
    (<p-item> ^current-word <c*2> ^lt <l*1> ^structure-type <pick-type>)
    (<c*2> ^first-word true)
    (<l*1> ^converts-to <pick-type>)
    (<c-item> ^lt <lli>)
    (<lli> ^spelling <up-word>)
   -{ (<s> ^failed-retrieval <fr2>)
      (<fr2> ^prior-word-first true ^current-word <up-word>
            ^prior-word <pick-type>)}
    (<s*1> ^retrieved-stack <rs>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-construction-retrieval + ^current-structure <up-word> +
           ^prior-structure <pick-type> + ^words current-word +
           ^prior-word-first true + ^priority 1 +)
}

sp {apply*remove-stale-receiver
    (state <s> ^operator <o> ^comprehension-structure <cs>)
    (<o> ^name remove-stale-receiver ^stale-receiver <uri1>)
    (<uri1> ^current-word <c*1> ^structure-type <st>)
    (<c*1> ^spelling <pw>)
    -->
    (<cs> ^remove-receiver <uri1> +)
}

sp {comprehend-construction*propose*remove-stale-receiver-second-most-recent
    (state <s> ^name comprehend-construction ^comprehension-structure <c*1>
          ^segment <seg>)
    (<c*1> ^words prior-word)
    (<seg> ^not-merged-receiver <uri1> ^retrieved-stack <r*1>)
   -{ (<s> ^comprehension-structure <c*2>)
      (<c*2> ^remove-receiver <uri1>)}
    (<r*1> ^prior <p*1>)
    (<p*1> ^item <uri1>)
    (<uri1> ^lt <l*1> ^structure-type <type>)
    (<l*1> ^spelling <spelling>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> <)
    (<op> ^name remove-stale-receiver + ^stale-receiver <uri1> +)
}

sp {comprehend-construction*propose*remove-stale-receiver-most-recent
    (state <s> ^name comprehend-construction ^comprehension-structure <c*1>
          ^segment <seg>)
    (<c*1> ^words current-word)
    (<seg> ^not-merged-receiver <uri1> ^retrieved-stack <r*1>)
   -{ (<s> ^comprehension-structure <c*2>)
      (<c*2> ^remove-receiver <uri1>)}
    (<r*1> ^item <uri1>)
    (<uri1> ^lt <l*1> ^structure-type <type>)
    (<l*1> ^spelling <spelling>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> <)
    (<op> ^name remove-stale-receiver + ^stale-receiver <uri1> +)
}

sp {apply*remove-stale-assigner
    (state <s> ^operator <op> ^comprehension-structure <cs> ^segment <seg>)
    (<op> ^name remove-stale-assigner ^assigner <uai> ^word <pw>)
    (<seg> ^not-merged-assigner <uai>)
    (<uai> ^structure-type <st>)
    -->
    (<cs> ^remove-assigner <uai> +)
}

sp {comprehend-construction*propose*remove-stale-assigner2
    (state <s> ^name comprehend-construction ^comprehension-structure <c*1>
          ^segment <seg>)
    (<c*1> ^words prior-word)
    (<seg> ^not-merged-assigner <uai> ^retrieved-stack <r*1>)
   -{ (<s> ^comprehension-structure <c*2>)
      (<c*2> ^remove-assigner <uai>)}
    (<r*1> ^prior <p*1>)
    (<uai> ^parent-receiver <pr>)
    (<pr> ^structure-type <pst> ^spelling <pw>)
    (<p*1> ^item <i*1>)
    (<i*1> ^current-word <c*3>)
    (<c*3> ^spelling <pw>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> <)
    (<op> ^name remove-stale-assigner + ^assigner <uai> + ^word <pw> +)
}

sp {comprehend-construction*propose*remove-stale-assigner
    (state <s> ^name comprehend-construction ^comprehension-structure <c*1>
          ^segment <seg>)
    (<c*1> ^words current-word)
    (<seg> ^not-merged-assigner <uai> ^retrieved-stack <r*1>)
   -{ (<s> ^comprehension-structure <c*2>)
      (<c*2> ^remove-assigner <uai>)}
    (<uai> ^parent-receiver <pr>)
    (<pr> ^structure-type <pst> ^spelling <pw>)
    (<r*1> ^item <i*1>)
    (<i*1> ^current-word <c*3>)
    (<c*3> ^spelling <pw>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> <)
    (<op> ^name remove-stale-assigner + ^assigner <uai> + ^word <pw> +)
}

sp {comprehend-construction*current-word
    (state <s> ^name comprehend-construction ^comprehension-structure <c*1>)
    (<c*1> ^retrieved-lexical-item <x>)
    -->
    (<s> ^current-word <x> +)
}

sp {comprehend-construction*elaborate*substate2
    (state <s> ^name comprehend-construction)
    -->
    (<s> ^comprehension-structure <cs> +)
    (<cs> ^type construction +)
}

sp {comprehend-construction*elaborate*substate
    (state <s> ^name comprehend-construction ^superstate <s*1>)
    (<s*1> ^operator <so>)
    (<so> ^name comprehend-construction ^prior-item <p-item>
          ^current-item <c-item>)
    -->
    (<s> ^current-item <c-item> + ^prior-item <p-item> +
           ^created-assigners 0 + ^retrievals 0 +)
}

sp {comprehension*compare*comprehend-construction*process-phrase-end
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name comprehend-construction)
    (<op2> ^name { << process-phrase-end >> <n*1> })
    -->
    (<s> ^operator <op1> < <op2>)
}

sp {comprehension*compare*comprehend-construction*process-semantics
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name comprehend-construction)
    (<op2> ^name { << process-semantics >> <n*1> })
    -->
    (<s> ^operator <op1> < <op2>)
}

sp {comprehension*compare*merge*comprehend-construction*diff*pi
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name merge ^receiver <pi>)
    (<op2> -^prior-item <pi> ^name { << comprehend-construction >> <n*1> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*merge*comprehend-construction*prefer-merge-to-terminal
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
    (<op2> ^name comprehend-construction ^current-item <c*1>)
    (<c*1> ^structure-type T)
    (<op1> ^name merge)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*merge*comprehend-construction3
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name merge ^assigner <a*1> ^receiver <pi>)
    (<a*1> ^lt <l*1>)
    (<l*1> ^delay-merge true)
    (<op2> ^prior-item <pi> ^current-item <c*1>
          ^name { << comprehend-construction >> <n*1> })
    (<c*1> ^lt <l*2>)
    (<l*2> ^delay-retry true)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*merge*comprehend-construction2
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
   -{ (<op2> ^current-item <c*1>)
      (<c*1> ^lt <l*2>)
      (<l*2> ^delay-retry true)}
    (<op1> ^name merge ^receiver <pi> ^assigner <a*1>)
    (<op2> ^prior-item <pi> ^name { << comprehend-construction >> <n*1> })
    (<a*1> ^lt <l*1>)
    (<l*1> ^delay-merge true)
    -->
    (<s> ^operator <op1> -)
}

sp {comprehension*compare*merge*comprehend-construction
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
   -{ (<s> ^operator <op3> +)
      (<op3> ^name merge ^assigner <a*1>)
      (<a*1> ^lt <l*1>)
      (<l*1> ^delay-merge true)}
   -{ (<op1> ^assigner <a*2>)
      (<a*2> ^lt <l*2>)
      (<l*2> ^delay-merge true)}
    (<op1> ^name merge ^receiver <pi>)
    (<op2> ^prior-item <pi> ^name { << comprehend-construction >> <n*1> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*merge*comprehend-construction*avoid-tie
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
    (<op2> ^name comprehend-construction ^prior-item <pi>)
    (<op1> ^name merge ^receiver <pi>)
    -->
    (<s> ^operator <op1> = <op2>)
}

sp {comprehension*compare*merge*comprehend-word*comprehend-completion
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name merge)
    (<op2> ^name { << comprehend-completion >> <n*1> })
    -->
    (<s> ^operator <op1> < <op2>)
}

sp {comprehension*compare*comprehend-construction
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
    (<op2> ^name next-word)
    (<op1> ^name comprehend-construction)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*propose*comprehend-construction*failed-merge
    (state <s> ^name comprehension ^segment <seg>)
   -{ (<seg> ^comprehension-structure <cs>)
      (<cs> ^processed true ^type construction)}
    (<seg> -^failed-construction true ^not-merged-assigner <ass>
          ^current-word <c*1> ^retrieved-stack <rs>
          ^not-merged-receiver <c-item> ^not-merged-receiver <p-item>)
   -{ (<seg> ^current-word <c*2>)
      (<c*2> ^comprehend-completed true)}
    (<ass> ^failed merge)
    (<c*1> ^processed true)
    (<rs> ^item <c-item> ^prior <p*1>)
    (<p*1> ^item <p-item>)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name comprehend-construction + ^failed-assigner <ass> +
           ^current-item <c-item> + ^prior-item <p-item> +)
}

sp {comprehension*propose*comprehend-construction2*unknown
    (state <s> ^name comprehension ^segment <seg>)
   -{ (<seg> ^comprehension-structure <cs>)
      (<cs> ^processed true ^type construction)}
   -{ (<seg> ^not-merged-assigner <n*1>)
      (<n*1> ^structure-type U)}
    (<seg> -^failed-construction true ^not-merged-receiver <c-item>
          ^retrieved-stack <rs> ^current-word <c*1>
          ^not-merged-receiver { <> nil <p-item> })
   -{ (<seg> ^current-word <c*2>)
      (<c*2> ^comprehend-completed true)}
   -{ (<c-item> ^lt <l*2>)
      (<l*2> ^structure CP)}
    (<c-item> -^structure-type <s*1> ^lt <l*1>)
    (<rs> ^item <c-item> ^prior <p*1>)
    (<c*1> ^processed true)
    (<p*1> ^item <p-item>)
    (<l*1> ^converts-to { <> CP <dp> })
   -{ (<seg> ^not-merged-assigner <n*2>)
      (<n*2> ^structure-type <dp>)}
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name comprehend-construction + ^current-item <c-item> +
           ^prior-item <p-item> +)
}

sp {comprehension*propose*comprehend-construction2
    (state <s> ^name comprehension ^segment <seg>)
   -{ (<seg> ^comprehension-structure <cs>)
      (<cs> ^processed true ^type construction)}
    (<seg> -^failed-construction true ^not-merged-receiver <c-item>
          ^retrieved-stack <rs> ^current-word <c*1>
          ^not-merged-receiver { <> nil <p-item> })
   -{ (<seg> ^current-word <c*2>)
      (<c*2> ^comprehend-completed true)}
   -{ (<c-item> ^lt <l*2>)
      (<l*2> ^structure CP)}
    (<rs> ^item <c-item> ^prior <p*1>)
    (<c*1> ^processed true)
    (<c-item> ^structure-type <p> ^lt <l*1>)
   -{ (<seg> ^not-merged-assigner <n*1>)
      (<n*1> ^structure-type <p>)}
    (<p*1> ^item <p-item>)
    (<l*1> ^converts-to { <> CP <dp> })
   -{ (<seg> ^not-merged-assigner <n*2>)
      (<n*2> ^structure-type <dp>)}
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name comprehend-construction + ^current-item <c-item> +
           ^prior-item <p-item> +)
}

sp {comprehension*propose*comprehend-construction*unknown
    (state <s> ^name comprehension ^segment <seg>)
   -{ (<seg> ^comprehension-structure <cs>)
      (<cs> ^processed true ^type construction)}
   -{ (<seg> ^not-merged-assigner <n*1>)
      (<n*1> ^structure-type U)}
    (<seg> -^failed-construction true ^not-merged-receiver <c-item>
          ^retrieved-stack <rs> ^current-word <c*1>
          ^not-merged-receiver { <> nil <p-item> })
   -{ (<seg> ^current-word <c*2>)
      (<c*2> ^comprehend-completed true)}
   -{ (<c-item> ^lt <l*2>)
      (<l*2> ^structure CP)}
   -{ (<c-item> ^lt <l*1>)
      (<l*1> ^converts-to <c*3>)}
    (<c-item> -^structure-type <s*1>)
    (<rs> ^item <c-item> ^prior <p*1>)
    (<c*1> ^processed true)
    (<p*1> ^item <p-item>)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name comprehend-construction + ^current-item <c-item> +
           ^prior-item <p-item> +)
}

sp {comprehension*propose*comprehend-construction*after-success-assigner
    (state <s> ^name comprehension ^segment <seg>)
   -{ (<seg> ^comprehension-structure <cs>)
      (<cs> ^processed true ^type construction)}
    (<seg> -^failed-construction true ^not-merged-receiver <c-item>
          ^retrieved-stack <rs> ^not-merged-receiver { <> nil <p-item> }
          ^current-word <c*1>)
   -{ (<seg> ^current-word <c*2>)
      (<c*2> ^comprehend-completed true)}
   -{ (<c-item> ^lt <l*2>)
      (<l*2> ^structure CP)}
   -{ (<c-item> ^lt <l*1> -^structure-type <dp>)
      (<l*1> ^converts-to <dp>)}
    (<rs> ^item <c-item> ^prior <p*1>)
   -{ (<seg> ^construction-comprehended <cc>)
      (<cc> ^prior-item <p-item> ^current-item <c-item>)}
    (<p*1> ^item <p-item>)
    (<c*1> ^processed true)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name comprehend-construction + ^current-item <c-item> +
           ^prior-item <p-item> +)
}

sp {apply*comprehend-completion*failed-without-stack
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name comprehend-completion)
    (<seg> ^comprehension-structure <c*1> ^retrieved-stack <rs>)
    (<c*1> ^failed true)
    (<rs> ^prior <p>)
    (<p> ^prior nil)
    -->
    (<seg> ^failed-construction true +)
}

sp {apply*comprehend-completion*failed-with-stack
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name comprehend-completion)
    (<seg> ^comprehension-structure <c*1> ^retrieved-stack <rs>)
    (<c*1> ^failed true)
    (<rs> ^prior <p>)
    (<p> ^prior { <> nil <p2> })
    -->
    (<rs> ^prior <p> - ^prior <p2> +)
}

sp {apply*comprehend-completion*stale-receiver-prior-word
    (state <s> ^quiescence t ^operator <o*1> ^segment <ss>)
    (<o*1> ^name comprehend-completion)
    (<ss> ^comprehension-structure <cs> ^retrieved-stack <rc>)
    (<cs> ^words prior-word ^remove-receiver <item>)
    (<rc> ^prior <prior>)
    (<prior> ^item <item> ^prior <prior2>)
    -->
    (<rc> ^prior <prior> - ^prior <prior2> +)
}

sp {apply*comprehend-completion*create-receiver*push-retrieved-stack*skip2*stale-receiver
    (state <s> ^quiescence t ^operator <o*1> ^segment <ss>)
    (<o*1> ^name comprehend-completion)
    (<ss> ^retrieved-stack <rc> ^comprehension-structure <cs>)
    (<rc> ^prior <prior> ^item <rr>)
    (<prior> ^prior <prior2> ^item <rr2>)
    (<cs> ^remove-receiver <rr2> ^remove-receiver <rr>
          ^not-merged-receiver { <> <rr> <item> })
    -->
    (<ss> ^retrieved-stack <rc> - ^retrieved-stack <nrc> +)
    (<nrc> ^item <item> + ^prior <prior2> +)
}

sp {apply*comprehend-completion*save-most-recent-alternative-structure
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name comprehend-completion)
    (<seg> ^comprehension-structure <c*1>)
    (<c*1> ^not-merged-receiver <nmr>)
    (<nmr> ^lt <l*1>)
    (<l*1> ^alternative-structure <a*1>)
    -->
    (<seg> ^alternative-structure-receiver <nmr> +)
}

sp {apply*comprehend-completion*create-receiver*push-retrieved-stack*skip1*stale-receiver
    (state <s> ^quiescence t ^operator <o*1> ^segment <ss>)
    (<o*1> ^name comprehend-completion)
    (<ss> ^retrieved-stack <rc> ^comprehension-structure <cs>)
    (<rc> ^prior <prior> ^item <rr>)
    (<cs> ^remove-receiver <rr> -^remove-receiver <rr2>
          ^not-merged-receiver { <> <rr> <item> })
    (<prior> ^item <rr2>)
    -->
    (<rc> ^item <rr> - ^item <item> +)
}

sp {apply*comprehend-completion*create-receiver*push-retrieved-stack*replace*stale-receiver
    (state <s> ^quiescence t ^operator <o*1> ^segment <ss>)
    (<o*1> ^name comprehend-completion)
    (<ss> ^retrieved-stack <rc> ^comprehension-structure <cs>)
    (<rc> ^prior nil ^item <rr>)
    (<cs> ^type word ^remove-receiver <rr>
          ^not-merged-receiver { <> <rr> <item> })
    -->
    (<rc> ^item <rr> - ^item <item> +)
}

sp {apply*comprehend-completion*create-receiver*push-retrieved-stack*noskip
    (state <s> ^quiescence t ^operator <o*1> ^segment <ss>)
    (<o*1> ^name comprehend-completion)
    (<ss> ^comprehension-structure <cs> ^retrieved-stack <rc>)
    (<cs> ^type word -^remove-receiver <rr>
          ^not-merged-receiver { <> <rr> <item> })
    (<rc> ^item <rr>)
    -->
    (<ss> ^retrieved-stack <rc> - ^retrieved-stack <nrc> +)
    (<nrc> ^item <item> + ^prior <rc> +)
}

sp {apply*comprehend-completion*create-receiver*init-retrieved-stack
    (state <s> ^segment <ss> ^operator <o*1>)
    (<ss> -^retrieved-stack <x> ^comprehension-structure <c*1>)
    (<o*1> ^name comprehend-completion)
    (<c*1> ^not-merged-receiver <item>)
    -->
    (<ss> ^retrieved-stack <stack> +)
    (<stack> ^item <item> + ^prior nil +)
}

sp {apply*comprehend-completion*remove-comprehension-structure*snip-assigner
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name comprehend-completion)
    (<seg> ^comprehension-structure <c*1> ^not-merged-assigner <rr>)
    (<c*1> ^remove-assigner <rr>)
    -->
    (<seg> ^not-merged-assigner <rr> -)
}

sp {apply*comprehend-completion*remove-comprehension-structure*snip-receiver
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name comprehend-completion)
    (<seg> ^comprehension-structure <c*1> ^not-merged-receiver <rr>)
    (<c*1> ^remove-receiver <rr>)
    -->
    (<seg> ^not-merged-receiver <rr> -)
}

sp {comprehension*compare*comprehend-completion*comprehend-construction
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name comprehend-completion)
    (<op2> ^name { << failed-comprehension comprehend-construction >> <n*1> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {apply*comprehend-completion*new-word*verb
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name comprehend-completion)
    (<seg> ^comprehension-structure <c*1> ^semantics <sem>)
    (<c*1> ^new-word <nw>)
    (<nw> ^structure-type V ^spelling <spelling>)
    -->
    (<sem> ^new-word <nw> +)
}

sp {apply*comprehend-completion*new-word
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name comprehend-completion)
    (<seg> ^comprehension-structure <c*1> ^semantics <sem>)
    (<c*1> ^new-word <nw>)
    (<nw> ^structure-type { <> V <> UV <s*1> } ^spelling <spelling>)
    -->
    (<sem> ^new-word <nw> + ^interaction-status <i*1> +)
    (<i*1> ^failure <failure> +)
    (<failure> ^type unknown-word + ^word <spelling> +)
}

sp {apply*comprehend-completion*remove-comprehension-structure*assigner
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name comprehend-completion)
    (<seg> ^comprehension-structure <c*1>)
    (<c*1> ^not-merged-assigner <item>)
    -->
    (<seg> ^not-merged-assigner <item> +)
}

sp {apply*comprehend-completion*remove-comprehension-structure*receiver*still-first-word
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name comprehend-completion)
    (<seg> ^comprehension-structure <cs>)
    (<cs> ^first-word true ^not-merged-receiver <item>)
    (<item> ^current-word <cw>)
    -->
    (<cw> ^first-word true +)
}

sp {apply*comprehend-completion*remove-comprehension-structure*receiver
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name comprehend-completion)
    (<seg> ^comprehension-structure <c*1>)
    (<c*1> ^not-merged-receiver <item>)
    -->
    (<seg> ^not-merged-receiver <item> +)
}

sp {apply*comprehend-completion*remove-comprehension-structure-word
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name comprehend-completion)
    (<seg> ^comprehension-structure <c*1> ^current-word <cw>)
    (<c*1> ^failed true)
    -->
    (<cw> ^comprehend-completed true +)
}

sp {apply*comprehend-completion*remove-comprehension-structure
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name comprehend-completion)
    (<seg> ^comprehension-structure <cs>)
    -->
    (<seg> ^comprehension-structure <cs> -)
}

sp {comprehension*propose*comprehend-completion
    (state <s> ^name comprehension ^segment <s*1>)
    (<s*1> ^comprehension-structure <c*1>)
    (<c*1> ^processed true)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name comprehend-completion +)
}

sp {comprehension*elaborate*state*sentence
    (state <s> ^name comprehension ^segment <s*1>)
    (<s*1> ^original-sentence <o*1>)
    (<o*1> ^complete-sentence <w>)
    -->
    
}

sp {comprehension*elaborate*state
    (state <s> ^name comprehension ^segment <s*1>)
    (<s*1> ^current-word <c*1>)
    (<c*1> ^spelling <w>)
    -->
    
}

sp {evaluate-operator*apply*count-grounded-verbs*5
    (state <s> ^operator <o> ^assigner-parent-receiver <aps> ^superstate <s*1>)
    (<o> ^name count-referents)
    (<aps> ^structure-type { << V VP G GP >> <s*2> }
          ^{ << complement complement2 >> <a*1> } <comp>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^evaluation <e>)
    (<e> -^final-referent-count <f*1>)
    (<comp> ^referent <r*1> ^referent { > <r*1> <sg4> }
          ^referent { > <sg4> > <r*1> <sg3> }
          ^referent { > <sg3> > <sg4> > <r*1> <sg2> }
          ^referent { > <sg2> > <sg3> > <sg4> > <r*1> <sg> })
    -->
    (<e> ^final-referent-count 5 +)
}

sp {evaluate-operator*apply*count-grounded-verbs*4
    (state <s> ^operator <o> ^assigner-parent-receiver <aps> ^superstate <s*1>)
    (<o> ^name count-referents)
    (<aps> ^structure-type { << V VP G GP >> <s*2> }
          ^{ << complement complement2 >> <a*1> } <comp>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^evaluation <e>)
    (<e> -^final-referent-count <f*1>)
    (<comp> ^referent <sg4> ^referent { > <sg4> <sg3> }
          ^referent { > <sg3> > <sg4> <sg2> }
          ^referent { > <sg2> > <sg3> > <sg4> <sg> }
          -^referent { <> <sg> <> <sg2> <> <sg3> <> <sg4> <r*1> })
    -->
    (<e> ^final-referent-count 4 +)
}

sp {evaluate-operator*apply*count-grounded-verbs*3
    (state <s> ^operator <o> ^assigner-parent-receiver <aps> ^superstate <s*1>)
    (<o> ^name count-referents)
    (<aps> ^structure-type { << V VP G GP >> <s*2> }
          ^{ << complement complement2 >> <a*1> } <comp>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^evaluation <e>)
    (<e> -^final-referent-count <f*1>)
    (<comp> ^referent <sg3> ^referent { > <sg3> <sg2> }
          ^referent { > <sg2> > <sg3> <sg> }
          -^referent { <> <sg> <> <sg2> <> <sg3> <r*1> })
    -->
    (<e> ^final-referent-count 3 +)
}

sp {evaluate-operator*apply*count-grounded-verbs*2
    (state <s> ^operator <o> ^assigner-parent-receiver <aps> ^superstate <s*1>)
    (<o> ^name count-referents)
    (<aps> ^structure-type { << V VP G GP >> <s*2> }
          ^{ << complement complement2 >> <a*1> } <comp>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^evaluation <e>)
    (<e> -^final-referent-count <f*1>)
    (<comp> ^referent <sg2> ^referent { > <sg2> <sg> }
          -^referent { <> <sg> <> <sg2> <r*1> })
    -->
    (<e> ^final-referent-count 2 +)
}

sp {evaluate-operator*apply*count-grounded-verbs*1
    (state <s> ^operator <o> ^assigner-parent-receiver <aps> ^superstate <s*1>)
    (<o> ^name count-referents)
    (<aps> ^structure-type { << V VP G GP >> <s*2> }
          ^{ << complement complement2 >> <a*1> } <comp>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^evaluation <e>)
    (<e> -^final-referent-count <f*1>)
    (<comp> ^referent <sg> -^referent { <> <sg> <r*1> })
    -->
    (<e> ^final-referent-count 1 +)
}

sp {evaluate-operator*apply*count-grounded-verbs*0
    (state <s> ^operator <o> ^assigner-parent-receiver <aps> ^superstate <s*1>)
    (<o> ^name count-referents)
    (<aps> ^structure-type { << V VP G GP >> <s*2> }
          ^{ << complement complement2 >> <a*1> } <comp>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^evaluation <e>)
    (<e> -^final-referent-count <f*1>)
    (<comp> -^referent <r*1>)
    -->
    (<e> ^final-referent-count 0 +)
}

sp {evaluate-operator*apply*count-referents*5
    (state <s> ^operator <o> ^assigner-parent-receiver <aps> ^superstate <s*1>)
    (<o> ^name count-referents)
    (<aps> ^referent <r*1> ^referent { > <r*1> <sg4> }
          ^referent { > <sg4> > <r*1> <sg3> }
          ^referent { > <sg3> > <sg4> > <r*1> <sg2> }
          ^referent { > <sg2> > <sg3> > <sg4> > <r*1> <sg> })
    (<s*1> ^operator <o*1>)
    (<o*1> ^evaluation <e>)
    (<e> -^final-referent-count <f*1>)
    -->
    (<e> ^final-referent-count 5 +)
}

sp {evaluate-operator*apply*count-referents*4
    (state <s> ^operator <o> ^assigner-parent-receiver <aps> ^superstate <s*1>)
    (<o> ^name count-referents)
    (<aps> ^referent <sg4> ^referent { > <sg4> <sg3> }
          ^referent { > <sg3> > <sg4> <sg2> }
          ^referent { > <sg2> > <sg3> > <sg4> <sg> }
          -^referent { <> <sg> <> <sg2> <> <sg3> <> <sg4> <r*1> })
    (<s*1> ^operator <o*1>)
    (<o*1> ^evaluation <e>)
    (<e> -^final-referent-count <f*1>)
    -->
    (<e> ^final-referent-count 4 +)
}

sp {evaluate-operator*apply*count-referents*3
    (state <s> ^operator <o> ^assigner-parent-receiver <aps> ^superstate <s*1>)
    (<o> ^name count-referents)
    (<aps> ^referent <sg3> ^referent { > <sg3> <sg2> }
          ^referent { > <sg2> > <sg3> <sg> }
          -^referent { <> <sg> <> <sg2> <> <sg3> <r*1> })
    (<s*1> ^operator <o*1>)
    (<o*1> ^evaluation <e>)
    (<e> -^final-referent-count <f*1>)
    -->
    (<e> ^final-referent-count 3 +)
}

sp {evaluate-operator*apply*count-referents*2
    (state <s> ^operator <o> ^assigner-parent-receiver <aps> ^superstate <s*1>)
    (<o> ^name count-referents)
    (<aps> ^referent <sg2> ^referent { > <sg2> <sg> }
          -^referent { <> <sg> <> <sg2> <r*1> })
    (<s*1> ^operator <o*1>)
    (<o*1> ^evaluation <e>)
    (<e> -^final-referent-count <f*1>)
    -->
    (<e> ^final-referent-count 2 +)
}

sp {evaluate-operator*apply*count-referents*1
    (state <s> ^operator <o> ^assigner-parent-receiver <aps> ^superstate <s*1>)
    (<o> ^name count-referents)
    (<aps> ^referent <sg> -^referent { <> <sg> <r*1> })
    (<s*1> ^operator <o*1>)
    (<o*1> ^evaluation <e>)
    (<e> -^final-referent-count <f*1>)
    -->
    (<e> ^final-referent-count 1 +)
}

sp {evaluate-operator*apply*count-referents*0
    (state <s> ^assigner-parent-receiver <aps> ^operator <o> ^superstate <s*1>)
    (<aps> -^structure-type { << V VP G GP >> <s*2> } -^referent <r*1>)
    (<o> ^name count-referents)
    (<s*1> ^operator <o*1>)
    (<o*1> ^evaluation <e>)
    (<e> -^final-referent-count <f*1>)
    -->
    (<e> ^final-referent-count 0 +)
}

sp {evaluate-operator*propose*count-referents
    (state <s> ^name evaluate-operator ^segment <seg>)
   -{ (<seg> ^last-merge <lm>)
      (<lm> ^assigner <a*1> ^receiver <r1>)
      (<a*1> ^parent-receiver <a1>)
      (<a1> ^structure-type DP -^ground-tested <r1>)}
    (<seg> -^not-merged-receiver <receiver> -^new-constraint <nc>)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name count-referents +)
}

sp {evaluate-operator*elaborate*state*receiver*parent
    (state <s> ^name evaluate-operator ^id-mapping <im> ^superstate <ss>)
    (<ss> ^superstate <s*2> ^operator <o*1>)
    (<s*2> ^segment <sss>)
    (<sss> ^not-merged-assigner <uai>)
    (<uai> ^parent-receiver <aps>)
    (<o*1> ^superoperator <s*1>)
    (<s*1> ^name merge)
    (<im> ^<uai> <nai> ^<aps> <apsi>)
    (<aps> ^<att> <value>)
    -->
    (<apsi> ^<att> <value> +)
}

sp {evaluate-operator*elaborate*state*assigner
    (state <s> ^name evaluate-operator ^id-mapping <im> ^superstate <ss>)
    (<ss> ^superstate <s*2> ^operator <o*1>)
    (<s*2> ^segment <sss>)
    (<sss> ^not-merged-assigner <assigner>)
    (<o*1> ^superoperator <s*1>)
    (<s*1> ^name merge)
    (<im> ^<assigner> <ai>)
    (<assigner> ^{ <> parent-receiver <att> } <value>)
    -->
    (<ai> ^<att> <value> +)
}

sp {evaluate-operator*elaborate*state*receiver
    (state <s> ^name evaluate-operator ^id-mapping <im> ^superstate <ss>)
    (<ss> ^superstate <s*2> ^operator <o*1>)
    (<s*2> ^segment <sss>)
    (<sss> ^not-merged-receiver <receiver>)
    (<o*1> ^superoperator <s*1>)
    (<s*1> ^name merge)
    (<im> ^<receiver> <ri>)
    (<receiver> ^<att> <value>)
    -->
    (<ri> ^<att> <value> +)
}

sp {evaluate-operator*elaborate*state*merge
    (state <s> ^name evaluate-operator ^superstate <ss>)
    (<ss> ^top-state <t*1> ^superstate <sss> ^operator <o*1>)
    (<t*1> ^world <world>)
    (<sss> ^segment <s*1>)
    (<s*1> ^last-merge <lm>)
    (<lm> ^assigner <a1> ^receiver <r1> ^structure-type <st>)
    (<o*1> ^superoperator <so>)
    (<so> ^name merge ^assigner <assigner> ^receiver <receiver>)
    (<assigner> ^parent-receiver <aps>)
    -->
    (<s> ^world <world> + ^id-mapping <im> +
           ^assigner-parent-receiver <apsi> + ^segment <seg> +)
    (<seg> ^last-merge <lmx> + ^not-merged-receiver <ri> +
           ^not-merged-assigner <ni> +)
    (<lmx> ^receiver <r1> + ^assigner <a1> + ^structure-type <st> +)
    (<im> ^<assigner> <ni> + ^<receiver> <ri> + ^<aps> <apsi> +)
    (<ni> ^parent-receiver <apsi> +)
}

sp {elaborate*top-state*pass-down-evaluate
    (state <s> ^name evaluate-operator ^superstate <s*1>)
    (<s*1> ^top-state <ts>)
    -->
    (<s> ^top-state <ts> +)
}

sp {evaluate-operator*elaborate*substate*verb*4
    (state <s> ^operator <o>)
    (<o> ^name evaluate-operator ^evaluation <e> ^superoperator <so>)
    (<e> -^initial-referent-count <i*1>)
    (<so> ^name merge ^assigner <ass>)
    (<ass> ^structure-type PP ^parent-receiver <aps>)
    (<aps> -^referent <r*1> ^complement <comp>
          ^structure-type { << V VP G GP >> <s*1> })
    (<comp> ^referent <sg4> ^referent { > <sg4> <sg3> }
          ^referent { > <sg3> > <sg4> <sg2> }
          ^referent { > <sg2> > <sg3> > <sg4> <sg> }
          -^referent { <> <sg> <> <sg2> <> <sg3> <> <sg4> <r*2> })
    -->
    (<e> ^initial-referent-count 4 +)
}

sp {evaluate-operator*elaborate*substate*verb*3
    (state <s> ^operator <o>)
    (<o> ^name evaluate-operator ^evaluation <e> ^superoperator <so>)
    (<e> -^initial-referent-count <i*1>)
    (<so> ^name merge ^assigner <ass>)
    (<ass> ^structure-type PP ^parent-receiver <aps>)
    (<aps> -^referent <r*1> ^complement <comp>
          ^structure-type { << V VP G GP >> <s*1> })
    (<comp> ^referent <sg3> ^referent { > <sg3> <sg2> }
          ^referent { > <sg2> > <sg3> <sg> }
          -^referent { <> <sg> <> <sg2> <> <sg3> <r*2> })
    -->
    (<e> ^initial-referent-count 3 +)
}

sp {evaluate-operator*elaborate*substate*verb*2
    (state <s> ^operator <o>)
    (<o> ^name evaluate-operator ^evaluation <e> ^superoperator <so>)
    (<e> -^initial-referent-count <i*1>)
    (<so> ^name merge ^assigner <ass>)
    (<ass> ^structure-type PP ^parent-receiver <aps>)
    (<aps> -^referent <r*1> ^complement <comp>
          ^structure-type { << V VP G GP >> <s*1> })
    (<comp> ^referent <sg2> ^referent { > <sg2> <sg> }
          -^referent { <> <sg> <> <sg2> <r*2> })
    -->
    (<e> ^initial-referent-count 2 +)
}

sp {evaluate-operator*elaborate*substate*verb*1
    (state <s> ^operator <o>)
    (<o> ^name evaluate-operator ^evaluation <e> ^superoperator <so>)
    (<e> -^initial-referent-count <i*1>)
    (<so> ^name merge ^assigner <ass>)
    (<ass> ^structure-type PP ^parent-receiver <aps>)
    (<aps> -^referent <r*1> ^complement <comp>
          ^structure-type { << V VP G GP >> <s*1> })
    (<comp> ^referent <sg> -^referent { <> <sg> <r*2> })
    -->
    (<e> ^initial-referent-count 1 +)
}

sp {evaluate-operator*elaborate*substate*verb*0
    (state <s> ^operator <o>)
    (<o> ^name evaluate-operator ^evaluation <e> ^superoperator <so>)
    (<e> -^initial-referent-count <i*1>)
    (<so> ^name merge ^assigner <ass>)
    (<ass> ^structure-type PP ^parent-receiver <aps>)
    (<aps> -^referent <r*1> ^complement <comp>
          ^structure-type { << V VP G GP >> <s*1> })
    (<comp> -^referent <sg>)
    -->
    (<e> ^initial-referent-count 1 +)
}

sp {evaluate-operator*elaborate*substate*verb
    (state <s> ^operator <o>)
    (<o> ^name evaluate-operator ^evaluation <e> ^superoperator <so>)
    (<e> -^initial-referent-count <i*1>)
    (<so> ^name merge ^assigner <ass>)
    (<ass> ^structure-type PP ^parent-receiver <aps>)
    (<aps> -^complement <c*1> -^referent <r*1>
          ^structure-type { << V VP G GP >> <s*1> })
    -->
    (<e> ^initial-referent-count 1 + ^final-referent-count 1 +
           ^count-difference 0 + ^value true +)
}

sp {apply*evaluate-operator*count-difference2
    (state <s> ^operator <op>)
    (<op> ^name evaluate-operator ^superoperator <s*1> ^evaluation <e>)
    (<s*1> ^name merge)
    (<e> ^initial-referent-count <ic> ^final-referent-count { > <ic> <fc> })
    -->
    (<e> ^count-difference (- <fc> <ic>) + ^value true +)
}

sp {apply*evaluate-operator*count-difference
    (state <s> ^operator <op>)
    (<op> ^name evaluate-operator ^superoperator <s*1> ^evaluation <e>)
    (<s*1> ^name merge)
    (<e> ^initial-referent-count <ic> ^final-referent-count { <= <ic> <fc> })
    -->
    (<e> ^count-difference (- <ic> <fc>) + ^value true +)
}

sp {evaluate-operator*elaborate*substate*5
    (state <s> ^operator <o>)
    (<o> ^name evaluate-operator ^evaluation <e> ^superoperator <so>)
    (<e> -^initial-referent-count <i*1>)
    (<so> ^name merge ^assigner <a*1>)
    (<a*1> ^parent-receiver <aps>)
    (<aps> -^structure-type { << V VP G GP >> <s*1> } ^referent <r*1>
          ^referent { > <r*1> <sg4> } ^referent { > <sg4> > <r*1> <sg3> }
          ^referent { > <sg3> > <sg4> > <r*1> <sg2> }
          ^referent { > <sg2> > <sg3> > <sg4> > <r*1> <sg> })
    -->
    (<e> ^initial-referent-count 5 +)
}

sp {evaluate-operator*elaborate*substate*4
    (state <s> ^operator <o>)
    (<o> ^name evaluate-operator ^evaluation <e> ^superoperator <so>)
    (<e> -^initial-referent-count <i*1>)
    (<so> ^name merge ^assigner <a*1>)
    (<a*1> ^parent-receiver <aps>)
    (<aps> -^structure-type { << V VP G GP >> <s*1> } ^referent <sg4>
          ^referent { > <sg4> <sg3> } ^referent { > <sg3> > <sg4> <sg2> }
          ^referent { > <sg2> > <sg3> > <sg4> <sg> }
          -^referent { <> <sg> <> <sg2> <> <sg3> <> <sg4> <r*1> })
    -->
    (<e> ^initial-referent-count 4 +)
}

sp {evaluate-operator*elaborate*substate*3
    (state <s> ^operator <o>)
    (<o> ^name evaluate-operator ^evaluation <e> ^superoperator <so>)
    (<e> -^initial-referent-count <i*1>)
    (<so> ^name merge ^assigner <a*1>)
    (<a*1> ^parent-receiver <aps>)
    (<aps> -^structure-type { << V VP G GP >> <s*1> } ^referent <sg3>
          ^referent { > <sg3> <sg2> } ^referent { > <sg2> > <sg3> <sg> }
          -^referent { <> <sg> <> <sg2> <> <sg3> <r*1> })
    -->
    (<e> ^initial-referent-count 3 +)
}

sp {evaluate-operator*elaborate*substate*2
    (state <s> ^operator <o>)
    (<o> ^name evaluate-operator ^evaluation <e> ^superoperator <so>)
    (<e> -^initial-referent-count <i*1>)
    (<so> ^name merge ^assigner <a*1>)
    (<a*1> ^parent-receiver <aps>)
    (<aps> -^structure-type { << V VP G GP >> <s*1> } ^referent <sg2>
          ^referent { > <sg2> <sg> } -^referent { <> <sg> <> <sg2> <r*1> })
    -->
    (<e> ^initial-referent-count 2 +)
}

sp {evaluate-operator*elaborate*substate*1
    (state <s> ^operator <o>)
    (<o> ^name evaluate-operator ^evaluation <e> ^superoperator <so>)
    (<e> -^initial-referent-count <i*1>)
    (<so> ^name merge ^assigner <a*1>)
    (<a*1> ^parent-receiver <aps>)
    (<aps> -^structure-type { << V VP G GP >> <s*1> } ^referent <sg>
          -^referent { <> <sg> <r*1> })
    -->
    (<e> ^initial-referent-count 1 +)
}

sp {evaluate-operator*elaborate*substate*0
    (state <s> ^operator <o>)
    (<o> ^name evaluate-operator ^evaluation <e> ^superoperator <so>)
    (<e> -^initial-referent-count <i*1>)
    (<so> ^name merge ^assigner <a*1>)
    (<a*1> ^parent-receiver <aps>)
    (<aps> -^structure-type { << V VP G GP >> <s*1> } -^referent <r*1>)
    -->
    (<e> ^initial-referent-count 0 +)
}

sp {apply*compare-count-differences*one*prefer-larger-change
    (state <s> ^operator <op> ^superstate <ss>)
    (<op> ^name compare-count-differences ^evaluation <e2> ^evaluation <e1>)
    (<e2> ^final-referent-count { <> 0 <f*2> } ^count-difference <c*1>
          ^superoperator <so2>)
    (<e1> ^final-referent-count { <> 0 <f*1> }
          ^count-difference { < <c*1> <cd1> } ^superoperator <so1>)
    -->
    (<ss> ^operator <so1> < <so2>)
    (<e1> ^compared <e2> +)
    (<e2> ^compared <e1> +)
}

sp {apply*compare-count-differences*one-goes-to-zero*other-doesnt
    (state <s> ^operator <op> ^superstate <ss>)
    (<op> ^name compare-count-differences ^evaluation <e1> ^evaluation <e2>)
   -{ (<e1> ^superoperator <s*1>)
      (<s*1> ^assigner <a*1>)
      (<a*1> ^parent-receiver <p*1>)
      (<p*1> ^lt <l*1>)
      (<l*1> ^referent nil)}
    (<e1> ^final-referent-count 0 ^superoperator <so1>)
    (<e2> ^final-referent-count { <> 0 <f*1> } ^superoperator <so2>)
    -->
    (<ss> ^operator <so1> < <so2>)
    (<e1> ^compared <e2> +)
    (<e2> ^compared <e1> +)
}

sp {apply*compare-count-differences*one-isnt-zero*other-doesnt*not-grounded2
    (state <s> ^operator <op> ^superstate <ss>)
    (<op> ^name compare-count-differences ^evaluation <e2> ^evaluation <e1>)
    (<e2> ^final-referent-count { <> 0 <f*1> } ^superoperator <so2>)
    (<so2> ^assigner <a*3>)
    (<a*3> ^decision-count <d*1>)
    (<e1> ^superoperator <so1> ^superoperator <s*1>)
    (<so1> ^assigner <a*2>)
    (<a*2> ^decision-count { < <d*1> <dc> })
    (<s*1> ^assigner <a*1>)
    (<a*1> ^parent-receiver <p*1>)
    (<p*1> ^lt <l*1>)
    (<l*1> ^referent nil)
    -->
    (<ss> ^operator <so1> < <so2>)
    (<e1> ^compared <e2> +)
    (<e2> ^compared <e1> +)
}

sp {apply*compare-count-differences*one-isnt-zero*other-doesnt*not-grounded
    (state <s> ^operator <op> ^superstate <ss>)
    (<op> ^name compare-count-differences ^evaluation <e2> ^evaluation <e1>)
    (<e2> ^final-referent-count { <> 0 <f*1> } ^superoperator <so2>)
    (<so2> ^assigner <a*3>)
    (<a*3> ^decision-count <d*1>)
    (<e1> ^superoperator <so1> ^superoperator <s*1>)
    (<so1> ^assigner <a*2>)
    (<a*2> ^decision-count { > <d*1> <dc> })
    (<s*1> ^assigner <a*1>)
    (<a*1> ^parent-receiver <p*1>)
    (<p*1> ^lt <l*1>)
    (<l*1> ^referent nil)
    -->
    (<ss> ^operator <so1> > <so2>)
    (<e1> ^compared <e2> +)
    (<e2> ^compared <e1> +)
}

sp {apply*compare-count-differences*both-go-to-zero*both-required*before
    (state <s> ^operator <op> ^superstate <ss>)
    (<op> ^name compare-count-differences ^evaluation <e2>
          ^evaluation { <> <e2> <e1> })
    (<e2> ^final-referent-count 0 ^superoperator <so2>)
    (<e1> ^final-referent-count 0 ^superoperator <so1>)
    (<so2> ^assigner <ass2>)
    (<ass2> ^lt <l*3> ^parent-receiver <pr> ^decision-count <dc> ^lt <solt>)
    (<l*3> ^required true)
    (<so1> ^assigner <ass1> ^assigner <a*1>)
    (<ass1> ^parent-receiver <pr> ^lt <l*2> ^lt <l*1>)
    (<a*1> ^decision-count <dc>)
    (<l*2> ^required true)
    (<l*1> ^before <solt>)
    -->
    (<ss> ^operator <so1> > <so2>)
    (<e1> ^compared <e2> +)
    (<e2> ^compared <e1> +)
}

sp {apply*compare-count-differences*both-go-to-zero*both-required*equal
    (state <s> ^operator <op> ^superstate <ss>)
    (<op> ^name compare-count-differences ^evaluation <e2>
          ^evaluation { <> <e2> <e1> })
    (<e2> ^final-referent-count 0 ^superoperator <so2>)
    (<e1> ^final-referent-count 0 ^superoperator <so1>)
    (<so2> ^assigner <a*4> ^assigner <a*3>)
    (<a*4> ^lt <l*2>)
    (<l*2> ^required true)
    (<a*3> ^decision-count <dc>)
    (<so1> ^assigner <a*1> ^assigner <a*2>)
    (<a*1> ^decision-count <dc>)
    (<a*2> ^lt <l*1>)
    (<l*1> ^required true)
    -->
    (<ss> ^operator <so1> = <so2>)
    (<e1> ^compared <e2> +)
    (<e2> ^compared <e1> +)
}

sp {apply*compare-count-differences*both-go-to-zero*both-required
    (state <s> ^operator <op> ^superstate <ss>)
    (<op> ^name compare-count-differences ^evaluation <e2>
          ^evaluation { <> <e2> <e1> })
    (<e2> ^final-referent-count 0 ^superoperator <so2>)
    (<e1> ^final-referent-count 0 ^superoperator <so1>)
    (<so2> ^assigner <a*4> ^assigner <a*3>)
    (<a*4> ^lt <l*2>)
    (<l*2> ^required true)
    (<a*3> ^decision-count <d*1>)
    (<so1> ^assigner <a*2> ^assigner <a*1>)
    (<a*2> ^lt <l*1>)
    (<l*1> ^required true)
    (<a*1> ^decision-count { > <d*1> <dc> })
    -->
    (<ss> ^operator <so1> > <so2>)
    (<e1> ^compared <e2> +)
    (<e2> ^compared <e1> +)
}

sp {apply*compare-count-differences*both-go-to-zero*no-required*equal
    (state <s> ^operator <op> ^superstate <ss>)
    (<op> ^name compare-count-differences ^evaluation <e2>
          ^evaluation { <> <e2> <e1> })
    (<e2> ^final-referent-count 0 ^superoperator <so2>)
    (<e1> ^final-referent-count 0 ^superoperator <so1>)
   -{ (<so2> ^assigner <a*5>)
      (<a*5> ^lt <l*3>)
      (<l*3> ^exclusive <e*1>)}
   -{ (<so2> ^assigner <a*4>)
      (<a*4> ^lt <l*2>)
      (<l*2> ^required true)}
   -{ (<so1> ^assigner <a*2>)
      (<a*2> ^lt <l*1>)
      (<l*1> ^required true)}
    (<so2> ^assigner <a*3>)
    (<a*3> ^decision-count <dc>)
    (<so1> ^assigner <a*1>)
    (<a*1> ^decision-count <dc>)
    -->
    (<ss> ^operator <so1> = <so2>)
    (<e1> ^compared <e2> +)
    (<e2> ^compared <e1> +)
}

sp {apply*compare-count-differences*both-go-to-zero*no-required
    (state <s> ^operator <op> ^superstate <ss>)
    (<op> ^name compare-count-differences ^evaluation <e2>
          ^evaluation { <> <e2> <e1> })
    (<e2> ^final-referent-count 0 ^superoperator <so2>)
    (<e1> ^final-referent-count 0 ^superoperator <so1>)
   -{ (<so2> ^assigner <a*5>)
      (<a*5> ^lt <l*3>)
      (<l*3> ^exclusive <e*1>)}
   -{ (<so2> ^assigner <a*4>)
      (<a*4> ^lt <l*2>)
      (<l*2> ^required true)}
   -{ (<so1> ^assigner <a*2>)
      (<a*2> ^lt <l*1>)
      (<l*1> ^required true)}
    (<so2> ^assigner <a*3>)
    (<a*3> ^decision-count <d*1>)
    (<so1> ^assigner <a*1>)
    (<a*1> ^decision-count { > <d*1> <dc> })
    -->
    (<ss> ^operator <so1> > <so2>)
    (<e1> ^compared <e2> +)
    (<e2> ^compared <e1> +)
}

sp {apply*compare-count-differences*both-go-to-zero*both-exclusive
    (state <s> ^operator <op> ^superstate <ss>)
    (<op> ^name compare-count-differences ^evaluation <e2>
          ^evaluation { <> <e2> <e1> })
    (<e2> ^final-referent-count 0 ^superoperator <so2>)
    (<e1> ^final-referent-count 0 ^superoperator <so1>)
   -{ (<so2> ^assigner <a*3>)
      (<a*3> ^lt <l*3>)
      (<l*3> ^required true)}
   -{ (<so1> ^assigner <a*2>)
      (<a*2> ^lt <l*2>)
      (<l*2> ^required true)}
    (<so2> ^assigner <a*4>)
    (<so1> ^assigner <a*1>)
    (<a*4> ^lt <l*4>)
    (<l*4> ^exclusive <e*2>)
    (<a*1> ^lt <l*1>)
    (<l*1> ^exclusive <e*1>)
    -->
    (<ss> ^operator <so1> = <so2>)
    (<e1> ^compared <e2> +)
    (<e2> ^compared <e1> +)
}

sp {apply*compare-count-differences*both-go-to-zero*one-exclusive
    (state <s> ^operator <op> ^superstate <ss>)
    (<op> ^name compare-count-differences ^evaluation <e2>
          ^evaluation { <> <e2> <e1> })
    (<e2> ^final-referent-count 0 ^superoperator <so2>)
    (<e1> ^final-referent-count 0 ^superoperator <so1>)
   -{ (<so2> ^assigner <a*3>)
      (<a*3> ^lt <l*3>)
      (<l*3> ^exclusive <e*2>)}
   -{ (<so2> ^assigner <a*2>)
      (<a*2> ^lt <l*2>)
      (<l*2> ^required true)}
    (<so1> ^assigner <a*1>)
    (<a*1> ^lt <l*1>)
    (<l*1> ^exclusive <e*1>)
    -->
    (<ss> ^operator <so1> > <so2>)
    (<e1> ^compared <e2> +)
    (<e2> ^compared <e1> +)
}

sp {apply*compare-count-differences*both-go-to-zero*one-required
    (state <s> ^operator <op> ^superstate <ss>)
    (<op> ^name compare-count-differences ^evaluation <e2>
          ^evaluation { <> <e2> <e1> })
    (<e2> ^final-referent-count 0 ^superoperator <so2>)
    (<e1> ^final-referent-count 0 ^superoperator <so1>)
   -{ (<so2> ^assigner <a*2>)
      (<a*2> ^lt <l*2>)
      (<l*2> ^required true)}
    (<so1> ^assigner <a*1>)
    (<a*1> ^lt <l*1>)
    (<l*1> ^required true)
    -->
    (<ss> ^operator <so1> > <so2>)
    (<e1> ^compared <e2> +)
    (<e2> ^compared <e1> +)
}

sp {apply*compare-count-differences*both-equal*not-zero*both-required
    (state <s> ^operator <op> ^superstate <ss>)
    (<op> ^name compare-count-differences ^evaluation <e2>
          ^evaluation { <> <e2> <e1> })
    (<e2> ^final-referent-count { <> 0 <f*2> } ^count-difference <cd1>
          ^superoperator <so2>)
    (<e1> ^count-difference <cd1> ^final-referent-count { <> 0 <f*1> }
          ^superoperator <so1>)
    (<so2> ^assigner <a*4> ^assigner <a*3>)
    (<a*4> ^lt <l*2>)
    (<l*2> ^required true)
    (<a*3> ^decision-count <d*1>)
    (<so1> ^assigner <a*2> ^assigner <a*1>)
    (<a*2> ^lt <l*1>)
    (<l*1> ^required true)
    (<a*1> ^decision-count { > <d*1> <dc> })
    -->
    (<ss> ^operator <so1> > <so2>)
    (<e1> ^compared <e2> +)
    (<e2> ^compared <e1> +)
}

sp {apply*compare-count-differences*both-equal*not-zero*not-required
    (state <s> ^operator <op> ^superstate <ss>)
    (<op> ^name compare-count-differences ^evaluation <e2>
          ^evaluation { <> <e2> <e1> })
    (<e2> ^superoperator <so2> ^final-referent-count { <> 0 <f*2> }
          ^count-difference <cd1>)
   -{ (<so2> ^assigner <a*4>)
      (<a*4> ^lt <l*2>)
      (<l*2> ^required true)}
    (<e1> ^count-difference <cd1> ^superoperator <so1>
          ^final-referent-count { <> 0 <f*1> })
   -{ (<so1> ^assigner <a*2>)
      (<a*2> ^lt <l*1>)
      (<l*1> ^required true)}
    (<so2> ^assigner <a*3>)
    (<a*3> ^decision-count <d*1>)
    (<so1> ^assigner <a*1>)
    (<a*1> ^decision-count { > <d*1> <dc> })
    -->
    (<ss> ^operator <so1> > <so2>)
    (<e1> ^compared <e2> +)
    (<e2> ^compared <e1> +)
}

sp {apply*compare-count-differences*both-equal*one-required
    (state <s> ^operator <op> ^superstate <ss>)
    (<op> ^name compare-count-differences ^evaluation <e2>
          ^evaluation { <> <e2> <e1> })
    (<e2> ^superoperator <so2> ^count-difference <cd1>)
   -{ (<so2> ^assigner <a*2>)
      (<a*2> ^lt <l*2>)
      (<l*2> ^required true)}
    (<e1> ^count-difference <cd1> ^superoperator <so1>)
    (<so1> ^assigner <a*1>)
    (<a*1> ^lt <l*1>)
    (<l*1> ^required true)
    -->
    (<ss> ^operator <so1> > <so2>)
    (<e1> ^compared <e2> +)
    (<e2> ^compared <e1> +)
}

sp {selection*propose*compare-count-differences
    (state <s> ^name selection ^evaluation <e2> ^evaluation { > <e2> <e1> })
    (<e2> -^compared <e1> ^count-difference <c*2>)
    (<e1> -^compared <e2> ^count-difference <c*1>)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name compare-count-differences + ^evaluation <e1> +
           ^evaluation <e2> +)
}

sp {selection*compare*merge*prefer*most-recent
    (state <s> ^name selection ^operator <op2> + ^operator <op1> +)
    (<op2> ^name evaluate-operator ^superoperator <sop2>)
    (<sop2> ^name merge ^assigner <a*2>)
    (<op1> ^name evaluate-operator ^superoperator <sop1>)
    (<sop1> ^name merge ^assigner <a*1>)
    (<a*2> ^decision-count <d*1>)
    (<a*1> ^decision-count { < <d*1> <dc> })
    -->
    (<s> ^operator <op1> < <op2>)
}

sp {elaborate*comprehend*hypothetical*game-learning
    :o-support
    (state <s> ^segment <seg> ^top-state <t*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learning true)
    -->
    (<seg> ^hypothetical true +)
}

sp {elaborate*comprehend*dialog-object-list-access*copy
    (state <s> ^name comprehension ^segment <seg> ^top-state <t*1>)
    (<t*1> ^dialog-object-list-saved <dol>)
    -->
    (<seg> ^dialog-object-list-access <dol> +)
}

sp {top-state*elaborate*objects*property
    (state <s> ^superstate nil ^world <w>)
    (<w> ^object <obj>)
    (<obj> ^property <prop>)
    (<prop> ^value <value> ^name <name>)
    (<value> ^label <label>)
    -->
    (<obj> ^<name> <label> +)
}

sp {comprehension*elaborate-segment
    (state <s> ^name comprehension -^name evaluate-operator)
    -->
    (<s> ^segment <seg> +)
    (<seg> ^semantics <sem> + ^last-merge <lm> +)
    (<lm> ^receiver nil + ^assigner nil + ^structure-type none +)
}

sp {comprehension*elaborate-problem-space
    (state <s> ^name comprehension)
    -->
    (<s> ^problem-space <ps> + ^desired <d> +)
    (<ps> ^default-operator-copy no + ^default-state-copy no +
           ^dont-copy-anything true + ^name comprehend +)
}

sp {pass-down-world*elaborate*substate*ground-referent
    (state <s> ^name ground-referent ^impasse no-change ^top-state <t*1>
          ^superstate <ss>)
    (<t*1> ^world-usage external)
    (<ss> ^world <world>)
    -->
    (<s> ^world <world> +)
}

sp {pass-down-world*elaborate*substate
    (state <s> ^name comprehension ^impasse no-change ^top-state <t*1>
          ^superstate <ss>)
    (<t*1> ^world-usage external)
    -->
    (<s> ^world <ss> +)
}

sp {pass-down-segment*elaborate*substate
    (state <s> ^impasse no-change
          ^name { << print-semantics termination-processing comprehend-word comprehend-construction ground-referent process-multiple-groundings >> <n*1> }
          ^superstate <s*1>)
    (<s*1> ^segment <seg>)
    -->
    (<s> ^segment <seg> +)
}

sp {comprehension*elaborate*sentence
    (state <s> ^segment <seg> ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^sentence <sentence>)
    -->
    (<seg> ^input-sentence (deep-copy <sentence>) +
           ^current-word (deep-copy <sentence>) +
           ^original-sentence (deep-copy <sentence>) +)
}

sp {apply*comprehension*save-most-recent-alternative-meaning
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name comprehension)
    (<seg> ^merged-receiver <nmr>)
    (<nmr> ^lt <l*1>)
    (<l*1> ^alternative-meaning <a*1>)
    -->
    (<seg> ^alternative-meaning-receiver <nmr> +)
}

sp {apply*performed-event*clean*dialog-world
    (state <s1> ^name interaction ^operator <o> ^top-state <t*1>)
   -{ (<o> ^event <e*2>)
      (<e*2> ^dialog-event <d*3>)
      (<d*3> ^type process-sentence)}
   -{ (<o> ^event <e*1>)
      (<e*1> ^dialog-event <d*2>)
      (<d*2> ^type process-unknown-word)}
    (<o> ^name performed-event)
    (<t*1> ^dialog-world <d*1>)
    (<d*1> ^{ << objects predicates >> <a*1> } <dw>)
    (<dw> ^<something> <obj>)
    -->
    (<dw> ^<something> <obj> -)
}

sp {apply*comprehension*save-most-recent-alternative-structure
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name comprehension)
    (<seg> ^not-merged-receiver <nmr>)
    (<nmr> ^lt <l*1>)
    (<l*1> ^alternative-structure <a*1>)
    -->
    (<seg> ^alternative-structure-receiver <nmr> +)
}

sp {dialog-event*propose*comprehension
    (state <s> ^name dialog-event ^purpose <p>)
    (<p> ^type process-sentence ^parameters <p*1>)
    (<p*1> ^sentence <sentence>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name comprehension + ^sentence <sentence> +)
}

sp {rosie*apply*process-new-sentence*copy*new-segment-info*from-input-link
    (state <s> ^name rosie ^operator <op> ^top-state <t*1>)
    (<op> ^name process-new-sentence ^original-sentence <os>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <c>)
    -->
    (<os> ^segment-proposed true +)
    (<c> ^new-segment-info <info> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type process-sentence + ^parameters <p*1> + ^satisfaction <sat> +)
    (<p*1> ^sentence (deep-copy <os>) +)
    (<sat> ^dialog-event <de> +)
    (<de> ^type process-sentence + ^originator agent +)
}

sp {rosie*apply*process-new-sentence*copy*new-segment-info*from-script
    (state <s> ^name rosie ^operator <op> ^top-state <t*1>)
    (<op> ^name process-new-sentence ^sentence <sentence>)
    (<sentence> ^original-sentence <os>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <c>)
    -->
    (<sentence> ^segment-proposed true +)
    (<c> ^new-segment-info <info> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type process-sentence + ^parameters <p*1> + ^satisfaction <sat> +)
    (<p*1> ^sentence (deep-copy <os>) +)
    (<sat> ^dialog-event <de> +)
    (<de> ^type process-sentence + ^originator agent +)
}

sp {rosie*propose*process-new-sentence*input-link
    (state <s> ^name rosie ^io <i*1>)
    (<i*1> ^input-link <i*2>)
    (<i*2> ^language <l*1>)
    (<l*1> ^sentence <sentence>)
    (<sentence> -^segment-proposed true)
    -->
    (<s> ^operator <op> + ^operator <op> >)
    (<op> ^name process-new-sentence + ^original-sentence <sentence> +)
}

sp {rosie*propose*process-new-sentence*scripted
    (state <s> ^world-usage internal -^terminated-sentence <cs>
          ^current-sentence <sentence> ^current-sentence-number <csn>)
    (<sentence> -^segment-proposed true)
    -->
    (<s> ^operator <op> + ^operator <op> >)
    (<op> ^name process-new-sentence + ^sentence <sentence> +)
}

sp {language-comprehension*elaborate-operator*language-comprehension-init
    (state <s> ^superstate nil)
    -->
    (<s> ^world-usage internal + ^create-trace-file false +
           ^dialog-world <world> + ^dialog-object-list nil +
           ^dialog-object-list-saved nil +)
    (<world> ^objects <objects> + ^predicates <predicates> +)
}

sp {selection*iterative-deepening*operator-tie*prefer*init*over*increment
    (state <s> ^top-selection true ^name selection ^operator <o2> +
          ^operator <o1> +)
    (<o2> ^name increment-current-evaluation-depth)
    (<o1>
          ^name { << init-current-evaluation-depth init-remaining-operators >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {apply*init-remaining-operators
    (state <s> ^operator <op>)
    (<op> ^name init-remaining-operators ^value <toc>)
    -->
    (<s> ^remaining-operators <toc> +)
}

sp {selection*propose*init-remaining-operators
    (state <s> ^name selection -^remaining-operators <r*1> ^item-count <toc>
          ^superstate <s*1>)
    (<s*1> ^problem-space <p*1>)
    (<p*1> ^learning <l*1>)
    (<l*1> ^type exploration)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name init-remaining-operators + ^value <toc> +)
}

sp {apply*init-current-evaluation-depth*io*output
    (state <s> ^operator <op> ^io <i*1>)
    (<op> ^name init-current-evaluation-depth ^value { <> 0 <v> })
    (<i*1> ^output-link <ol>)
    -->
    (<ol> ^send-message <msg> +)
    (<msg> ^type begin-exploration +)
}

sp {apply*init-current-evaluation-depth
    (state <s> ^operator <op>)
    (<op> ^name init-current-evaluation-depth ^value <v>)
    -->
    (<s> ^current-evaluation-depth <v> +)
}

sp {selection*propose*init-current-evaluation-depth*top-selection
    (state <s> ^top-selection true -^current-evaluation-depth <c*1>
          ^name selection ^superstate <s*1>)
    (<s*1> ^problem-space <p*1>)
    (<p*1> ^learning <l*1>)
    (<l*1> ^type exploration)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name init-current-evaluation-depth + ^value 1 +)
}

sp {Impasse__Operator_Tie*compare*increment-current-evaluation-depth
    (state <s> ^operator <op2> + ^operator <op1> +)
    (<op2> ^name init-current-evaluation-depth)
    (<op1> ^name increment-current-evaluation-depth)
    -->
    (<s> ^operator <op1> < <op2>)
}

sp {apply*increment-current-evalaution*clean-up-evaluations
    (state <s> ^evaluation <e2> ^operator <op>)
    (<e2> ^value true)
    (<op> ^name increment-current-evaluation-depth
          ^current-evaluation-depth <ced>)
    -->
    (<s> ^evaluation <e2> -)
}

sp {apply*increment-current-evaluation-depth
    (state <s> ^operator <op> ^item-count <toc>)
    (<op> ^name increment-current-evaluation-depth
          ^next-evaluation-depth <ned> ^current-evaluation-depth <ced>)
    -->
    (<s> ^remaining-operators 0 - ^remaining-operators <toc> +
           ^current-evaluation-depth <ced> - ^current-evaluation-depth <ned> +)
}

sp {selection*propose*increment-current-evaluation-depth*45
    (state <s> ^top-selection true -^current-evaluation-depth { <> 4 <c*1> }
          -^remaining-operators { <> 0 <r*1> } ^name selection
          ^superstate <s*1>)
    (<s*1> ^problem-space <p*1>)
    (<p*1> ^learning <l*1>)
    (<l*1> ^type exploration)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name increment-current-evaluation-depth +
           ^current-evaluation-depth 4 + ^next-evaluation-depth 5 +)
}

sp {selection*propose*increment-current-evaluation-depth*34
    (state <s> ^top-selection true -^current-evaluation-depth { <> 3 <c*1> }
          -^remaining-operators { <> 0 <r*1> } ^name selection
          ^superstate <s*1>)
    (<s*1> ^problem-space <p*1>)
    (<p*1> ^learning <l*1>)
    (<l*1> ^type exploration)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name increment-current-evaluation-depth +
           ^current-evaluation-depth 3 + ^next-evaluation-depth 4 +)
}

sp {selection*propose*increment-current-evaluation-depth*23
    (state <s> ^top-selection true -^current-evaluation-depth { <> 2 <c*1> }
          -^remaining-operators { <> 0 <r*1> } ^name selection
          ^superstate <s*1>)
    (<s*1> ^problem-space <p*1>)
    (<p*1> ^learning <l*1>)
    (<l*1> ^type exploration)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name increment-current-evaluation-depth +
           ^current-evaluation-depth 2 + ^next-evaluation-depth 3 +)
}

sp {selection*propose*increment-current-evaluation-depth*12
    (state <s> ^top-selection true -^current-evaluation-depth { > 1 <c*1> }
          -^remaining-operators { <> 0 <r*1> } ^name selection
          ^superstate <s*1>)
    (<s*1> ^problem-space <p*1>)
    (<p*1> ^learning <l*1>)
    (<l*1> ^type exploration)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name increment-current-evaluation-depth +
           ^current-evaluation-depth 1 + ^next-evaluation-depth 2 +)
}

sp {evalaute-operator*propose*init-current-evaluation-depth
    (state <s> ^current-evaluation-depth <ced> ^superstate <s*1> ^operator <o>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^name evaluate-operator)
    (<o> ^name { <> exceed-depth <n*1> })
    -->
    (<s> ^current-evaluation-depth (- <ced> 1) +
           ^current-evaluation-depth <ced> -)
}

sp {apply*exceed-depth
    (state <s> ^operator <op> ^desired <d>)
    (<op> ^name exceed-depth)
    -->
    (<s> ^depth-exceeded <d> +)
}

sp {evaluate-operator*compare*exceed-depth
    (state <s> ^name evaluate-operator ^look-ahead-operator <op2>
          ^operator <op2> + ^operator <op1> +)
    (<op1> ^name exceed-depth)
    -->
    (<s> ^operator <op1> < <op2>)
}

sp {evaluate-operator*propose*exceed-depth
    (state <s> ^tried-tied-operator <o> ^look-ahead-operator <o>
          ^current-evaluation-depth { <= 0 <c*1> })
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name exceed-depth +)
}

sp {apply*increment-no-more-evaluations
    (state <s> ^operator <op> ^superstate <s*1>)
    (<op> ^name no-more-evaluations)
    (<s*1> ^superstate <s*2>)
    (<s*2> ^operator <o>)
    (<o> ^name evaluate-operator ^evaluation <e>)
    -->
    (<e> ^symbolic-value depth-exceeded +)
}

sp {selection*propose*no-more-evaluations
    (state <s> ^remaining-operators 0 -^top-selection true ^name selection)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name no-more-evaluations +)
}

sp {apply*all-evaluations-failed
    (state <s> ^operator <op> ^superstate <s*1>)
    (<op> ^name all-evaluations-failed)
    (<s*1> ^superstate <s*2>)
    (<s*2> ^operator <o>)
    (<o> ^name evaluate-operator ^evaluation <e>)
    -->
    (<e> ^symbolic-value failure +)
}

sp {selection*propose*all-evaluations-failed6
    (state <s> ^name selection -^top-selection true ^item-count 6
          ^evaluation <e6> ^evaluation { > <e6> <e5> }
          ^evaluation { > <e5> > <e6> <e4> }
          ^evaluation { > <e4> > <e5> > <e6> <e3> }
          ^evaluation { > <e3> > <e4> > <e5> > <e6> <e2> }
          ^evaluation { > <e2> > <e3> > <e4> > <e5> > <e6> <e1> })
    (<e6> ^symbolic-value failure)
    (<e5> ^symbolic-value failure)
    (<e4> ^symbolic-value failure)
    (<e3> ^symbolic-value failure)
    (<e2> ^symbolic-value failure)
    (<e1> ^symbolic-value failure)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name all-evaluations-failed +)
}

sp {selection*propose*all-evaluations-failed5
    (state <s> ^remaining-operators 0 -^top-selection true ^name selection
          ^item-count 5 ^evaluation <e5> ^evaluation { > <e5> <e4> }
          ^evaluation { > <e4> > <e5> <e3> }
          ^evaluation { > <e3> > <e4> > <e5> <e2> }
          ^evaluation { > <e2> > <e3> > <e4> > <e5> <e1> })
    (<e5> ^symbolic-value failure)
    (<e4> ^symbolic-value failure)
    (<e3> ^symbolic-value failure)
    (<e2> ^symbolic-value failure)
    (<e1> ^symbolic-value failure)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name all-evaluations-failed +)
}

sp {selection*propose*all-evaluations-failed4
    (state <s> ^remaining-operators 0 -^top-selection true ^name selection
          ^item-count 4 ^evaluation <e4> ^evaluation { > <e4> <e3> }
          ^evaluation { > <e3> > <e4> <e2> }
          ^evaluation { > <e2> > <e3> > <e4> <e1> })
    (<e4> ^symbolic-value failure)
    (<e3> ^symbolic-value failure)
    (<e2> ^symbolic-value failure)
    (<e1> ^symbolic-value failure)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name all-evaluations-failed +)
}

sp {selection*propose*all-evaluations-failed3
    (state <s> ^remaining-operators 0 -^top-selection true ^name selection
          ^item-count 3 ^evaluation <e3> ^evaluation { > <e3> <e2> }
          ^evaluation { > <e2> > <e3> <e1> })
    (<e3> ^symbolic-value failure)
    (<e2> ^symbolic-value failure)
    (<e1> ^symbolic-value failure)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name all-evaluations-failed +)
}

sp {selection*propose*all-evaluations-failed2
    (state <s> ^remaining-operators 0 -^top-selection true ^name selection
          ^item-count 2 ^evaluation <e2> ^evaluation { > <e2> <e1> })
    (<e2> ^symbolic-value failure)
    (<e1> ^symbolic-value failure)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name all-evaluations-failed +)
}

sp {selection*propose*init-current-evaluation-depth*middle-selection
    (state <s> ^name { << selection evaluate-operator >> <n*1> }
          -^top-selection true ^superstate <s*1>)
    (<s*1> ^current-evaluation-depth <ced>)
    -->
    (<s> ^current-evaluation-depth <ced> +)
}

sp {evaluate-operator*elaborate*state
    (state <s> ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^name evaluate-operator ^evaluation <e*1>)
    (<e*1> ^current-evaluation-depth <ced>)
    -->
    (<s> ^current-evaluation-depth <ced> +)
}

sp {selection*compare*evaluate-operator
    (state <s> ^name selection ^operator <op1> + ^superstate <s*1>)
    (<op1> -^current-evaluation-depth <c*1> ^name evaluate-operator)
    (<s*1> ^problem-space <p*1>)
    (<p*1> ^learning <l*1>)
    (<l*1> ^type exploration)
    -->
    (<s> ^operator <op1> -)
}

sp {apply*evaluate-operator*clean-up-evaluations2
    :o-support
    (state <s> ^operator <op>)
    (<op> ^name evaluate-operator ^current-evaluation-depth <ced>
          ^evaluation <e2>)
    (<e2> ^current-evaluation-depth { <> <ced> <c*1> })
    -->
    (<op> ^evaluation <e2> -)
}

sp {apply*evaluate-operator*clean-up-evaluations
    (state <s> ^evaluation <e2> ^operator <op>)
    (<e2> ^value true -^current-evaluation-depth <ced>)
    (<op> ^name evaluate-operator ^current-evaluation-depth <ced>)
    -->
    (<s> ^evaluation <e2> -)
}

sp {apply*decrement-remaining-operators
    (state <s> ^operator <op> ^remaining-operators <ro>)
    (<op> ^name decrement-remaining-operators)
    -->
    (<s> ^remaining-operators (- <ro> 1) + ^remaining-operators <ro> -)
}

sp {selection*propose*decrement-remaining-operators
    (state <s> ^name selection ^evaluation <e> ^remaining-operators <ro>
          ^current-evaluation-depth <ced>)
    (<e> ^value true ^remaining-operators <ro> ^current-evaluation-depth <ced>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name decrement-remaining-operators +)
}

sp {apply*exceed-depth*report*interaction
    (state <s> ^operator <op> ^io <i*1>)
    (<op> ^name achieved-max-depth)
    (<i*1> ^output-link <ol>)
    -->
    (<ol> ^send-message <msg> +)
    (<msg> ^type failure-exploration +)
}

sp {selection*propose*achieved-max-depth*more
    (state <s> ^name selection ^max-evaluation-depth <med>
          ^current-evaluation-depth { > <med> <med2> })
    -->
    (<s> ^operator <op> + ^operator <op> !)
    (<op> ^name achieved-max-depth +)
}

sp {selection*propose*achieved-max-depth
    (state <s> ^remaining-operators 0 ^name selection
          ^max-evaluation-depth <med> ^current-evaluation-depth <med>)
    -->
    (<s> ^operator <op> + ^operator <op> !)
    (<op> ^name achieved-max-depth +)
}

sp {selection*monitor*depth
    (state <s> ^top-selection true ^name selection ^remaining-operators <ro>
          ^current-evaluation-depth <ced>)
    -->
    
}

sp {selection*elaboration*top-selection
    (state <s> ^name selection -^problemspace games)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^superstate <s*2>)
      (<s*2> ^name selection)}
    -->
    (<s> ^top-selection true +)
}

sp {evaluate-operator*reject*next-waypoint*operator*visited*on*state
    (state <s> ^name evaluate-operator ^quiescence t ^visited <v>
          ^operator <op1> +)
    (<op1> ^next-waypoint <v>)
    -->
    (<s> ^operator <op1> -)
}

sp {evaluate-operator*reject*next-waypoint*operator*visited*on*evaluation
    (state <s> ^name evaluate-operator ^quiescence t ^superstate <s*1>
          ^operator <op1> +)
    (<op1> ^next-waypoint <v>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^evaluation <e*1>)
    (<e*1> ^visited <v>)
    -->
    (<s> ^operator <op1> -)
}

sp {apply*compute-evaluations
    (state <s> ^operator <op> ^superstate <ss>)
    (<op> ^name compute-evaluations ^op2 <so2> ^op1 <so1>)
    -->
    (<ss> ^operator <so1> > <so2>)
    (<s> ^compared <com> +)
    (<com> ^op1 <so1> + ^op2 <so2> +)
}

sp {selection*propose*compute-evaluations2
    (state <s> ^name selection ^evaluation <e2> ^evaluation { <> <e2> <e1> })
    (<e2> ^total-estimated-cost <t*1> ^superoperator <so2>)
    (<e1> ^final-cost { < <t*1> <fc> } ^superoperator <so1>)
   -{ (<s> ^compared <com>)
      (<com> ^op2 <so2> ^op1 <so1>)}
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name compute-evaluations + ^op1 <so1> + ^op2 <so2> +)
}

sp {selection*propose*compute-evaluations
    (state <s> ^name selection ^evaluation <e2> ^evaluation { <> <e2> <e1> })
    (<e2> ^final-cost <f*1> ^superoperator <so2>)
    (<e1> ^final-cost { < <f*1> <fc> } ^superoperator <so1>)
   -{ (<s> ^compared <com>)
      (<com> ^op2 <so2> ^op1 <so1>)}
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name compute-evaluations + ^op1 <so1> + ^op2 <so2> +)
}

sp {prefer*complete-location-question*over*describe-object*describe-object-location
    (state <s> ^name describe-object-location ^operator <o2> +
          ^operator <o1> +)
    (<o2> ^name complete-location-question)
    (<o1> ^name describe-object)
    -->
    (<s> ^operator <o2> > <o1>)
}

sp {describe-object-location*elaborate*copy-down-attrs
    (state <s> ^name describe-object-location ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^object <obj>)
    -->
    (<s> ^obj <obj> + ^descriptions <d> +)
}

sp {describe-object-location*apply*end-location-question
    (state <s> ^name describe-object-location ^operator <o> ^top-state <t*2>
          ^top-state <t*1>)
    (<o> ^name end-location-question)
    (<t*2> ^status <status>)
    (<t*1> ^io <i*1>)
    (<i*1> ^output-link <out>)
    -->
    (<out> ^send-message <msg> +)
    (<msg> ^type location-unknown + ^fields <f> +)
    (<status> ^performed <p*1> +)
    (<p*1> ^dialog-event <d*1> +)
    (<d*1> ^type explanation +)
}

sp {describe-object-location*propose*end-location-question*no-preps
    (state <s> ^name describe-object-location ^obj <o*1>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^prepositions <p*1>)
      (<p*1> ^prep <p*2>)
      (<p*2> ^pair <p*3>)
      (<p*3> ^a <obj>)}
    (<o*1> ^id <objid>)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name end-location-question +)
}

sp {describe-object-location*apply*complete-location-question
    (state <s> ^name describe-object-location ^operator <o> ^top-state <t*2>
          ^top-state <t*1>)
    (<o> ^name complete-location-question ^obj2 <desc2> ^obj1 <desc1>
          ^relation <rel>)
    (<t*2> ^status <status>)
    (<t*1> ^io <i*1>)
    (<i*1> ^output-link <out>)
    -->
    (<out> ^send-message <msg> +)
    (<msg> ^type describe-scene + ^fields <f> +)
    (<f> ^object1 <desc1> + ^object2 <desc2> + ^prep <rel> +)
    (<status> ^performed <p*1> +)
    (<p*1> ^dialog-event <d*1> +)
    (<d*1> ^type explanation +)
}

sp {describe-object-location*propose*complete-location-question
    (state <s> ^name describe-object-location ^obj2 <obj2> ^obj <obj1>
          ^descriptions <d> ^relation <rel>)
    (<d> ^obj-desc <objd2> ^obj-desc <objd1>)
    (<objd2> ^desc <desc2> ^object <obj2>)
    (<objd1> ^desc <desc1> ^object <obj1>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name complete-location-question + ^obj1 <desc2> + ^obj2 <desc1> +
           ^relation <rel> +)
}

sp {describe-object-location*apply*find-a-relation
    (state <s> ^name describe-object-location ^operator <o> ^obj <obj>)
    (<o> ^name find-a-relation ^obj <obj> ^obj2 <obj2> ^relation <rel>)
    -->
    (<s> ^obj2 <obj2> + ^relation <rel> +)
}

sp {describe-object-location*propose*find-a-relation
    (state <s> ^name describe-object-location -^relation <r*1>
          ^described <obj> ^obj <obj> ^top-state <t*2> ^top-state <t*1>)
    (<t*2> ^prepositions <p*1>)
    (<p*1> ^prep <p>)
    (<p> ^pair <pair> ^name <prep>)
    (<pair> ^b <id2> ^a <id1>)
    (<obj> ^id <id>)
    (<t*1> ^object <obj2>)
    (<obj2> ^id <id2>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name find-a-relation + ^obj <obj> + ^obj2 <obj2> +
           ^relation <prep> +)
}

sp {describe-object-location*apply*describe-object
    (state <s> ^name describe-object-location ^operator <o> ^descriptions <d>)
    (<o> ^name describe-object ^description <desc> ^object <obj>)
    -->
    (<s> ^described <obj> +)
    (<d> ^obj-desc <objd> +)
    (<objd> ^desc <desc> + ^object <obj> +)
}

sp {describe-object-location*propose*describe-object
    (state <s> ^name describe-object-location ^{ << obj obj2 >> <a*1> } <obj>
          -^described <obj>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name describe-object + ^object <obj> +)
}

sp {query-relation*apply*complete-query-relation*preposition-unknown
    (state <s> ^name query-relation -^described <d*1> ^relationships <r*1>
          ^operator <o*1> ^io <i*1>)
    (<r*1> ^failure prep-not-found)
    (<o*1> ^name complete-query-relation)
    (<i*1> ^output-link <out>)
    -->
    (<out> ^send-message <msg> +)
    (<msg> ^type no-prep + ^fields <f*1> +)
    (<f*1> ^object failure +)
}

sp {query-relation*apply*complete-query-relation
    (state <s> ^name query-relation ^operator <o*1> ^relationships <r>
          ^descriptions <d> ^top-state <t*1> ^io <i*1>)
    (<o*1> ^name complete-query-relation)
    (<t*1> ^interaction <i*2>)
    (<i*2> ^status <status>)
    (<i*1> ^output-link <out>)
    -->
    (<out> ^send-message <msg> +)
    (<msg> ^type list-objects + ^fields <f*1> +)
    (<f*1> ^objects <d> +)
    (<status> ^performed <p*1> +)
    (<p*1> ^dialog-event <d*1> +)
    (<d*1> ^type describe +)
}

sp {query-relation*propose*complete-query-relation
    (state <s> ^name query-relation ^relationships <r>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name complete-query-relation + ^category svs +)
}

sp {query-relation*apply*describe-object*record
    (state <s> ^name query-relation ^operator <o> ^relationships <r>
          ^descriptions <d> ^top-state <t*1>)
    (<o> ^name describe-object ^description <desc> ^object <obj>)
    (<t*1> ^io <i*1>)
    (<i*1> ^output-link <out>)
    -->
    (<s> ^described <obj> +)
    (<d> ^object <desc> +)
}

sp {query-relation*propose*describe-object
    (state <s> ^name query-relation ^relationships <r*1> ^top-state <t*1>
          -^described <obj>)
    (<r*1> ^relations <r*2>)
    (<r*2> ^obj <obj-id>)
    (<t*1> ^object <obj>)
    (<obj> ^id <obj-id>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name describe-object + ^category svs + ^object <obj> +)
}

sp {query-relation*propose*find-relations
    (state <s> ^name query-relation -^relationships <r*1> ^superstate <s*1>)
    (<s*1> ^operator <so>)
    (<so> ^message <m*1>)
    (<m*1> ^fields <f*1>)
    (<f*1> ^objects <objs>)
    (<objs> ^obj <object> ^type <prep>)
    (<object> ^id <id>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name find-relations + ^category svs + ^interaction true +
           ^obj <id> + ^ind 2 + ^prep <prep> +)
}

sp {query-relation*elaborate*copy-down-attrs*
    (state <s> ^name query-relation ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^descriptions <d>)
    -->
    (<s> ^descriptions <d> +)
}

sp {prefer*respond*with*description*over*find-relations
    (state <s> ^name query-relation ^operator <o2> + ^operator <o1> +)
    (<o2> ^name find-relations)
    (<o1> ^name describe-object)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*describe-object*over*complete-describe-objs
    (state <s> ^name query-relation ^operator <o2> + ^operator <o1> +)
    (<o2> ^name complete-describe-objs)
    (<o1> ^name describe-object)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*describe-object*over*complete-query-relation
    (state <s> ^name query-relation ^operator <o2> + ^operator <o1> +
          ^relationships <r>)
    (<o2> ^name complete-query-relation)
    (<o1> ^name describe-object)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {learn-preposition*apply*store-predicate*mark*stored
    (state <s> ^name learn-preposition ^operator <o> ^smem <s*1>)
    (<o> ^name store-predicate ^predicate <p>)
    (<s*1> ^command <cmd>)
    -->
    (<s> ^stored <p> +)
}

sp {learn-preposition*apply*store-predicate*store*relation
    (state <s> ^name learn-preposition ^operator <o> ^smem <s*1>)
    (<o> ^name store-predicate ^predicate <p*1>)
    (<s*1> ^command <cmd>)
    (<p*1> ^relation <r>)
    -->
    (<cmd> ^store <r> +)
}

sp {learn-preposition*apply*store-predicate*store*predicate
    (state <s> ^name learn-preposition ^operator <o> ^smem <s*1>)
    (<o> ^name store-predicate ^predicate <p>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^store <p> +)
}

sp {learn-preposition*propose*store-predicate
    (state <s> ^name learn-preposition ^predicate <p> -^stored <p>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name store-predicate + ^predicate <p> +)
}

sp {learn-preposition*apply*update-relation-distance*first*distance
    (state <s> ^name learn-preposition ^operator <o>)
    (<o> ^name update-relation-distance ^axis <a*1> ^relation <rel>)
    (<a*1> ^distance <d>)
    (<rel> ^count 0)
    -->
    (<rel> ^count 0 - ^count 1 + ^bottom 0.000000 + ^top 100.000000 +
           ^avg <d> + ^dist <d> + ^sum <d> + ^squaredsum (* <d> <d>) +)
}

sp {learn-preposition*apply*update-relation-distance*mark*added
    (state <s> ^name learn-preposition ^operator <o>)
    (<o> ^name update-relation-distance ^axis <axis>)
    -->
    (<axis> ^added true +)
}

sp {learn-preposition*elaborate*update-relation-distance*new-std-dev
    (state <s> ^name learn-preposition ^operator <o> +)
    (<o> ^name update-relation-distance ^new-sq-avg <sq-avg> ^new-avg <avg>)
    -->
    (<o> ^new-std-dev (sqrt (abs (- <sq-avg> (* <avg> <avg>)))) +)
    (interrupt)
}

sp {learn-preposition*elaborate*update-relation-distance*new-avg
    (state <s> ^name learn-preposition ^operator <o> +)
    (<o> ^name update-relation-distance ^new-count <count>
          ^new-squaredsum <sqsum> ^new-sum <sum>)
    -->
    (<o> ^new-avg (|/| <sum> <count>) + ^new-sq-avg (|/| <sqsum> <count>) +)
}

sp {learn-preposition*elaborate*update-relation-distance*new-info
    (state <s> ^name learn-preposition ^operator <o> +)
   -{ (<o> ^axis <a*2>)
      (<a*2> ^added <a*3>)}
    (<o> ^name update-relation-distance ^axis <a*1> ^relation <rel>)
    (<a*1> ^distance <d>)
    (<rel> ^squaredsum <sqsum> ^sum <sum> ^count <count>)
    -->
    (<o> ^new-sum (+ <sum> <d>) + ^new-squaredsum (+ <sqsum> (* <d> <d>)) +
           ^new-count (+ <count> 1) +)
}

sp {learn-preposition*propose*update-relation-distance
    (state <s> ^name learn-preposition ^instance-info <i*1> ^predicate <p*1>)
    (<i*1> ^axis <axis>)
    (<axis> -^added <a*1> ^case { << greater less >> <c*1> } ^name <axis-name>)
    (<p*1> ^relation <rel>)
    (<rel> ^axis <axis-name>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name update-relation-distance + ^relation <rel> + ^axis <axis> +)
}

sp {learn-preposition*apply*add-case-type
    (state <s> ^name learn-preposition ^operator <o>)
    (<o> ^name add-case-type ^case-type <type> ^relation <rel>)
    -->
    (<rel> ^type <type> +)
}

sp {learn-preposition*propose*add-case-type
    (state <s> ^name learn-preposition ^instance-info <i*1> ^predicate <p*1>)
    (<i*1> ^axis <axis>)
    (<axis> ^case <type> ^name <axis-name>)
    (<p*1> ^relation <rel>)
    (<rel> -^type <type> ^axis <axis-name>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name add-case-type + ^relation <rel> + ^case-type <type> +)
}

sp {learn-preposition*apply*check-new-relation*false*copy*predicate
    (state <s> ^name learn-preposition ^operator <o*1> ^relation-lti <rlti>)
    (<o*1> ^name check-new-relation)
    (<rlti> ^relation <r*1>)
    (<r*1> ^axis z)
    -->
    (<s> ^predicate <rlti> +)
}

sp {learn-preposition*check-new-relation*true*create*predicate
    (state <s> ^name learn-preposition ^relation-lti <rlti> ^operator <o*1>)
    (<rlti> -^relation <r*1>)
    (<o*1> ^name check-new-relation)
    -->
    (<s> ^predicate <rlti> +)
    (<rlti> ^relation <px> + ^relation <py> + ^relation <pz> +)
    (<px> ^axis x + ^count 0 +)
    (<py> ^axis y + ^count 0 +)
    (<pz> ^axis z + ^count 0 +)
}

sp {learn-preposition*propose*check-new-relation
    (state <s> ^name learn-preposition -^predicate <p*1> ^smem-result <s*1>
          ^relation-lti <r>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name check-new-relation + ^relation <r> +)
}

sp {learn-preposition*propose*smem-retrieve-full
    (state <s> ^name learn-preposition -^smem-result <s*1> -^predicate <p*1>
          ^relation-lti <r>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-retrieve-full + ^lti <r> +)
}

sp {learn-preposition*elaboroate*preposition-list
    (state <s> ^name learn-preposition ^top-state <t*1>)
    (<t*1> ^prepositions <p>)
    -->
    (<s> ^prep-list <p> +)
}

sp {learn-preposition*elaborate*axis-info
    (state <s> ^name learn-preposition)
    -->
    (<s> ^axis-info <i> +)
    (<i> ^axis <a*1> + ^axis <a*2> + ^axis <a*3> +)
    (<a*1> ^name x +)
    (<a*2> ^name y +)
    (<a*3> ^name z +)
}

sp {learn-preposition*elaborate*obj2
    (state <s> ^name learn-preposition ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^arg2 <obj>)
    -->
    (<s> ^obj2 <obj> +)
}

sp {learn-preposition*elaborate*obj1
    (state <s> ^name learn-preposition ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^arg1 <obj>)
    -->
    (<s> ^obj1 <obj> +)
}

sp {learn-preposition*elaborate*relation
    (state <s> ^name learn-preposition ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^relation-lti <rel>)
    -->
    (<s> ^relation-lti <rel> +)
}

sp {learn-preposition*apply*complete-learn-preposition*store*preps
    (state <s> ^name learn-preposition ^operator <o*1> ^predicate <p*1>
          ^top-state <t*1>)
    (<o*1> ^name complete-learn-preposition)
    (<t*1> ^prepositions <preps>)
    (<p*1> ^name <name>)
   -{ (<preps> ^prep <p*2>)
      (<p*2> ^name <name>)}
    -->
    (<preps> ^prep <p*3> +)
    (<p*3> ^name <name> +)
}

sp {learn-preposition*apply*complete-learn-preposition*mark*performed
    (state <s> ^name learn-preposition ^operator <o*1> ^top-state <t*1>
          ^io <i*1>)
    (<o*1> ^name complete-learn-preposition)
    (<t*1> ^interaction <i*2>)
    (<i*2> ^status <status>)
    (<i*1> ^output-link <ol>)
    -->
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <l*1> +)
    (<l*1> ^type relation +)
    (<ol> ^send-message <msg> +)
    (<msg> ^type confirmation +)
}

sp {learn-preposition*propose*complete-learn-preposition
    (state <s> ^name learn-preposition)
    -->
    (<s> ^operator <o> +)
    (<o> ^name complete-learn-preposition +)
}

sp {learn-preposition*prefer*store*over*complete
    (state <s> ^name learn-preposition ^operator <o2> + ^operator <o1> +)
    (<o2> ^name complete-learn-preposition)
    (<o1> ^name store-predicate)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {learn-preposition*prefer*learning*over*store*complete
    (state <s> ^name learn-preposition ^operator <o2> + ^operator <o1> +)
    (<o2> ^name { << store-predicate complete-learn-preposition >> <n*2> })
    (<o1>
          ^name { << smem-retrieve-full add-case-type update-relation-distance >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {learn-preposition*prefer*check-new-relation*first
    (state <s> ^name learn-preposition ^operator <o1> + ^operator <o2> +)
    (<o1> ^name check-new-relation)
    (<o2> ^name { <> check-new-relation <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {learn-preposition*elaborate*instance-info*case*less
    (state <s> ^name learn-preposition ^instance-info <i*1>)
    (<i*1> ^axis <a>)
    (<a> ^raw-value { < 0 <r*1> })
    -->
    (<a> ^case less +)
}

sp {learn-preposition*elaborate*instance-info*case*aligned
    (state <s> ^name learn-preposition ^instance-info <i*1>)
    (<i*1> ^axis <a>)
    (<a> ^raw-value 0.000000)
    -->
    (<a> ^case aligned +)
}

sp {learn-preposition*elaborate*instance-info*case*greater
    (state <s> ^name learn-preposition ^instance-info <i*1>)
    (<i*1> ^axis <a>)
    (<a> ^raw-value { > 0.000000 <r*1> })
    -->
    (<a> ^case greater +)
}

sp {learn-preposition*elaborate*instance-info*distance
    (state <s> ^name learn-preposition ^instance-info <i*1>)
    (<i*1> ^axis <a>)
    (<a> ^raw-value <v>)
    -->
    (<a> ^distance (abs <v>) +)
}

sp {learn-prepsition*extract-relations*copy*results
    (state <s> ^name learn-preposition ^instance-info <i> ^axis-filter <f>)
    (<f> ^axis <axis> ^result <r>)
    (<r> ^record <r*1>)
    (<r*1> ^value <v>)
    -->
    (<i> ^axis <a> +)
    (<a> ^name <axis> + ^raw-value <v> +)
}

sp {learn-preposition*elaborate*instance-info
    (state <s> ^name learn-preposition)
    -->
    (<s> ^instance-info <i> +)
}

sp {learn-preposition*extract-relations*extract_once*axis-distance
    (state <s> ^name learn-preposition ^axis-info <a*1> ^obj2 <o*2>
          ^obj1 <o*1> ^top-state <t*1>)
    (<a*1> ^axis <a*2>)
    (<o*2> ^belief-id <id2>)
    (<o*1> ^belief-id <id1>)
    (<t*1> ^svs <s*1>)
    (<s*1> ^command <cmd>)
    (<a*2> ^name <axis>)
    -->
    (<cmd> ^extract_once <f> +)
    (<s> ^axis-filter <f> +)
    (<f> ^a <NA> + ^b <NB> + ^type axis_distance + ^axis <axis> +)
    (<NA> ^type node + ^id <id2> +)
    (<NB> ^type node + ^id <id1> +)
}

sp {find-projection*apply*report-failure*copy*superstate
    (state <s> ^name find-projection ^operator <o> ^superstate <ss>)
    (<o> ^name report-failure ^failure-type <type>)
    -->
    (<ss> ^projection-result failure + ^find-projection-failure <type> +)
}

sp {find-projection*propose*report-failure*no-object
    (state <s> ^name find-projection ^argument-list <a*1> ^svs-link <s*1>)
    (<s*1> ^spatial-scene <scene>)
    (<a*1> ^<arg-num> <arg>)
   -{ (<arg> ^svs-obj <s*2>)
      (<s*2> ^id <id>)
      (<scene> ^child <c*1>)
      (<c*1> ^id <id>)}
    -->
    (<s> ^operator <o> + ^operator <o> > ^operator <o> =)
    (<o> ^name report-failure + ^failure-type no-object +)
}

sp {find-projection*propose*report-failure*no-relation
    (state <s> ^name find-projection ^retrieved-lti <rel> ^predicate <p*1>)
    (<rel> -^type <t*1>)
    (<p*1> ^relation <rel>)
    -->
    (<s> ^operator <o> + ^operator <o> > ^operator <o> =)
    (<o> ^name report-failure + ^failure-type no-relation +)
}

sp {find-projection*propose*report-failure*no-predicate*retrieved
    (state <s> ^predicate failure ^name find-projection)
    -->
    (<s> ^operator <o> + ^operator <o> > ^operator <o> =)
    (<o> ^name report-failure + ^failure-type no-predicate +)
}

sp {find-projection*propose*report-failure*no-predicate
    (state <s> ^name find-projection -^predicate-handle <p*1>)
    -->
    (<s> ^operator <o> + ^operator <o> > ^operator <o> =)
    (<o> ^name report-failure + ^failure-type no-predicate +)
}

sp {find-projection*project*svs*complete-projection
    (state <s> ^name find-projection ^calculate-placement-filter <f>
          ^operator <o*1> ^result <res> ^superstate <ss>)
    (<f> ^type calculate_placement ^b <b*1> ^a <a*1> ^result <r*1>)
    (<o*1> ^name calculate-placement)
    (<b*1> ^id <idb>)
    (<a*1> ^id <ida>)
    (<r*1> ^record <r*2>)
    (<r*2> ^value <pos>)
    (<pos> ^z <z> ^y <y> ^x <x>)
    -->
    (<ss> ^projection-result <result> +)
    (<result> ^x <x> + ^y <y> + ^z <z> + ^1 <ida> + ^2 <idb> +)
}

sp {find-projection*project*svs*create-projection*2-args*local
    (state <s> ^name find-projection ^predicate <p*1> ^operator <o>
          ^arg-list <a*2> ^arg-list <a*1> ^svs-link <s*3> ^result <res>)
    (<p*1> ^reference-frame local)
    (<o> ^name calculate-placement ^distances <d>)
    (<d> ^z <dz> ^y <dy> ^x <dx>)
    (<a*2> ^2 <v*2>)
    (<v*2> ^svs-obj <s*2>)
    (<a*1> ^1 <v*1>)
    (<v*1> ^svs-obj <s*1>)
    (<s*2> ^id <id2>)
    (<s*1> ^id <id1>)
    (<s*3> ^command <cmd>)
    -->
    (<cmd> ^extract_once <e> +)
    (<e> ^type calculate_placement + ^a <nodea> + ^b <nodeb> +
           ^reference <ref> + ^x_axis_separation <dx> +
           ^y_axis_separation <dy> + ^z_axis_separation <dz> +)
    (<nodea> ^type node + ^id <id1> +)
    (<nodeb> ^type node + ^id <id2> +)
    (<ref> ^type node + ^id robot +)
    (<s> ^calculate-placement-filter <e> +)
}

sp {find-projection*project*svs*create-projection*2-args*global
    (state <s> ^name find-projection ^operator <o> ^arg-list <a*2>
          ^arg-list <a*1> ^svs-link <s*3> ^result <res>)
   -{ (<s> ^predicate <p*1>)
      (<p*1> ^reference-frame local)}
    (<o> ^name calculate-placement ^distances <d>)
    (<d> ^z <dz> ^y <dy> ^x <dx>)
    (<a*2> ^2 <v*2>)
    (<v*2> ^svs-obj <s*2>)
    (<a*1> ^1 <v*1>)
    (<v*1> ^svs-obj <s*1>)
    (<s*2> ^id <id2>)
    (<s*1> ^id <id1>)
    (<s*3> ^command <cmd>)
    -->
    (<cmd> ^extract_once <e> +)
    (<e> ^type calculate_placement + ^a <nodea> + ^b <nodeb> +
           ^x_axis_separation <dx> + ^y_axis_separation <dy> +
           ^z_axis_separation <dz> +)
    (<nodea> ^type node + ^id <id1> +)
    (<nodeb> ^type node + ^id <id2> +)
    (<s> ^calculate-placement-filter <e> +)
}

sp {find-projection*elaborate*axis*distance*less
    (state <s> ^name find-projection ^operator <o> + ^predicate <p*1>)
    (<o> ^name calculate-placement ^distances <dists> ^types <t*1>)
    (<t*1> ^<axis> less)
    (<p*1> ^relation <rel>)
    (<rel> ^axis <axis> ^avg <dist>)
    -->
    (<dists> ^<axis> (- <dist>) +)
}

sp {find-projection*elaborate*axis*distance*aligned
    (state <s> ^name find-projection ^operator <o> +)
    (<o> ^name calculate-placement ^distances <dists> ^types <t*1>)
    (<t*1> ^<axis> aligned)
    -->
    (<dists> ^<axis> 0.000000 +)
}

sp {find-projection*elaborate*axis*distance*greater
    (state <s> ^name find-projection ^operator <o> + ^predicate <p*1>)
    (<o> ^name calculate-placement ^distances <dists> ^types <t*1>)
    (<t*1> ^<axis> greater)
    (<p*1> ^relation <rel>)
    (<rel> ^axis <axis> ^avg <dist>)
    -->
    (<dists> ^<axis> <dist> +)
}

sp {find-projection*propose*calculate-placement
    (state <s> ^name find-projection ^predicate <p*1>)
    (<p*1> ^relation <rz> ^relation <ry> ^relation <rx>)
    (<rz> ^axis z ^type <ztype>)
    (<ry> ^axis y ^type <ytype>)
    (<rx> ^axis x ^type <xtype>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name calculate-placement + ^types <types> + ^distances <dists> +)
    (<types> ^x <xtype> + ^y <ytype> + ^z <ztype> +)
}

sp {find-projection*elaborate*predicate*from*query-result
    (state <s> ^name find-projection ^smem-query <query>
          ^predicate-handle <pred-handle>)
    (<query> ^cue <c*1> ^result <id>)
    (<c*1> ^handle <pred-handle>)
    -->
    (<s> ^predicate <id> +)
}

sp {find-projection*elaborate*smem-query-cue*predicate
    (state <s> ^name find-projection ^predicate-handle <pred-handle>)
    -->
    (<s> ^smem-query <query> +)
    (<query> ^cue <cue> + ^depth 2 +)
    (<cue> ^handle <pred-handle> +)
}

sp {find-projection*elaborate*svs-link*top-state
    (state <s> ^name find-projection ^top-state <t*1>)
    (<t*1> ^svs <svs>)
    -->
    (<s> ^svs-link <svs> +)
}

sp {find-projection*elaborate*result
    (state <s> ^name find-projection)
    -->
    (<s> ^result <res> +)
}

sp {find-projection*elaborate*attributes*superoperator
    (state <s> ^name find-projection ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^arg-list <args> ^predicate-handle <pred-handle>)
    -->
    (<s> ^arg-list <args> + ^predicate-handle <pred-handle> +)
}

sp {find-relations*apply*complete-relations-search
    (state <s> ^name find-relations ^operator <o> ^relationships <rels>
          ^superstate <ss>)
    (<o> ^name complete-relations-search)
    -->
    (<ss> ^relationships <rels> +)
}

sp {find-relations*propose*complete-relations-search
    (state <s> ^name find-relations ^relationships <rels> ^prep <name>)
    (<rels> ^preposition <name>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name complete-relations-search + ^type true + ^category svs +)
}

sp {find-relations*apply*copy-relationship*three-args
    (state <s> ^name find-relations ^operator <o> ^relationships <rels>
          ^prep-link <p*1> ^prep { << linear-with >> <name> } ^prep-link <pl>
          ^obj <id>)
    (<o> ^name copy-relationships ^rel <rels>)
    (<p*1> ^prep2 <p>)
    (<p> ^name <name> ^pair <pair>)
    (<pair> ^a <id> ^c <id3> ^b <id2>)
    -->
    (<rels> ^relations <r> +)
    (<r> ^name <name> + ^obj1 <id2> + ^obj2 <id3> + ^matched true +)
}

sp {find-relations*apply*copy-relationship
    (state <s> ^name find-relations ^operator <o> ^relationships <rels>
          ^extract-prepositions <e*1> ^other <ind2> ^ind <ind> ^prep <name>
          ^obj <id> ^top-state <t*1>)
    (<o> ^name copy-relationships ^rel <rels>)
    (<e*1> ^extract-info <e*2>)
    (<e*2> ^result <r*1>)
    (<r*1> ^pair <pair>)
    (<pair> ^<ind> <id> ^<ind2> <bid2>)
    (<t*1> ^object <obj>)
    (<obj> ^belief-id <bid2> ^id <id2>)
    -->
    (<rels> ^relations <r> +)
    (<r> ^name <name> + ^obj <id2> + ^matched true +)
}

sp {find-relations*apply*copy-relationship*name
    (state <s> ^name find-relations ^operator <o> ^relationships <rels>
          ^prep <name>)
    (<o> ^name copy-relationships ^rel <rels>)
    -->
    (<rels> ^preposition <name> +)
}

sp {find-relations*propose*copy-relationship
    (state <s> ^name find-relations ^relationships <rels> ^prep <name>)
    (<rels> -^preposition <name>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name copy-relationships + ^rel <rels> +)
}

sp {find-relations*propose*relation-search*build-answerlist*id
    (state <s> ^name find-relations ^prep-link <pl> ^prep <type> ^obj <bid>
          ^top-state <t*1>)
    (<pl> ^prep <p*1>)
    (<p*1> ^name <type>)
    (<t*1> ^object <obj>)
    (<obj> ^belief-id <bid> ^id <id>)
    -->
    (<s> ^relationships <rels> +)
    (<rels> ^with <id> +)
}

sp {find-relations*elaborate*copy-down-attrs*prep
    (state <s> ^name find-relations ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^prep <prep>)
    -->
    (<s> ^prep <prep> +)
}

sp {find-relations*elaborate*copy-down-attrs*svs-no-link-usetop-state
    (state <s> ^name find-relations ^top-state <t*1> ^svs <svs>
          ^superstate <s*1>)
    (<t*1> ^prepositions <pre>)
    (<s*1> ^operator <o>)
    (<o> -^svs-link <s*2>)
    -->
    (<s> ^prep-link <pre> +)
}

sp {find-relations*elaborate*copy-down-attrs*svs-link
    (state <s> ^name find-relations ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^svs-link <svs>)
    -->
    (<s> ^svs-link <svs> + ^prep-link <pl> +)
}

sp {find-relations*elaborate*extract-prepositions*extract-info
    (state <s> ^name find-relations ^other <base> ^prep <name> ^obj <id>
          ^top-state <t*1>)
    (<t*1> ^found-prep <p>)
    (<p> ^type <name> ^predicate <pred>)
    -->
    (<s> ^extract-prepositions <e*1> +)
    (<e*1> ^extract-info <info> +)
    (<info> ^object-id <id> + ^prep <pred> + ^base <base> +)
}

sp {find-relations*elaborate*copy-down-attrs*ind2
    (state <s> ^name find-relations ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^ind 2)
    -->
    (<s> ^ind b + ^other a +)
}

sp {find-relations*elaborate*copy-down-attrs*ind1
    (state <s> ^name find-relations ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^ind 1)
    -->
    (<s> ^ind a + ^other b +)
}

sp {find-relations*elaborate*copy-down-attrs
    (state <s> ^name find-relations ^top-state <t*1> ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^obj <id>)
    (<t*1> ^object <obj>)
    (<obj> ^id <id> ^belief-id <bel-id>)
    -->
    (<s> ^obj <bel-id> +)
    (interrupt)
}

sp {lookup-preposition*elaborate*copy-down-attrs*type
    (state <s> ^name lookup-preposition ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^type <type>)
    -->
    (<s> ^prep <type> +)
}

sp {prefer*lookup-relations*over*complete-lookup-relations
    (state <s> ^name lookup-preposition ^operator <o2> + ^operator <o1> +)
    (<o2> ^name complete-lookup-relations)
    (<o1> ^name lookup-relations)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {lookup-smem*svs*relations*retrieved
    (state <s> ^name lookup-relations ^smem <s*1> ^superstate <s*2>
          ^superstate <ss>)
    (<s*1> ^result <res>)
    (<res> ^retrieved <ret>)
    (<s*2> ^operator <o*1>)
    (<o*1> ^lte <rel>)
    -->
    (<ss> ^relation <ret> +)
}

sp {lookup-smem*svs*relations*retrieve-lte
    (state <s> ^name lookup-relations ^smem <s*1> ^superstate <s*2>)
    (<s*1> ^command <sc>)
    (<s*2> ^operator <o*1>)
    (<o*1> ^lte <rel>)
    -->
    (<sc> ^retrieve <rel> +)
}

sp {lookup-smem*preposition*apply*complete-lookup-relations*add-to-top-state
    (state <s> ^name lookup-preposition ^operator <o>
          ^found-preposition <fprep> ^top-state <t*2> ^superstate <ss>)
    (<o> ^name complete-lookup-relations)
    (<fprep> ^type <type> ^predicate <p>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^prepositions <p*1>)
      (<p*1> ^prep <p*2>)
      (<p*2> ^name <type>)}
    (<t*2> ^prepositions <tprep>)
    -->
    (<ss> ^found-prep <fprep> +)
    (<tprep> ^prep <p*3> +)
    (<p*3> ^name <type> +)
}

sp {lookup-smem*preposition*apply*complete-lookup-relations
    (state <s> ^name lookup-preposition ^operator <o>
          ^found-preposition <fprep> ^superstate <ss>)
    (<o> ^name complete-lookup-relations)
    (<fprep> ^predicate <p>)
    -->
    (<ss> ^found-prep <fprep> +)
}

sp {lookup-smem*preposition*apply*complete-lookup-relations*top-state
    (state <s> ^name lookup-preposition ^operator <o*2> ^top-state <t*1>
          ^superstate <s*1>)
    (<o*2> ^name complete-lookup-relations)
    (<t*1> ^found-prep <fprep>)
    (<fprep> ^type <type>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^type <type>)
    -->
    (<s> ^found-preposition <fprep> +)
}

sp {lookup-smem*preposition*copy*predicate
    (state <s> ^status old ^name lookup-preposition ^operator <o*1>
          ^found-preposition <fprep> ^predicate <p1>)
    (<o*1> ^name complete-lookup-relations)
    -->
    (<fprep> ^predicate <p1> + ^stat old +)
}

sp {lookup-smem*preposition*copy*relations
    (state <s> ^status old ^name lookup-preposition ^found-preposition <fprep>
          ^relation <rel>)
    -->
    (<fprep> ^relation <rel> +)
}

sp {lookup-smem*preposition*propose*complete-lookup-relations*on-top-state
    (state <s> ^name lookup-preposition ^top-state <t*1> ^superstate <s*1>)
    (<t*1> ^found-prep <f*1>)
    (<f*1> ^type <type>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^type <type>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name complete-lookup-relations + ^category svs +)
}

sp {lookup-smem*preposition*propose*complete-lookup-relations
    (state <s> ^status old ^name lookup-preposition ^predicate <p1>
          ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^type <type>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name complete-lookup-relations + ^category svs +)
}

sp {lookup-smem*preposition*propose*lookup-relations
    (state <s> ^status old ^name lookup-preposition ^predicate <p1>
          ^superstate <s*1> -^relation <rel>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^type <type>)
    (<p1> ^relation <rel>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name lookup-relations + ^category svs + ^lte <rel> +)
}

sp {lookup-smem*preposition*query*success
    (state <s> ^name lookup-preposition ^smem <s*3> ^smem <s*2>
          ^superstate <s*1>)
    (<s*3> ^result <res>)
    (<res> ^retrieved <ret>)
    (<s*2> ^result <r*1>)
    (<r*1> ^success <cue>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^type <type>)
    -->
    (<s> ^predicate <ret> + ^status old +)
}

sp {lookup-smem*preposition*apply*complete-failure*after-interaction
    (state <s> ^interaction true ^name lookup-preposition
          ^found-preposition <fprep> ^top-state <t*1> ^superstate <ss>)
    (<fprep> ^stat default)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <s*2>)
    (<s*2> ^info <i*2>)
    (<i*2> ^status <s*3>)
    (<s*3> ^no-teaching true)
    -->
    (<ss> ^found-prep <fprep> +)
}

sp {lookup-smem*preposition*apply*complete-failure
    (state <s> ^name lookup-preposition -^interaction true
          ^found-preposition <fprep> ^superstate <ss>)
    (<fprep> ^stat default)
    -->
    (<ss> ^found-prep <fprep> +)
}

sp {lookup-smem*preposition*query*failure
    (state <s> ^name lookup-preposition ^found-preposition <fprep> ^smem <s*1>)
    (<s*1> ^result <r*1>)
    (<r*1> ^failure <cue>)
    -->
    (<fprep> ^stat default +)
}

sp {lookup-smem*preposition*smaller-than
    :o-support
    (state <s> ^name lookup-preposition ^superstate <s*1> ^superstate <ss>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^type smaller-than)
    -->
    (<ss> ^found-prep <fprep> +)
    (<fprep> ^prep <p*1> +)
    (<p*1> ^name smaller-than +)
}

sp {lookup-smem*preposition*query
    (state <s> ^name lookup-preposition ^smem <s*2> ^superstate <s*1>)
    (<s*2> ^command <sc>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^type <type>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^found-prep <f*1>)
      (<f*1> ^type <type>)}
    -->
    (<sc> ^query <q> +)
    (<s> ^found-preposition <fprep> +)
    (<fprep> ^type <type> +)
    (<q> ^prep-name <type> +)
}

sp {top-state*elaborate*extract-relations*result*predicate*instance
    (state <s> ^top-state <s> ^extract-relations <e*1> ^world <w*1>)
    (<e*1> ^extract-info <info>)
    (<info> ^x <x*1> ^relation <rel> ^object <obj1>)
    (<w*1> ^objects <o*1>)
    (<x*1> ^result <r*1>)
    (<r*1> ^record <r*2>)
    (<r*2> ^params <p>)
    (<p> ^b <id2>)
    (<o*1> ^object <obj2>)
    (<obj2> ^svs-obj <s*1>)
    (<s*1> ^id <id2>)
    -->
    (<rel> ^instance <args> +)
    (<args> ^1 <obj1> + ^2 <obj2> +)
}

sp {top-state*elaborate*extract-relations*extract-info
    (state <s> ^top-state <s> ^extract-relations <rels> ^world <w*2>
          ^world <w*1>)
    (<w*2> ^objects <o*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <pred>)
    (<pred> ^predicate-info <p*2>)
    (<p*2> ^item-type relation)
    (<o*1> ^object <obj>)
    -->
    (<rels> ^extract-info <i> +)
    (<i> ^object <obj> + ^relation <pred> +)
}

sp {top-state*elaborate*extract-relations
    (state <s> ^top-state <s>)
    -->
    (<s> ^extract-relations <rels> +)
}

sp {anystate*extract-relations*put*on*svs*command
    (state <s> ^extract-relations <e*1> ^svs <s*1>)
    (<e*1> ^extract-info <e>)
    (<e> ^x <filter>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^extract <filter> +)
    (<filter> ^mark test +)
}

sp {anystate*extract-relations*connect*z*belief-nodes
    (state <s> ^extract-relations <e*1>)
    (<e*1> ^extract-info <e>)
    (<e> ^z <z>)
    -->
    (<z> ^b <belief-nodes> +)
    (<belief-nodes> ^type tag_select + ^a <a*1> + ^tag_name object-source +
           ^tag_value belief +)
    (<a*1> ^type all_nodes +)
}

sp {anystate*extract-relations*connect*yz
    (state <s> ^extract-relations <e*1>)
    (<e*1> ^extract-info <e>)
    (<e> ^z <z> ^y <y>)
    -->
    (<y> ^b <z> +)
}

sp {anystate*extract-relations*connect*xy
    (state <s> ^extract-relations <e*1>)
    (<e*1> ^extract-info <e>)
    (<e> ^y <y> ^x <x>)
    -->
    (<x> ^b <y> +)
}

sp {anystate*extract-relations*extract-axis*copy*top*bottom
    (state <s> ^extract-relations <e*1>)
    (<e*1> ^extract-info <e>)
    (<e> ^relation <r*1> ^<axis> <axis-filter>)
    (<r*1> ^predicate-info <p*1>)
    (<p*1> ^relation <r>)
    (<r> ^axis <axis> ^top <top> ^bottom <bot>)
    -->
    (<axis-filter> ^bottom <bot> + ^top <top> +)
}

sp {anystate*extract-relations*extract-axis*copy*relation*types
    (state <s> ^extract-relations <e*1>)
    (<e*1> ^extract-info <e>)
    (<e> ^relation <r*1> ^<axis> <axis-filter>)
    (<r*1> ^predicate-info <p*1>)
    (<p*1> ^relation <r>)
    (<r> ^axis <axis> ^type <type>)
    -->
    (<axis-filter> ^<type> true +)
}

sp {anystate*extract-relations*extract-axis*initial
    (state <s> ^extract-relations <e*1>)
    (<e*1> ^extract-info <e>)
    (<e> ^relation <r*1> ^object <o*1>)
    (<r*1> ^predicate-info <p*1>)
    (<p*1> ^relation <r>)
    (<r> ^axis <axis>)
    (<o*1> ^svs-obj <s*1>)
    (<s*1> ^id <id>)
    -->
    (<e> ^<axis> <axis-filter> +)
    (<axis-filter> ^type axis_relation_select + ^axis <axis> + ^a <a> +)
    (<a> ^type node + ^id <id> + ^base a +)
}

sp {elaborate*status*unknown*task
    (state <s> ^choices none ^attribute state ^top-state <ts> ^superstate <ts>)
    (<ts> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^failure <f> +)
    (<f> ^type unknown-task +)
}

sp {anystate*overlap-command*apply*create-result*success*no-result
    (state <s> ^overlap-filter <filter> ^operator <o>)
    (<filter> -^result <r*1> ^status success)
    (<o> ^name overlap-command ^object-b <b> ^object-a <a>)
    -->
    (<s> ^overlap-command <o*1> +)
    (<o*1> ^result <r> +)
    (<r> ^object-a <a> + ^object-b <b> + ^overlap 0 +)
}

sp {anystate*apply*overlap-command*create-overlap-filter*failure
    (state <s> ^operator <o> ^overlap-filter <o*1>)
    (<o> ^name overlap-command ^object-b <b> ^object-a <a>)
    (<o*1> ^result <res>)
   -{ (<res> ^record <r*1>)
      (<r*1> ^value <v*1>)}
    -->
    (<s> ^overlap-command <o*2> +)
    (<o*2> ^result <r> +)
    (<r> ^object-a <a> + ^object-b <b> + ^overlap 0 +)
}

sp {anystate*apply*overlap-command*create-overlap-filter*success
    (state <s> ^operator <o> ^overlap-filter <o*1>)
    (<o> ^name overlap-command ^object-b <b> ^object-a <a>)
    (<o*1> ^result <r*1>)
    (<r*1> ^record <r*2>)
    (<r*2> ^value <val>)
    -->
    (<s> ^overlap-command <o*2> +)
    (<o*2> ^result <res> +)
    (<res> ^object-a <a> + ^object-b <b> + ^overlap <val> +)
}

sp {anystate*apply*overlap-command*create-overlap-filter*cleanup
    (state <s> ^operator <o*1> ^overlap-filter <over> ^top-state <t*1>)
    (<o*1> ^name overlap-command)
    (<t*1> ^svs <s*1>)
    (<s*1> ^command <cmd>)
    (<cmd> ^extract_once <over>)
    (<over> ^result <foo>)
    -->
    (<cmd> ^extract_once <over> -)
    (<s> ^overlap-filter <over> -)
}

sp {anystate*apply*overlap-command*create-overlap-filter
    (state <s> ^operator <o> ^top-state <t*1>)
    (<o> ^name overlap-command ^object-b <idb> ^object-a <ida>)
    (<t*1> ^svs <s*1>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^extract_once <overlap> +)
    (<overlap> ^type overlap + ^a <obja> + ^b <objb> +)
    (<obja> ^type node + ^id <ida> +)
    (<objb> ^type node + ^id <idb> +)
    (<s> ^overlap-filter <overlap> +)
}

sp {check-for-occlusion*apply*occlusion-command*debug-perception*report
    (state <s> ^name check-for-occlusion ^agent-params <a*1> ^operator <o*1>
          ^occlusion-amount <val> ^object-info <o*2>)
    (<a*1> ^debug-perception true)
    (<o*1> ^name occlusion-command)
    (<o*2> ^belief-obj <b*1>)
    (<b*1> ^id <id>)
    -->
    (write |Occlusion Result for | <id> | is | <val> (crlf))
}

sp {check-for-occlusion*apply*occlusion-command*report-to-superstate
    (state <s> ^report-to-superstate true ^name check-for-occlusion
          ^operator <o*1> ^object-occluded <bool> ^occlusion-amount <val>
          ^superstate <ss>)
    (<o*1> ^name occlusion-command)
    -->
    (<ss> ^object-occluded <bool> + ^occlusion-amount <val> +)
}

sp {check-for-occlusion*apply*occlusion-command*occluded*update*time
    (state <s> ^object-occluded true ^report-to-top-state true
          ^name check-for-occlusion ^operator <o*1> ^object-info <obj-info>
          ^occlusion-check-period <period> ^io <i*1>)
    (<o*1> ^name occlusion-command)
    (<obj-info> ^check-occlusion-time <old-t>)
    (<i*1> ^input-link <i*2>)
    (<i*2> ^time <t*1>)
    (<t*1> ^seconds <cur-t>)
    -->
    (<obj-info> ^check-occlusion-time <old-t> -
           ^check-occlusion-time (+ <cur-t> <period>) +)
}

sp {check-for-occlusion*apply*occlusion-command*occluded*create*time
    (state <s> ^object-occluded true ^report-to-top-state true
          ^name check-for-occlusion ^object-info <obj-info> ^operator <o*1>
          ^occlusion-check-period <period> ^io <i*1>)
    (<obj-info> -^check-occlusion-time <c*1>)
    (<o*1> ^name occlusion-command)
    (<i*1> ^input-link <i*2>)
    (<i*2> ^time <t*1>)
    (<t*1> ^seconds <cur-t>)
    -->
    (<obj-info> ^check-occlusion-time (+ <cur-t> <period>) +)
}

sp {check-for-occlusion*apply*occlusion-command*not*occluded*remove*flag
    (state <s> ^object-occluded false ^report-to-top-state true
          ^name check-for-occlusion ^operator <o*1> ^object-info <o*2>)
    (<o*1> ^name occlusion-command)
    (<o*2> ^status <status>)
    (<status> ^is-occluded true)
    -->
    (<status> ^is-occluded true -)
}

sp {check-for-occlusion*apply*occlusion-command*mark*occluded
    (state <s> ^object-occluded true ^report-to-top-state true
          ^name check-for-occlusion ^operator <o*1> ^object-info <o*2>)
    (<o*1> ^name occlusion-command)
    (<o*2> ^status <status>)
    -->
    (<status> ^is-occluded true +)
}

sp {check-for-occlusion*apply*occlusion-command*copy*object-occluded*false
    (state <s> ^name check-for-occlusion ^operator <o*1>
          ^occlusion-amount <o*2> ^occlusion-threshold { > <o*2> <threshold> })
    (<o*1> ^name occlusion-command)
    -->
    (<s> ^object-occluded false +)
}

sp {check-for-occlusion*apply*occlusion-command*copy*object-occluded*true
    (state <s> ^name check-for-occlusion ^operator <o*1>
          ^occlusion-amount <o*2>
          ^occlusion-threshold { <= <o*2> <threshold> })
    (<o*1> ^name occlusion-command)
    -->
    (<s> ^object-occluded true +)
}

sp {check-for-occlusion*apply*occlusion-command*copy*occlusion-amount
    (state <s> ^name check-for-occlusion ^operator <o*1>
          ^occlusion-command <o*2>)
    (<o*1> ^name occlusion-command)
    (<o*2> ^result <val>)
    -->
    (<s> ^occlusion-amount <val> +)
}

sp {check-for-occlusion*apply*issue-occlusion-reset*remove*occlusion-filter
    (state <s> ^name check-for-occlusion ^operator <o*1>
          ^occlusion-filter <filter>)
    (<o*1> ^name issue-occlusion-reset)
    -->
    (<s> ^occlusion-filter <filter> -)
}

sp {check-for-occlusion*apply*issue-occlusion-reset*remove*filter
    (state <s> ^name check-for-occlusion ^operator <o*1>
          ^occlusion-filter <filter> ^top-state <t*1>)
    (<o*1> ^name issue-occlusion-reset)
    (<t*1> ^svs <s*1>)
    (<s*1> ^command <cmd>)
    (<cmd> ^extract_once <filter>)
    -->
    (<cmd> ^extract_once <filter> -)
}

sp {check-for-occlusion*apply*issue-occlusion-reset*Remove*redo
    (state <s> ^redo-command true ^name check-for-occlusion ^operator <o*1>)
    (<o*1> ^name issue-occlusion-reset)
    -->
    (<s> ^redo-command true -)
}

sp {check-for-occlusion*issue*reset
    (state <s> ^redo-command true ^name check-for-occlusion)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name issue-occlusion-reset +)
}

sp {check-for-occlusion*propose*occlusion-command
    (state <s> ^name check-for-occlusion -^redo-command <r*1>
          ^candidate-set <cand> ^object-info <o*1>)
    (<o*1> ^belief-obj <b*1>)
    (<b*1> ^id <id>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name occlusion-command + ^object-id <id> + ^candidate-set <cand> +)
}

sp {check-for-occlusion*propose*occlusion-command*with*perception-obj
    (state <s> ^name check-for-occlusion ^object-info <obj-info>)
    (<obj-info> ^perception-obj <p*1> ^perception-id <perc-id>
          ^belief-obj <b*1>)
    (<p*1> ^id <perc-id>)
    (<b*1> ^id <id>)
    -->
    (<s> ^candidate-set <cand> +)
    (<cand> ^type combine_nodes + ^a <arm> + ^a <filtered-p-objs> +)
    (<arm> ^type node + ^id arm +)
    (<filtered-p-objs> ^type remove_node + ^id <perc-id> + ^a <perc-objs> +)
    (<perc-objs> ^type tag_select + ^a <a*1> + ^tag_name object-source +
           ^tag_value perception +)
    (<a*1> ^type all_nodes +)
}

sp {check-for-occlusion*propose*occlusion-command*no-perception-obj
    (state <s> ^name check-for-occlusion ^object-info <obj-info>)
    (<obj-info> ^perception-id <pid> ^belief-obj <b*1>)
   -{ (<obj-info> ^perception-obj <p*1>)
      (<p*1> ^id <pid>)}
    (<b*1> ^id <id>)
    -->
    (<s> ^candidate-set <cand> +)
    (<cand> ^type combine_nodes + ^a <arm> + ^a <perc-objs> +)
    (<arm> ^type node + ^id arm +)
    (<perc-objs> ^type tag_select + ^a <a*1> + ^tag_name object-source +
           ^tag_value perception +)
    (<a*1> ^type all_nodes +)
}

sp {check-for-occlusion*elaborate*agent-params*occlusion-threshold
    (state <s> ^name check-for-occlusion ^agent-params <a*1>)
    (<a*1> ^occlusion-threshold <t>)
    -->
    (<s> ^occlusion-threshold <t> +)
}

sp {check-for-occlusion*elaborate*agent-params*occlusion-check-period
    (state <s> ^name check-for-occlusion ^agent-params <a*1>)
    (<a*1> ^occlusion-check-period <p>)
    -->
    (<s> ^occlusion-check-period <p> +)
}

sp {check-for-occlusion*elaborate*report-to-top-state*default
    (state <s> ^name check-for-occlusion ^superstate <s*1>)
    (<s*1> ^operator <op>)
    (<op> -^report-to-top-state <r*1>)
    -->
    (<s> ^report-to-top-state true +)
}

sp {check-for-occlusion*elaborate*report-to-top-state*copy
    (state <s> ^name check-for-occlusion ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^report-to-top-state <bool>)
    -->
    (<s> ^report-to-top-state <bool> +)
}

sp {check-for-occlusion*elaborate*report-to-superstate*default
    (state <s> ^name check-for-occlusion ^superstate <s*1>)
    (<s*1> ^operator <op>)
    (<op> -^report-to-superstate <r*1>)
    -->
    (<s> ^report-to-superstate false +)
}

sp {check-for-occlusion*elaborate*report-to-superstate*copy
    (state <s> ^name check-for-occlusion ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^report-to-superstate <bool>)
    -->
    (<s> ^report-to-superstate <bool> +)
}

sp {check-for-occlusion*elaborate*object-info
    (state <s> ^name check-for-occlusion ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^object-info <obj-info>)
    -->
    (<s> ^object-info <obj-info> +)
}

sp {anystate*intersect-command*apply*create-result*success*no-result
    (state <s> ^intersect-filter <filter> ^operator <o*1>
          ^intersect-command <icmd>)
    (<filter> -^result <r*1> ^status success)
    (<o*1> ^name intersect-command)
    -->
    (<icmd> ^result none +)
}

sp {anystate*apply*intersect-command*create-intersect-filter*failure*no-result
    (state <s> ^operator <o*1> ^intersect-filter <i*1>
          ^intersect-command <icmd>)
    (<o*1> ^name intersect-command)
    (<i*1> ^result <res>)
   -{ (<res> ^record <r*1>)
      (<r*1> ^value true)}
    -->
    (<icmd> ^result none +)
}

sp {anystate*apply*intersect-command*create-intersect-filter*success
    (state <s> ^operator <o*1> ^intersect-filter <i*1>
          ^intersect-command <icmd>)
    (<o*1> ^name intersect-command)
    (<i*1> ^result <r*1>)
    (<r*1> ^record <rec>)
    (<rec> ^value true ^params <p*1>)
    (<p*1> ^b <id>)
    -->
    (<icmd> ^result <id> +)
}

sp {anystate*apply*intersect-command*create-intersect-filter*cleanup
    (state <s> ^operator <o*1> ^intersect-filter <intersect> ^top-state <t*1>)
    (<o*1> ^name intersect-command)
    (<t*1> ^svs <s*1>)
    (<s*1> ^command <cmd>)
    (<cmd> ^extract_once <intersect>)
    (<intersect> ^result <res>)
    -->
    (<cmd> ^extract_once <intersect> -)
    (<s> ^intersect-filter <intersect> -)
}

sp {anystate*apply*intersect-command*create-intersect-filter
    (state <s> ^operator <o> ^top-state <t*1>)
    (<o> ^name intersect-command ^used-candidate-set <candidates>
          ^object-id <id>)
    (<t*1> ^svs <s*1>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^extract_once <intersect> +)
    (<intersect> ^type intersect + ^a <obj> + ^b <candidates> +
           ^intersect_type hull +)
    (<obj> ^type node + ^id <id> +)
    (<s> ^intersect-filter <intersect> + ^intersect-command <f> +)
}

sp {anystate*elaborate*intersect-command*candidate-set
    (state <s> ^operator <o> +)
    (<o> ^name intersect-command ^candidate-set <set>)
    -->
    (<o> ^used-candidate-set <set> +)
}

sp {anystate*elaborate*intersect-command*default*candidate-set
    (state <s> ^operator <o> +)
    (<o> -^candidate-set <c*1> ^name intersect-command)
    -->
    (<o> ^used-candidate-set <u*1> +)
    (<u*1> ^type all_nodes +)
}

sp {anystate*closest-command*apply*create-result*success*no-result
    (state <s> ^closest-filter <filter> ^operator <o*1>)
    (<filter> -^result <r*1> ^status success)
    (<o*1> ^name closest-command)
    -->
    (<s> ^closest-command <c*1> +)
    (<c*1> ^result none +)
}

sp {anystate*closest-command*apply*create-result*failure*no-result
    (state <s> ^operator <o> ^closest-filter <c*1>)
    (<o> ^name closest-command ^object-id <id>)
    (<c*1> ^result <res>)
   -{ (<res> ^record <r*1>)
      (<r*1> ^params <p*1>)
      (<p*1> ^b <foo>)}
    -->
    (<s> ^closest-command <c*2> +)
    (<c*2> ^result none +)
}

sp {anystate*closest-command*apply*create-result*failure*same-id
    (state <s> ^operator <o> ^closest-filter <c*1>)
    (<o> ^name closest-command ^object-id <id>)
    (<c*1> ^result <r*1>)
    (<r*1> ^record <r*2>)
    (<r*2> ^params <p*1>)
    (<p*1> ^b <id>)
    -->
    (<s> ^closest-command <c*2> +)
    (<c*2> ^result none +)
}

sp {anystate*closest-command*apply*create-result*success
    (state <s> ^operator <o> ^closest-filter <c*1>)
    (<o> ^name closest-command ^object-id <id>)
    (<c*1> ^result <r*1>)
    (<r*1> ^record <r*2>)
    (<r*2> ^params <p*1>)
    (<p*1> ^b { <> <id> <closest-id> })
    -->
    (<s> ^closest-command <c*2> +)
    (<c*2> ^result <closest-id> +)
}

sp {anystate*closest-command*apply*create-closest-filter*cleanup
    (state <s> ^operator <o*1> ^closest-filter <closest> ^top-state <t*1>)
    (<o*1> ^name closest-command)
    (<t*1> ^svs <s*1>)
    (<s*1> ^command <cmd>)
    (<cmd> ^extract_once <closest>)
    (<closest> ^result <res>)
    -->
    (<cmd> ^extract_once <closest> -)
}

sp {anystate*closest-command*apply*create-closest-filter
    (state <s> ^operator <o> ^top-state <t*1>)
    (<o> ^name closest-command ^used-candidate-set <candidates>
          ^object-id <id>)
    (<t*1> ^svs <s*1>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^extract_once <closest> +)
    (<closest> ^type closest + ^distance_type centroid + ^a <obj> +
           ^b <candidates> +)
    (<obj> ^type node + ^id <id> +)
    (<s> ^closest-filter <closest> +)
}

sp {anystate*closest-command*elaborate*used-candidate-set*copy
    (state <s> ^operator <o> +)
    (<o> ^name closest-command ^candidate-set <cand>)
    -->
    (<o> ^used-candidate-set <cand> +)
}

sp {anystate*closest-command*elaborate*used-candidate-set*default
    (state <s> ^operator <o> +)
    (<o> -^candidate-set <c*1> ^name closest-command)
    -->
    (<o> ^used-candidate-set <u*1> +)
    (<u*1> ^type all_nodes +)
}

sp {anystate*distance-command*apply*create-result*success*no-result
    (state <s> ^distance-filter <filter> ^operator <o*1>)
    (<filter> -^result <r*1> ^status success)
    (<o*1> ^name distance-command)
    -->
    (<s> ^distance-command <d*1> +)
    (<d*1> ^result none +)
}

sp {anystate*distance-command*apply*create-result*failure
    (state <s> ^operator <o*1> ^distance-filter <d*1>)
    (<o*1> ^name distance-command)
    (<d*1> ^result <res>)
   -{ (<res> ^record <r*1>)
      (<r*1> ^value <v*1>)}
    -->
    (<s> ^distance-command <d*2> +)
    (<d*2> ^result none +)
}

sp {anystate*distance-command*apply*create-result*success
    (state <s> ^operator <o*1> ^distance-filter <d*1>)
    (<o*1> ^name distance-command)
    (<d*1> ^result <r*1>)
    (<r*1> ^record <r*2>)
    (<r*2> ^value <dist>)
    -->
    (<s> ^distance-command <d*2> +)
    (<d*2> ^result <dist> +)
}

sp {anystate*distance-command*apply*distance-command*cleanup
    (state <s> ^operator <o*1> ^distance-filter <dist> ^top-state <t*1>)
    (<o*1> ^name distance-command)
    (<t*1> ^svs <s*1>)
    (<s*1> ^command <cmd>)
    (<cmd> ^extract_once <dist>)
    (<dist> ^result <foo>)
    -->
    (<cmd> ^extract_once <dist> -)
}

sp {anystate*distance-command*apply*create-distance-filter
    (state <s> ^operator <o> ^top-state <t*1>)
    (<o> ^name distance-command ^object-b <idb> ^object-a <ida>
          ^used-distance-type <type>)
    (<t*1> ^svs <s*1>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^extract_once <distance> +)
    (<distance> ^type distance + ^distance_type <type> + ^a <obja> +
           ^b <objb> +)
    (<obja> ^type node + ^id <ida> +)
    (<objb> ^type node + ^id <idb> +)
    (<s> ^distance-filter <distance> +)
}

sp {anystate*distance-command*elaborate*used-distance-type*copy
    (state <s> ^operator <o> +)
    (<o> ^name distance-command ^distance-type <type>)
    -->
    (<o> ^used-distance-type <type> +)
}

sp {anystate*distance-command*elaborate*used-distance-type*default
    (state <s> ^operator <o> +)
    (<o> -^distance-type <d*1> ^name distance-command)
    -->
    (<o> ^used-distance-type centroid_distance +)
}

sp {occlusion-command*state-no-change*redo*occlusion*operator
    (state <s> ^impasse no-change ^attribute state ^superstate <ss>
          ^superstate <s*1> ^agent-params <a*1>)
   -{ (<ss> ^occlusion-command <o*1>)
      (<o*1> ^result <r*1>)}
    (<s*1> ^name occlusion-command)
    (<a*1> ^debug-perception <flag>)
    (<ss> ^superstate <sss>)
    (<sss> ^operator <o>)
    (<o> ^name occlusion-command)
    -->
    (<sss> ^redo-command true +)
    (write (ifeq <flag> true (concat |Have to redo occlusion check| (crlf)) ||))
}

sp {anystate*occlusion-command*apply*create-result*success*no-result
    (state <s> ^occlusion-filter <filter> ^operator <o*1>)
    (<filter> -^result <r*1> ^status success)
    (<o*1> ^name occlusion-command)
    -->
    (<s> ^occlusion-command <o*2> +)
    (<o*2> ^result 0 +)
}

sp {anystate*occlusion-command*apply*create-result*failure
    (state <s> ^operator <o*1> ^occlusion-filter <o*2>)
    (<o*1> ^name occlusion-command)
    (<o*2> ^result <res>)
   -{ (<res> ^record <r*1>)
      (<r*1> ^value <val>)}
    -->
    (<s> ^occlusion-command <o*3> +)
    (<o*3> ^result 0 +)
}

sp {anystate*occlusion-command*apply*create-result*success
    (state <s> ^operator <o*1> ^occlusion-filter <o*2>)
    (<o*1> ^name occlusion-command)
    (<o*2> ^result <r*1>)
    (<r*1> ^record <r*2>)
    (<r*2> ^value <val>)
    -->
    (<s> ^occlusion-command <o*3> +)
    (<o*3> ^result <val> +)
}

sp {anystate*occlusion-command*apply*cleanup
    (state <s> ^operator <o*1> ^occlusion-filter <occlusion> ^top-state <t*1>)
    (<o*1> ^name occlusion-command)
    (<t*1> ^svs <s*1>)
    (<s*1> ^command <cmd>)
    (<cmd> ^extract_once <occlusion>)
    (<occlusion> ^result <res>)
    -->
    (<cmd> ^extract_once <occlusion> -)
}

sp {anystate*occlusion-command*apply*create-occlusion-filter
    (state <s> ^operator <o> ^top-state <t*1>)
    (<o> ^name occlusion-command ^used-eye <eye>
          ^used-candidate-set <candidates> ^object-id <id>)
    (<t*1> ^svs <s*1>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^extract_once <occlusion> +)
    (<occlusion> ^type occlusion + ^a <node> + ^b <candidates> + ^eye <eye> +)
    (<node> ^type node + ^id <id> +)
    (<s> ^occlusion-filter <occlusion> +)
}

sp {anystate*occlusion-command*elaborate*used-eye*copy
    (state <s> ^operator <o> +)
    (<o> ^name occlusion-command ^eye <eye>)
    -->
    (<o> ^used-eye <eye> +)
}

sp {anystate*occlusion-command*elaborate*used-eye*default
    (state <s> ^operator <o> +)
    (<o> -^eye <e*1> ^name occlusion-command)
    -->
    (<o> ^used-eye <eye> +)
    (<eye> ^type node + ^id eye +)
}

sp {anystate*occlusion-command*elaborate*used-candidate-set*copy
    (state <s> ^operator <o> +)
    (<o> ^name occlusion-command ^candidate-set <cand>)
    -->
    (<o> ^used-candidate-set <cand> +)
}

sp {anystate*occlusion-command*elaborate*used-candidate-set*default
    (state <s> ^operator <o> +)
    (<o> -^candidate-set <c*1> ^name occlusion-command)
    -->
    (<o> ^used-candidate-set <u*1> +)
    (<u*1> ^type all_nodes +)
}

sp {convert-TCN-to-NL*apply*complete-state
    (state <s> ^name convert-TCN-to-NL ^description <d> ^operator <o*1>
          ^tcn <tcn> ^superstate <ss>)
   -{ (<s> ^sentence <se>)
      (<d> -^sentence <se>)}
    (<o*1> ^name complete-state)
    -->
    (<ss> ^description <d> +)
}

sp {convert-TCN-to-NL*apply*complete-state*copy-sentences
    (state <s> ^name convert-TCN-to-NL ^operator <o*1> ^description <d>
          ^sentence <sent>)
    (<o*1> ^name complete-state)
    -->
    (<d> ^sentence <sent> +)
}

sp {convert-TCN-to-NL*propose*complete-state
    (state <s> ^name convert-TCN-to-NL)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name complete-state + ^category svs +)
}

sp {prefer*convert-TCN-to-NL*create-sentence*prefer*mentioned-similar-objects
    (state <s> ^name convert-TCN-to-NL ^operator <o2> +
          ^operator { <> <o2> <o1> } + ^state-rep <s*2> ^state-rep <s*1>
          ^param <p*2> ^param <p*1>)
    (<o2> ^name create-sentence ^condition <cond2>)
    (<o1> ^name create-sentence ^condition <cond1>)
    (<s*2> ^object-desc-set <o*2>)
    (<o*2> ^obj-desc <objd2>)
    (<objd2> -^mentioned true ^id <idb>)
    (<s*1> ^object-desc-set <o*1>)
    (<o*1> ^obj-desc { <> <objd2> <objd> })
    (<objd> ^mentioned true ^same-description <objd2> ^id <id>)
   -{ (<s> ^state-rep <s*4> ^state-rep <s*3> ^param <p*4> ^param <p*3>)
      (<s*4> ^object-desc-set <o*4>)
      (<o*4> ^obj-desc <objd4>)
      (<objd4> ^mentioned true ^same-description { <> <objd4> <objd3> }
            ^id <idd>)
      (<objd3> -^mentioned true ^id <idc>)
      (<s*3> ^object-desc-set <o*3>)
      (<o*3> ^obj-desc <objd3>)
      (<p*4> ^<arg4> <a*8>)
      (<a*8> ^id <idd>)
      (<cond2> ^{ << 1 2 3 >> <a*6> } <arg4>)
      (<p*3> ^<arg3> <a*7>)
      (<a*7> ^id <idc>)
      (<cond1> ^{ << 1 2 3 >> <a*5> } <arg3>)}
    (<p*2> ^<arg2> <a*2>)
    (<a*2> ^id <idb>)
    (<cond2> ^{ << 1 2 3 >> <a*4> } <arg2>)
    (<p*1> ^<arg1> <a*1>)
    (<a*1> ^id <id>)
    (<cond1> ^{ << 1 2 3 >> <a*3> } <arg1>)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {convert-TCN-to-NL*apply*create-sentence*INDEF*bINDEF
    (state <s> ^name convert-TCN-to-NL ^operator <o> ^count <c>
          ^state-rep <s*1> ^param <p*1>)
    (<o> ^name create-sentence ^condition <cond> ^count <c>)
    (<cond> -^3 <v*1> ^2 INDEF ^btype <type> ^negative <bool> ^1 <arga>
          ^name <prep>)
    (<s*1> ^object-desc-set <o*1>)
    (<o*1> ^obj-desc <objd>)
    (<objd> -^mentioned true ^id <id>)
    (<p*1> ^<arga> <a*1>)
    (<a*1> ^id <id>)
    -->
    (<s> ^count <c> - ^count (+ 1 <c>) + ^sentence <sent> +)
    (<sent> ^condition <cond> + ^object1 <objd> + ^object2 <objd2> +
           ^1 <aspec> + ^2 <bspec> + ^word <prep> + ^prep <prep> +
           ^order <c> + ^negative <bool> +)
    (<aspec> ^specifier a +)
    (<bspec> ^specifier a +)
    (<objd2> ^word <type> +)
}

sp {convert-TCN-to-NL*apply*create-sentence*DEF*bINDEF
    (state <s> ^name convert-TCN-to-NL ^operator <o> ^count <c>
          ^state-rep <s*1> ^param <p*1>)
    (<o> ^name create-sentence ^condition <cond> ^count <c>)
    (<cond> -^3 <v*1> ^2 INDEF ^btype <type> ^negative <bool> ^1 <arga>
          ^name <prep>)
    (<s*1> ^object-desc-set <o*1>)
    (<o*1> ^obj-desc <objd>)
    (<objd> ^mentioned true ^id <id>)
    (<p*1> ^<arga> <a*1>)
    (<a*1> ^id <id>)
    -->
    (<s> ^count <c> - ^count (+ 1 <c>) + ^sentence <sent> +)
    (<sent> ^condition <cond> + ^object1 <objd> + ^object2 <objd2> +
           ^1 <aspec> + ^2 <bspec> + ^word <prep> + ^prep <prep> +
           ^order <c> + ^negative <bool> +)
    (<aspec> ^specifier the +)
    (<bspec> ^specifier a +)
    (<objd2> ^word <type> +)
}

sp {convert-TCN-to-NL*apply*create-sentence*INDEFDEF
    (state <s> ^name convert-TCN-to-NL ^operator <o> ^count <c>
          ^state-rep <s*2> ^state-rep <s*1> ^param <p*2> ^param <p*1>)
    (<o> ^name create-sentence ^condition <cond> ^count <c>)
    (<cond> -^3 <v*1> ^negative <bool> ^2 <argb> ^1 <arga> ^name <prep>)
    (<s*2> ^object-desc-set <o*2>)
    (<o*2> ^obj-desc <objd2>)
    (<objd2> ^mentioned true ^id <idb>)
    (<s*1> ^object-desc-set <o*1>)
    (<o*1> ^obj-desc { <> <objd2> <objd> })
    (<objd> -^mentioned true ^id <id>)
    (<p*2> ^<argb> <a*2>)
    (<a*2> ^id <idb>)
    (<p*1> ^<arga> <a*1>)
    (<a*1> ^id <id>)
    -->
    (<s> ^count <c> - ^count (+ 1 <c>) + ^sentence <sent> +)
    (<sent> ^condition <cond> + ^object1 <objd> + ^object2 <objd2> +
           ^1 <aspec> + ^2 <bspec> + ^prep <prep> + ^word <prep> +
           ^order <c> + ^negative <bool> +)
    (<aspec> ^specifier a +)
    (<bspec> ^specifier the +)
}

sp {convert-TCN-to-NL*apply*create-sentence*DEFINDEF
    (state <s> ^name convert-TCN-to-NL ^operator <o> ^count <c>
          ^state-rep <s*2> ^state-rep <s*1> ^param <p*2> ^param <p*1>)
    (<o> ^name create-sentence ^condition <cond> ^count <c>)
    (<cond> -^3 <v*1> ^negative <bool> ^2 <argb> ^1 <arga> ^name <prep>)
    (<s*2> ^object-desc-set <o*2>)
    (<o*2> ^obj-desc <objd2>)
    (<objd2> -^mentioned true ^id <idb>)
    (<s*1> ^object-desc-set <o*1>)
    (<o*1> ^obj-desc { <> <objd2> <objd> })
    (<objd> ^mentioned true ^id <id>)
    (<p*2> ^<argb> <a*2>)
    (<a*2> ^id <idb>)
    (<p*1> ^<arga> <a*1>)
    (<a*1> ^id <id>)
    -->
    (<s> ^count <c> - ^count (+ 1 <c>) + ^sentence <sent> +)
    (<sent> ^condition <cond> + ^object1 <objd> + ^object2 <objd2> +
           ^1 <aspec> + ^2 <bspec> + ^prep <prep> + ^word <prep> +
           ^order <c> + ^negative <bool> +)
    (<aspec> ^specifier the +)
    (<bspec> ^specifier a +)
}

sp {convert-TCN-to-NL*apply*create-sentence*INDEFINDEF
    (state <s> ^name convert-TCN-to-NL ^operator <o> ^count <c>
          ^state-rep <s*2> ^state-rep <s*1> ^param <p*2> ^param <p*1>)
    (<o> ^name create-sentence ^condition <cond> ^count <c>)
    (<cond> -^3 <v*1> ^negative <bool> ^2 <argb> ^1 <arga> ^name <prep>)
    (<s*2> ^object-desc-set <o*2>)
    (<o*2> ^obj-desc <objd2>)
    (<objd2> -^mentioned true ^id <idb>)
    (<s*1> ^object-desc-set <o*1>)
    (<o*1> ^obj-desc { <> <objd2> <objd> })
    (<objd> -^mentioned true ^id <id>)
    (<p*2> ^<argb> <a*2>)
    (<a*2> ^id <idb>)
    (<p*1> ^<arga> <a*1>)
    (<a*1> ^id <id>)
    -->
    (<s> ^count <c> - ^count (+ 1 <c>) + ^sentence <sent> +)
    (<sent> ^condition <cond> + ^object1 <objd> + ^object2 <objd2> +
           ^1 <aspec> + ^2 <bspec> + ^prep <prep> + ^word <prep> +
           ^order <c> + ^negative <bool> +)
    (<aspec> ^specifier a +)
    (<bspec> ^specifier a +)
}

sp {convert-TCN-to-NL*apply*create-sentence*DEFDEF
    (state <s> ^name convert-TCN-to-NL ^operator <o> ^count <c>
          ^state-rep <s*2> ^state-rep <s*1> ^param <p*2> ^param <p*1>)
    (<o> ^name create-sentence ^condition <cond> ^count <c>)
    (<cond> -^3 <v*1> ^negative <bool> ^2 <argb> ^1 <arga> ^name <prep>)
    (<s*2> ^object-desc-set <o*2>)
    (<o*2> ^obj-desc <objd2>)
    (<objd2> ^mentioned true ^id <idb>)
    (<s*1> ^object-desc-set <o*1>)
    (<o*1> ^obj-desc { <> <objd2> <objd> })
    (<objd> ^mentioned true ^id <id>)
    (<p*2> ^<argb> <a*2>)
    (<a*2> ^id <idb>)
    (<p*1> ^<arga> <a*1>)
    (<a*1> ^id <id>)
    -->
    (<s> ^count <c> - ^count (+ 1 <c>) + ^sentence <sent> +)
    (<sent> ^condition <cond> + ^object1 <objd> + ^object2 <objd2> +
           ^1 <aspec> + ^2 <bspec> + ^prep <prep> + ^word <prep> +
           ^order <c> + ^negative <bool> +)
    (<aspec> ^specifier the +)
    (<bspec> ^specifier the +)
}

sp {convert-TCN-to-NL*apply*create-sentence*3arg*INDEF
    (state <s> ^name convert-TCN-to-NL ^operator <o> ^count <c>
          ^state-rep <s*3> ^state-rep <s*2> ^state-rep <s*1> ^param <p*3>
          ^param <p*2> ^param <p*1>)
    (<o> ^name create-sentence ^count <c> ^condition <cond>)
    (<s*3> ^object-desc-set <o*3>)
    (<o*3> ^obj-desc <objd3>)
    (<objd3> ^mentioned true ^id <idc>)
    (<s*2> ^object-desc-set <o*2>)
    (<o*2> ^obj-desc { <> <objd3> <objd2> })
    (<objd2> ^mentioned true ^id <idb>)
    (<s*1> ^object-desc-set <o*1>)
    (<o*1> ^obj-desc { <> <objd3> <> <objd2> <objd> })
    (<objd> -^mentioned true ^id <id>)
    (<cond> ^negative <bool> ^2 <argb> ^3 <argc> ^1 <arga> ^name <prep>)
    (<p*3> ^<argc> <a*3>)
    (<a*3> ^id <idc>)
    (<p*2> ^<argb> <a*2>)
    (<a*2> ^id <idb>)
    (<p*1> ^<arga> <a*1>)
    (<a*1> ^id <id>)
    -->
    (<s> ^count <c> - ^count (+ 1 <c>) + ^sentence <sent> +)
    (<sent> ^condition <cond> + ^object1 <objd> + ^object2 <objd2> +
           ^object3 <objd3> + ^1 <aspec> + ^2 <bspec> + ^3 <cspec> +
           ^word <prep> + ^prep <prep> + ^order <c> + ^negative <bool> +)
    (<aspec> ^specifier a +)
    (<bspec> ^specifier the +)
    (<cspec> ^specifier the +)
}

sp {convert-TCN-to-NL*apply*create-sentence*3arg*DEF
    (state <s> ^name convert-TCN-to-NL ^operator <o> ^count <c>
          ^state-rep <s*3> ^state-rep <s*2> ^state-rep <s*1> ^param <p*3>
          ^param <p*2> ^param <p*1>)
    (<o> ^name create-sentence ^count <c> ^condition <cond>)
    (<s*3> ^object-desc-set <o*3>)
    (<o*3> ^obj-desc <objd3>)
    (<objd3> ^mentioned true ^id <idc>)
    (<s*2> ^object-desc-set <o*2>)
    (<o*2> ^obj-desc { <> <objd3> <objd2> })
    (<objd2> ^mentioned true ^id <idb>)
    (<s*1> ^object-desc-set <o*1>)
    (<o*1> ^obj-desc { <> <objd3> <> <objd2> <objd> })
    (<objd> ^mentioned true ^id <id>)
    (<cond> ^negative <bool> ^2 <argb> ^3 <argc> ^1 <arga> ^name <prep>)
    (<p*3> ^<argc> <a*3>)
    (<a*3> ^id <idc>)
    (<p*2> ^<argb> <a*2>)
    (<a*2> ^id <idb>)
    (<p*1> ^<arga> <a*1>)
    (<a*1> ^id <id>)
    -->
    (<s> ^count <c> - ^count (+ 1 <c>) + ^sentence <sent> +)
    (<sent> ^condition <cond> + ^object1 <objd> + ^object2 <objd2> +
           ^object3 <objd3> + ^1 <aspec> + ^2 <bspec> + ^3 <cspec> +
           ^word <prep> + ^prep <prep> + ^order <c> + ^negative <bool> +)
    (<aspec> ^specifier the +)
    (<bspec> ^specifier the +)
    (<cspec> ^specifier the +)
}

sp {convert-TCN-to-NL*propose*create-sentence
    (state <s> ^name convert-TCN-to-NL ^tcn <t*1> ^count <c>)
    (<t*1> ^conditions <c*1>)
    (<c*1> ^cond <c*2>)
    (<c*2> ^prep <cond>)
   -{ (<s> ^state-rep <s*3> ^param <p*2>)
      (<s*3> ^object-desc-set <o*2>)
      (<o*2> ^obj-desc <objd>)
      (<objd> -^mentioned true ^id <idb>)
      (<cond> ^2 <argb> ^3 <argc>)
      (<p*2> ^<argb> <a*2>)
      (<a*2> ^id <idb>)}
   -{ (<s> ^state-rep <s*2> ^param <p*1>)
      (<s*2> ^object-desc-set <o*1>)
      (<o*1> ^obj-desc <objd2>)
      (<objd2> -^mentioned true ^id <idc>)
      (<cond> ^2 <argb> ^3 <argc>)
      (<p*1> ^<argc> <a*1>)
      (<a*1> ^id <idc>)}
   -{ (<s> ^sentence <s*1>)
      (<s*1> ^condition <cond>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name create-sentence + ^count <c> + ^condition <cond> +
           ^category svs +)
}

sp {convert-TCN-to-NL*elaborate*mentioned-obj
    (state <s> ^name convert-TCN-to-NL ^state-rep <s*2> ^param <p*1>
          ^sentence <s*1>)
    (<s*2> ^object-desc-set <o*1>)
    (<o*1> ^obj-desc <objd>)
    (<s*1> ^condition <c*1>)
    (<objd> ^id <id>)
    (<p*1> ^<arg> <a*2>)
    (<a*2> ^id <id>)
    (<c*1> ^{ << 1 2 3 >> <a*1> } <arg>)
    -->
    (<objd> ^mentioned true +)
}

sp {convert-TCN-to-NL*elaborate*same-description
    (state <s> ^name convert-TCN-to-NL ^state-rep <s*2> ^state-rep <s*1>)
    (<s*2> ^object-desc-set <o*2>)
    (<o*2> ^obj-desc <objd2>)
    (<s*1> ^object-desc-set <o*1>)
    (<o*1> ^obj-desc { <> <objd2> <objd> })
   -{ (<objd> ^type <type>)
      (<objd2> -^type <type>)}
   -{ (<objd> ^adjective <adj>)
      (<objd2> -^adjective <adj>)}
   -{ (<objd> ^word <word>)
      (<objd2> -^word <word>)}
    -->
    (<objd> ^same-description <objd2> +)
}

sp {convert-state-to-TCN*apply*complete-state
    (state <s> ^name convert-state-to-TCN ^operator <o*1> ^param <params>
          ^tcn <tcn> ^superstate <ss>)
    (<o*1> ^name complete-state)
    (<tcn> ^cond-args <c*1>)
    -->
    (<ss> ^tcn <tcn> + ^param <params> +)
}

sp {convert-state-to-TCN*apply*complete-state*copyrels
    (state <s> ^name convert-state-to-TCN ^operator <o*1> ^arg <arg>
          ^tcn <tcn>)
    (<o*1> ^name complete-state)
    -->
    (<tcn> ^cond-args (- <arg> 1) +)
}

sp {convert-state-to-TCN*propose*complete-state
    (state <s> ^name convert-state-to-TCN)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name complete-state + ^category svs +)
}

sp {convert-state-to-TCN*apply*create-condition*rels*3args
    (state <s> ^name convert-state-to-TCN ^operator <o> ^state-rep <s*3>
          ^state-rep <s*2> ^state-rep <s*1> ^param <p*3> ^param <p*2>
          ^param <p*1> ^tcn <t*1>)
    (<o> ^name create-condition ^arg <arg>)
    (<t*1> ^conditions <c*1>)
    (<c*1> ^cond <co>)
    (<s*3> ^relationships <r*1>)
    (<r*1> ^relations <rel>)
    (<rel> ^instance <instance> ^name <name>)
    (<instance> ^1 <obj> ^2 <objb> ^3 <objc>)
    (<p*1> ^<arg> <obj>)
    (<s*2> ^objects <o*2>)
    (<s*1> ^objects <o*1>)
    (<objb> ^predicates <p*4>)
    (<p*4> ^category <type>)
    (<p*3> ^<arg3> <objc>)
    (<p*2> ^<arg2> <objb>)
    (<o*1> ^object <obj>)
    (<o*2> ^object <obj2>)
    -->
    (<co> ^prep <prep> +)
    (<prep> ^name <name> + ^1 <arg> + ^2 <arg2> + ^3 <arg3> + ^btype <type> +
           ^negative false +)
}

sp {convert-state-to-TCN*apply*create-condition*rels
    (state <s> ^name convert-state-to-TCN ^operator <o> ^state-rep <s*2>
          ^state-rep <s*1> ^param <p*2> ^param <p*1> ^tcn <t*1>)
    (<o> ^name create-condition ^arg <arg>)
    (<t*1> ^conditions <c*1>)
    (<c*1> ^cond <co>)
    (<s*2> ^relationships <r*1>)
    (<r*1> ^relations <rel>)
    (<rel> ^instance <instance> ^name <name>)
    (<instance> -^3 <v*1> ^1 <obja> ^2 <objb>)
    (<p*1> ^<arg> <obja>)
    (<s*1> ^objects <o*1>)
    (<objb> ^predicates <p*3>)
    (<p*3> ^category <type>)
    (<p*2> ^<arg2> <objb>)
    (<o*1> ^object <objb>)
    -->
    (<co> ^prep <prep> +)
    (<prep> ^name <name> + ^1 <arg> + ^2 <arg2> + ^btype <type> +
           ^negative false +)
}

sp {convert-state-to-TCN*apply*create-condition*default
    (state <s> ^name convert-state-to-TCN ^operator <o> ^tcn <t*2> ^tcn <t*1>)
    (<o> ^name create-condition ^arg <arg>)
    (<t*2> ^conditions <c*1>)
    (<t*1> ^parameters <p*1>)
    (<c*1> ^<arg> <a*2>)
    (<p*1> ^<arg> <a*1>)
    -->
    (<s> ^default-finish <arg> +)
}

sp {convert-state-to-TCN*apply*create-condition*objdesc
    (state <s> ^name convert-state-to-TCN ^operator <o> ^state-rep <s*1>
          ^param <p*1> ^tcn <t*1>)
    (<o> ^name create-condition ^arg <arg>)
    (<t*1> ^conditions <c*1>)
    (<s*1> ^predicates <p*2>)
    (<p*2> ^predicate <ps>)
    (<ps> ^value <word> ^name <attr> ^object <obj>)
    (<c*1> ^<arg> <co>)
    (<p*1> ^<arg> <obj>)
    -->
    (<co> ^attribute <a*1> +)
    (<a*1> ^<attr> <word> +)
}

sp {convert-state-to-TCN*apply*create-condition
    (state <s> ^name convert-state-to-TCN ^operator <o> ^param <p*1>
          ^tcn <t*1>)
    (<o> ^name create-condition ^arg <arg>)
    (<t*1> ^conditions <co>)
    (<p*1> ^<arg> <obj>)
    -->
    (<co> ^<arg> <cond> +)
}

sp {convert-state-to-TCN*propose*create-condition
    (state <s> ^name convert-state-to-TCN ^tcn <t*1> -^default-finish <arg>)
    (<t*1> ^parameters <p*1>)
    (<p*1> ^<arg> <a*1>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name create-condition + ^arg <arg> +)
}

sp {convert-state-to-TCN*apply*create-parameter
    (state <s> ^name convert-state-to-TCN ^operator <o> ^arg <arg>
          ^state-rep <s*1> ^param <params> ^tcn <t*1>)
    (<o> ^name create-parameter ^obj <obj>)
    (<t*1> ^parameters <pa>)
    (<s*1> ^objects <o*1>)
    (<obj> ^predicates <p*1>)
    (<p*1> ^category <type>)
    (<o*1> ^object <obj>)
    -->
    (<pa> ^<arg> <a*1> +)
    (<a*1> ^type <type> +)
    (<params> ^<arg> <obj> +)
    (<s> ^arg <arg> - ^arg (+ <arg> 1) +)
}

sp {convert-state-to-TCN*propose*create-parameter
    (state <s> ^name convert-state-to-TCN ^arg <arg> ^state-rep <s*1>)
   -{ (<s> ^tcn <t*1>)
      (<t*1> ^parameters <p*1>)
      (<p*1> ^<arg> <a*1>)}
    (<s*1> ^objects <o*1>)
    (<o*1> ^object <obj>)
   -{ (<s> ^param <p*2>)
      (<p*2> ^<something> <obj>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name create-parameter + ^obj <obj> +)
}

sp {convert-state-to-TCN*elaborate*operator-attrs
    (state <s> ^name convert-state-to-TCN ^top-state <t*1> ^superstate <s*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learn-link <l*1>)
    (<l*1> ^handle <name>)
    (<s*1> ^operator <o>)
    (<o> ^name convert-state-to-TCN ^state-rep <state-rep>)
    -->
    (<s> ^state-rep <state-rep> + ^tcn <tcn> + ^param <p> + ^arg 1 +)
    (<tcn> ^conditions <co> + ^parameters <pa> + ^name <name> +)
    (<co> ^cond <cond> +)
}

sp {convert-TCN-to-NL*elaborate*operator-attrs
    (state <s> ^name convert-TCN-to-NL ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^name convert-TCN-to-NL ^state-rep <state-rep> ^param <params>
          ^tcn <tcn>)
    -->
    (<s> ^state-rep <state-rep> + ^description <d> + ^param <params> +
           ^count 1 + ^tcn <tcn> +)
}

sp {learn-goal-demonstration*elaborate*copy-down-attrs
    (state <s> ^name learn-goal-demonstration ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^type <type>)
    -->
    (<s> ^type <type> +)
}

sp {prefer*create-parameter*over*complete-state*convert-state-to-TCN
    (state <s> ^name convert-state-to-TCN ^operator <o2> + ^operator <o1> +)
    (<o2> ^name complete-state)
    (<o1> ^name create-parameter)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*create-condition*over*complete-state*convert-state-to-TCN
    (state <s> ^name convert-state-to-TCN ^operator <o2> + ^operator <o1> +)
    (<o2> ^name complete-state)
    (<o1> ^name create-condition)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*create-condition*over*create-parameter*convert-state-to-TCN
    (state <s> ^name convert-state-to-TCN ^operator <o2> + ^operator <o1> +)
    (<o2> ^name create-parameter)
    (<o1> ^name create-condition)
    -->
    (<s> ^operator <o1> < <o2>)
}

sp {prefer*create-sentence*over*complete-state
    (state <s> ^name convert-TCN-to-NL ^operator <o2> + ^operator <o1> +)
    (<o2> ^name complete-state)
    (<o1> ^name create-sentence)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {learn-goal-demonstration*send-message*game-final-state
    :o-support
    (state <s> ^name learn-goal-demonstration ^type initial ^top-state <t*3>
          ^top-state <t*2> ^top-state <t*1>)
    (<t*3> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<t*2> ^dialog-context <dc>)
    (<dc> -^final <f*1> ^needs-setup <t> ^initial <i*3>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<dc> ^needs-setup <t> -)
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type define-actions +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <l*1> +)
    (<l*1> ^type game +)
}

sp {learn-goal-demonstration*propose*learn-predicate
    (state <s> ^name learn-goal-demonstration -^done chunked-action ^tcn <act>
          ^nlp-set <nps> ^top-state <t*1>)
    (<t*1> ^dialog-context <cg>)
    (<cg> ^finished-demo true ^structure <g> ^learn-link <l> ^name <gname>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name learn-predicate + ^nlp-set <nps> + ^type goal +
           ^game-name <gname> +)
}

sp {learn-goal-demonstration*propose*convert-TCN-to-NLP
    (state <s> ^name learn-goal-demonstration -^nlp-set <n*1> ^tcn <g>)
    -->
    (<s> ^operator <o> + ^operator <o> = ^operator <o> >)
    (<o> ^name convert-TCN-to-NLP + ^type goal + ^tcn <g> +)
}

sp {learn-goal-demonstration*propose*convert-state-to-TCN
    (state <s> ^name learn-goal-demonstration -^tcn <t*3> ^top-state <t*4>
          ^top-state <t*2> ^top-state <t*1>)
    (<t*4> ^dialog-context <d*3>)
    (<d*3> ^type game-learning)
    (<t*2> ^dialog-context <d*2>)
    (<d*2> ^finished-demo true)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^goal-state <gstate>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name convert-state-to-TCN + ^state-rep <gstate> +)
}

sp {learn-goal-demonstration*apply*complete*create*new-segment
    (state <s> ^name learn-goal-demonstration ^operator <o*1>
          ^new-segment-info <info> ^top-state <ts>)
    (<o*1> ^name complete)
    (<info> ^purpose <p*1>)
    (<p*1> ^parameters <p*2>)
    (<ts> ^dialog-context <dc> ^interaction <i*2> ^interaction <i*1>)
    (<dc> ^goal-relationships <gs>)
    (<i*2> ^changes <c>)
    (<i*1> ^status <status>)
    -->
    (<c> ^new-segment-info <info> + ^outgoing-message <msg> +)
    (<ts> ^dialog-context <dc> -)
    (<msg> ^type describe-final-goal-state + ^fields <f> +)
    (<f> ^relationships <gs> + ^definitive no +)
    (<status> ^performed <p*3> +)
    (<p*3> ^learning-event <de> +)
    (<de> ^type game + ^originator agent +)
}

sp {learn-goal-demonstration*elaborate*goal-predicates*relation-predicate
    (state <s> ^name learn-goal-demonstration ^new-segment-info <n*1>
          ^top-state <t*2> ^top-state <t*1>)
    (<n*1> ^purpose <p*1>)
    (<p*1> ^parameters <params>)
    (<t*2> ^dialog-context <d*2>)
    (<d*2> ^finished-demo true)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^goal-state <g*1>)
    (<g*1> ^relationships <G10020>)
    (<G10020> ^relations <r>)
    (<r> ^instance <i> ^name <name>)
    (<i> ^2 <obj2> ^1 <obj1>)
    -->
    (<params> ^goal-predicate <pred> +)
    (<pred> ^handle <name> + ^1 <obj1> + ^2 <obj2> + ^type relation +)
}

sp {learn-goal-demonstration*elaborate*goal-predicates*state-predicate
    (state <s> ^name learn-goal-demonstration ^new-segment-info <n*1>
          ^top-state <t*2> ^top-state <t*1>)
    (<n*1> ^purpose <p*1>)
    (<p*1> ^parameters <params>)
    (<t*2> ^dialog-context <d*2>)
    (<d*2> ^finished-demo true)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^goal-state <g*1>)
    (<g*1> ^relationships <G10020>)
    (<G10020> ^relations <r>)
    (<r> ^instance <i> ^name <name>)
    (<i> -^2 <v*1> ^1 <obj1>)
    -->
    (<params> ^goal-predicate <pred> +)
    (<pred> ^handle <name> + ^1 <obj1> + ^type state +)
}

sp {learn-goal-demonstration*propose*complete
    (state <s> ^name learn-goal-demonstration ^top-state <t*2>
          ^top-state <t*1>)
   -{ (<s> ^top-state <t*3>)
      (<t*3> ^dialog-context <d*3>)
      (<d*3> ^type game-learning)}
    (<t*2> ^dialog-context <d*2>)
    (<d*2> ^finished-demo true)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^goal-relationships <G10020>)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete +)
}

sp {learn-goal-demonstration*elaborate*new-segment-info*learn-goal-definition
    (state <s> ^name learn-goal-demonstration ^top-state <t*2>
          ^top-state <t*1>)
   -{ (<s> ^top-state <t*3>)
      (<t*3> ^dialog-context <d*3>)
      (<d*3> ^type game-learning)}
    (<t*2> ^dialog-context <d*2>)
    (<d*2> ^finished-demo true)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^goal-relationships <G10020>)
    -->
    (<s> ^new-segment-info <info> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type learn-goal-definition + ^parameters <params> +
           ^satisfaction <sat> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type goal +)
}

sp {learn-goal-demonstration*send-message*describe-goal-state
    (state <s> ^name learn-goal-demonstration ^top-state <t*6>
          ^top-state <t*5> ^top-state <t*4> ^top-state <t*3>)
   -{ (<s> ^top-state <t*2>)
      (<t*2> ^dialog-context <d*2>)
      (<d*2> ^modified true)}
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^dialog-context <d*1>)
      (<d*1> ^finished-demo true)}
    (<t*6> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<t*5> ^interaction <i*1>)
    (<t*4> ^dialog-context <d*4>)
    (<d*4> ^goal-relationships <gs>)
    (<t*3> ^dialog-context <d*3>)
    (<d*3> ^type game-learning)
    (<i*1> ^status <status>)
    -->
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type describe-goal-state + ^fields <f> +)
    (<f> ^relationships <gs> + ^definitive yes +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <de> +)
    (<de> ^type game + ^originator agent +)
}

sp {learn-goal-demonstration*apply*state-diff*copy-goal-relations*1arg
    (state <s> ^name learn-goal-demonstration ^top-state <t*1>)
    (<t*1> ^dialog-context <g>)
    (<g> ^goal-relationships <gr> ^goal-state <dstate>)
    (<dstate> ^relationships <r*1> ^predicates <p>)
    (<r*1> ^relations <r>)
    (<r> ^instance <in> ^name <name>)
    (<in> -^2 <v*1> ^1 <obj1>)
    (<p> ^<obj1> <desc1> ^<obj2> <desc2>)
    -->
    (<gr> ^relation <r1> +)
    (<r1> ^1 <desc1> + ^name <name> +)
}

sp {learn-goal-demonstration*apply*state-diff*copy-goal-relations
    (state <s> ^name learn-goal-demonstration ^top-state <t*1>)
    (<t*1> ^dialog-context <g>)
    (<g> ^goal-relationships <gr> ^goal-state <dstate>)
    (<dstate> ^relationships <r*1> ^predicates <p>)
    (<r*1> ^relations <r>)
    (<r> ^instance <in> ^name <name>)
    (<in> ^2 <obj2> ^1 <obj1>)
    (<p> ^<obj2> <desc2> ^<obj1> <desc1>)
    -->
    (<gr> ^relation <r1> +)
    (<r1> ^1 <desc1> + ^2 <desc2> + ^name <name> +)
}

sp {learn-goal-demonstration*apply*state-diff
    (state <s> ^name learn-goal-demonstration ^operator <o*1>
          ^diff-result <dstate> ^top-state <t*1>)
    (<o*1> ^name state-diff)
    (<t*1> ^dialog-context <g>)
    (<g> ^final <fstate> ^initial <istate>)
    -->
    (<g> ^goal-state <dstate> + ^goal-relationships <gr> +)
}

sp {learn-goal-demonstration*propose*state-diff
    (state <s> ^name learn-goal-demonstration ^top-state <t*1>)
    (<t*1> ^dialog-context <g>)
    (<g> -^goal-state <g*1> ^ignore <ig> ^attend <at> ^final <fstate>
          ^initial <istate>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name state-diff + ^initial <istate> + ^final <fstate> +
           ^ignore <ig> + ^attend <at> +)
}

sp {learn-goal-demonstration*remove*goal-state
    :o-support
    (state <s> ^name learn-goal-demonstration ^top-state <t*1>)
    (<t*1> ^dialog-context <g>)
    (<g> ^goal-relationships <gr> ^modified <t> ^goal-state <gs>
          ^final <fstate> ^initial <istate>)
    -->
    (<g> ^modified <t> - ^goal-relationships <gr> - ^goal-state <gs> -
           ^finished-demo true +)
}

sp {learn-goal-demonstration*elaborate*attend
    :o-support
    (state <s> ^name learn-goal-demonstration ^top-state <t*1>)
    (<t*1> ^dialog-context <g>)
    (<g> -^attend <a*1> ^initial <i*1>)
    -->
    (<g> ^attend <at> + ^ignore <ig> +)
}

sp {learn-goal-demonstration*apply*extract-state
    (state <s> ^name learn-goal-demonstration ^operator <o> ^type <type>
          ^state-result <staterep> ^top-state <t*1>)
    (<o> ^name extract-state ^type { << initial final >> <type> })
    (<t*1> ^dialog-context <g>)
    -->
    (<g> ^<type> <staterep> +)
}

sp {learn-goal-demonstration*propose*extract-state
    (state <s> ^name learn-goal-demonstration
          ^type { << initial final >> <type> } ^top-state <t*3>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^dialog-context <d*1>)
      (<d*1> ^<type> <t*2>)}
    (<t*3> ^dialog-context <d*2>)
    (<d*2> ^type game-learning)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name extract-state + ^type <type> +)
}

sp {goal-feature-tracking*apply*complete
    (state <s> ^name goal-feature-tracking ^operator <o*1> ^parameter <pa>
          ^top-state <t*2> ^top-state <t*1>)
    (<o*1> ^name complete)
    (<t*2> ^interaction <i*2>)
    (<i*2> ^status <status>)
    (<t*1> ^io <i*1>)
    (<i*1> ^output-link <out>)
    -->
    (<out> ^send-message <msg> +)
    (<msg> ^type confirmation + ^fields <f> +)
    (<status> ^performed <p*1> +)
    (<p*1> ^dialog-event <d*1> +)
    (<d*1> ^type game +)
}

sp {goal-feature-tracking*apply*add-to-list*relation
    (state <s> ^name goal-feature-tracking ^operator <o*1> ^parameter <pa>
          ^top-state <t*1>)
    (<o*1> ^name add-to-list)
    (<t*1> ^current-game <cg>)
    (<pa> ^type <attig> ^relation <r>)
    (<cg> ^<attig> <at>)
    -->
    (<at> ^relation <r> +)
    (<s> ^done true +)
}

sp {goal-feature-tracking*apply*add-to-list*object
    (state <s> ^name goal-feature-tracking ^parameter <pa> ^operator <o*1>
          ^top-state <t*1>)
    (<pa> -^relation <r*1> ^indexable <i*1> ^type <attig>)
    (<o*1> ^name add-to-list)
    (<t*1> ^current-game <cg>)
    (<i*1> ^result <o>)
    (<cg> ^<attig> <at>)
    -->
    (<at> ^object <o> +)
    (<s> ^done true +)
}

sp {goal-feature-tracking*propose*complete
    (state <s> ^name goal-feature-tracking ^done <d*1> ^parameter <pa>)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name complete +)
}

sp {goal-feature-tracking*propose*add-to-list
    (state <s> ^name goal-feature-tracking -^done <d*1> ^parameter <pa>)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name add-to-list +)
}

sp {goal-feature-tracking*elaborate*parameter
    (state <s> ^name goal-feature-tracking ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^name goal-feature-tracking ^parameter <pa>)
    -->
    (<s> ^parameter <pa> +)
}

sp {extract-state*apply*complete-state
    (state <s> ^name extract-state ^operator <o*1> ^object-set <os>
          ^predicate-set <preds> ^relationships <rels> ^superstate <ss>
          ^superstate <s*1>)
    (<o*1> ^name complete-state)
    (<s*1> ^operator <op>)
    -->
    (<ss> ^state-result <res> +)
    (<res> ^relationships <rels> + ^objects <os> + ^predicate-set <preds> +)
}

sp {extract-state*propose*complete-state
    (state <s> ^name extract-state)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name complete-state +)
}

sp {extract-state*apply*copy-predicates*create*objects
    (state <s> ^name extract-state ^operator <o*1> ^object-set <o*2>
          ^predicate-set <preds>)
    (<o*1> ^name copy-predicates)
    (<o*2> ^object <obj>)
    (<obj> ^predicates <p*1>)
    (<p*1>
          ^{ <> door1 <> movable <> indicated <> object-handle <> category <> arm-status <> dialog-object <> value <> handle <> type <> visible <> multiple <> number <att> } { <> grid-green <val> })
    -->
    (<preds> ^predicate <pred> +)
    (<pred> ^object <obj> + ^name <att> + ^value <val> +)
}

sp {extract-state*apply*copy-predicates*mark*done
    (state <s> ^name extract-state ^operator <o*1> ^predicate-set <preds>)
    (<o*1> ^name copy-predicates)
    -->
    (<preds> ^done true +)
}

sp {extract-state*propose*copy-predicates
    (state <s> ^name extract-state)
   -{ (<s> ^predicate-set <p*1>)
      (<p*1> ^done <d*1>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name copy-predicates +)
}

sp {extract-state*apply*copy-objects
    (state <s> ^name extract-state ^operator <o*2> ^object-set <os>
          ^relationships <rels> ^relationships <r*1> ^top-state <t*1>)
    (<o*2> ^name copy-objects)
    (<r*1> ^relations <p>)
    (<p> ^instance <instance> ^name <name>)
    (<t*1> ^world <w*1>)
    (<w*1> ^objects <o*1>)
    (<instance> ^{ << 1 2 3 >> <a*1> } <obja>)
    (<o*1> ^object <obja>)
    -->
    (<os> ^object <obja> +)
}

sp {extract-state*apply*copy-objects*default
    (state <s> ^name extract-state ^operator <o*1> ^object-set <set>)
    (<o*1> ^name copy-objects)
    -->
    (<set> ^done true +)
}

sp {extract-state*propose*copy-objects
    (state <s> ^name extract-state)
   -{ (<s> ^object-set <o*1>)
      (<o*1> ^done <d*1>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name copy-objects +)
}

sp {extract-state*apply*copy-relationships*3arg
    (state <s> ^name extract-state ^operator <o*1> ^relationships <rels>
          ^top-state <t*1>)
    (<o*1> ^name copy-relationships)
    (<t*1> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <p>)
    (<p> ^instance <instance3> ^handle <name>)
    (<instance3> ^2 <idb> ^3 <idc> ^1 <ida>)
    -->
    (<rels> ^relations <r> +)
    (<r> ^name <name> + ^instance <instance> +)
    (<instance> ^1 <ida> + ^2 <idb> + ^3 <idc> +)
}

sp {extract-state*apply*copy-relationships
    (state <s> ^name extract-state ^operator <o*1> ^relationships <rels>
          ^top-state <t*1>)
    (<o*1> ^name copy-relationships)
    (<t*1> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <p>)
    (<p> ^instance <instance3> ^handle <name>)
    (<instance3> -^3 <v*1> ^2 <idb> ^1 <ida>)
    -->
    (<rels> ^relations <r> +)
    (<r> ^name <name> + ^instance <instance> +)
    (<instance> ^1 <ida> + ^2 <idb> +)
}

sp {extract-state*apply*copy-relationships*default
    (state <s> ^name extract-state ^operator <o*1> ^relationships <rels>)
    (<o*1> ^name copy-relationships)
    -->
    (<rels> ^done true +)
}

sp {extract-state*propose*copy-relationships
    (state <s> ^name extract-state)
   -{ (<s> ^relationships <r*1>)
      (<r*1> ^done <d*1>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name copy-relationships +)
}

sp {state-union*apply*complete
    (state <s> ^name state-union ^operator <o*1> ^object-desc-set <ods>
          ^object-set <os> ^predicate-set <preds> ^relationships <rels>
          ^superstate <ss>)
    (<o*1> ^name complete)
    -->
    (<ss> ^state-result <res> +)
    (<res> ^relationships <rels> + ^objects <os> + ^object-desc-set <ods> +
           ^predicate-set <preds> +)
}

sp {state-union*propose*complete
    (state <s> ^name state-union)
    -->
    (<s> ^operator <o> + ^operator <o> = ^operator <o> <)
    (<o> ^name complete +)
}

sp {state-union*apply*copy-predicates*copy
    (state <s> ^name state-union ^operator <o*1> ^predicate-set <preds>
          ^final <f*1> ^initial <i*1>)
    (<o*1> ^name copy-predicates)
    (<f*1> ^predicate-set <p*2>)
    (<i*1> ^predicate-set <p*1>)
    (<p*2> ^predicate <final-pred>)
    (<p*1> ^predicate <initial-pred>)
    (<final-pred> ^value <pred-value> ^name <pred-name> ^object <obj>)
    (<initial-pred> ^value <pred-value> ^name <pred-name> ^object <obj>)
    -->
    (<preds> ^predicate <new-pred> +)
    (<new-pred> ^object <obj> + ^name <pred-name> + ^value <pred-value> +)
}

sp {state-union*apply*copy-predicates*mark*copied
    (state <s> ^name state-union ^operator <o*1>)
    (<o*1> ^name copy-predicates)
    -->
    (<s> ^copied-predicates true +)
}

sp {state-union*propose*copy-predicates
    (state <s> ^name state-union -^copied-predicates <c*1>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name copy-predicates +)
}

sp {state-union*apply*copy-objects
    (state <s> ^name state-union ^operator <o*4> ^object-desc-set <ods>
          ^object-set <os> ^relationships <rels> ^relationships <r*1>
          ^final <f*2> ^final <f*1> ^initial <i*2>)
    (<o*4> ^name copy-objects)
    (<r*1> ^relations <p>)
    (<p> ^instance <instance> ^name <name>)
    (<f*1> ^object-desc-set <o*2>)
    (<o*2> ^obj-desc <desc>)
    (<f*2> ^objects <o*3>)
    (<i*2> ^objects <o*1>)
    (<desc> ^id <id>)
    (<instance> ^{ << 1 2 3 >> <a*1> } <id>)
    (<o*3> ^object <obj>)
   -{ (<s> ^ignore <i*1>)
      (<i*1> ^object <obj>)}
    (<obj> ^id <id>)
    (<o*1> ^object <obj>)
    -->
    (<os> ^object <obj> +)
    (<ods> ^obj-desc <desc> +)
}

sp {state-union*apply*copy-objects*mark*copied
    (state <s> ^name state-union ^operator <o*1>)
    (<o*1> ^name copy-objects)
    -->
    (<s> ^copied-objects true +)
}

sp {state-union*propose*copy-objects
    (state <s> ^name state-union -^copied-objects <c*1>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name copy-objects +)
}

sp {state-union*apply*copy-relationships*3-args
    (state <s> ^name state-union ^operator <o*1> ^relationships <r>
          ^final <f*1> ^initial <i*2>)
    (<o*1> ^name copy-relationships)
    (<f*1> ^relationships <r*2>)
    (<r*2> ^relations <rel2>)
    (<rel2> ^instance <instance> ^name <name>)
   -{ (<s> ^ignore <i*3>)
      (<instance> ^{ << 1 2 3 >> <a*1> } <id>)
      (<i*3> ^object <o*2>)
      (<o*2> ^id <id>)}
   -{ (<s> ^ignore <i*1>)
      (<i*1> ^relation <name>)}
    (<i*2> ^relationships <r*1>)
    (<r*1> ^relations <rels>)
    (<rels> ^name <name> ^instance <instance2>)
    (<instance2> ^2 <idb> ^3 <idc> ^1 <ida>)
    (<instance> ^2 <idb> ^3 <idc> ^1 <ida>)
    -->
    (<r> ^relations <r1> +)
    (<r1> ^name <name> + ^instance <instance> +)
}

sp {state-union*apply*copy-relationships
    (state <s> ^name state-union ^operator <o*1> ^relationships <r>
          ^final <f*1> ^initial <i*2>)
    (<o*1> ^name copy-relationships)
    (<f*1> ^relationships <r*2>)
    (<r*2> ^relations <rel2>)
    (<rel2> ^instance <instance> ^name <name>)
   -{ (<s> ^ignore <i*3>)
      (<instance> ^{ << 1 2 3 >> <a*1> } <id>)
      (<i*3> ^object <o*2>)
      (<o*2> ^id <id>)}
    (<instance> -^3 <v*1> ^2 <idb> ^1 <ida>)
   -{ (<s> ^ignore <i*1>)
      (<i*1> ^relation <name>)}
    (<i*2> ^relationships <r*1>)
    (<r*1> ^relations <rels>)
    (<rels> ^name <name> ^instance <instance2>)
    (<instance2> -^3 <v*2> ^2 <idb> ^1 <ida>)
    -->
    (<r> ^relations <r1> +)
    (<r1> ^name <name> + ^instance <instance> +)
}

sp {state-union*apply*copy-relationships*mark*copied
    (state <s> ^name state-union ^operator <o*1>)
    (<o*1> ^name copy-relationships)
    -->
    (<s> ^copied-relationships true +)
}

sp {state-union*propose*copy-relationships
    (state <s> ^name state-union -^copied-relationships <c*1>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name copy-relationships +)
}

sp {state-diff*apply*complete
    (state <s> ^name state-diff ^operator <o*1> ^object-set <os>
          ^predicate-set <preds> ^relationships <rels> ^superstate <ss>
          ^superstate <s*1>)
    (<o*1> ^name complete)
    (<s*1> ^operator <op>)
    -->
    (<ss> ^diff-result <res> +)
    (<res> ^relationships <rels> + ^objects <os> + ^predicates <preds> +)
}

sp {state-diff*propose*complete
    (state <s> ^name state-diff)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name complete +)
}

sp {state-diff*apply*copy-extra-relationships*3args
    (state <s> ^name state-diff ^operator <o*1> ^copied-relations <copied>
          ^valid-relations <v*1> ^object-set <o*4> ^object-set <o*3>
          ^object-set <o*2> ^relationships <rels> ^final <f*1>)
    (<o*1> ^name copy-extra-relationships)
    (<f*1> ^relationships <r*1>)
    (<r*1> ^relations <final-rel>)
    (<final-rel> ^instance <instance> ^name <rel-name>)
    (<copied> -^<rel-name> <instance>)
    (<instance> ^c <idc> ^2 <idb> ^1 <ida>)
    (<v*1> ^relation <rel-name>)
    (<o*4> ^object <idc>)
    (<o*3> ^object <idb>)
    (<o*2> ^object <ida>)
    -->
    (<rels> ^relations <new-rel> +)
    (<new-rel> ^name <rel-name> + ^instance <instance> +)
    (<copied> ^<rel-name> <instance> +)
}

sp {state-diff*apply*copy-extra-relationships*2args
    (state <s> ^name state-diff ^operator <o*1> ^copied-relations <copied>
          ^valid-relations <v*1> ^object-set <o*3> ^object-set <o*2>
          ^relationships <rels> ^final <f*1>)
    (<o*1> ^name copy-extra-relationships)
    (<f*1> ^relationships <r*1>)
    (<r*1> ^relations <final-rel>)
    (<final-rel> ^instance <instance> ^name <rel-name>)
    (<instance> -^c <c*1> ^2 <idb> ^1 <ida>)
    (<copied> -^<rel-name> <instance>)
    (<v*1> ^relation <rel-name>)
    (<o*3> ^object <idb>)
    (<o*2> ^object <ida>)
    -->
    (<rels> ^relations <new-rel> +)
    (<new-rel> ^name <rel-name> + ^instance <instance> +)
    (<copied> ^<rel-name> <instance> +)
}

sp {state-diff*apply*copy-extra-relationships*default
    (state <s> ^name state-diff ^operator <o*1>)
    (<o*1> ^name copy-extra-relationships)
    -->
    (<s> ^copied-extra-relationships true +)
}

sp {state-diff*propose*copy-extra-relationships
    (state <s> ^copied-objects true -^copied-extra-relationships <c*1>
          ^name state-diff)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name copy-extra-relationships +)
}

sp {state-diff*apply*copy-predicates*create*diff*changed
    (state <s> ^name state-diff ^operator <o*1> ^valid-predicates <v*1>
          ^valid-objects <v*2> ^object-set <o*2> ^predicate-set <preds>
          ^final <f*1>)
    (<o*1> ^name copy-predicates)
    (<f*1> ^predicate-set <p*1>)
    (<v*1> ^predicate <name>)
    (<p*1> ^predicate <final-pred>)
    (<final-pred> ^name <name> ^value <val2> ^object <obj>)
    (<preds> ^<obj> <desc>)
    (<v*2> ^object <obj>)
    (<o*2> ^object <obj>)
    -->
    (<preds> ^predicate <new-pred> +)
    (<new-pred> ^object <obj> + ^name <name> + ^value <val2> +)
    (<desc> ^<name> <val2> +)
}

sp {state-diff*apply*copy-predicates*object-descriptions
    (state <s> ^name state-diff ^valid-objects <v*1> ^object-set <o*1>
          ^predicate-set <preds>)
    (<v*1> ^object <obj>)
    (<obj> ^predicates <p*1>)
    (<p*1> ^category <type>)
    (<o*1> ^object <obj>)
    -->
    (<preds> ^<obj> <description> +)
    (<description> ^type <type> +)
}

sp {state-diff*apply*copy-predicates*mark*done
    (state <s> ^name state-diff ^operator <o*1>)
    (<o*1> ^name copy-predicates)
    -->
    (<s> ^copied-predicates true +)
}

sp {state-diff*propose*copy-predicates
    (state <s> ^name state-diff -^copied-predicates <c*1>)
    -->
    (<s> ^operator <o> + ^operator <o> = ^operator <o> >)
    (<o> ^name copy-predicates +)
}

sp {state-diff*apply*copy-objects*copy*object*from*relationship
    (state <s> ^name state-diff ^operator <o*1> ^copied-relations <c*1>
          ^object-set <obj-set> ^final <f*1>)
    (<o*1> ^name copy-objects)
    (<f*1> ^objects <o*2>)
    (<c*1> ^<rel-name> <r*1>)
    (<r*1> ^{ << 1 2 3 >> <a*1> } <obj>)
    (<o*2> ^object <obj>)
    -->
    (<obj-set> ^object <obj> +)
}

sp {state-diff*apply*copy-objects*copy*object*in*attend
    (state <s> ^name state-diff ^operator <o*1> ^object-set <obj-set>
          ^attend <a*1> ^final <f*1>)
    (<o*1> ^name copy-objects)
    (<f*1> ^objects <o*2>)
    (<o*2> ^object <ocj>)
    (<a*1> ^object <obj>)
    -->
    (<obj-set> ^object <obj> +)
}

sp {state-diff*apply*copy-objects*mark*copied
    (state <s> ^name state-diff ^operator <o*1>)
    (<o*1> ^name copy-objects)
    -->
    (<s> ^copied-objects true +)
}

sp {state-diff*propose*copy-objects
    (state <s> ^copied-relationships true -^copied-objects <c*1>
          ^name state-diff)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name copy-objects +)
}

sp {state-diff*apply*copy-new-relationships*copy*3arg
    (state <s> ^name state-diff ^operator <o*1> ^copied-relations <copied>
          ^valid-relations <v*4> ^valid-objects <v*3> ^valid-objects <v*2>
          ^valid-objects <v*1> ^relationships <r> ^final <f*1>)
    (<o*1> ^name copy-new-relationships)
    (<f*1> ^relationships <r*1>)
    (<r*1> ^relations <final-rel>)
    (<final-rel> ^name <rel-name> ^instance <instance>)
   -{ (<s> ^attend <a*1>)
      (<a*1> ^relation <rel-name>)}
    (<instance> ^2 <idb> ^3 <idc> ^1 <ida>)
   -{ (<s> ^initial <i*1>)
      (<i*1> ^relationships <initial-rels>)
      (<initial-rels> ^relations <initial-rel>)
      (<initial-rel> ^name <rel-name> ^instance <initial-instance>)
      (<initial-instance> ^2 <idb> ^3 <idc> ^1 <ida>)}
    (<v*4> ^relation <rel-name>)
    (<v*3> ^object <idc>)
    (<v*2> ^object <idb>)
    (<v*1> ^object <ida>)
    -->
    (<r> ^relations <new-rel> +)
    (<new-rel> ^name <rel-name> + ^instance <instance> +)
    (<copied> ^<rel-name> <instance> +)
}

sp {state-diff*apply*copy-new-relationships*copy*2arg
    (state <s> ^name state-diff ^operator <o*1> ^copied-relations <copied>
          ^valid-relations <v*3> ^valid-objects <v*2> ^valid-objects <v*1>
          ^relationships <r> ^final <f*1>)
    (<o*1> ^name copy-new-relationships)
    (<f*1> ^relationships <r*1>)
    (<r*1> ^relations <final-rel>)
    (<final-rel> ^instance <instance> ^name <rel-name>)
    (<instance> -^3 <v*4> ^2 <idb> ^1 <ida>)
   -{ (<s> ^attend <a*1>)
      (<a*1> ^relation <rel-name>)}
   -{ (<s> ^initial <i*1>)
      (<i*1> ^relationships <initial-rels>)
      (<initial-rels> ^relations <initial-rel>)
      (<initial-rel> ^name <rel-name> ^instance <initial-instance>)
      (<initial-instance> ^2 <idb> ^1 <ida>)}
    (<v*3> ^relation <rel-name>)
    (<v*2> ^object <idb>)
    (<v*1> ^object <ida>)
    -->
    (<r> ^relations <new-rel> +)
    (<new-rel> ^name <rel-name> + ^instance <instance> +)
    (<copied> ^<rel-name> <instance> +)
}

sp {state-diff*apply*copy-new-relationships*copy*1arg
    (state <s> ^name state-diff ^operator <o*1> ^copied-relations <copied>
          ^valid-relations <v*2> ^valid-objects <v*1> ^relationships <r>
          ^final <f*1>)
    (<o*1> ^name copy-new-relationships)
    (<f*1> ^relationships <r*1>)
    (<r*1> ^relations <final-rel>)
    (<final-rel> ^instance <instance> ^name <rel-name>)
    (<instance> -^2 <v*3> ^1 <ida>)
   -{ (<s> ^attend <a*1>)
      (<a*1> ^relation <rel-name>)}
   -{ (<s> ^initial <i*1>)
      (<i*1> ^relationships <initial-rels>)
      (<initial-rels> ^relations <initial-rel>)
      (<initial-rel> ^name <rel-name> ^instance <initial-instance>)
      (<initial-instance> ^1 <ida>)}
    (<v*2> ^relation <rel-name>)
    (<v*1> ^object <ida>)
    -->
    (<r> ^relations <new-rel> +)
    (<new-rel> ^name <rel-name> + ^instance <instance> +)
    (<copied> ^<rel-name> <instance> +)
}

sp {state-diff*apply*copy-new-relationships*copy*attend*relation
    (state <s> ^name state-diff ^operator <o*1> ^copied-relations <copied>
          ^valid-objects <objs> ^relationships <r> ^attend <a*1> ^final <f*1>)
    (<o*1> ^name copy-new-relationships)
    (<f*1> ^relationships <r*1>)
    (<r*1> ^relations <final-rel>)
    (<final-rel> ^instance <instance> ^name <rel-name>)
   -{ (<instance> ^{ << 1 2 3 >> <a*2> } <obj>)
      (<objs> -^object <obj>)}
    (<a*1> ^relation <rel-name>)
    -->
    (<r> ^relations <new-rel> +)
    (<new-rel> ^name <rel-name> + ^instance <instance> +)
    (<copied> ^<rel-name> <instance> +)
}

sp {state-diff*apply*copy-new-relationships*mark*copied-relatioships
    (state <s> ^name state-diff ^operator <o*1>)
    (<o*1> ^name copy-new-relationships)
    -->
    (<s> ^copied-relationships true +)
}

sp {state-diff*propose*copy-new-relationships
    (state <s> ^name state-diff -^copied-relationships <c*1>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name copy-new-relationships +)
}

sp {state-diff*elaborate*copied-relations
    (state <s> ^name state-diff)
    -->
    (<s> ^copied-relations <rels> +)
}

sp {state-diff*elaborate*valid-predicate*attend-only
    (state <s> ^name state-diff ^valid-predicates <preds> ^attend-only <a*1>)
    (<a*1> ^predicates <p*1>)
    (<p*1> ^predicate <pred>)
    -->
    (<preds> ^predicate <pred> +)
}

sp {state-diff*elaborate*valid-predicate*from-final
    (state <s> ^name state-diff ^valid-predicates <preds> ^final <f*1>)
   -{ (<s> ^attend-only <a*1>)
      (<a*1> ^predicates <p*3>)
      (<p*3> ^predicate <any>)}
    (<f*1> ^predicate-set <p*1>)
    (<p*1> ^predicate <p*2>)
    (<p*2> ^name <pred>)
   -{ (<s> ^ignore <i*1>)
      (<i*1> ^predicate <pred>)}
    -->
    (<preds> ^predicate <pred> +)
}

sp {state-diff*elaborate*valid-predicates
    (state <s> ^name state-diff)
    -->
    (<s> ^valid-predicates <preds> +)
}

sp {state-diff*elaborate*valid-relation*attend-only
    (state <s> ^name state-diff ^valid-relations <rels> ^attend-only <a*1>)
    (<a*1> ^relations <r*1>)
    (<r*1> ^relation <rel>)
    -->
    (<rels> ^relation <rel> +)
}

sp {state-diff*elaborate*valid-relation*from-final
    (state <s> ^name state-diff ^valid-relations <rels> ^final <f*1>)
   -{ (<s> ^attend-only <a*1>)
      (<a*1> ^relations <r*3>)
      (<r*3> ^relation <any>)}
    (<f*1> ^relationships <r*1>)
    (<r*1> ^relations <r*2>)
    (<r*2> ^name <rel>)
   -{ (<s> ^ignore <i*1>)
      (<i*1> ^relation <rel>)}
    -->
    (<rels> ^relation <rel> +)
}

sp {state-diff*elaborate*valid-relations
    (state <s> ^name state-diff)
    -->
    (<s> ^valid-relations <rels> +)
}

sp {state-diff*elaborate*valid-object*attend-only
    (state <s> ^name state-diff ^valid-objects <objs> ^attend-only <a*1>)
    (<a*1> ^objects <o*1>)
    (<o*1> ^object <obj>)
    -->
    (<objs> ^object <obj> +)
}

sp {state-diff*elaborate*valid-object*attend
    (state <s> ^name state-diff ^valid-objects <objs> ^attend <a*1>)
    (<a*1> ^object <obj>)
    -->
    (<objs> ^object <obj> +)
}

sp {state-diff*elaborate*valid-object*from-final
    (state <s> ^name state-diff ^valid-objects <objs> ^final <f*1>)
   -{ (<s> ^attend-only <a*1>)
      (<a*1> ^objects <o*2>)
      (<o*2> ^object <any>)}
    (<f*1> ^objects <o*1>)
    (<o*1> ^object <obj>)
   -{ (<s> ^ignore <i*1>)
      (<i*1> ^object <obj>)}
    -->
    (<objs> ^object <obj> +)
}

sp {state-diff*elaborate*valid-objects
    (state <s> ^name state-diff)
    -->
    (<s> ^valid-objects <objs> +)
}

sp {state-union*elaborate*ignore
    (state <s> ^name state-union ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^name state-union ^ignore <ig>)
    -->
    (<s> ^ignore <ig> +)
}

sp {state-diff*elaborate*attend-only
    (state <s> ^name state-diff ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^name state-diff ^attend-only <ig>)
    -->
    (<s> ^attend-only <ig> +)
}

sp {state-diff*elaborate*attend
    (state <s> ^name state-diff ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^name state-diff ^attend <ig>)
    -->
    (<s> ^attend <ig> +)
}

sp {state-diff*elaborate*ignore
    (state <s> ^name state-diff ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^name state-diff ^ignore <ig>)
    -->
    (<s> ^ignore <ig> +)
}

sp {state-union*elaborate*operator-attrs
    (state <s> ^name state-union ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^name state-union ^final <fstate> ^initial <istate>)
    -->
    (<s> ^initial <istate> + ^final <fstate> + ^relationships <rels> +
           ^object-set <os> + ^object-desc-set <ods> +
           ^predicate-set <preds> +)
}

sp {state-diff*elaborate*operator-attrs
    (state <s> ^name state-diff ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^name state-diff ^final <fstate> ^initial <istate>)
    -->
    (<s> ^initial <istate> + ^final <fstate> + ^relationships <rels> +
           ^extra-relationships <erels> + ^object-set <os> +
           ^object-desc-set <ods> + ^predicate-set <preds> +)
}

sp {extract-state*elaborate*operator-attrs
    (state <s> ^name extract-state ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^name extract-state)
    -->
    (<s> ^relationships <rels> + ^object-set <objects> +
           ^predicate-set <preds> +)
}

sp {prefer*copy-extra-relationships*over*complete*state-diff
    (state <s> ^name state-diff ^operator <o2> + ^operator <o1> +)
    (<o2> ^name complete)
    (<o1> ^name copy-extra-relationships)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*copy-objects*over*complete*state-union
    (state <s> ^name state-union ^operator <o2> + ^operator <o1> +)
    (<o2> ^name complete)
    (<o1> ^name copy-objects)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*copy-objects*over*complete*state-diff
    (state <s> ^name state-diff ^operator <o2> + ^operator <o1> +)
    (<o2> ^name complete)
    (<o1> ^name copy-objects)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*copy-predicates*over*complete*state-union
    (state <s> ^name state-diff ^operator <o2> + ^operator <o1> +)
    (<o2> ^name complete)
    (<o1> ^name copy-predicates)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*copy-relationships*over*complete*state-union
    (state <s> ^name state-union ^operator <o2> + ^operator <o1> +)
    (<o2> ^name complete)
    (<o1> ^name copy-relationships)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*copy-new-relationships*over*complete*state-diff
    (state <s> ^name state-diff ^operator <o2> + ^operator <o1> +)
    (<o2> ^name complete)
    (<o1> ^name copy-new-relationships)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*copy-objects*over*copy-predicates*state-diff
    (state <s> ^name state-diff ^operator <o2> + ^operator <o1> +)
    (<o2> ^name copy-predicates)
    (<o1>
          ^name { << copy-objects copy-relationships copy-extra-relationships copy-new-relationships >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*copy-objects*over*copy-extra-relationships*state-diff
    (state <s> ^name state-diff ^operator <o2> + ^operator <o1> +)
    (<o2> ^name copy-extra-relationships)
    (<o1> ^name copy-objects)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*copy-new-relationships*over*copy-extra-relationships*state-diff
    (state <s> ^name state-diff ^operator <o2> + ^operator <o1> +)
    (<o2> ^name copy-extra-relationships)
    (<o1> ^name copy-new-relationships)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*copy-relationships*over*copy-objects*state-union
    (state <s> ^name state-union ^operator <o2> + ^operator <o1> +)
    (<o2> ^name copy-objects)
    (<o1> ^name copy-relationships)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*copy-new-relationships*over*copy-objects*state-diff
    (state <s> ^name state-diff ^operator <o2> + ^operator <o1> +)
    (<o2> ^name copy-objects)
    (<o1> ^name copy-new-relationships)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*copy-predicates*over*complete-state
    (state <s> ^name extract-state ^operator <o2> + ^operator <o1> +)
    (<o2> ^name complete-state)
    (<o1> ^name copy-predicates)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*copy-objects*over*complete-state
    (state <s> ^name extract-state ^operator <o2> + ^operator <o1> +)
    (<o2> ^name complete-state)
    (<o1> ^name copy-objects)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*copy-relationships*over*complete-state
    (state <s> ^name extract-state ^operator <o2> + ^operator <o1> +)
    (<o2> ^name complete-state)
    (<o1> ^name copy-relationships)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*copy-objects*over*copy-predicates
    (state <s> ^name extract-state ^operator <o2> + ^operator <o1> +)
    (<o2> ^name copy-predicates)
    (<o1> ^name copy-objects)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*copy-relationships*over*copy-objects
    (state <s> ^name extract-state ^operator <o2> + ^operator <o1> +)
    (<o2> ^name copy-objects)
    (<o1> ^name copy-relationships)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {clean-up*top-state*found-action-aftersolve
    (state <s> ^name interaction ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name complete-interaction)
    (<t*1> ^dialog-context <ts>)
    (<ts> ^perform-action <fa>)
    (<fa> ^mark done)
    -->
    (<ts> ^perform-action <fa> -)
}

sp {find-solution*apply*complete-finding-solution*send-message*lose
    (state <s> ^name find-solution ^operator <o> ^top-state <t*2>
          ^top-state <t*1>)
    (<o> ^name complete-finding-solution)
    (<t*2> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type easy +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <de> +)
    (<de> ^type game + ^originator agent +)
}

#sp {find-solution*apply*complete-finding-solution*write-solution
#    (state <s> ^name find-solution ^operator <o>)
#    (<o> ^name complete-finding-solution)
#    -->
#    (write (cmd |ctf solution.txt print (* ^dcount *) -d 3|))
#}

sp {find-solution*apply*complete-finding-solution*action-stack-push*number
    (state <s> ^name find-solution ^operator <o> ^top-state <t*2>
          ^top-state <t*1>)
    (<o> ^name complete-finding-solution)
    (<t*2> ^dialog-context <dc>)
    (<dc> ^perform-action <pa>)
    (<pa> ^vname write1 ^obj1 <obj1> ^pname <prep> ^dcount <order>
          ^obj2 <obj2>)
    (<obj1> -^handle <h*1>)
    (<t*1> ^action-stack <as>)
    (<as> ^changes <a2>)
    -->
    (<a2> ^push <eo> +)
    (<eo> ^execution-operator <eo1> + ^order <order> +)
    (<eo1> ^action-handle <verb> + ^arg1 <arg1> + ^arg2 <arg2> +
           ^name op_write1 +)
    (<arg1> ^arg-type number + ^id <obj1> +)
    (<arg2> ^2 <obj2> + ^arg-type predicate + ^handle <prep> +)
}

sp {find-solution*apply*complete-finding-solution*action-stack-push
    (state <s> ^name find-solution ^operator <o> ^top-state <t*2>
          ^top-state <t*1>)
    (<o> ^name complete-finding-solution)
    (<t*2> ^dialog-context <dc>)
    (<dc> ^perform-action <pa>)
    (<pa> ^vname move1 ^pname <prep> ^dcount <order> ^obj2 <obj2> ^obj1 <obj1>)
    (<obj1> ^handle <h*1>)
    (<t*1> ^action-stack <as>)
    (<as> ^changes <a2>)
    -->
    (<a2> ^push <eo> +)
    (<eo> ^execution-operator <eo1> + ^order <order> +)
    (<eo1> ^action-handle <verb> + ^arg1 <arg1> + ^arg2 <arg2> +
           ^name op_move1 +)
    (<arg1> ^arg-type object + ^id <obj1> +)
    (<arg2> ^2 <obj2> + ^arg-type predicate + ^handle <prep> +)
}

sp {find-solution*apply*completed-all-actions*send-message*lose
    (state <s> ^name find-solution ^superstate <s*1> ^operator <o>
          ^top-state <t*3> ^top-state <t*2> ^top-state <t*1>)
    (<s*1> ^multiplayer true)
    (<o> ^name completed-all-actions)
    (<t*3> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<t*2> ^interaction <i*1>)
    (<t*1> ^game-status <g*1>)
    (<g*1> ^game-lost true)
    (<i*1> ^status <status>)
    -->
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type i-lose +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <de> +)
    (<de> ^type game + ^originator agent +)
}

sp {find-solution*apply*completed-all-actions*send-message*won
    (state <s> ^name find-solution ^superstate <s*1> ^operator <o>
          ^top-state <t*3> ^top-state <t*2> ^top-state <t*1>)
    (<s*1> ^multiplayer true)
    (<o> ^name completed-all-actions)
    (<t*3> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<t*2> ^interaction <i*1>)
    (<t*1> ^game-status <g*1>)
    (<g*1> ^game-won true)
    (<i*1> ^status <status>)
    -->
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type i-win +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <de> +)
    (<de> ^type game + ^originator agent +)
}

sp {find-solution*apply*completed-all-actions*send-message*your-turn
    (state <s> ^name find-solution ^superstate <s*1> ^operator <o>
          ^top-state <t*4> ^top-state <t*3>)
   -{ (<s> ^top-state <t*2>)
      (<t*2> ^game-status <g*2>)
      (<g*2> ^game-won true)}
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^game-status <g*1>)
      (<g*1> ^game-lost true)}
    (<s*1> ^multiplayer true)
    (<o> ^name completed-all-actions)
    (<t*4> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<t*3> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type your-turn +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <de> +)
    (<de> ^type game + ^originator agent +)
}

sp {find-solution*apply*completed-all-actions*send-message
    (state <s> ^name find-solution ^superstate <s*1> ^operator <o>
          ^top-state <t*2> ^top-state <t*1>)
    (<s*1> ^multiplayer false)
    (<o> ^name completed-all-actions)
    (<t*2> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type easy +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <de> +)
    (<de> ^type game + ^originator agent +)
}

sp {find-solution*apply*completed-all-actions*remove*dialog-context*game
    (state <s> ^name find-solution ^superstate <s*1> ^operator <o>
          ^top-state <ts>)
    (<s*1> ^multiplayer true)
    (<o> ^name completed-all-actions)
    (<ts> ^game-status <gs> ^dialog-context <dc>)
    (<gs> ^{ << game-lost game-won >> <a*1> } true)
    -->
    (<ts> ^dialog-context <dc> - ^game-status <gs> -)
}

sp {find-solution*apply*completed-all-actions*remove*game-replay*game
    (state <s> ^name find-solution ^superstate <s*1> ^operator <o>
          ^top-state <ts>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^dialog-context <d*1>)}
    (<s*1> ^multiplayer true)
    (<o> ^name completed-all-actions)
    (<ts> ^game-replay <g> ^game-status <gs>)
    (<gs> ^{ << game-lost game-won >> <a*1> } true)
    -->
    (<ts> ^game-replay <g> -)
}

sp {find-solution*apply*completed-all-actions*remove*game-status*game
    (state <s> ^name find-solution ^superstate <s*1> ^operator <o>
          ^top-state <ts>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^dialog-context <d*1>)}
    (<s*1> ^multiplayer true)
    (<o> ^name completed-all-actions)
    (<ts> ^game-status <gs>)
    (<gs> ^{ << game-lost game-won >> <a*1> } true)
    -->
    (<ts> ^game-status <gs> -)
}

sp {find-solution*apply*completed-all-actions*remove*game-status
    (state <s> ^name find-solution ^operator <o> ^top-state <ts>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^multiplayer true)}
    (<o> ^name completed-all-actions)
    (<ts> ^game-status <dc>)
    -->
    (<ts> ^game-status <dc> -)
}

sp {find-solution*apply*completed-all-actions*remove*dialog-context
    (state <s> ^name find-solution ^operator <o> ^top-state <ts>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^multiplayer true)}
    (<o> ^name completed-all-actions)
    (<ts> ^dialog-context <dc>)
    -->
    (<ts> ^dialog-context <dc> -)
}

sp {find-solution*apply*complete-finding-solution*remove*game-replay
    (state <s> ^name find-solution ^operator <o> ^top-state <ts>)
    (<o> ^name complete-finding-solution)
    (<ts> ^game-replay <dc>)
    -->
    (<ts> ^game-replay <dc> -)
}

sp {find-solution*apply*complete-finding-solution*remove*game-status
    (state <s> ^name find-solution ^operator <o> ^top-state <ts>)
    (<o> ^name complete-finding-solution)
    (<ts> ^game-status <dc>)
    -->
    (<ts> ^game-status <dc> -)
}

sp {find-solution*apply*complete-finding-solution*remove*dialog-context
    (state <s> ^name find-solution ^top-state <ts> ^operator <o>)
    (<ts> ^world-usage external ^dialog-context <dc>)
    (<o> ^name complete-finding-solution)
    -->
    (<ts> ^dialog-context <dc> -)
}

sp {find-solution*apply*complete-finding-solution*remove*found-action
    (state <s> ^name find-solution ^top-state <ts> ^operator <o> ^game <game>)
    (<ts> ^game-scripting true ^world-usage external ^perform-action <fa>
          ^<game> <g1>)
    (<o> ^name complete-finding-solution)
    -->
    (<ts> ^perform-action <fa> -)
    (<g1> ^performed-action <fa> +)
}

sp {find-solution*apply*completed-all-actions*remove*found-action
    (state <s> ^name find-solution ^top-state <t*1> ^operator <o>
          ^top-state <t*2>)
    (<t*1> ^world-usage external)
    (<o> ^name completed-all-actions)
    (<t*2> ^dialog-context <ts>)
    (<ts> ^perform-action <fa>)
    -->
    (<ts> ^perform-action <fa> -)
}

sp {find-solution*propose*completed-all-actions*game-lost
    (state <s> ^name find-solution ^top-state <t*1>)
    (<t*1> ^game-status <g*1>)
    (<g*1> ^game-lost true)
    -->
    (<s> ^operator <o> + ^operator <o> > ^operator <o> =)
    (<o> ^name completed-all-actions +)
}

sp {find-solution*propose*completed-all-actions
    (state <s> ^name find-solution ^top-state <ts> ^top-state <t*1>)
   -{ (<ts> ^perform-action <fa2>)
      (<fa2> -^mark <m*2>)}
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^perform-action <fa>)
    (<fa> ^mark <m*1> ^dcount <dc> ^obj2 <ob> ^obj1 <oa>)
    -->
    (<s> ^operator <o> + ^operator <o> < ^operator <o> =)
    (<o> ^name completed-all-actions +)
}

sp {find-solution*elabroate*attend-to-arm
    (state <s> ^name find-solution ^robot-state <r*1> ^found-action <f*1>)
    (<r*1> ^arm <a*1>)
    (<a*1> ^grabbed <g*1>)
    -->
    (<s> ^attend-to-arm true +)
}

sp {find-solution*apply*execute-action
    (state <s> ^name find-solution ^operator <o>)
    (<o> ^name execute-action ^action-ref <fa>)
    -->
    (<fa> ^started true +)
}

sp {find-solution*propose*complete-finding-solution*number
    (state <s> ^name find-solution ^found-action <f*1> ^top-state <ts>
          ^world <w*1>)
    (<ts> ^dialog-context <d5>)
    (<d5> ^perform-action <fa>)
    (<fa> -^mark <m*1> ^dcount <dc> ^obj1 <oa> ^pname <pname> ^obj2 <ob>)
   -{ (<d5> ^perform-action <fa2>)
      (<fa2> -^mark <m*2> ^dcount { < <dc> <d*1> })}
    (<oa> -^handle <h*1>)
    (<ob> ^handle <id2>)
    (<w*1> ^objects <objs>)
    (<objs> ^object <obj2>)
    (<obj2> ^handle <id2>)
    -->
    (<s> ^operator <o> + ^operator <o> = ^operator <o> >)
    (<o> ^name complete-finding-solution +)
}

sp {find-solution*propose*complete-finding-solution
    (state <s> ^name find-solution ^found-action <f*1> ^top-state <ts>
          ^world <w*1>)
    (<ts> ^dialog-context <d5>)
    (<d5> ^perform-action <fa>)
    (<fa> -^mark <m*1> ^dcount <dc> ^pname <pname> ^obj2 <ob> ^obj1 <oa>)
   -{ (<d5> ^perform-action <fa2>)
      (<fa2> -^mark <m*2> ^dcount { < <dc> <d*1> })}
    (<ob> ^handle <id2>)
    (<oa> ^handle <id1>)
    (<w*1> ^objects <objs>)
    (<objs> ^object <obj2> ^object <obj1>)
    (<obj2> ^handle <id2>)
    (<obj1> ^handle <id1>)
    -->
    (<s> ^operator <o> + ^operator <o> = ^operator <o> >)
    (<o> ^name complete-finding-solution +)
}

sp {find-solution*propose*game-search*muliplayer
    (state <s> ^name find-solution -^found-action <f*1> ^superstate <s*1>
          ^superstate <s*2>)
    (<s*1> ^multiplayer true)
    (<s*2> ^operator <op>)
    (<op> ^game-name <name>)
    -->
    (<s> ^operator <o> + ^operator <o> = ^operator <o> <)
    (<o> ^name game-search + ^dcount 0 + ^depth-limit 3 + ^list <l*1> +
           ^current <g> + ^game <name> +)
    (<l*1> ^game <g> +)
    (<g> ^game <name> + ^type action + ^type goal + ^type failure +
           ^type heuristic +)
}

sp {find-solution*apply*game-learning-complete
    (state <s> ^name find-solution ^operator <o> ^top-state <t*3>
          ^top-state <t*2> ^top-state <t*1>)
    (<o> ^name game-learning-complete ^game <name> ^type <type>)
    (<t*3> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<t*2> ^interaction <i*1>)
    (<t*1> ^dialog-context <dc>)
    (<i*1> ^status <status>)
    -->
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type learned-game + ^fields <f> +)
    (<f> ^game <name> + ^type <type> +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <de> +)
    (<de> ^type game + ^originator agent +)
    (<dc> ^finished-game-teaching true +)
}

sp {find-solution*propose*game-learning-complete*puzzle
    (state <s> ^name find-solution -^found-action <f*1> -^replay true
          ^superstate <s*2>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^multiplayer true)}
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^dialog-context <d*1>)
      (<d*1> ^finished-game-teaching true)}
    (<s*2> ^operator <op>)
    (<op> ^game-name <name>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name game-learning-complete + ^type puzzle + ^game <name> +)
}

sp {find-solution*propose*game-learning-complete
    (state <s> ^name find-solution -^replay true -^found-action <f*1>
          ^superstate <s*1> ^superstate <s*2>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^dialog-context <d*1>)
      (<d*1> ^finished-game-teaching true)}
    (<s*1> ^multiplayer true)
    (<s*2> ^operator <op>)
    (<op> ^game-name <name>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name game-learning-complete + ^type game + ^game <name> +)
}

sp {find-solution*prefer*chunk-game*over*game-learning-complete
    (state <s> ^name find-solution ^operator <o> + ^operator <o2> +)
    (<o> ^name chunk-game)
    (<o2> ^name game-learning-complete)
    -->
    (<s> ^operator <o> > <o2>)
}

sp {find-solution*prefer*chunk-game*over*chunk-game-structure
    (state <s> ^name find-solution ^operator <o> + ^operator <o2> +)
    (<o> ^name chunk-game)
    (<o2> ^name chunk-game-structure)
    -->
    (<s> ^operator <o> > <o2>)
}

sp {find-solution*prefer*chunk-game*over*chunk-predicate-structure
    (state <s> ^name find-solution ^operator <o> + ^operator <o2> +)
    (<o> ^name chunk-game)
    (<o2> ^name chunk-predicate-structure)
    -->
    (<s> ^operator <o> < <o2>)
}

sp {find-solution*prefer*chunk-game-structure*over*chunk-predicate-structure
    (state <s> ^name find-solution ^operator <o> + ^operator <o2> +)
    (<o> ^name chunk-game-structure)
    (<o2> ^name chunk-predicate-structure)
    -->
    (<s> ^operator <o> < <o2>)
}

sp {find-solution*prefer*chunk-game-structure*over*game-learning-complete
    (state <s> ^name find-solution ^operator <o> + ^operator <o2> +)
    (<o> ^name chunk-game-structure)
    (<o2> ^name game-learning-complete)
    -->
    (<s> ^operator <o> > <o2>)
}

sp {find-solution*prefer*chunk-predicate-structure*over*game-learning-complete
    (state <s> ^name find-solution ^operator <o> + ^operator <o2> +)
    (<o> ^name chunk-predicate-structure)
    (<o2> ^name game-learning-complete)
    -->
    (<s> ^operator <o> > <o2>)
}

sp {find-solution*elaborate*found-true
    (state <s> ^name find-solution ^top-state <t*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^perform-action <p*1>)
    (<p*1> ^dcount 0)
    -->
    (<s> ^found-action true +)
}

sp {find-solution*elaborate*depth-limit-1-less
    (state <s> ^name find-solution ^depth-limit <dl>)
    -->
    (<s> ^depth-limit-1-less (- <dl> 1) +)
}

sp {find-solution*propose*game-search
    (state <s> ^name find-solution -^found-action <f*1> ^depth-limit <dl>
          ^action <a*1> ^goal <g*1> ^superstate <s*2>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^multiplayer true)}
    (<s*2> ^operator <op>)
    (<op> ^game-name <name>)
    -->
    (<s> ^operator <o> + ^operator <o> = ^operator <o> <)
    (<o> ^name game-search + ^dcount 0 + ^depth-limit <dl> + ^list <l*1> +
           ^current <g> + ^game <name> +)
    (<l*1> ^game <g> +)
    (<g> ^game <name> + ^type action + ^type goal + ^type failure +
           ^type heuristic +)
}

sp {find-solution*propose*chunk-predicate-structure*failure
    (state <s> ^name find-solution -^found-action <f*2> ^top-state <t*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^structure <s*1>)
    (<s*1> ^failures <f*3>)
    (<f*3> ^retrieve-handle <h>)
   -{ (<s> ^failure <f*1>)
      (<f*1> ^handle <h>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name chunk-predicate-structure + ^gtype failure +
           ^predicate-handle <h> +)
}

sp {find-solution*propose*chunk-predicate-structure*goal
    (state <s> ^name find-solution -^found-action <f*1> ^top-state <t*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^structure <s*1>)
    (<s*1> ^goals <g*2>)
    (<g*2> ^retrieve-handle <h>)
   -{ (<s> ^goal <g*1>)
      (<g*1> ^handle <h>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name chunk-predicate-structure + ^gtype goal +
           ^predicate-handle <h> +)
}

sp {find-solution*propose*chunk-predicate-structure*action
    (state <s> ^name find-solution -^found-action <f*1> ^top-state <t*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^structure <s*1>)
    (<s*1> ^actions <a*2>)
    (<a*2> ^retrieve-handle <h>)
   -{ (<s> ^action <a*1>)
      (<a*1> ^handle <h>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name chunk-predicate-structure + ^gtype action +
           ^predicate-handle <h> +)
}

sp {find-solution*propose*chunk-predicate-structure*heuristics
    (state <s> ^name find-solution -^found-action <f*1> ^top-state <t*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^structure <s*1>)
    (<s*1> ^heuristics <h*2>)
    (<h*2> ^retrieve-handle <h>)
   -{ (<s> ^heuristic <h*1>)
      (<h*1> ^handle <h>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name chunk-predicate-structure + ^gtype heuristic +
           ^predicate-handle <h> +)
}

sp {fchunk-game*chunk-game-structure
    (state <s> ^name chunk-game ^game-struct <g> ^smem <s*1> ^superstate <ss>)
   -{ (<g> -^retrieve-handle <r*1>)
      (state <s> ^<a*1> <v*1>)}
    (<s*1> ^command <sc>)
    -->
    (<sc> ^store <g> +)
    (<ss> ^chunked true +)
}

sp {chunk-game*start-search-depth
    (state <s> ^name chunk-game ^game-struct <g> ^top-state <t*1> ^smem <s*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^structure <s*2>)
    (<s*2> ^start-search-depth <d1>)
    (<s*1> ^command <sc>)
    -->
    (<g> ^start-search-depth <d1> +)
}

sp {chunk-game*retrieve-handles
    (state <s> ^name chunk-game ^game-struct <g> ^top-state <t*1> ^smem <s*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^structure <s*2>)
    (<s*1> ^command <sc>)
    (<s*2> ^{ << actions goals failures heuristics >> <a*1> } <v*1>)
    (<v*1> ^retrieve-handle <gname>)
    -->
    (<g> ^retrieve-handle <gname> +)
}

sp {chunk-game*elaborate*opponent*goals
    (state <s> ^name chunk-game ^game-struct <g> ^top-state <t*1>
          ^superstate <s*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^structure <s*2>)
    (<s*2> ^goals <g*1>)
    (<g*1> ^retrieve-handle <name>)
    (<s*1> ^action <a>)
    (<a> ^opponent true)
    -->
    (<g> ^opponent <name> +)
}

sp {chunk-game*elaborate*opponent
    (state <s> ^name chunk-game ^game-struct <g> ^top-state <t*1>
          ^superstate <s*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^structure <s*2>)
    (<s*2> ^actions <a*1>)
    (<a*1> ^retrieve-handle <name>)
    (<s*1> ^action <a>)
    (<a> ^opponent true ^handle <name>)
    -->
    (<g> ^opponent <name> +)
}

sp {chunk-game*game-handle
    (state <s> ^name chunk-game ^top-state <t*1> ^smem <s*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^structure <s*2>)
    (<s*2> ^handle <gname>)
    (<s*1> ^command <sc>)
    -->
    (<s> ^game-struct <g> +)
    (<g> ^handle <gname> + ^retrieve game +)
}

sp {find-solution*propose*chunk-game-structure
    (state <s> ^name find-solution -^found-action <f*1>
          -^retrieve-handle <r*1> ^top-state <t*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^structure <st>)
    (<st> ^handle <h>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name chunk-game-structure + ^predicate-handle <h> +)
}

sp {find-solution*elaborate*opponent
    (state <s> ^name find-solution ^action <a> ^top-state <t*1>)
    (<a> ^opponent <o> ^handle <r>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^structure <st>)
    (<st> ^handle <h>)
    -->
    (<s> ^opponent true + ^opponent false +)
}

sp {find-solution*propose*chunk-game
    (state <s> ^name find-solution -^found-action <f*1> -^chunked <c*1>
          ^top-state <t*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^structure <st>)
    (<st> ^handle <h>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name chunk-game + ^predicate-handle <h> +)
}

sp {find-solution*elaborate*problem-space*world
    (state <s> ^name find-solution ^top-state <t*1>)
    (<t*1> ^world <world2>)
    -->
    (<s> ^problem-space <p*1> +)
    (<p*1> ^world <world> +)
    (<world> ^source <world2> + ^copy-type shallow +)
}

sp {find-solution*propose*game-search*elab-replay-true
    (state <s> ^name find-solution ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^replay true)
    -->
    (<s> ^chunked true + ^replay true +)
}

sp {find-solution*elab*opponent*finished
    (state <s> ^name find-solution ^top-state <t*2> ^top-state <t*1>)
    (<t*2> ^dialog-context <d*2>)
    (<d*2> ^finished-game-teaching true)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^structure <s*1>)
    (<s*1> ^multiplayer true)
    -->
    (<s> ^opponent true + ^opponent false +)
}

sp {find-solution*propose*game-search*elaborate*start-search-depth
    (state <s> ^name find-solution ^start-search-depth <d>
          ^retrieve-game <name>)
    -->
    (<s> ^depth-limit <d> +)
}

sp {find-solution*propose*game-search*elaborate*initial-depth-limit
    (state <s> ^name find-solution -^start-search-depth <s*1>
          ^retrieve-game <name>)
    -->
    (<s> ^depth-limit 1 +)
}

sp {find-solution*propose*game-search*elaborate*retrieve-game
    (state <s> ^name find-solution ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^game-name <name>)
    -->
    (<s> ^game <name> + ^retrieve-game <name> + ^gtype goal + ^gtype action +
           ^gtype failure + ^gtype heuristic +)
}

sp {finished-game-teaching*apply*prepare-game
    (state <s> ^name finished-game-teaching ^operator <o> ^top-state <t*2>
          ^top-state <t*1>)
    (<o> ^name prepare-game)
    (<t*2> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type tell-me-go +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <de> +)
    (<de> ^type game + ^originator agent +)
}

sp {finished-game-teaching*apply*clean-up-after-learning
    (state <s> ^name finished-game-teaching ^operator <o> ^top-state <ts>)
    (<o> ^name clean-up-after-learning)
    (<ts> ^dialog-context <dc> ^interaction <int>)
    (<int> ^changes <changes> ^status <status>)
    -->
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type ok +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <de> +)
    (<de> ^type game + ^originator agent +)
    (<dc> ^capture-data yes +)
}

sp {apply*clean-up-after-learning*capture-data
    (state <s> ^name interaction ^operator <o*1> ^top-state <ts>)
    (<o*1> ^name pop-segment)
    (<ts> ^dialog-context <dc>)
    (<dc> ^capture-data yes)
    -->
    (<ts> ^dialog-context <dc> -)
    (<s> ^old-context <dc> +)
#    (write (cmd |ctf -a pertaskstats.txt stats|))
#    (write (cmd |ctf -a smemuse.txt smem --stats mem-usage|))
}

sp {finished-game-teaching*propose*clean-up-after-learning*no
    (state <s> ^name finished-game-teaching ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^response no)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name clean-up-after-learning +)
}

sp {finished-game-teaching*propose*prepare-game*yes
    (state <s> ^name finished-game-teaching ^top-state <t*2> ^top-state <t*1>
          ^superstate <s*2>)
    (<t*2> ^dialog-context <d*2>)
    (<d*2> ^structure <s*3>)
    (<s*3> ^handle <name>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^structure <s*1>)
    (<s*1> ^multiplayer true)
    (<s*2> ^operator <o*1>)
    (<o*1> ^response yes)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name prepare-game +)
}

sp {finished-game-teaching*apply*prepare-game*replay
    (state <s> ^name finished-game-teaching ^operator <o*1> ^top-state <ts>
          ^superstate <s*1>)
    (<o*1> ^name prepare-game)
    (<s*1> ^operator <sop>)
    (<sop> ^multiplayer true ^type replay-game ^game-name <name>)
    -->
    (<ts> ^game-replay <name> +)
}

sp {finished-game-teaching*propose*prepare-game*replay
    (state <s> ^name finished-game-teaching ^superstate <s*1>)
    (<s*1> ^operator <sop>)
    (<sop> ^multiplayer true ^type replay-game ^game-name <name>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name prepare-game +)
}

sp {finished-game-teaching*propose*setup-search*replay
    (state <s> ^name finished-game-teaching ^superstate <s*1>)
    (<s*1> ^operator <sop>)
    (<sop> ^multiplayer false ^type replay-game ^game-name <name>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name setup-search + ^multiplayer false + ^game-name <name> +)
}

sp {finished-game-teaching*propose*setup-search*yes
    (state <s> ^name finished-game-teaching ^top-state <t*2> ^superstate <s*2>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^dialog-context <d*1>)
      (<d*1> ^structure <s*1>)
      (<s*1> ^multiplayer true)}
    (<t*2> ^dialog-context <d*2>)
    (<d*2> ^structure <s*3>)
    (<s*3> ^handle <name>)
    (<s*2> ^operator <o*1>)
    (<o*1> ^response yes)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name setup-search + ^multiplayer false + ^game-name <name> +)
}

#sp {finished-game-teaching*apply*setup-search*printtime
#    (state <s> ^name finished-game-teaching ^operator <o*2> ^superstate <s*2>)
#   -{ (<s> ^top-state <t*1>)
#      (<t*1> ^dialog-context <d*1>)
#      (<d*1> ^structure <s*1>)
#      (<s*1> ^multiplayer true)}
#    (<o*2> ^name setup-search)
#    (<s*2> ^operator <o*1>)
#    (<o*1> ^response yes)
#    -->
#    (write (cmd |ctf endlearntime.txt stats|))
#}

sp {finished-game-teaching*propose*setup-search*game-replay
    (state <s> ^name finished-game-teaching ^top-state <t*1> ^superstate <s*1>)
   -{ (<s> ^top-state <t*2>)
      (<t*2> ^dialog-context <d*1>)}
    (<t*1> ^game-replay <name>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^type game)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name setup-search + ^multiplayer true + ^game-name <name> +)
}

sp {finished-game-teaching*propose*setup-search
    (state <s> ^name finished-game-teaching ^top-state <t*1> ^superstate <s*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^structure <s*2>)
    (<s*2> ^handle <name>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^type game)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name setup-search + ^game-name <name> +)
}

sp {setup-search*elaborate*problem-space*predicate-structure
    (state <s> ^name setup-search ^top-state <t*1>)
    (<t*1> ^world <world2>)
    -->
    (<s> ^problem-space <p*1> +)
    (<p*1> ^world <world> +)
    (<world> ^source <world2> + ^copy-type deep +)
}

sp {setup-search*propose*find-solution2
    (state <s> ^name setup-search ^superstate <s*1>)
    (<s*1> ^operator <op>)
    (<op> ^multiplayer <m*1> ^game-name <name>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name find-solution + ^replay true + ^game-name <name> +)
}

sp {setup-search*propose*find-solution
    (state <s> ^name setup-search ^superstate <s*1>)
    (<s*1> ^operator <op>)
    (<op> -^multiplayer <m*1> ^game-name <name>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name find-solution + ^game-name <name> +)
}

sp {setup-search*elaborate*multiplayer
    (state <s> ^name setup-search ^superstate <s*1>)
    (<s*1> ^operator <op>)
    (<op> ^multiplayer <m> ^game-name <name>)
    -->
    (<s> ^multiplayer <m> +)
}

sp {setup-search*elaborate*tcn
    (state <s> ^name setup-search ^top-state <t*1> ^superstate <s*2>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^structure <s*1>)
    (<s*1> ^multiplayer <cg>)
    (<s*2> ^operator <op>)
    (<op> ^game-name <name>)
    -->
    (<s> ^multiplayer <cg> +)
}

sp {selection*prefer*evaluate*action*over*hackforcannibals
    (state <s> ^name selection ^superstate <s*1> ^operator <o2> +
          ^operator <o1> +)
    (<s*1> ^dcount 0)
    (<o2> ^name evaluate-operator ^superoperator <so2>)
    (<so2> ^type action ^verb-structure <v*3>)
    (<o1> ^name evaluate-operator ^superoperator <so>)
   -{ (<so> ^verb-structure <v*1>)
      (<v*1> ^3 <v*2>)}
    (<so> ^type action)
    (<v*3> ^3 <v*4>)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {selection*prefer*evaluate*action*over*default
    (state <s> ^name selection ^operator <o2> + ^operator <o1> +)
    (<o2> ^name evaluate-operator ^superoperator <s*2>)
    (<s*2> ^name default)
    (<o1> ^name evaluate-operator ^superoperator <s*1>)
    (<s*1> ^type action)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {game-search*apply*default*depth-limit-increase
    (state <s> ^dcount 0 ^multiplayer false ^name game-search ^operator <o*1>
          ^superstate <ss>)
    (<o*1> ^name default)
    (<ss> ^depth-limit <d>)
    -->
    (write (crlf) (+ <d> 1))
    (<ss> ^depth-limit <d> - ^depth-limit (+ <d> 1) +)
}

sp {game-search*apply*default*top-select-random-action*top*pick*random
    (state <s> ^dcount 0 ^multiplayer true ^name game-search ^operator <o*1>
          ^operator <o> +)
    (<o*1> ^name default)
    (<o> ^type action)
    -->
    (<s> ^operator <o> = ^operator <o> >)
}

sp {game-search*apply*default*top-select-random-action
    (state <s> ^opponent true ^multiplayer true ^name game-search
          ^operator <o*1> ^operator <o> +)
    (<o*1> ^name default)
    (<o> ^type action)
    -->
    (<s> ^operator <o> = ^operator <o> >)
}

sp {game-search*apply*default*multiplayer*success
    (state <s> ^multiplayer true -^dcount 0 -^opponent true ^name game-search
          ^operator <o*1> ^desired <d>)
    (<o*1> ^name default)
    -->
    (<s> ^partial-failure <d> +)
}

sp {game-search*apply*default
    (state <s> ^name game-search -^dcount 0 -^multiplayer true ^operator <o*1>
          ^desired <d>)
    (<o*1> ^name default)
    -->
    (<s> ^partial-failure <d> +)
}

sp {game-search*propose*default
    (state <s> ^name game-search)
   -{ (<s> ^action <a>)
     -{ (<a> ^parameter-set <p*1>)
        (<p*1> ^argnum <a*1>)}}
    -->
    (<s> ^operator <o1> +)
    (<o1> ^name default +)
}

sp {game-search*equivalent-action*reject4*ordering
    (state <s> ^name game-search ^operator <o2> + ^operator <o1> +)
    (<o2> -^duplicate-of <d*2> ^type action ^name <cname> ^parameters <p2>)
    (<o1> -^duplicate-of <d*1> ^type action ^name <cname> ^verb-structure <vs>
          ^parameters { < <p2> <p> })
    (<vs> ^3 <act3> ^1 <act1>)
    (<act3> ^2 <in4> ^1 <in3>)
    (<act1> ^2 <in2> ^1 <in1>)
    (<p2> ^<in2> <b1> ^<in4> <b> ^<in1> <a1> ^<in3> <a>)
    (<p> ^<in4> <b1> ^<in2> <b> ^<in3> <a1> ^<in1> <a>)
    -->
    (<s> ^operator <o2> -)
}

sp {game-search*prefer*failure*to*goal
    (state <s> ^name game-search ^operator <o2> + ^operator <o1> +)
    (<o2> ^type goal)
    (<o1> ^type failure)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {game-search*prefer*failure
    (state <s> ^name game-search ^operator <o1> +)
    (<o1> ^type failure)
    -->
    (<s> ^operator <o1> > ^operator <o1> =)
}

sp {game-search*prefer*goal
    (state <s> ^name game-search ^operator <o1> +)
    (<o1> ^type goal)
    -->
    (<s> ^operator <o1> > ^operator <o1> =)
}

sp {game-search*depth-limit*multiplayer
    (state <s> ^goal-search-delay 50 ^simulated true ^multiplayer true
          ^name game-search ^depth-limit <dc> ^dcount <dc> ^desired <d>)
   -{ (<s> ^operator <o2> +)
      (<o2> ^type goal)}
   -{ (<s> ^goal <g*1>)
      (<g*1> ^parameter-set <p*1>)
      (<p*1> ^set <s*1>)}
    -->
    (<s> ^partial-failure <d> +)
}

sp {game-search*depth-limit
    (state <s> ^goal-search-delay 50 -^multiplayer true ^simulated true
          ^name game-search ^depth-limit <dc> ^dcount <dc> ^operator <o> +
          ^desired <d>)
   -{ (<s> ^operator <o2> +)
      (<o2> ^type goal)}
   -{ (<s> ^goal <g*1>)
      (<g*1> ^parameter-set <p*1>)
      (<p*1> ^set <s*1>)}
    (<o> -^duplicate-of <d*1> ^type action)
    -->
    (<s> ^partial-failure <d> +)
}

sp {selection*pass-back-success*puzzle
    (state <s> ^superstate <ss> ^evaluation <e*1> ^superstate <s*1>)
    (<ss> ^multiplayer false ^superstate <s*3>)
    (<e*1> ^symbolic-value { << success >> <s*2> })
    (<s*3> ^operator <sso>)
    (<sso> ^name evaluate-operator ^evaluation <e2> ^superoperator <s*4>)
    (<s*4> ^name <n*1>)
    -->
    (<e2> ^symbolic-value success +)
}

sp {game-search*apply*failure*multiplayer
    (state <s> ^multiplayer true ^name game-search ^operator <o*1>
          ^superstate <s*1>)
    (<o*1> ^type failure)
    (<s*1> ^superstate <ss>)
    (<ss> ^desired <d>)
    -->
    (<ss> ^failure <d> +)
}

sp {game-search*apply*failure
    (state <s> ^name game-search -^multiplayer true ^operator <o*1>
          ^desired <d>)
    (<o*1> ^type failure)
    -->
    (<s> ^partial-failure <d> +)
}

sp {game-search*apply*game-lost
    (state <s> ^dcount 0 ^multiplayer true ^name game-search ^operator <o*1>
          ^desired <d> ^top-state <ts>)
    (<o*1> ^type failure)
    -->
    (<ts> ^game-status <dc> +)
    (<dc> ^game-lost true +)
}

sp {game-search*apply*goal*multiplayer
    (state <s> ^multiplayer true -^dcount 0 -^dcount 1 ^name game-search
          ^operator <o*1> ^superstate <s*1>)
    (<o*1> ^type goal)
    (<s*1> ^superstate <ss>)
    (<ss> ^desired <d> ^superstate <sss>)
    (<sss> ^superstate <ts> ^operator <o*2>)
    (<o*2> ^superoperator <sop>)
    -->
    (<ss> ^failure <d> +)
    (<ts> ^fail <sop> +)
}

sp {game-search*apply*goal*multiplayer*depth0
    (state <s> ^multiplayer true ^name game-search ^operator <o*1>
          ^dcount { << 0 1 >> <d*1> } ^desired <d>)
    (<o*1> ^type goal)
    -->
    (<s> ^success <d> +)
}

sp {game-search*apply*goal
    (state <s> ^name game-search -^multiplayer true ^operator <o*1>
          ^desired <d>)
    (<o*1> ^type goal)
    -->
    (<s> ^success <d> +)
}

sp {game-search*apply*game-won
    (state <s> ^dcount 1 ^multiplayer true ^name game-search ^operator <o*1>
          ^desired <d> ^top-state <ts>)
    (<o*1> ^type goal)
    -->
    (<ts> ^game-status <dc> +)
    (<dc> ^game-won true +)
}

sp {game-search*apply*action*perform-action*top*singleaction*number
    (state <s> ^dcount 0 ^multiplayer true ^name game-search ^operator <o>
          ^action <act> ^top-state <ts> ^superstate <sss>)
    (<o> -^duplicate-of <d*1> ^type action ^parameters <p> ^name <cname>)
    (<act> ^handle <cname> ^verb-structure <v*1>)
    (<ts> ^dialog-context <d5> ^world <w*1>)
    (<w*1> ^objects <objs>)
    (<p> ^<i1> <o1> ^<i2> <o2>)
    (<o1> -^handle <h*1>)
    (<v*1> ^<num> <v1>)
    (<v1> ^1 <i1> ^verb-prep <vp> ^verb-name <vname> ^2 <i2>)
    (<o2> ^handle <handle2>)
    (<objs> ^object <objb>)
    (<objb> ^handle <handle2>)
    -->
    (<d5> ^perform-action <fa> +)
    (<fa> ^dcount (- <num> 1) + ^obj1 <o1> + ^obj2 <objb> + ^pname <vp> +
           ^vname <vname> +)
}

sp {game-search*apply*action*perform-action*top*singleaction
    (state <s> ^dcount 0 ^multiplayer true ^name game-search ^operator <o>
          ^action <act> ^top-state <ts> ^superstate <sss>)
    (<o> -^duplicate-of <d*1> ^type action ^parameters <p> ^name <cname>)
    (<act> ^handle <cname> ^verb-structure <v*1>)
    (<ts> ^dialog-context <d5> ^world <w*1>)
    (<w*1> ^objects <objs>)
    (<p> ^<i2> <o2> ^<i1> <o1>)
    (<o2> ^handle <handle2>)
    (<v*1> ^<num> <v1>)
    (<v1> ^2 <i2> ^verb-prep <vp> ^verb-name <vname> ^1 <i1>)
    (<o1> ^handle <handle1>)
    (<objs> ^object <objb> ^object <obja>)
    (<objb> ^handle <handle2>)
    (<obja> ^handle <handle1>)
    -->
    (<d5> ^perform-action <fa> +)
    (<fa> ^dcount (- <num> 1) + ^obj1 <obja> + ^obj2 <objb> + ^pname <vp> +
           ^vname <vname> +)
}

sp {game-search*apply*action*perform-action*top
    (state <s> ^dcount 0 ^name game-search ^operator <o> ^action <act>
          ^top-state <ts> ^superstate <sss>)
    (<o> -^duplicate-of <d*1> ^type action ^parameters <p> ^name <cname>)
    (<act> ^handle <cname> ^verb-structure <v*1>)
    (<v*1> ^<num> <v1>)
    (<v1> ^verb-prep <vp> ^verb-name <vname> ^2 <i2> ^1 <i1>)
    (<p> ^<i2> <o2> ^<i1> <o1>)
    -->
    (<sss> ^found-action true +)
}

sp {game-search*apply*action-failure*success
    (state <s> ^opponent true -^dcount 0 ^multiplayer true ^name game-search
          ^fail <o> ^operator <o> ^desired <d>)
    (<o> -^duplicate-of <d*1> ^type action)
    -->
    (<s> ^success <d> +)
}

sp {game-search*apply*action-failure
    (state <s> ^opponent true -^dcount 0 ^multiplayer true ^name game-search
          ^operator <o> -^fail <o> ^desired <d>)
    (<o> -^duplicate-of <d*1> ^type action)
    -->
    (<s> ^partial-failure <d> +)
}

sp {game-search*apply*action-success
    (state <s> ^opponent false -^dcount 0 ^multiplayer true ^name game-search
          ^operator <o> ^desired <d>)
    (<o> -^duplicate-of <d*1> ^type action)
    -->
    (<s> ^success <d> +)
}

sp {game-search*apply*action*perform-action*number
    (state <s> ^problemspace games ^name selection ^evaluation <e>
          ^superstate <ss> ^top-state <ts>)
    (<e> ^symbolic-value success ^superoperator <so>)
    (<ss> -^multiplayer true ^dcount <dc>)
    (<so> ^verb-structure <vs> ^parameters <p>)
    (<ts> ^dialog-context <d5> ^world <w*1>)
    (<w*1> ^objects <objs>)
    (<p> ^<i1> <o1> ^<i2> <o2>)
    (<o1> -^handle <h*1>)
    (<vs> ^<num> <vs2>)
    (<vs2> ^1 <i1> ^verb-prep <vp> ^verb-name <vname> ^2 <i2>)
    (<o2> ^handle <handle2>)
    (<objs> ^object <objb>)
    (<objb> ^handle <handle2>)
    -->
    (<d5> ^perform-action <fa> +)
    (<fa> ^dcount (- (+ (* 2 <dc>) <num>) 1) + ^obj1 <o1> + ^obj2 <objb> +
           ^pname <vp> + ^vname <vname> +)
}

sp {game-search*apply*action*perform-action
    (state <s> ^problemspace games ^name selection ^evaluation <e>
          ^superstate <ss> ^top-state <ts>)
    (<e> ^symbolic-value success ^superoperator <so>)
    (<ss> -^multiplayer true ^dcount <dc>)
    (<so> ^verb-structure <vs> ^parameters <p>)
    (<ts> ^dialog-context <d5> ^world <w*1>)
    (<w*1> ^objects <objs>)
    (<p> ^<i2> <o2> ^<i1> <o1>)
    (<o2> ^handle <handle2>)
    (<vs> ^<num> <vs2>)
    (<vs2> ^2 <i2> ^verb-prep <vp> ^verb-name <vname> ^1 <i1>)
    (<o1> ^handle <handle1>)
    (<objs> ^object <objb> ^object <obja>)
    (<objb> ^handle <handle2>)
    (<obja> ^handle <handle1>)
    -->
    (<d5> ^perform-action <fa> +)
    (<fa> ^dcount (- (+ (* 2 <dc>) <num>) 1) + ^obj1 <obja> + ^obj2 <objb> +
           ^pname <vp> + ^vname <vname> +)
}

sp {game-search*elaborate*input-args*set-to-single*objects
    (state <s> ^name game-search ^gtype <gtype> ^predicate <T5> ^<gtype> <g*1>)
    (<T5> ^link <co> ^condition <c> ^potential-args <P125>
          ^parameter-set <P124> ^nlp-set <nlps>)
    (<co> ^type concept ^attribute predicate ^name <name> ^args <args>)
    (<c> ^rtype single ^attribute input-arg ^parameter <p*1> ^result <r*2>)
    (<g*1> ^condition <co>)
    (<nlps> ^aname <name>)
    (<args> ^num { > 0 <n*1> } ^<a1> <c1>)
    (<p*1> ^1 <v*2>)
    (<v*2> ^param-id <a1>)
    (<c1> ^rtype set ^result <r*1>)
    (<r*2> ^set <res>)
    (<r*1> ^set <s*1>)
    (<s*1> ^instance <i*1>)
    (<i*1> ^1 <v*1>)
    (<v*1> ^<elem> <obj>)
    -->
    (<res> ^instance <i15> +)
    (<i15> ^1 <obj> +)
}

sp {game-search*elaborate*input-args
    (state <s> ^name game-search ^gtype <gtype> ^predicate <T5> ^<gtype> <g*1>)
    (<T5> ^link <co> ^condition <c> ^potential-args <P125>
          ^parameter-set <P124> ^nlp-set <nlps>)
    (<co> ^type concept ^attribute predicate ^name <name> ^args <args>)
    (<c> ^attribute input-arg ^rtype <rtype> ^parameter <p*1> ^result <r*2>)
    (<g*1> ^condition <co>)
    (<nlps> ^aname <name>)
    (<args> ^num { > 0 <n*1> } ^<a1> <c1>)
    (<p*1> ^1 <v*1>)
    (<v*1> ^param-id <a1>)
    (<c1> ^rtype <rtype> ^result <r*1>)
    (<r*2> ^set <res2>)
    (<r*1> ^set <s*1>)
    (<s*1> ^instance <in1>)
    -->
    (<res2> ^instance <in1> +)
}

sp {game-search*elaborate*retrieve-game
    (state <s> ^name game-search ^game <m>)
    -->
    (<s> ^retrieve-game <m> +)
}

sp {game-search*elaborate*opponent*false
    (state <s> ^multiplayer true ^name game-search
          ^dcount { << 0 2 4 6 8 >> <d*1> })
    -->
    (<s> ^opponent false +)
}

sp {game-search*elaborate*opponent
    (state <s> ^multiplayer true ^name game-search
          ^dcount { << 1 3 5 7 9 >> <d*1> })
    -->
    (<s> ^opponent true +)
}

sp {game-search*elaborate*nlp-set*verb-structure
    (state <s> ^gtype action ^name game-search ^action <t>)
    (<t> ^nlp-set <n*1>)
    (<n*1> ^verb-structure <vs>)
    -->
    (<t> ^verb-structure <vs> +)
}

sp {game-search*elaborate*sub-conditions*predicate
    (state <s> ^name game-search ^gtype <type> ^<type> <t>)
    (<t> ^nlp-set <n*1>)
    (<n*1> ^conditions <cond>)
    -->
    (<t> ^condition <cond> +)
}

sp {game-search*elaborate*sub-conditions
    (state <s> ^name game-search ^gtype <type> ^<type> <t>)
    (<t> ^condition <co>)
    (<co> ^args <a*1>)
    (<a*1> ^{ << 1 2 3 4 5 6 7 8 9 10 >> <arg> } <cond>)
    (<cond> ^name <name>)
    -->
    (<t> ^condition <cond> +)
}

sp {game-search*elaborate*action*nlp-set
    (state <s> ^name game-search ^gtype <gtype> ^<gtype> <act>)
    (<act> ^predicate-structure <p>)
    -->
    (<act> ^nlp-set <p> +)
}

sp {game-search*elaborate*other-levels*simulated
    (state <s> ^name game-search ^operator <o>)
    (<o> ^type action ^duplicate-of <d*1>)
    -->
    (<s> ^simulated true +)
}

sp {game-search*elaborate*top-level*simulated
    (state <s> ^name game-search ^superstate <s*1>)
    (<s*1> ^name find-solution)
    -->
    (<s> ^simulated true +)
}

sp {game-search*apply*simulate2*set
    (state <s> ^name game-search ^operator <o> ^deep-copy-world <d*1>
          ^world <w*1>)
    (<o> ^type action ^verb-structure <v*1> ^parameters <p> ^name <cname>)
    (<d*1> ^copy-objects-map <com>)
    (<w*1> ^predicates <p2>)
    (<p2> ^predicate <prep2> ^predicate <prep>)
    (<prep2> ^handle on1)
    (<prep> ^handle below1)
    (<com> ^<obj> <obja> ^<obj1> <objb>)
   -{ (<prep2> ^instance <i*2>)
      (<i*2> ^1 <obja>)}
   -{ (<prep> ^instance <i*1>)
      (<i*1> ^2 <obja>)}
    (<obj> ^handle <ha>)
    (<v*1> ^<num> <v1>)
    (<v1> ^verb-prep on1 ^2 <i2> ^1 <i1>)
    (<p> ^<i2> <obj1> ^<i1> <objects>)
    (<objects> ^object <obj>)
    -->
    (<prep> ^instance <instance3> +)
    (<prep2> ^instance <instance4> +)
    (<instance3> ^1 <objb> + ^2 <obja> +)
    (<instance4> ^1 <obja> + ^2 <objb> +)
}

sp {game-search*apply*simulate2
    (state <s> ^name game-search ^operator <o> ^deep-copy-world <d*1>
          ^world <w*1>)
    (<o> ^type action ^verb-structure <v*1> ^parameters <p> ^name <cname>)
    (<d*1> ^copy-objects-map <com>)
    (<w*1> ^predicates <p2>)
    (<p2> ^predicate <prep2> ^predicate <prep>)
    (<prep2> ^handle on1)
    (<prep> ^handle below1)
    (<com> ^<obj> <obja> ^<obj1> <objb>)
   -{ (<prep2> ^instance <i*2>)
      (<i*2> ^1 <obja>)}
   -{ (<prep> ^instance <i*1>)
      (<i*1> ^2 <obja>)}
    (<obj> ^handle <ha>)
    (<p> ^<i1> <obj> ^<i2> <obj1>)
    (<v*1> ^<num> <v1>)
    (<v1> ^verb-prep on1 ^1 <i1> ^2 <i2>)
    -->
    (<prep> ^instance <instance3> +)
    (<prep2> ^instance <instance4> +)
    (<instance3> ^1 <objb> + ^2 <obja> +)
    (<instance4> ^1 <obja> + ^2 <objb> +)
}

sp {game-search*apply*simulate*set
    (state <s> ^name game-search ^operator <o> ^deep-copy-world <d*1>
          ^world <w*1>)
    (<o> ^type action ^verb-structure <v*1> ^parameters <p> ^name <cname>)
    (<d*1> ^copy-objects-map <com>)
    (<w*1> ^predicates <p2>)
    (<p2> ^predicate <prep2> ^predicate <prep>)
    (<prep2> ^handle on1 ^instance <instance2>)
    (<prep> ^handle below1 ^instance <instance>)
    (<instance> ^2 <obja>)
    (<instance2> ^1 <obja>)
    (<com> ^<obj> <obja> ^<obj1> <objb>)
    (<obj> ^handle <ha>)
    (<v*1> ^<num> <v1>)
    (<v1> ^verb-prep on1 ^2 <i2> ^1 <i1>)
    (<p> ^<i2> <obj1> ^<i1> <objects>)
    (<objects> ^object <obj>)
    -->
    (<prep> ^instance <instance> - ^instance <instance3> +)
    (<prep2> ^instance <instance2> - ^instance <instance4> +)
    (<instance3> ^1 <objb> + ^2 <obja> +)
    (<instance4> ^1 <obja> + ^2 <objb> +)
}

sp {game-search*apply*simulate*right-of
    (state <s> ^name game-search ^operator <o> ^deep-copy-world <d*1>
          ^world <w*1>)
    (<o> ^type action ^verb-structure <v*1> ^parameters <p> ^name <cname>)
    (<d*1> ^copy-objects-map <com>)
    (<com> ^entry <e2> ^entry <e1>)
    (<e2> ^copy <objb> ^source <obj1>)
    (<e1> ^copy <obja> ^source <obj>)
    (<obj> ^handle <ha>)
    (<w*1> ^predicates <p2>)
    (<p2> ^predicate <prep>)
    (<prep> ^handle right-of1 ^instance <instance>)
    (<p> ^<i2> <obj1> ^<i1> <obj>)
    (<instance> ^{ << 1 2 >> <a*1> } <obja>)
    (<v*1> ^<num> <v1>)
    (<v1> ^verb-prep on1 ^2 <i2> ^1 <i1>)
    -->
    (<prep> ^instance <instance> -)
}

sp {game-search*apply*simulate
    (state <s> ^name game-search ^operator <o> ^deep-copy-world <d*1>
          ^world <w*1>)
    (<o> ^type action ^verb-structure <v*1> ^parameters <p> ^name <cname>)
    (<d*1> ^copy-objects-map <com>)
    (<w*1> ^predicates <p2>)
    (<p2> ^predicate <prep2> ^predicate <prep>)
    (<prep2> ^handle on1 ^instance <instance2>)
    (<prep> ^handle below1 ^instance <instance>)
    (<instance> ^2 <obja>)
    (<instance2> ^1 <obja>)
    (<com> ^<obj> <obja> ^<obj1> <objb>)
    (<obj> ^handle <ha>)
    (<p> ^<i1> <obj> ^<i2> <obj1>)
    (<v*1> ^<num> <v1>)
    (<v1> -^verb-name write1 ^verb-prep on1 ^1 <i1> ^2 <i2>)
    -->
    (<prep> ^instance <instance> - ^instance <instance3> +)
    (<prep2> ^instance <instance2> - ^instance <instance4> +)
    (<instance3> ^1 <objb> + ^2 <obja> +)
    (<instance4> ^1 <obja> + ^2 <objb> +)
}

sp {game-search*apply*simulate*write
    (state <s> ^name game-search ^operator <o> ^deep-copy-world <d*1>
          ^world <w*1>)
    (<o> ^type action ^verb-structure <v*1> ^parameters <p> ^name <cname>)
    (<d*1> ^copy-objects-map <com>)
    (<w*1> ^predicates <p2>)
    (<v*1> ^<vnum> <v1>)
    (<v1> ^verb-prep on1 ^verb-name write1 ^2 <i2> ^1 <i1>)
    (<p> ^<i2> <obj1> ^<i1> <num>)
    (<com> ^<obj1> <objb>)
    (<objb> ^predicates <pb>)
    -->
    (<pb> ^value <num> +)
}

sp {game-search*elaborate*problem-space*world
    (state <s> ^name game-search ^superstate <s*1>)
    (<s*1> ^superstate <s*2>)
    (<s*2> ^world <world2>)
    -->
    (<s> ^problem-space <ps> +)
    (<ps> ^world <world> + ^dont-copy-anything true + ^name game +)
    (<world> ^source <world2> + ^copy-type deep +)
}

sp {game-search*elaborate*dcount
    (state <s> ^name game-search ^superstate <s*1>)
    (<s*1> ^superstate <s*2>)
    (<s*2> ^dcount <dc>)
    -->
    (<s> ^dcount (+ 1 <dc>) +)
}

sp {game-search*elaborate*list
    (state <s> ^name game-search ^superstate <s*1>)
    (<s*1> ^superstate <s*2>)
    (<s*2> ^list <m>)
    -->
    (<s> ^list <m> +)
}

sp {game-search*elaborate*depth-limit
    (state <s> ^name game-search ^superstate <s*1>)
    (<s*1> ^superstate <s*2>)
    (<s*2> ^depth-limit <m>)
    -->
    (<s> ^depth-limit <m> +)
}

sp {game-search*elaborate*game
    (state <s> ^name game-search ^superstate <s*1>)
    (<s*1> ^superstate <s*2>)
    (<s*2> ^game <m>)
    -->
    (<s> ^game <m> +)
}

sp {game-search*elaborate*multiplayer
    (state <s> ^name game-search ^superstate <s*1>)
    (<s*1> ^superstate <s*2>)
    (<s*2> ^multiplayer <m>)
    -->
    (<s> ^multiplayer <m> +)
}

sp {game-search*increment-goal-delay
    (state <s> ^name game-search ^goal-search-delay { < 50 <d> })
    -->
    (<s> ^goal-search-delay (+ 1 <d>) +)
}

sp {game-search*elaborate*goal*multiplayer
    (state <s> ^simulated true ^multiplayer true ^name game-search)
    -->
    (<s> ^gtype goal + ^goal-search-delay 1 +)
}

sp {game-search*elaborate*goal
    (state <s> ^simulated true -^multiplayer true ^name game-search
          ^depth-limit <dc> ^dcount <dc>)
    -->
    (<s> ^gtype goal + ^goal-search-delay 1 +)
}

sp {game-search*elaborate*operator
    (state <s> ^name game-search ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^name game-search ^depth-limit <dl> ^dcount <dc> ^list <l>
          ^current <g> ^game <name>)
    -->
    (<s> ^dcount <dc> + ^depth-limit <dl> + ^list <l> + ^problemspace games +
           ^desired <d> + ^current <g> + ^game <name> +)
    (<d> ^found true +)
}

sp {game-search*elaborate*problem-space*bottom
    (state <s> ^simulated true ^name game-search ^depth-limit <dc>
          ^dcount <dc>)
    -->
    (<s> ^ntype action + ^ntype goal + ^ntype failure + ^gtype failure +)
}

sp {game-search*elaborate*problem-space
    (state <s> ^simulated true ^name game-search ^dcount <dc>
          -^depth-limit <dc>)
    -->
    (<s> ^ntype action + ^ntype goal + ^ntype failure + ^gtype action +
           ^gtype failure + ^gtype heuristic +)
}

sp {create-object*apply*complete*single*moved
    (state <s> ^complete true ^name create-object ^operator <o*1>
          ^last-condition <cond> ^moved <mov> ^superstate <ss>)
    (<o*1> ^name complete)
    (<ss> ^operator <o*2>)
    (<o*2> ^parameter <c>)
   -{ (<c> ^predicates <p*2> ^relation <r*1>)
      (<p*2> ^number { <> singular <n*1> })}
   -{ (<c> ^predicates <p*1>)
      (<p*1> ^multiple true)}
    -->
    (<ss> ^moved <mov> +)
    (<c> ^formatted <cond> +)
    (<cond> ^rtype single +)
}

sp {create-object*apply*complete*single
    (state <s> ^complete true -^moved <m*1> ^name create-object
          ^operator <o*1> ^last-condition <cond> ^superstate <s*1>)
    (<o*1> ^name complete)
    (<s*1> ^operator <o*2>)
    (<o*2> ^parameter <c>)
   -{ (<c> ^predicates <p*2> ^relation <r*1>)
      (<p*2> ^number { <> singular <n*1> })}
   -{ (<c> ^predicates <p*1>)
      (<p*1> ^multiple true)}
    -->
    (<c> ^formatted <cond> +)
    (<cond> ^rtype single +)
}

sp {create-object*apply*complete*hasnumber*with*relation
    (state <s> ^complete true ^name create-object ^operator <o*1>
          ^last-condition <cond> ^superstate <s*1>)
    (<o*1> ^name complete)
    (<s*1> ^operator <o*2>)
    (<o*2> ^parameter <c>)
   -{ (<c> ^predicates <p*1>)
      (<p*1> ^multiple true)}
    (<c> ^predicates <p*2> ^relation <r>)
    (<p*2> ^number { <> singular <n*1> })
    (<r> -^handle between)
    -->
    (<c> ^formatted <cond> + ^rtype set +)
    (<cond> ^rtype single +)
}

sp {create-object*apply*complete*multiple*with*relation
    (state <s> ^complete true ^name create-object ^operator <o*1>
          ^last-condition <cond> ^superstate <s*1>)
    (<o*1> ^name complete)
    (<s*1> ^operator <o*2>)
    (<o*2> ^parameter <c>)
    (<c> ^predicates <p*1> ^relation <r>)
    (<p*1> ^multiple true)
    (<r> -^handle between)
    -->
    (<c> ^formatted <cond> + ^rtype set +)
    (<cond> ^rtype single +)
}

sp {create-object*apply*complete*multiple
    (state <s> ^complete true ^name create-object ^operator <o*1>
          ^last-condition <cond> ^superstate <s*1>)
    (<o*1> ^name complete)
    (<s*1> ^operator <o*2>)
    (<o*2> ^parameter <c>)
   -{ (<c> ^relation <r>)
      (<r> -^handle between)}
    (<c> ^predicates <p*1>)
    (<p*1> ^multiple true)
    -->
    (<c> ^formatted <cond> +)
    (<cond> ^rtype set +)
}

sp {create-object*apply*complete*all-parameter*set
    (state <s> ^name create-object ^operator <o*1> ^last-condition <cond>
          ^superstate <s*1>)
    (<o*1> ^name complete)
    (<cond> ^parameter <p>)
    (<s*1> ^operator <o*2>)
    (<o*2> ^parameter <c>)
    (<c> ^parameter-index <id> ^predicates <p*1>)
    (<p*1> ^quantified <q*1>)
    (<q*1> ^handle all)
    -->
    (<p> ^1 <para1> +)
    (<para1> ^param-id <id> + ^type set +)
}

sp {create-object*apply*complete*not-indef-parameter*set
    (state <s> ^name create-object ^operator <o*1> ^last-condition <cond>
          ^superstate <s*1>)
    (<o*1> ^name complete)
    (<cond> ^parameter <p>)
    (<s*1> ^operator <o*2>)
    (<o*2> ^parameter <c>)
    (<c> -^relation <r*1> ^parameter-index <id> ^predicates <p*1>)
    (<p*1> ^number { <> singular <n*1> })
    -->
    (<p> ^1 <para1> +)
    (<para1> ^param-id <id> + ^type set +)
}

sp {create-object*apply*complete*remove-rtype
    (state <s> ^name create-object ^operator <o*1> ^last-condition <cond>
          ^superstate <s*1>)
    (<o*1> ^name complete)
    (<cond> ^rtype <rtype>)
    (<s*1> ^operator <o*2>)
    (<o*2> ^parameter <c>)
    -->
    (<s> ^complete true +)
    (<cond> ^rtype <rtype> -)
}

sp {create-object*propose*complete
    (state <s> ^name create-object ^last-condition <co>)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete +)
}

sp {create-object*elaborate*condition*learned-predicate*negative
    (state <s> ^name create-object ^property-modifier <m> ^operator <o>
          ^last-condition <cond> ^parameter <c>)
    (<m> ^handle negation ^modifying <m*1>)
    (<o> -^value moved ^name unary-predicate ^attribute property ^value <val>)
    (<m*1> ^handle <val>)
    -->
    (<s> ^condition <co> + ^last-condition <cond> - ^last-condition <co> +)
    (<co> ^name <val> + ^parameter <p> + ^type concept +
           ^attribute predicate + ^args <a> + ^rtype single + ^negative true +)
    (<a> ^1 <cond> +)
}

sp {create-object*elaborate*condition*learned-predicate
    (state <s> ^name create-object ^operator <o> ^last-condition <cond>
          ^parameter <c>)
    (<o> -^value moved ^name unary-predicate ^attribute property ^value <val>)
   -{ (<s> ^property-modifier <m>)
      (<m> ^handle negation ^modifying <m*1>)
      (<m*1> ^handle <val>)}
    -->
    (<s> ^condition <co> + ^last-condition <cond> - ^last-condition <co> +)
    (<co> ^name <val> + ^parameter <p> + ^type concept +
           ^attribute predicate + ^args <a> + ^rtype single +)
    (<a> ^1 <cond> +)
}

sp {create-object*elaborate*condition*learned-predicate*moved
    (state <s> ^name create-object ^operator <o> ^last-condition <cond>
          ^parameter <c>)
   -{ (<s> ^property-modifier <m>)
      (<m> ^handle negation ^modifying <m*1>)
      (<m*1> ^handle <val>)}
    (<o> ^value moved ^name unary-predicate ^attribute property)
    -->
    (<s> ^condition <co> + ^moved <co> + ^last-condition <cond> -
           ^last-condition <co> +)
    (<co> ^name move1 + ^args <a> + ^parameter <para> + ^type concept +
           ^attribute action + ^rtype single +)
}

sp {create-object*elaborate*condition*relation*negative
    (state <s> ^name create-object ^property-modifier <m> ^operator <o>
          ^last-condition <cond> ^parameter <c>)
    (<m> ^handle negation ^modifying <m*1>)
    (<o> ^name unary-predicate ^attribute relation ^value <val>)
    (<m*1> ^handle <val>)
    -->
    (<s> ^condition <co> + ^last-condition <cond> - ^last-condition <co> +)
    (<co> ^name <val> + ^parameter <p> + ^type state-pair +
           ^attribute preposition + ^args <a> + ^rtype set + ^negative true +)
    (<a> ^1 <cond> +)
}

sp {create-object*elaborate*condition*relation
    (state <s> ^name create-object ^operator <o> ^last-condition <cond>
          ^parameter <c>)
    (<o> ^name unary-predicate ^attribute relation ^value <val>)
   -{ (<s> ^property-modifier <m>)
      (<m> ^handle negation ^modifying <m*1>)
      (<m*1> ^handle <val>)}
    -->
    (<s> ^condition <co> + ^last-condition <cond> - ^last-condition <co> +)
    (<co> ^name <val> + ^parameter <p> + ^type state-pair +
           ^attribute preposition + ^args <a> + ^rtype set +)
    (<a> ^1 <cond> +)
}

sp {create-object*elaborate*condition*negative
    (state <s> ^name create-object ^property-modifier <m> ^operator <o>
          ^last-condition <cond> ^parameter <c>)
    (<m> ^handle negation ^modifying <m*1>)
    (<o> ^name unary-predicate ^value <val>
          ^attribute { << color size shape name >> <att> })
    (<m*1> ^handle <val>)
    -->
    (<s> ^condition <co> + ^last-condition <cond> - ^last-condition <co> +)
    (<co> ^name <val> + ^parameter <p> + ^type attribute + ^attribute <att> +
           ^args <a> + ^rtype single + ^negative true +)
    (<a> ^1 <cond> +)
}

sp {create-object*elaborate*condition
    (state <s> ^name create-object ^operator <o> ^last-condition <cond>
          ^parameter <c>)
    (<o> ^name unary-predicate ^value <val>
          ^attribute { << color size shape name >> <att> })
   -{ (<s> ^property-modifier <m>)
      (<m> ^handle negation ^modifying <m*1>)
      (<m*1> ^handle <val>)}
    -->
    (<s> ^condition <co> + ^last-condition <cond> - ^last-condition <co> +)
    (<co> ^name <val> + ^parameter <p> + ^type attribute + ^attribute <att> +
           ^args <a> + ^rtype single +)
    (<a> ^1 <cond> +)
}

sp {create-object*propose*unary-predicate*linear
    (state <s> ^name create-object ^parameter <c>)
   -{ (<s> ^condition <c*1>)
      (<c*1> ^name linear)}
    (<c> ^predicates <p>)
    (<p> ^property linear)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name unary-predicate + ^attribute relation + ^value linear +)
}

sp {create-object*propose*unary-predicate
    (state <s> ^name create-object ^parameter <c>)
    (<c> ^predicates <p>)
    (<p>
          ^{ <> category <> quantified <> property-modifier <> dialog-object <> value <> handle <> type <> visible <> visibility <> multiple <> number <att> } { <> linear <val> })
   -{ (<p> ^<att> { << moved >> <val> })
      (<s> ^moved <mov>)}
   -{ (<s> ^condition <c*1>)
      (<c*1> ^name <val>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name unary-predicate + ^attribute <att> + ^value <val> +)
}

sp {create-object*elaborate*cateogy*object
    :o-support
    (state <s> ^name create-object ^parameter <p*1>)
    (<p*1> ^predicates <c>)
    (<c> ^category { << object >> <cat> })
    -->
    (<s> ^condition <c1> + ^last-condition <c1> +)
    (<c1> ^name <cat> + ^parameter <p> + ^type attribute +
           ^attribute primitive + ^rtype single +)
}

sp {create-object*elaborate*previously
    :o-support
    (state <s> ^name create-object ^property-modifier <mod> ^superstate <ss>)
    (<mod> ^handle previously)
    -->
    (<ss> ^modifier previously +)
}

sp {create-object*elaborate*property-modifier
    :o-support
    (state <s> ^name create-object ^parameter <p*1>)
    (<p*1> ^predicates <p>)
    (<p> ^property-modifier <mod>)
    -->
    (<s> ^property-modifier <mod> +)
}

sp {create-object*elaborate*category
    :o-support
    (state <s> ^name create-object ^parameter <p*1>)
    (<p*1> ^predicates <c>)
    (<c> ^category { <> object <cat> })
    -->
    (<s> ^condition <c1> + ^last-condition <c1> +)
    (<c1> ^name <cat> + ^parameter <p> + ^type attribute +
           ^attribute category + ^rtype single +)
}

sp {create-object*elaborate*parameter
    (state <s> ^name create-object ^superstate <s*3>)
    (<s*3> ^operator <o*1>)
    (<o*1> ^parameter <c>)
   -{ (<s> ^superstate <s*2>)
      (<s*2> ^input-object-2 <c>)}
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^input-object-1 <c>)}
    -->
    (<s> ^parameter <c> +)
}

sp {create-object*elaborate*parameter*input-object
    (state <s> ^name create-object ^superstate <s*2> ^superstate <s*1>)
    (<s*2> ^operator <o*1>)
    (<o*1> ^parameter <c>)
    (<c> ^parameter-index <oc>)
    (<s*1> ^{ << input-object-2 input-object-1 >> <a*1> } <c>)
    -->
    (<s> ^condition <co> + ^last-condition <co> +)
    (<co> ^args <A67> + ^attribute input-arg + ^name object +
           ^negative false + ^parameter <P628> + ^rtype single +)
    (<P628> ^1 <para> +)
    (<para> ^param-id <oc> +)
}

sp {preference*create-object*prefer*unary-predicate*over*complete
    (state <s> ^name create-object ^operator <o2> + ^operator <o> +)
    (<o2> ^name complete)
    (<o> ^name unary-predicate)
    -->
    (<s> ^operator <o> > <o2>)
}

sp {preference*create-object*dispref*unary-predicate
    (state <s> ^name create-object ^operator <o> +)
    (<o> ^name unary-predicate ^attribute { << relation property >> <a*1> })
    -->
    (<s> ^operator <o> <)
}

sp {prefer*create-object*over*create-object*input-object
    (state <s> ^name convert-parsed-format ^operator <o2> +
          ^input-object-2 <p2> ^operator <o1> +
          ^{ << output-object-1 input-object-1 >> <a*1> } <p>)
    (<o2> ^name create-object ^parameter <p2>)
    (<o1> ^name create-object ^parameter <p>)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*create-object*over*input-object
    (state <s> ^name convert-parsed-format ^operator <o1> +
          ^{ << output-object-1 input-object-2 input-object-1 >> <a*1> } <p>)
    (<o1> ^name create-object ^parameter <p>)
    -->
    (<s> ^operator <o1> >)
}

sp {prefer*create-object*over*handle-predicate*convert-parsed-format
    (state <s> ^name convert-parsed-format ^operator <o2> + ^operator <o1> +)
    (<o2> ^name handle-predicate)
    (<o1> ^name create-object)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*create-object*over*handle-pref-action*convert-parsed-format
    (state <s> ^name convert-parsed-format ^operator <o2> + ^operator <o1> +)
    (<o2> ^name handle-pref-action)
    (<o1> ^name create-object)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*create-object*over*handle-action*convert-parsed-format
    (state <s> ^name convert-parsed-format ^operator <o2> + ^operator <o1> +)
    (<o2> ^name handle-action)
    (<o1> ^name create-object)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*create-object*over*handle-clause*convert-parsed-format
    (state <s> ^name convert-parsed-format ^operator <o2> + ^operator <o1> +)
    (<o2> ^name handle-clause)
    (<o1> ^name create-object)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*handle-predicate*over*handle-property-predicate*convert-parsed-format
    (state <s> ^name convert-parsed-format ^operator <o2> + ^operator <o1> +)
    (<o2> ^name handle-property-predicate)
    (<o1> ^name handle-predicate)
    -->
    (<s> ^operator <o2> > <o1>)
}

sp {prefer*create-object*over*handle-property-predicate*convert-parsed-format
    (state <s> ^name convert-parsed-format ^operator <o2> + ^operator <o1> +)
    (<o2> ^name handle-property-predicate)
    (<o1> ^name create-object)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*handle-property-predicate*over*complete*convert-parsed-format
    (state <s> ^name convert-parsed-format ^operator <o2> + ^operator <o1> +)
    (<o2> ^name complete)
    (<o1> ^name handle-property-predicate)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*handle-clause*over*handle-property-predicate*convert-parsed-format
    (state <s> ^name convert-parsed-format ^operator <o2> + ^operator <o1> +)
    (<o2> ^name handle-clause)
    (<o1> ^name handle-property-predicate)
    -->
    (<s> ^operator <o2> > <o1>)
}

sp {prefer*handle-pref-action*over*complete*convert-parsed-format
    (state <s> ^name convert-parsed-format ^operator <o2> + ^operator <o1> +)
    (<o2> ^name complete)
    (<o1> ^name handle-pref-action)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*handle-action*over*complete*convert-parsed-format
    (state <s> ^name convert-parsed-format ^operator <o2> + ^operator <o1> +)
    (<o2> ^name complete)
    (<o1> ^name handle-action)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*handle-predicate*over*handle-predicate*contains*convert-parsed-format
    (state <s> ^name convert-parsed-format ^operator <o2> + ^operator <o1> +)
    (<o2> ^name handle-predicate ^predicate <p*1>)
    (<o1> ^name handle-predicate ^predicate <p>)
    (<p*1> ^{ << 1 2 >> <num> } <p>)
    -->
    (<s> ^operator <o2> < <o1>)
}

sp {prefer*handle-clause*over*handle-clause-clause*convert-parsed-format
    (state <s> ^name convert-parsed-format ^operator <o2> + ^operator <o1> +)
    (<o2> ^name handle-clause ^clause <c*1>)
    (<o1> ^name handle-clause ^parameter <p*1>)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*handle-clause*over*handle-predicate*convert-parsed-format
    (state <s> ^name convert-parsed-format ^operator <o2> + ^operator <o1> +)
    (<o2> ^name handle-predicate)
    (<o1> ^name handle-clause)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*of*handle-predicate*over*handle-predicate
    (state <s> ^name convert-parsed-format ^operator <o2> + ^operator <o1> +)
   -{ (<o2> ^predicate <p*2>)
      (<p*2> ^handle of1)}
    (<o2> ^name handle-predicate)
    (<o1> ^name handle-predicate ^predicate <p*1>)
    (<p*1> ^handle of1)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*handle-predicate*over*complete*convert-parsed-format
    (state <s> ^name convert-parsed-format ^operator <o2> + ^operator <o1> +)
    (<o2> ^name complete)
    (<o1> ^name handle-predicate)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*handle-clause*over*complete*convert-parsed-format
    (state <s> ^name convert-parsed-format ^operator <o2> + ^operator <o1> +)
    (<o2> ^name complete)
    (<o1> ^name handle-clause)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*create-object*lower*hanlde*convert-parsed-format
    (state <s> ^name convert-parsed-format ^operator <o2> +
          -^output-object-1 <p> -^input-object-2 <p> -^input-object-1 <p>
          ^operator <o1> +)
    (<o2> ^name create-object ^parameter <p>)
    (<o1> ^name create-object ^parameter <p*1>)
    (<p> ^handle <h2>)
    (<p*1> ^handle { < <h2> <h1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {convert-NLP-to-language*apply*complete
    (state <s> ^name convert-NLP-to-language ^operator <o*1> ^functions <fc>
          ^relationships <gr> ^superstate <ss>)
    (<o*1> ^name complete)
    -->
    (<ss> ^nlp-relationships <gr> + ^nlp-functions <fc> +)
}

sp {convert-NLP-to-language*propose*complete
    (state <s> ^name convert-NLP-to-language)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete +)
}

sp {convert-NLP-to-language*apply*state-diff*copy-function-relations
    (state <s> ^name convert-NLP-to-language ^functions <gr> ^<num1> <f2>
          ^<num1> { <> <f2> <f1> })
    (<f2> ^of <desc2> ^type <name2>)
    (<desc2> ^type it)
    (<f1> ^of <desc1> ^type <name1>)
    -->
    (<gr> ^function <r1> +)
    (<r1> ^1 <desc1> + ^2 <desc2> + ^of1 <name1> + ^of2 <name2> + ^type is +)
}

sp {convert-NLP-to-language*apply*state-diff*copy-goal-relations
    (state <s> ^name convert-NLP-to-language ^relationships <gr>
          ^condition <c> ^<c2> <desc2> ^<c1> <desc1>)
    (<c> ^args <a> ^negative <n> ^name <name>)
    (<a> -^3 <v*1> ^2 <c2> ^1 <c1>)
    -->
    (<gr> ^relation <r1> +)
    (<r1> ^1 <desc1> + ^2 <desc2> + ^name <name> + ^negative <n> +)
}

sp {convert-NLP-to-language*elaborate*object-description*telescope
    (state <s> ^name convert-NLP-to-language ^condition <cond> ^<cond> <desc>
          ^<c2> <desc2>)
    (<cond> ^args <a*1>)
    (<a*1> ^1 <c2>)
    (<desc2> ^<something> <value>)
    -->
    (<desc> ^<something> <value> +)
}

sp {convert-NLP-to-language*elaborate*object-description*input-arg
    (state <s> ^name convert-NLP-to-language ^condition <cond>)
    (<cond> ^name object ^attribute input-arg)
    -->
    (<s> ^<cond> <desc1> +)
    (<desc1> ^type it +)
}

sp {convert-NLP-to-language*elaborate*object-description*primitive
    (state <s> ^name convert-NLP-to-language ^condition <cond>)
    (<cond> ^type attribute ^attribute primitive ^name <name>)
    -->
    (<s> ^<cond> <desc1> +)
    (<desc1> ^type <name> +)
}

sp {convert-NLP-to-language*elaborate*object-description*function
    (state <s> ^name convert-NLP-to-language ^condition <cond> ^<c> <desc1>)
    (<cond> ^type attribute-of ^args <a*1> ^parameter <p*1> ^name <name>)
    (<a*1> ^2 <c>)
    (<p*1> ^1 <v*1>)
    (<v*1> ^param-id <num>)
    -->
    (<s> ^<num> <f> +)
    (<f> ^type <name> + ^of <desc1> +)
}

sp {convert-NLP-to-language*elaborate*object-description
    (state <s> ^name convert-NLP-to-language ^condition <cond>)
    (<cond> -^attribute primitive -^attribute input-arg ^type attribute
          ^name <name> ^attribute <at>)
    -->
    (<s> ^<cond> <desc1> +)
    (<desc1> ^<at> <name> +)
}

sp {convert-NLP-to-language*elaborate*conditions*depth
    (state <s> ^name convert-NLP-to-language ^condition <cond>)
    (<cond> ^args <a*1>)
    (<a*1> ^{ << 1 2 3 4 5 6 >> <a*2> } <cond2>)
    -->
    (<s> ^condition <cond2> +)
}

sp {convert-NLP-to-language*elaborate*conditions
    (state <s> ^name convert-NLP-to-language ^structure <s*1>)
    (<s*1> ^conditions <cond>)
    -->
    (<s> ^condition <cond> +)
}

sp {convert-NLP-to-language*elaborate*relationships
    (state <s> ^name convert-NLP-to-language ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^structure <ps>)
    -->
    (<s> ^relationships <gr> + ^functions <fc> + ^structure <ps> +)
}

sp {convert-TCN-to-NLP*apply*complete*superstate*copy
    (state <s> ^name convert-TCN-to-NLP ^nlp-set <nps> ^operator <o*2>
          ^set <s*2> ^superstate <s*1> ^superstate <ss>)
   -{ (<s> ^nlp <nlp>)
      (<nps> -^nlp <nlp>)}
    (<o*2> ^name complete)
    (<s*2> ^name <name>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^type <type>)
    -->
    (<ss> ^nlp-set <nps> +)
}

sp {convert-TCN-to-NLP*apply*complete*name
    (state <s> ^name convert-TCN-to-NLP ^operator <o*1> ^nlp-set <nps>
          ^set <s*1>)
    (<o*1> ^name complete)
    (<s*1> ^name <name>)
    -->
    (<nps> ^name <name> + ^aname <name> +)
}

sp {convert-TCN-to-NLP*apply*complete
    (state <s> ^name convert-TCN-to-NLP ^operator <o*1> ^nlp <nlp>
          ^nlp-set <nps>)
    (<o*1> ^name complete)
    -->
    (<nps> ^nlp <nlp> +)
}

sp {convert-TCN-to-NLP*propose*complete
    (state <s> ^name convert-TCN-to-NLP)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name complete +)
}

sp {convert-TCN-to-NLP*elaborate*nlp*3args
    (state <s> ^name convert-TCN-to-NLP ^set <a> ^<num> <c> ^<num2> <c2>
          ^<num3> <c3>)
    (<a> ^conditions <c*1>)
    (<c*1> ^cond <c*2>)
    (<c*2> ^prep <cond>)
    (<cond> ^negative <neg> ^2 <num2> ^3 <num3> ^1 <num> ^name <name>)
    -->
    (<s> ^nlp <co> +)
    (<co> ^name <name> + ^negative <neg> + ^parameter <p3z> + ^args <args> +
           ^type state-pair + ^attribute prepositions +)
    (<p3z> ^1 <p1b> + ^2 <p2b> + ^3 <p3b> +)
    (<p1b> ^param-id <num> +)
    (<p2b> ^param-id <num2> +)
    (<p3b> ^param-id <num3> +)
    (<args> ^1 <c> + ^2 <c2> + ^3 <c3> +)
}

sp {convert-TCN-to-NLP*elaborate*nlp*not-INDEF
    (state <s> ^name convert-TCN-to-NLP ^set <a> ^<num> <c> ^<num2> <c2>)
    (<a> ^conditions <c*1>)
    (<c*1> ^cond <c*2>)
    (<c*2> ^prep <cond>)
    (<cond> -^3 <v*1> -^2 INDEF ^negative <neg> ^2 <num2> ^1 <num>
          ^name <name>)
    -->
    (<s> ^nlp <co> +)
    (<co> ^name <name> + ^negative <neg> + ^parameter <p3z> + ^args <args> +
           ^type state-pair + ^attribute prepositions +)
    (<p3z> ^1 <p1b> + ^2 <p2b> +)
    (<p1b> ^param-id <num> +)
    (<p2b> ^param-id <num2> +)
    (<args> ^1 <c> + ^2 <c2> +)
}

sp {convert-TCN-to-NLP*elaborate*nlp*INDEF
    (state <s> ^name convert-TCN-to-NLP ^set <a> ^condition <c> ^<num> <c2>)
    (<a> ^conditions <c*1>)
    (<c*1> ^cond <c*2>)
    (<c*2> ^prep <cond>)
    (<cond> -^3 <v*1> ^2 INDEF ^btype <type> ^negative <neg> ^1 <num>
          ^name <name>)
    (<c> ^name <type>)
    -->
    (<s> ^nlp <co> +)
    (<co> ^name <name> + ^negative <neg> + ^parameter <p3z> + ^args <args> +
           ^type state-pair + ^attribute prepositions +)
    (<p3z> ^1 <p1b> +)
    (<p1b> ^param-id <num> +)
    (<args> ^1 <c2> + ^2 <c> +)
}

sp {convert-TCN-to-NLP*elaborate*parameter
    (state <s> ^name convert-TCN-to-NLP ^set <a> ^condition <c>)
    (<a> ^parameters <p*1>)
    (<c> ^name <type>)
    (<p*1> ^{ << 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 >> <num> } <n*1>)
   -{ (<a> ^conditions <c*1>)
      (<c*1> ^<num> <n*2>)
      (<n*2> ^attribute <a*1>)
      (<a*1> ^<attr> <value>)}
    (<n*1> ^type <type>)
    -->
    (<s> ^<num> <c> +)
}

sp {convert-TCN-to-NLP*elaborate*parameter*attr
    (state <s> ^name convert-TCN-to-NLP ^set <a> ^condition <c>)
    (<a> ^conditions <c*1> ^parameters <p*1>)
    (<c> ^name <type>)
    (<p*1> ^{ << 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 >> <num> } <n*1>)
    (<n*1> ^type <type>)
    (<c*1> ^<num> <n*2>)
    (<n*2> ^attribute <a*1>)
    (<a*1> ^<attr> <value>)
    -->
    (<s> ^<num> <c1> +)
    (<c1> ^name <value> + ^attribute <attr> + ^args <ag2> + ^type attribute +)
    (<ag2> ^1 <c> +)
}

sp {convert-TCN-to-NLP*elaborate*state2
    (state <s> ^name convert-TCN-to-NLP)
    -->
    (<s> ^condition <c3> + ^condition <c4> + ^condition <c5> +
           ^nlp-set <nps> +)
    (<c4> ^name block + ^rtype single + ^attribute category +
           ^type attribute +)
    (<c3> ^name location + ^rtype single + ^attribute category +
           ^type attribute +)
    (<c5> ^name object + ^rtype single + ^attribute category +
           ^type attribute +)
}

sp {convert-TCN-to-NLP*elaborate*state
    (state <s> ^name convert-TCN-to-NLP ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^tcn <tcn>)
    -->
    (<s> ^set <tcn> +)
}

sp {convert-parsed-format*apply*complete*superstate*copy*considererence
    (state <s> ^complete-flag true ^name convert-parsed-format ^nlp-set <nps>
          ^operator <o*1> ^consider <pref> ^top-state <t*1> ^superstate <ss>)
   -{ (<s> ^nlp <nlp>)
      (<nps> -^nlp <nlp>)}
    (<o*1> ^name complete)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learn-link <l*1>)
    (<l*1> ^handle <name>)
    (<ss> ^gtype <type> ^<type> <a>)
    -->
    (<a> ^nlp-set <nps> + ^aname <name> + ^consider <pref> +)
    (<nps> ^aname <name> +)
}

sp {convert-parsed-format*apply*complete*superstate*copy*prefererence*avoid*modifier
    (state <s> ^complete-flag true -^moved <m*1> ^name convert-parsed-format
          ^nlp-set <nps> ^operator <o*1> ^modifier <m> ^avoid <pref>
          ^top-state <t*1> ^superstate <ss>)
   -{ (<s> ^nlp <nlp>)
      (<nps> -^nlp <nlp>)}
    (<o*1> ^name complete)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learn-link <l*1>)
    (<l*1> ^handle <name>)
    (<ss> ^gtype <type> ^<type> <a>)
    -->
    (<a> ^nlp-set <nps> + ^aname <name> + ^avoid <pref> + ^modifier <m> +)
    (<nps> ^aname <name> +)
}

sp {convert-parsed-format*apply*complete*superstate*copy*prefererence*modifier
    (state <s> ^complete-flag true -^moved <m*1> ^name convert-parsed-format
          ^nlp-set <nps> ^operator <o*1> ^modifier <m> ^prefer <pref>
          ^top-state <t*1> ^superstate <ss>)
   -{ (<s> ^nlp <nlp>)
      (<nps> -^nlp <nlp>)}
    (<o*1> ^name complete)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learn-link <l*1>)
    (<l*1> ^handle <name>)
    (<ss> ^gtype <type> ^<type> <a>)
    -->
    (<a> ^nlp-set <nps> + ^aname <name> + ^prefer <pref> + ^modifier <m> +)
    (<nps> ^aname <name> +)
}

sp {convert-parsed-format*apply*complete*superstate*copy*prefererence*modifier*moved
    (state <s> ^complete-flag true ^name convert-parsed-format ^nlp-set <nps>
          ^operator <o*1> ^modifier <m> ^moved <mov> ^prefer <pref>
          ^top-state <t*1> ^superstate <ss>)
   -{ (<s> ^nlp <nlp>)
      (<nps> -^nlp <nlp>)}
    (<o*1> ^name complete)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learn-link <l*1>)
    (<l*1> ^handle <name>)
    (<ss> ^gtype <type> ^<type> <a>)
    -->
    (<a> ^nlp-set <nps> + ^aname <name> + ^prefer <pref> + ^modifier <m> +
           ^moved <mov> +)
    (<nps> ^aname <name> +)
}

sp {convert-parsed-format*apply*complete*superstate*copy*prefererence*avoid*modifier*moved
    (state <s> ^complete-flag true ^name convert-parsed-format ^nlp-set <nps>
          ^operator <o*1> ^modifier <m> ^moved <mov> ^avoid <pref>
          ^top-state <t*1> ^superstate <ss>)
   -{ (<s> ^nlp <nlp>)
      (<nps> -^nlp <nlp>)}
    (<o*1> ^name complete)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learn-link <l*1>)
    (<l*1> ^handle <name>)
    (<ss> ^gtype <type> ^<type> <a>)
    -->
    (<a> ^nlp-set <nps> + ^aname <name> + ^avoid <pref> + ^modifier <m> +
           ^moved <mov> +)
    (<nps> ^aname <name> +)
}

sp {convert-parsed-format*apply*complete*superstate*copy*prefererence*avoid
    (state <s> ^complete-flag true -^modifier <m> ^name convert-parsed-format
          ^nlp-set <nps> ^operator <o*1> ^avoid <pref> ^top-state <t*1>
          ^superstate <ss>)
   -{ (<s> ^nlp <nlp>)
      (<nps> -^nlp <nlp>)}
    (<o*1> ^name complete)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learn-link <l*1>)
    (<l*1> ^handle <name>)
    (<ss> ^gtype <type> ^<type> <a>)
    -->
    (<a> ^nlp-set <nps> + ^aname <name> + ^avoid <pref> +)
    (<nps> ^aname <name> +)
}

sp {convert-parsed-format*apply*complete*superstate*copy*prefererence
    (state <s> ^complete-flag true -^modifier <m> ^name convert-parsed-format
          ^nlp-set <nps> ^operator <o*1> ^prefer <pref> ^top-state <t*1>
          ^superstate <ss>)
   -{ (<s> ^nlp <nlp>)
      (<nps> -^nlp <nlp>)}
    (<o*1> ^name complete)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learn-link <l*1>)
    (<l*1> ^handle <name>)
    (<ss> ^gtype <type> ^<type> <a>)
    -->
    (<a> ^nlp-set <nps> + ^aname <name> + ^prefer <pref> +)
    (<nps> ^aname <name> +)
}

sp {convert-parsed-format*apply*complete*superstate*copy
    (state <s> ^complete-flag true -^consider <c*1> -^avoid <a*1>
          -^prefer <p*1> ^name convert-parsed-format ^nlp-set <nps>
          ^operator <o*1> ^top-state <t*1> ^superstate <ss>)
   -{ (<s> ^nlp <nlp>)
      (<nps> -^nlp <nlp>)}
    (<o*1> ^name complete)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learn-link <l*1>)
    (<l*1> ^handle <name>)
    (<ss> ^gtype <type> ^<type> <a>)
    -->
    (<a> ^nlp-set <nps> + ^aname <name> +)
    (<nps> ^aname <name> +)
}

sp {convert-parsed-format*apply*complete*only-objects
    (state <s> ^name convert-parsed-format ^parameter <pp>
          -^input-object-2 <pp> -^input-object-1 <pp> -^indef <pp>
          ^operator <o*1>)
    (<o*1> ^name complete)
    (<pp> ^parameter-index <id> ^formatted <p>)
   -{ (<s> ^nlp <nlp>)
      (<nlp> ^args <a*1> ^parameter <p*1>)
      (<a*1> ^<num> <p>)
      (<p*1> ^<num> <n*1>)
      (<n*1> ^param-id <id>)}
    (<p> ^parameter <para>)
    -->
    (<s> ^nlp <p> +)
    (<para> ^1 <p2> +)
    (<p2> ^param-id <id> +)
}

sp {convert-parsed-format*apply*complete
    (state <s> ^name convert-parsed-format ^operator <o*1> ^nlp <nlp>
          ^nlp-set <nps>)
    (<o*1> ^name complete)
    -->
    (<nps> ^nlp <nlp> +)
}

sp {convert-parsed-format*apply*complete-flag
    (state <s> ^name convert-parsed-format ^operator <o*1> ^nlp <nlp>
          ^nlp-set <nps>)
    (<o*1> ^name complete)
    -->
    (<s> ^complete-flag true +)
}

sp {convert-parsed-format*propose*complete
    (state <s> ^name convert-parsed-format)
    -->
    (<s> ^operator <op> + ^operator <op> <)
    (<op> ^name complete +)
}

sp {convert-parsed-format*apply*handle-clause*parameter*concept*arg3
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^name handle-clause ^parameter <c1>)
    (<c1> ^parameter-index <id> ^formatted <p> ^relation <r>)
    (<p> ^rtype <rtype>)
    (<r> ^handle <name> ^2 <c2> ^3 <c3>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^world <w*1>)
      (<w*1> ^predicates <p*1>)
      (<p*1> ^predicate <p*2>)
      (<p*2> ^handle <name>)}
    (<c2> ^parameter-index <id2> ^formatted <p2>)
    (<p2> ^rtype <rtype2>)
    (<c3> ^parameter-index <id3> ^formatted <p3>)
    (<p3> ^rtype <rtype3>)
    -->
    (<c1> ^new-formatted <n> +)
    (<r> ^formatted true +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type function +
           ^function board-between + ^rtype <rtype> +)
    (<a> ^1 <p> + ^2 <p2> + ^3 <p3> +)
    (<para> ^1 <para1> + ^2 <para2> + ^3 <para3> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
    (<para3> ^param-id <id3> + ^type <rtype3> +)
}

sp {convert-parsed-format*apply*handle-clause*parameter*concept
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^name handle-clause ^parameter <c1>)
    (<c1> ^parameter-index <id> ^formatted <p> ^relation <r>)
    (<p> ^rtype <rtype>)
    (<r> -^3 <v*1> ^handle <name> ^2 <c2>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^world <w*1>)
      (<w*1> ^predicates <p*1>)
      (<p*1> ^predicate <p*2>)
      (<p*2> ^handle <name>)}
    (<c2> ^parameter-index <id2> ^formatted <p2>)
    (<p2> ^rtype <rtype2>)
    -->
    (<r> ^formatted true +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type concept +
           ^attribute predicate + ^rtype <rtype> +)
    (<a> ^1 <p> + ^2 <p2> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*apply*handle-clause*parameter*arg3
    (state <s> ^name convert-parsed-format ^operator <o> ^superstate <s*1>)
    (<o> ^name handle-clause ^parameter <c1>)
    (<c1> ^parameter-index <id> ^formatted <p> ^relation <r>)
    (<p> ^rtype <rtype>)
    (<s*1> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <p*2>)
    (<p*2> ^handle <name>)
    (<r> ^handle <name> ^2 <c2> ^3 <c3>)
    (<c2> ^parameter-index <id2> ^formatted <p2>)
    (<p2> ^rtype <rtype2>)
    (<c3> ^parameter-index <id3> ^formatted <p3>)
    (<p3> ^rtype <rtype3>)
    -->
    (<r> ^formatted true +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type state-pair +
           ^attribute prepositions + ^rtype <rtype> +)
    (<a> ^1 <p> + ^2 <p2> + ^3 <p3> +)
    (<para> ^1 <para1> + ^2 <para2> + ^3 <para3> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
    (<para3> ^param-id <id3> + ^type <rtype3> +)
}

sp {convert-parsed-format*apply*handle-clause*parameter
    (state <s> ^name convert-parsed-format ^operator <o> ^superstate <s*1>)
    (<o> ^name handle-clause ^parameter <c1>)
    (<c1> ^parameter-index <id> ^formatted <p> ^rtype <rtype> ^relation <r>)
    (<s*1> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <p*2>)
    (<p*2> ^handle <name>)
    (<r> -^3 <v*1> ^handle <name> ^2 <c2>)
    (<c2> ^parameter-index <id2> ^formatted <p2>)
    (<p2> ^rtype <rtype2>)
    -->
    (<c1> ^new-formatted <n> +)
    (<r> ^formatted true +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type state-pair +
           ^attribute prepositions + ^rtype <rtype> +)
    (<a> ^1 <p> + ^2 <p2> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*apply*handle-clause*parameter*nortype
    (state <s> ^name convert-parsed-format ^operator <o> ^superstate <s*1>)
    (<o> ^name handle-clause ^parameter <c1>)
    (<c1> -^rtype <r*1> ^parameter-index <id> ^formatted <p> ^relation <r>)
    (<p> ^rtype <rtype>)
    (<s*1> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <p*2>)
    (<p*2> ^handle <name>)
    (<r> -^3 <v*1> ^handle <name> ^2 <c2>)
    (<c2> ^parameter-index <id2> ^formatted <p2>)
    (<p2> ^rtype <rtype2>)
    -->
    (<c1> ^new-formatted <n> +)
    (<r> ^formatted true +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type state-pair +
           ^attribute prepositions + ^rtype <rtype> +)
    (<a> ^1 <p> + ^2 <p2> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*apply*handle-clause*negative*indef
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^name handle-clause ^clause <c>)
    (<c> ^modifier <m*1> ^predicate <r> ^arg1 <c1>)
    (<m*1> ^handle negation)
    (<r> -^3 <v*1> ^2 <c2> ^handle <name>)
    (<c2> -^parameter-index <p*1> ^formatted <p2>)
    (<p2> ^rtype <rtype2>)
    (<c1> ^parameter-index <id> ^formatted <p>)
    (<p> ^rtype <rtype>)
    -->
    (<c> ^formatted true +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^negative true +
           ^type state-pair + ^attribute prepositions + ^rtype <rtype> +)
    (<a> ^1 <p> + ^2 <p2> +)
    (<para> ^1 <para1> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
}

sp {convert-parsed-format*apply*handle-clause*negative*arg3
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^name handle-clause ^clause <c>)
    (<c> ^modifier <m*1> ^predicate <r> ^arg1 <c1>)
    (<m*1> ^handle negation)
    (<r> ^2 <c2> ^3 <c3> ^handle <name>)
    (<c2> ^parameter-index <id3> ^parameter-index <id2> ^formatted <p3>
          ^formatted <p2>)
    (<p3> ^rtype <rtype3>)
    (<p2> ^rtype <rtype2>)
    (<c1> ^parameter-index <id> ^formatted <p>)
    (<p> ^rtype <rtype>)
    -->
    (<c> ^formatted true +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^negative true +
           ^type state-pair + ^attribute prepositions + ^rtype <rtype> +)
    (<a> ^1 <p> + ^2 <p2> + ^3 <p3> +)
    (<para> ^1 <para1> + ^2 <para2> + ^3 <para3> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
    (<para3> ^param-id <id3> + ^type <rtype3> +)
}

sp {convert-parsed-format*apply*handle-clause*negative
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^name handle-clause ^clause <c>)
    (<c> ^modifier <m*1> ^predicate <r> ^arg1 <c1>)
    (<m*1> ^handle negation)
    (<r> -^3 <v*1> ^2 <c2> ^handle <name>)
    (<c2> ^parameter-index <id2> ^formatted <p2>)
    (<p2> ^rtype <rtype2>)
    (<c1> ^parameter-index <id> ^formatted <p>)
    (<p> ^rtype <rtype>)
    -->
    (<c> ^formatted true +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^negative true +
           ^type state-pair + ^attribute prepositions + ^rtype <rtype> +)
    (<a> ^1 <p> + ^2 <p2> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*apply*handle-clause*indef2*concept*arg3
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^name handle-clause ^clause <c>)
   -{ (<c> ^modifier <m*1>)
      (<m*1> ^handle negation)}
    (<c> ^predicate <r> ^arg1 <c1>)
    (<r> ^3 <c3> ^handle <name> ^2 <c2>)
    (<c3> -^parameter-index <p*3> ^formatted <p3>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^world <w*1>)
      (<w*1> ^predicates <p*1>)
      (<p*1> ^predicate <p*2>)
      (<p*2> ^handle <name>)}
    (<p3> ^rtype <rtype3>)
    (<c2> ^parameter-index <id2> ^formatted <p2>)
    (<p2> ^rtype <rtype2>)
    (<c1> ^parameter-index <id> ^formatted <p>)
    (<p> ^rtype <rtype>)
    -->
    (<c> ^formatted true +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type concept +
           ^attribute predicate + ^rtype <rtype> +)
    (<a> ^1 <p> + ^2 <p2> + ^3 <p3> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*apply*handle-clause*indef*concept*arg3
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^name handle-clause ^clause <c>)
   -{ (<c> ^modifier <m*1>)
      (<m*1> ^handle negation)}
    (<c> ^predicate <r> ^arg1 <c1>)
    (<r> ^2 <c2> ^3 <c3> ^handle <name>)
    (<c2> -^parameter-index <p*3> ^formatted <p2>)
    (<c3> -^parameter-index <p*4> ^formatted <p3>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^world <w*1>)
      (<w*1> ^predicates <p*1>)
      (<p*1> ^predicate <p*2>)
      (<p*2> ^handle <name>)}
    (<p3> ^rtype <rtype3>)
    (<p2> ^rtype <rtype2>)
    (<c1> ^parameter-index <id> ^formatted <p>)
    (<p> ^rtype <rtype>)
    -->
    (<c> ^formatted true +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type concept +
           ^attribute predicate + ^rtype <rtype> +)
    (<a> ^1 <p> + ^2 <p2> + ^3 <p3> +)
    (<para> ^1 <para1> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
}

sp {convert-parsed-format*apply*handle-clause*indef*concept
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^name handle-clause ^clause <c>)
   -{ (<c> ^modifier <m*1>)
      (<m*1> ^handle negation)}
    (<c> ^predicate <r> ^arg1 <c1>)
    (<r> -^3 <v*1> ^2 <c2> ^handle <name>)
    (<c2> -^parameter-index <p*3> ^formatted <p2>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^world <w*1>)
      (<w*1> ^predicates <p*1>)
      (<p*1> ^predicate <p*2>)
      (<p*2> ^handle <name>)}
    (<p2> ^rtype <rtype2>)
    (<c1> ^parameter-index <id> ^formatted <p>)
    (<p> ^rtype <rtype>)
    -->
    (<c> ^formatted true +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type concept +
           ^attribute predicate + ^rtype <rtype> +)
    (<a> ^1 <p> + ^2 <p2> +)
    (<para> ^1 <para1> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
}

sp {convert-parsed-format*apply*handle-clause*indef2*arg3
    (state <s> ^name convert-parsed-format ^operator <o> ^superstate <s*1>)
    (<o> ^name handle-clause ^clause <c>)
   -{ (<c> ^modifier <m*1>)
      (<m*1> ^handle negation)}
    (<c> ^predicate <r> ^arg1 <c1>)
    (<r> ^3 <c3> ^2 <c2> ^handle <name>)
    (<c3> -^parameter-index <p*3> ^formatted <p3>)
    (<p3> ^rtype <rtype3>)
    (<c2> ^parameter-index <id2> ^formatted <p2>)
    (<p2> ^rtype <rtype2>)
    (<c1> ^parameter-index <id> ^formatted <p>)
    (<p> ^rtype <rtype>)
    (<s*1> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <p*2>)
    (<p*2> ^handle <name>)
    -->
    (<c> ^formatted true +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type state-pair +
           ^attribute prepositions + ^rtype <rtype> +)
    (<a> ^1 <p> + ^2 <p2> + ^3 <p3> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*apply*handle-clause*indef*arg3
    (state <s> ^name convert-parsed-format ^operator <o> ^superstate <s*1>)
    (<o> ^name handle-clause ^clause <c>)
   -{ (<c> ^modifier <m*1>)
      (<m*1> ^handle negation)}
    (<c> ^predicate <r> ^arg1 <c1>)
    (<r> ^2 <c2> ^3 <c3> ^handle <name>)
    (<c2> -^parameter-index <p*3> ^formatted <p2>)
    (<c3> -^parameter-index <p*4> ^formatted <p3>)
    (<p3> ^rtype <rtype3>)
    (<p2> ^rtype <rtype2>)
    (<c1> ^parameter-index <id> ^formatted <p>)
    (<p> ^rtype <rtype>)
    (<s*1> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <p*2>)
    (<p*2> ^handle <name>)
    -->
    (<c> ^formatted true +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type state-pair +
           ^attribute prepositions + ^rtype <rtype> +)
    (<a> ^1 <p> + ^2 <p2> + ^3 <p3> +)
    (<para> ^1 <para1> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
}

sp {convert-parsed-format*apply*handle-clause*indef
    (state <s> ^name convert-parsed-format ^operator <o> ^superstate <s*1>)
    (<o> ^name handle-clause ^clause <c>)
   -{ (<c> ^modifier <m*1>)
      (<m*1> ^handle negation)}
    (<c> ^predicate <r> ^arg1 <c1>)
    (<r> -^3 <v*1> ^2 <c2> ^handle <name>)
    (<c2> -^parameter-index <p*3> ^formatted <p2>)
    (<p2> ^rtype <rtype2>)
    (<c1> ^parameter-index <id> ^formatted <p>)
    (<p> ^rtype <rtype>)
    (<s*1> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <p*2>)
    (<p*2> ^handle <name>)
    -->
    (<c> ^formatted true +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type state-pair +
           ^attribute prepositions + ^rtype <rtype> +)
    (<a> ^1 <p> + ^2 <p2> +)
    (<para> ^1 <para1> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
}

sp {convert-parsed-format*apply*handle-clause*concept*arg3
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^name handle-clause ^clause <c>)
   -{ (<c> ^modifier <m*1>)
      (<m*1> ^handle negation)}
    (<c> ^predicate <r> ^arg1 <c1>)
    (<r> -^handle between ^handle <name> ^2 <c2> ^3 <c3>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^world <w*1>)
      (<w*1> ^predicates <p*1>)
      (<p*1> ^predicate <p*2>)
      (<p*2> ^handle <name>)}
    (<c2> ^parameter-index <id2> ^formatted <p2>)
    (<p2> ^rtype <rtype2>)
    (<c1> ^parameter-index <id> ^formatted <p>)
    (<p> ^rtype <rtype>)
    (<c3> ^parameter-index <id3> ^formatted <p3>)
    (<p3> ^rtype <rtype3>)
    -->
    (<c> ^formatted true +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type concept +
           ^attribute predicate + ^rtype <rtype> +)
    (<a> ^1 <p> + ^2 <p2> + ^3 <p3> +)
    (<para> ^1 <para1> + ^2 <para2> + ^3 <para3> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
    (<para3> ^param-id <id3> + ^type <rtype3> +)
}

sp {convert-parsed-format*apply*handle-clause*concept*arg3*between*new-format
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^name handle-clause ^clause <c>)
   -{ (<c> ^modifier <m*1>)
      (<m*1> ^handle negation)}
    (<c> ^predicate <r> ^arg1 <c1>)
    (<r> ^handle between ^handle <name> ^2 <c2> ^3 <c3>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^world <w*1>)
      (<w*1> ^predicates <p*1>)
      (<p*1> ^predicate <p*2>)
      (<p*2> ^handle <name>)}
    (<c2> ^parameter-index <id2> ^formatted <p2>)
    (<p2> ^rtype <rtype2>)
    (<c1> ^new-formatted <p> ^parameter-index <id>)
    (<p> ^rtype <rtype>)
    (<c3> ^parameter-index <id3> ^formatted <p3>)
    (<p3> ^rtype <rtype3>)
    -->
    (<c> ^formatted true +)
    (<r> ^formatted true +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type function +
           ^function board-between + ^rtype <rtype> +)
    (<a> ^1 <p> + ^2 <p2> + ^3 <p3> +)
    (<para> ^1 <para1> + ^2 <para2> + ^3 <para3> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
    (<para3> ^param-id <id3> + ^type <rtype3> +)
}

sp {convert-parsed-format*apply*handle-clause*concept*arg3*between
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^name handle-clause ^clause <c>)
   -{ (<c> ^modifier <m*1>)
      (<m*1> ^handle negation)}
    (<c> ^predicate <r> ^arg1 <c1>)
    (<r> ^handle between ^handle <name> ^2 <c2> ^3 <c3>)
    (<c1> -^new-formatted <n*1> ^parameter-index <id> ^formatted <p>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^world <w*1>)
      (<w*1> ^predicates <p*1>)
      (<p*1> ^predicate <p*2>)
      (<p*2> ^handle <name>)}
    (<p> ^rtype <rtype>)
    (<c2> ^parameter-index <id2> ^formatted <p2>)
    (<p2> ^rtype <rtype2>)
    (<c3> ^parameter-index <id3> ^formatted <p3>)
    (<p3> ^rtype <rtype3>)
    -->
    (<c> ^formatted true +)
    (<r> ^formatted true +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type function +
           ^function board-between + ^rtype <rtype> +)
    (<a> ^1 <p> + ^2 <p2> + ^3 <p3> +)
    (<para> ^1 <para1> + ^2 <para2> + ^3 <para3> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
    (<para3> ^param-id <id3> + ^type <rtype3> +)
}

sp {convert-parsed-format*apply*handle-clause*concepts
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^name handle-clause ^clause <c>)
   -{ (<c> ^modifier <m*1>)
      (<m*1> ^handle negation)}
    (<c> ^predicate <r> ^arg1 <c1>)
    (<r> -^3 <v*1> ^handle <name> ^2 <c2>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^world <w*1>)
      (<w*1> ^predicates <p*1>)
      (<p*1> ^predicate <p*2>)
      (<p*2> ^handle <name>)}
    (<c2> ^parameter-index <id2> ^formatted <p2>)
    (<p2> ^rtype <rtype2>)
    (<c1> ^parameter-index <id> ^formatted <p>)
    (<p> ^rtype <rtype>)
    -->
    (<c> ^formatted true +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type concept +
           ^attribute predicate + ^rtype <rtype> +)
    (<a> ^1 <p> + ^2 <p2> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*apply*handle-clause*arg3
    (state <s> ^name convert-parsed-format ^operator <o> ^superstate <s*1>)
    (<o> ^name handle-clause ^clause <c>)
   -{ (<c> ^modifier <m*1>)
      (<m*1> ^handle negation)}
    (<c> ^predicate <r> ^arg1 <c1>)
    (<r> ^2 <c2> ^3 <c3> ^handle <name>)
    (<c2> ^parameter-index <id2> ^formatted <p2>)
    (<p2> ^rtype <rtype2>)
    (<c1> ^parameter-index <id> ^formatted <p>)
    (<p> ^rtype <rtype>)
    (<c3> ^parameter-index <id3> ^formatted <p3>)
    (<p3> ^rtype <rtype3>)
    (<s*1> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <p*2>)
    (<p*2> ^handle <name>)
    -->
    (<c> ^formatted true +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type state-pair +
           ^attribute prepositions + ^rtype <rtype> +)
    (<a> ^1 <p> + ^2 <p2> + ^3 <p3> +)
    (<para> ^1 <para1> + ^2 <para2> + ^3 <para3> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
    (<para3> ^param-id <id3> + ^type <rtype3> +)
}

sp {convert-parsed-format*apply*handle-clause
    (state <s> ^name convert-parsed-format ^operator <o> ^superstate <s*1>)
    (<o> ^name handle-clause ^clause <c>)
   -{ (<c> ^modifier <m*1>)
      (<m*1> ^handle negation)}
    (<c> ^predicate <r> ^arg1 <c1>)
    (<r> -^3 <v*1> ^2 <c2> ^handle <name>)
    (<c2> ^parameter-index <id2> ^formatted <p2>)
    (<p2> ^rtype <rtype2>)
    (<c1> ^parameter-index <id> ^formatted <p>)
    (<p> ^rtype <rtype>)
    (<s*1> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <p*2>)
    (<p*2> ^handle <name>)
    -->
    (<c> ^formatted true +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type state-pair +
           ^attribute prepositions + ^rtype <rtype> +)
    (<a> ^1 <p> + ^2 <p2> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*apply*handle-property-predicate*concept-property
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^name handle-property-predicate ^pred-clause <c> ^pred-name <name>
          ^param <p> ^property property)
   -{ (<c> ^modifier <m*1>)
      (<m*1> ^handle negation)}
    (<p> ^new-formatted <p1> ^parameter-index <id>)
    (<p1> ^rtype <rtype>)
    -->
    (<c> ^formatted true +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type concept +
           ^attribute predicate + ^rtype <rtype> +)
    (<a> ^1 <p1> +)
    (<para> ^1 <para1> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
}

sp {convert-parsed-format*apply*handle-property-predicate*concept-property*primitive
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^name handle-property-predicate ^pred-clause <c> ^pred-name <name>
          ^param <p> ^property { << color size shape >> <prop> })
   -{ (<c> ^modifier <m*1>)
      (<m*1> ^handle negation)}
    (<p> ^new-formatted <p1> ^parameter-index <id>)
    (<p1> ^rtype <rtype>)
    -->
    (<c> ^formatted true +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type attribute +
           ^attribute <prop> + ^rtype <rtype> +)
    (<a> ^1 <p1> +)
    (<para> ^1 <para1> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
}

sp {convert-parsed-format*apply*handle-property-predicate*concept-property*primitive*notnew
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^name handle-property-predicate ^pred-clause <c> ^param <p>
          ^pred-name <name> ^property { << color size shape >> <prop> })
   -{ (<c> ^modifier <m*1>)
      (<m*1> ^handle negation)}
    (<p> -^new-formatted <n*1> ^parameter-index <id> ^formatted <p1>)
    (<p1> ^rtype <rtype>)
    -->
    (<c> ^formatted true +)
    (<p> ^new-formatted <n> +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type attribute +
           ^attribute <prop> + ^rtype <rtype> +)
    (<a> ^1 <p1> +)
    (<para> ^1 <para1> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
}

sp {convert-parsed-format*apply*handle-property-predicate*concept-property*notnew
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^name handle-property-predicate ^pred-clause <c> ^param <p>
          ^pred-name <name> ^property property)
   -{ (<c> ^modifier <m*1>)
      (<m*1> ^handle negation)}
    (<p> -^new-formatted <n*1> ^parameter-index <id> ^formatted <p1>)
    (<p1> ^rtype <rtype>)
    -->
    (<c> ^formatted true +)
    (<p> ^new-formatted <n> +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type concept +
           ^attribute predicate + ^rtype <rtype> +)
    (<a> ^1 <p1> +)
    (<para> ^1 <para1> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
}

sp {convert-parsed-format*propose*handle-property-predicate
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> -^formatted <f*1> ^predicate <pred> ^arg1 <p>)
    (<pred> ^item-type predicate ^handle <name> ^property <p*2>)
   -{ (<s> ^learning-predicate <l*2>)
      (<l*2> ^spelling <name>)}
   -{ (<s> ^learn-link <l*1>)
      (<l*1> ^handle <name>)}
    (<p> ^predicates <ps> ^predicates <p*1>)
    (<p*1> ^category <type>)
    (<p*2> ^handle { <> category <prop> })
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name handle-property-predicate + ^param <p> + ^property <prop> +
           ^pred-name <name> + ^pred-clause <c> +)
}

sp {convert-parsed-format*propose*handle-clause*attribute-of
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> -^formatted <f*1> ^predicate <p> ^arg1 <a*1>)
    (<p> ^handle of1 ^2 <v*1>)
    (<v*1> ^handle <name>)
   -{ (<s> ^learning-predicate <l*2>)
      (<l*2> ^spelling <name>)}
   -{ (<s> ^learn-link <l*1>)
      (<l*1> ^handle <name>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name handle-clause + ^clause <c> +)
}

sp {convert-parsed-format*propose*handle-clause
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> -^formatted <f*1> ^predicate <p> ^arg1 <a*1>)
    (<p> -^handle of1 ^handle <name> ^2 <v*1>)
   -{ (<s> ^learning-predicate <l*2>)
      (<l*2> ^spelling <name>)}
   -{ (<s> ^learn-link <l*1>)
      (<l*1> ^handle <name>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name handle-clause + ^clause <c> +)
}

sp {convert-parsed-format*propose*handle-clause*parameter
    (state <s> ^name convert-parsed-format ^parameter <p>)
    (<p> ^relation <r>)
    (<r> -^formatted <f*1> ^handle <name>)
   -{ (<s> ^learning-predicate <l*2>)
      (<l*2> ^spelling <name>)}
   -{ (<s> ^learn-link <l*1>)
      (<l*1> ^handle <name>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name handle-clause + ^parameter <p> +)
}

sp {convert-parsed-format*apply*handle-predicate*count*equal*reverse
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^name handle-predicate ^predicate <c>)
    (<c> ^handle number1 ^equal-to <e*1> ^relation <p2> ^property <p*1>)
    (<e*1> ^formatted <oc>)
    (<oc> ^parameter <p*2>)
    (<p*2> ^1 <v*1>)
    (<v*1> ^param-id <id1>)
    (<p2> ^handle of1 ^2 <c2>)
    (<c2> -^new-formatted <n*1> ^parameter-index <id2> ^formatted <f2>)
    (<f2> ^rtype <rtype2>)
    -->
    (<c> ^formatted <n> +)
    (<s> ^nlp <n> +)
    (<n> ^name count + ^args <a> + ^parameter <para> + ^type function +
           ^function soar-count + ^rtype single + ^return-type number +)
    (<a> ^2 <f2> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <id1> + ^type single +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*apply*handle-predicate*count*equal
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^name handle-predicate ^predicate <c>)
    (<c> ^handle of1 ^2 <p2> ^equal-to <e*1>)
    (<p2> ^handle number1 ^2 <c2>)
    (<c2> -^new-formatted <n*1> ^parameter-index <id2> ^formatted <f2>)
    (<e*1> ^formatted <oc>)
    (<f2> ^rtype <rtype2>)
    (<oc> ^parameter <p*1>)
    (<p*1> ^1 <v*1>)
    (<v*1> ^param-id <id1>)
    -->
    (<c> ^formatted <n> +)
    (<s> ^nlp <n> +)
    (<n> ^name count + ^args <a> + ^parameter <para> + ^type function +
           ^function soar-count + ^rtype single + ^return-type number +)
    (<a> ^2 <f2> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <id1> + ^type single +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*apply*handle-predicate*count*new-formatted*reversed
    (state <s> ^name convert-parsed-format ^operator <o> ^object-count <oc>)
    (<o> ^name handle-predicate ^predicate <c>)
   -{ (<c> ^equal-to <e*1>)
      (<e*1> ^formatted <f*1>)}
    (<c> ^handle number1 ^relation <p2> ^property <p*1>)
    (<p2> ^handle of1 ^2 <c2>)
    (<c2> ^new-formatted <f2> ^parameter-index <id2>)
    (<f2> ^rtype <rtype2>)
    -->
    (<c> ^formatted <n> +)
    (<s> ^object-count <oc> - ^object-count (+ <oc> 1) + ^nlp <n> +)
    (<n> ^name count + ^args <a> + ^parameter <para> + ^type function +
           ^function soar-count + ^rtype single + ^return-type number +)
    (<a> ^2 <f2> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <oc> + ^type single +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*apply*handle-predicate*count*new-formatted
    (state <s> ^name convert-parsed-format ^operator <o> ^object-count <oc>)
    (<o> ^name handle-predicate ^predicate <c>)
   -{ (<c> ^equal-to <e*1>)
      (<e*1> ^formatted <f*1>)}
    (<c> ^handle of1 ^2 <p2>)
    (<p2> ^handle number1 ^2 <c2>)
    (<c2> ^new-formatted <f2> ^parameter-index <id2>)
    (<f2> ^rtype <rtype2>)
    -->
    (<c> ^formatted <n> +)
    (<s> ^object-count <oc> - ^object-count (+ <oc> 1) + ^nlp <n> +)
    (<n> ^name count + ^args <a> + ^parameter <para> + ^type function +
           ^function soar-count + ^rtype single + ^return-type number +)
    (<a> ^2 <f2> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <oc> + ^type single +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*apply*handle-predicate*count*equal*new-formatted
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^name handle-predicate ^predicate <c>)
    (<c> ^handle of1 ^2 <p2> ^equal-to <e*1>)
    (<p2> ^handle number1 ^2 <c2>)
    (<e*1> ^formatted <oc>)
    (<oc> ^parameter <p*1>)
    (<c2> ^new-formatted <f2> ^parameter-index <id2>)
    (<f2> ^rtype <rtype2>)
    (<p*1> ^1 <v*1>)
    (<v*1> ^param-id <id1>)
    -->
    (<c> ^formatted <n> +)
    (<s> ^nlp <n> +)
    (<n> ^name count + ^args <a> + ^parameter <para> + ^type function +
           ^function soar-count + ^rtype single + ^return-type number +)
    (<a> ^2 <f2> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <id1> + ^type single +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*apply*handle-predicate*more-than*constant
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^name handle-predicate ^predicate <c>)
    (<c> ^handle more-than1 ^2 <p2> ^1 <p1>)
    (<p2> -^formatted <f*1> ^number <num>)
    (<p1> ^formatted <f1>)
    (<f1> ^rtype <rtype1> ^parameter <p*1>)
    (<p*1> ^1 <v*1>)
    (<v*1> ^param-id <id1>)
    -->
    (<c> ^formatted <n> +)
    (<s> ^nlp <n> +)
    (<n> ^name greater + ^args <a> + ^parameter <para> + ^rtype single +
           ^return-type number + ^type function + ^function soar-greater +)
    (<a> ^1 <f1> + ^2 <f2> +)
    (<f2> ^name number + ^result <r*1> + ^args <a> + ^parameter <paraf> +
           ^rtype single + ^return-type number +)
    (<r*1> ^set <s*1> +)
    (<s*1> ^instance <i> +)
    (<i> ^1 <num> +)
    (<para> ^1 <para1> +)
    (<para1> ^param-id <id1> + ^type <rtype1> +)
}

sp {convert-parsed-format*apply*handle-predicate*more-than
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^name handle-predicate ^predicate <c>)
    (<c> ^handle more-than1 ^2 <p2> ^1 <p1>)
    (<p2> ^formatted <f2>)
    (<f2> ^rtype <rtype2> ^parameter <p*2>)
    (<p*2> ^1 <v*2>)
    (<v*2> ^param-id <id2>)
    (<p1> ^formatted <f1>)
    (<f1> ^rtype <rtype1> ^parameter <p*1>)
    (<p*1> ^1 <v*1>)
    (<v*1> ^param-id <id1>)
    -->
    (<c> ^formatted <n> +)
    (<s> ^nlp <n> +)
    (<n> ^name greater + ^args <a> + ^parameter <para> + ^rtype single +
           ^return-type number + ^type function + ^function soar-greater +)
    (<a> ^1 <f1> + ^2 <f2> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <id1> + ^type <rtype1> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*apply*handle-predicate*count*equal*new-formatted*reverse
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^name handle-predicate ^predicate <c>)
    (<c> ^handle number1 ^equal-to <e*1> ^relation <p2> ^property <p*1>)
    (<e*1> ^formatted <oc>)
    (<oc> ^parameter <p*2>)
    (<p*2> ^1 <v*1>)
    (<v*1> ^param-id <id1>)
    (<p2> ^handle of1 ^2 <c2>)
    (<c2> ^new-formatted <f2> ^parameter-index <id2>)
    (<f2> ^rtype <rtype2>)
    -->
    (<c> ^formatted <n> +)
    (<s> ^nlp <n> +)
    (<n> ^name count + ^args <a> + ^parameter <para> + ^type function +
           ^function soar-count + ^rtype single + ^return-type number +)
    (<a> ^2 <f2> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <id1> + ^type single +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*apply*handle-predicate*count*reverse
    (state <s> ^name convert-parsed-format ^operator <o> ^object-count <oc>)
    (<o> ^name handle-predicate ^predicate <c>)
   -{ (<c> ^equal-to <e*1>)
      (<e*1> ^formatted <f*1>)}
    (<c> ^handle number1 ^relation <p2> ^property <p*1>)
    (<p2> ^handle of1 ^2 <c2>)
    (<c2> -^new-formatted <n*1> ^parameter-index <id2> ^formatted <f2>)
    (<f2> ^rtype <rtype2>)
    -->
    (<c> ^formatted <n> +)
    (<s> ^object-count <oc> - ^object-count (+ <oc> 1) + ^nlp <n> +)
    (<n> ^name count + ^args <a> + ^parameter <para> + ^type function +
           ^function soar-count + ^rtype single + ^return-type number +)
    (<a> ^2 <f2> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <oc> + ^type single +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*apply*handle-predicate*count
    (state <s> ^name convert-parsed-format ^operator <o> ^object-count <oc>)
    (<o> ^name handle-predicate ^predicate <c>)
   -{ (<c> ^equal-to <e*1>)
      (<e*1> ^formatted <f*1>)}
    (<c> ^handle of1 ^2 <p2>)
    (<p2> ^handle number1 ^2 <c2>)
    (<c2> -^new-formatted <n*1> ^parameter-index <id2> ^formatted <f2>)
    (<f2> ^rtype <rtype2>)
    -->
    (<c> ^formatted <n> +)
    (<s> ^object-count <oc> - ^object-count (+ <oc> 1) + ^nlp <n> +)
    (<n> ^name count + ^args <a> + ^parameter <para> + ^type function +
           ^function soar-count + ^rtype single + ^return-type number +)
    (<a> ^2 <f2> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <oc> + ^type single +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*apply*handle-predicate*number*equal
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^name handle-predicate ^predicate <c>)
    (<c> -^2 <v*1> ^equal-to <e*1> ^handle <name> ^property <p*1>)
    (<e*1> ^formatted <oc>)
    (<oc> ^parameter <p*2>)
    (<p*2> ^1 <v*2>)
    (<v*2> ^param-id <id1>)
    (<p*1> ^handle number)
    -->
    (<c> ^formatted <n> +)
    (<s> ^nlp <n> +)
    (<n> ^name number + ^result <r*1> + ^args <a> + ^parameter <para> +
           ^rtype single + ^return-type number +)
    (<r*1> ^set <s*1> +)
    (<s*1> ^instance <i> +)
    (<i> ^1 <name> +)
    (<para> ^1 <para1> +)
    (<para1> ^param-id <id1> + ^type single +)
}

sp {convert-parsed-format*apply*handle-predicate*number
    (state <s> ^name convert-parsed-format ^operator <o> ^object-count <oc>)
    (<o> ^name handle-predicate ^predicate <c>)
   -{ (<c> ^equal-to <e*1>)
      (<e*1> ^formatted <f*1>)}
    (<c> -^2 <v*1> ^handle <name> ^property <p*1>)
    (<p*1> ^handle number)
    -->
    (<c> ^formatted <n> +)
    (<s> ^object-count <oc> - ^object-count (+ <oc> 1) + ^nlp <n> +)
    (<n> ^name number + ^result <r*1> + ^args <a> + ^parameter <para> +
           ^rtype single + ^return-type number +)
    (<r*1> ^set <s*1> +)
    (<s*1> ^instance <i> +)
    (<i> ^1 <name> +)
    (<para> ^1 <para1> +)
    (<para1> ^param-id <oc> + ^type single +)
}

sp {convert-parsed-format*apply*handle-predicate*between*numbers
    (state <s> ^name convert-parsed-format ^operator <o> ^object-count <oc>)
    (<o> ^name handle-predicate ^numeric-predicate <c>)
    (<c> ^relation <r>)
    (<r> ^handle between ^2 <r2> ^3 <r3>)
    (<r2> ^number <num1>)
    (<r3> ^number <num2>)
    -->
    (<c> ^formatted <n> +)
    (<s> ^object-count <oc> - ^object-count (+ <oc> 3) + ^nlp <n> +)
    (<n> ^name between + ^args <a> + ^parameter <para> + ^type function +
           ^function numeric-between + ^rtype single + ^return-type number +)
    (<a> ^2 <p2> + ^3 <p3> +)
    (<para> ^1 <para1> + ^2 <para2> + ^3 <para3> +)
    (<para1> ^param-id <oc> + ^type single +)
    (<para2> ^param-id (+ <oc> 1) + ^type single +)
    (<para3> ^param-id (+ <oc> 2) + ^type single +)
    (<p2> ^name number + ^result <r*1> + ^args <a> + ^parameter <parap> +
           ^rtype single + ^return-type number +)
    (<r*1> ^set <s*1> +)
    (<s*1> ^instance <i> +)
    (<i> ^1 <num1> +)
    (<parap> ^1 <parag> +)
    (<parag> ^param-id (+ <oc> 1) + ^type single +)
    (<p3> ^name number + ^result <r*2> + ^args <a> + ^parameter <par2> +
           ^rtype single + ^return-type number +)
    (<r*2> ^set <s*2> +)
    (<s*2> ^instance <i2> +)
    (<i2> ^1 <num2> +)
    (<par2> ^1 <para2g> +)
    (<para2g> ^param-id (+ <oc> 2) + ^type single +)
}

sp {convert-parsed-format*apply*handle-predicate*equal-exists
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^name handle-predicate ^predicate <c>)
    (<c> ^handle of1 ^2 <p2> ^equal-to <eq>)
    (<p2> -^handle number1 ^2 <c2> ^handle <name>)
    (<eq> ^formatted <oc>)
    (<oc> ^parameter <p*1>)
    (<c2> ^parameter-index <id2> ^formatted <f2>)
    (<f2> ^rtype <rtype2>)
    (<p*1> ^1 <v*1>)
    (<v*1> ^param-id <id1>)
    -->
    (<c> ^formatted <n> +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type attribute-of +
           ^rtype <rtype2> + ^return-type number +)
    (<a> ^2 <f2> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <id1> + ^type <rtype2> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*apply*handle-predicate*of*learned
    (state <s> ^name convert-parsed-format ^operator <o> ^object-count <oc>)
    (<o> ^name handle-predicate ^predicate <c>)
   -{ (<c> ^equal-to <e*1>)
      (<e*1> ^formatted <f*1>)}
    (<c> ^handle of1 ^2 <p2>)
    (<p2> -^handle number1 ^handle <name> ^2 <c2>)
   -{ (state <s> ^superstate <s*1> ^<a*1> <v*1>)
      (<s*1> ^world <w*1>)
      (<w*1> ^objects <o*1>)
      (<o*1> ^object <o*2>)
      (<o*2> ^predicates <p*1>)
      (<p*1> ^<name> <n*1>)}
    (<c2> ^parameter-index <id2> ^formatted <f2>)
    (<f2> ^rtype <rtype2>)
    -->
    (<c> ^formatted <n> +)
    (<s> ^object-count <oc> - ^object-count (+ <oc> 1) + ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type concept +
           ^attribute predicate + ^rtype <rtype2> +)
    (<a> ^2 <f2> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <oc> + ^type <rtype2> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*apply*handle-predicate*attribute*absent
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^name handle-predicate ^predicate <c>)
    (<c> ^handle of1 ^equal-to <eq> ^2 <p2>)
    (<eq> ^handle absent)
    (<p2> -^handle number1 ^handle <name> ^2 <c2>)
   -{-{ (<s> ^superstate <s*1>)
        (<s*1> ^world <w*1>)
        (<w*1> ^objects <o*1>)
        (<o*1> ^object <o*2>)
        (<o*2> ^predicates <p*1>)
        (<p*1> ^<name> <n*1>)}
      (state <s> ^<a*1> <v*1>)}
    (<c2> ^parameter-index <id2> ^formatted <f2>)
    (<f2> ^rtype <rtype2>)
    -->
    (<c> ^formatted <n> +)
    (<eq> ^formatted true +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type has-attribute +
           ^rtype <rtype2> + ^negative true +)
    (<a> ^1 <f2> +)
    (<para> ^1 <para1> +)
    (<para1> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*apply*handle-predicate
    (state <s> ^name convert-parsed-format ^operator <o> ^object-count <oc>)
    (<o> ^name handle-predicate ^predicate <c>)
   -{ (<c> ^equal-to <e*2>)
      (<e*2> ^handle absent)}
   -{ (<c> ^equal-to <e*1>)
      (<e*1> ^formatted <f*1>)}
    (<c> ^handle of1 ^2 <p2>)
    (<p2> -^handle number1 ^handle <name> ^2 <c2>)
   -{-{ (<s> ^superstate <s*1>)
        (<s*1> ^world <w*1>)
        (<w*1> ^objects <o*1>)
        (<o*1> ^object <o*2>)
        (<o*2> ^predicates <p*1>)
        (<p*1> ^<name> <n*1>)}
      (state <s> ^<a*1> <v*1>)}
    (<c2> ^parameter-index <id2> ^formatted <f2>)
    (<f2> ^rtype <rtype2>)
    -->
    (<c> ^formatted <n> +)
    (<s> ^object-count <oc> - ^object-count (+ <oc> 1) + ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type attribute-of +
           ^rtype <rtype2> + ^return-type number +)
    (<a> ^2 <f2> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <oc> + ^type <rtype2> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*apply*handle-predicate*equal-exists*reverse
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^name handle-predicate ^predicate <c>)
    (<c> -^handle number1 ^equal-to <eq> ^handle <name> ^relation <p2>)
    (<eq> ^formatted <oc>)
    (<oc> ^parameter <p*1>)
    (<p*1> ^1 <v*1>)
    (<v*1> ^param-id <id1>)
    (<p2> ^handle of1 ^2 <c2>)
    (<c2> ^parameter-index <id2> ^formatted <f2>)
    (<f2> ^rtype <rtype2>)
    -->
    (<c> ^formatted true +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type attribute-of +
           ^rtype <rtype2> + ^return-type number +)
    (<a> ^2 <f2> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <id1> + ^type <rtype2> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*apply*handle-predicate*equal-exists*state-pair*negative
    (state <s> ^name convert-parsed-format ^operator <o> ^superstate <s*1>)
    (<o> ^name handle-predicate ^predicate <c>)
    (<c> -^handle number1 ^modifier <m*1> ^equal-to <eq> ^2 <p> ^handle <name>)
    (<m*1> ^handle negation)
    (<eq> ^formatted <oc>)
    (<oc> ^rtype <rtype> ^parameter <p*3>)
    (<p> ^parameter-index <id2> ^formatted <oc2>)
    (<oc2> ^rtype <rtype2>)
    (<p*3> ^1 <v*1>)
    (<v*1> ^param-id <id1>)
    (<s*1> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <p*2>)
    (<p*2> ^handle <name>)
    -->
    (<c> ^formatted true +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type state-pair +
           ^negative true + ^attribute prepositions + ^rtype <rtype> +)
    (<a> ^1 <oc> + ^2 <oc2> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <id1> + ^type <rtype> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*apply*handle-predicate*equal-exists*state-pair
    (state <s> ^name convert-parsed-format ^operator <o> ^superstate <s*1>)
    (<o> ^name handle-predicate ^predicate <c>)
   -{ (<c> ^modifier <m*1>)
      (<m*1> ^handle negation)}
    (<c> -^handle number1 ^equal-to <eq> ^2 <p> ^handle <name>)
    (<eq> ^formatted <oc>)
    (<oc> ^rtype <rtype> ^parameter <p*3>)
    (<p> ^parameter-index <id2> ^formatted <oc2>)
    (<oc2> ^rtype <rtype2>)
    (<p*3> ^1 <v*1>)
    (<v*1> ^param-id <id1>)
    (<s*1> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <p*2>)
    (<p*2> ^handle <name>)
    -->
    (<c> ^formatted true +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type state-pair +
           ^attribute prepositions + ^rtype <rtype> +)
    (<a> ^1 <oc> + ^2 <oc2> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <id1> + ^type <rtype> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*apply*handle-predicate*reverseorder-of
    (state <s> ^name convert-parsed-format ^operator <o> ^object-count <oc>)
    (<o> ^name handle-predicate ^predicate <c>)
    (<c> -^handle number1 ^handle <name> ^relation <p2>)
   -{ (<c> ^equal-to <e*1>)
      (<e*1> ^formatted <f*1>)}
    (<p2> ^handle of1 ^2 <c2>)
    (<c2> ^parameter-index <id2> ^formatted <f2>)
    (<f2> ^rtype <rtype2>)
    -->
    (<c> ^formatted <n> +)
    (<s> ^object-count <oc> - ^object-count (+ <oc> 1) + ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type attribute-of +
           ^rtype <rtype2> + ^return-type number +)
    (<a> ^2 <f2> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <oc> + ^type <rtype2> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*propose*handle-predicate*attribute-of
    (state <s> ^name convert-parsed-format ^predicate <p>)
    (<p> -^formatted <f*1> ^handle of1 ^2 <v*1>)
    (<v*1> ^handle <name>)
   -{ (<s> ^learning-predicate <l*2>)
      (<l*2> ^spelling <name>)}
   -{ (<s> ^learn-link <l*1>)
      (<l*1> ^handle <name>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name handle-predicate + ^predicate <p> +)
}

sp {convert-parsed-format*propose*handle-predicate*numeric-predicate
    (state <s> ^name convert-parsed-format ^numeric-predicate <p>)
    (<p> -^formatted <f*1>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name handle-predicate + ^numeric-predicate <p> +)
}

sp {convert-parsed-format*propose*handle-predicate*parameter
    (state <s> ^name convert-parsed-format ^predicate <p>)
    (<p> -^handle of1 -^formatted <f*1> ^handle <name>)
   -{ (<s> ^learning-predicate <l*2>)
      (<l*2> ^spelling <name>)}
   -{ (<s> ^learn-link <l*1>)
      (<l*1> ^handle <name>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name handle-predicate + ^predicate <p> +)
}

sp {convert-parsed-format*apply*handle-action*3verbs
    (state <s> ^name convert-parsed-format ^operator <o> ^nlp-set <nps>
          ^superstate <ss>)
    (<o> ^name handle-action ^arg2c <a2c> ^arg1c <a1c> ^arg2b <a2b>
          ^arg1b <a1b> ^arg2 <a2> ^arg1 <a1> ^action <a>)
    (<a1c> ^parameter-index <pac>)
    (<a1b> ^parameter-index <pab>)
    (<nps> ^verb-structure <va2>)
    (<a2c> ^2 <obj2c> ^handle <rnamec>)
    (<obj2c> ^parameter-index <pa2c>)
    (<a2b> ^2 <obj2b> ^handle <rnameb>)
    (<obj2b> ^parameter-index <pa2b>)
    (<a2> ^2 <obj2> ^handle <rname>)
    (<obj2> ^parameter-index <pa2>)
    (<a1> ^parameter-index <pa>)
    (<a> ^handle <name>)
    -->
    (<ss> ^verb-structure <va2> +)
    (<va2> ^1 <va> + ^2 <vab> + ^3 <vac> +)
    (<va> ^verb-name <name> + ^verb-prep <rname> + ^1 <pa> + ^2 <pa2> +)
    (<a> ^formatted true +)
    (<vab> ^verb-name <name> + ^verb-prep <rnameb> + ^1 <pab> + ^2 <pa2b> +)
    (<vac> ^verb-name <name> + ^verb-prep <rnamec> + ^1 <pac> + ^2 <pa2c> +)
}

sp {convert-parsed-format*apply*handle-action*2verbs
    (state <s> ^name convert-parsed-format ^operator <o> ^nlp-set <nps>
          ^superstate <ss>)
    (<o> -^arg1c <a*1> ^name handle-action ^arg2b <a2b> ^arg1b <a1b>
          ^arg2 <a2> ^arg1 <a1> ^action <a>)
    (<a1b> ^parameter-index <pab>)
    (<nps> ^verb-structure <va2>)
    (<a2b> ^2 <obj2b> ^handle <rnameb>)
    (<obj2b> ^parameter-index <pa2b>)
    (<a2> ^2 <obj2> ^handle <rname>)
    (<obj2> ^parameter-index <pa2>)
    (<a1> ^parameter-index <pa>)
    (<a> ^handle <name>)
    -->
    (<ss> ^verb-structure <va2> +)
    (<va2> ^1 <va> + ^2 <vab> +)
    (<va> ^verb-name <name> + ^verb-prep <rname> + ^1 <pa> + ^2 <pa2> +)
    (<a> ^formatted true +)
    (<vab> ^verb-name <name> + ^verb-prep <rnameb> + ^1 <pab> + ^2 <pa2b> +)
}

sp {convert-parsed-format*apply*handle-action*first-argof
    (state <s> ^name convert-parsed-format ^operator <o> ^action-count <an>
          ^nlp-set <nps> ^superstate <ss>)
    (<o> -^arg1b <a*1> ^name handle-action ^arg1 <a1> ^arg2 <a2> ^action <a>)
    (<a1> -^parameter-index <p*1> ^formatted <f*1>)
    (<nps> ^verb-structure <va2>)
    (<f*1> ^parameter <p*2>)
    (<a2> ^2 <obj2> ^handle <rname>)
    (<obj2> ^parameter-index <pa2>)
    (<a> ^handle <name>)
    (<p*2> ^1 <v*1>)
    (<v*1> ^param-id <pa>)
    -->
    (<s> ^action-count <an> - ^action-count (+ <an> 1) +)
    (<ss> ^verb-structure <va2> +)
    (<va2> ^<an> <va> +)
    (<va> ^verb-name <name> + ^verb-prep <rname> + ^1 <pa> + ^2 <pa2> +)
    (<a> ^formatted true +)
}

sp {convert-parsed-format*apply*handle-action
    (state <s> ^name convert-parsed-format ^operator <o> ^action-count <an>
          ^nlp-set <nps> ^superstate <ss>)
    (<o> -^arg1b <a*1> ^name handle-action ^arg2 <a2> ^arg1 <a1> ^action <a>)
    (<nps> ^verb-structure <va2>)
    (<a2> ^2 <obj2> ^handle <rname>)
    (<obj2> ^parameter-index <pa2>)
    (<a1> ^parameter-index <pa>)
    (<a> ^handle <name>)
    -->
    (<s> ^action-count <an> - ^action-count (+ <an> 1) +)
    (<ss> ^verb-structure <va2> +)
    (<va2> ^<an> <va> +)
    (<va> ^verb-name <name> + ^verb-prep <rname> + ^1 <pa> + ^2 <pa2> +)
    (<a> ^formatted true +)
}

sp {convert-parsed-format*apply*handle-action*one-arg
    (state <s> ^name convert-parsed-format ^operator <o> ^nlp-set <nps>
          ^superstate <ss>)
    (<o> -^arg2 <a*1> ^name handle-action ^arg1 <a1> ^action <a>)
    (<nps> ^verb-structure <va>)
    (<a1> ^parameter-index <pa>)
    (<a> ^handle <name>)
    -->
    (<ss> ^verb-structure <va> +)
    (<va> ^1 <va1> +)
    (<va1> ^verb-name <name> + ^verb-prep <name> + ^1 <pa> +)
    (<a> ^formatted true +)
}

sp {convert-parsed-format*propose*handle-action*one-arg
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> -^arg2 <a*1> ^action <a> ^arg1 <a1>)
    (<a> -^handle is1 -^formatted <f*1>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name handle-action + ^action <a> + ^arg1 <a1> +)
}

sp {convert-parsed-format*propose*handle-action*2actions*1arg3
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> ^arg2 <a2> -^arg2 { <> <a2> <a*1> } ^action <a> ^arg1 <a1c>
          ^arg1 { > <a1c> <a1b> } ^arg1 { > <a1b> <a1> })
    (<a> -^formatted <f*1>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name handle-action + ^action <a> + ^arg1 <a1b> + ^arg2 <a2> +
           ^arg1b <a1> + ^arg2b <a2> + ^arg1c <a1c> + ^arg2c <a2> +)
}

sp {convert-parsed-format*propose*handle-action*2actions*1arg1number
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> ^arg2 <a2> -^arg2 { <> <a2> <a*1> } ^arg1 <a1b>
          ^arg1 { <> <a1b> <a1> } -^arg1 { <> <a1b> <> <a1> <a1c> }
          ^action <a>)
    (<a1b> ^handle number1)
    (<a> -^formatted <f*1>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name handle-action + ^action <a> + ^arg1 <a1> + ^arg2 <a2> +)
}

sp {convert-parsed-format*propose*handle-action*2actions*1arg2
    (state <s> ^name convert-parsed-format ^clause <c>)
   -{ (<c> ^arg1 <a*1>)
      (<a*1> ^handle number1)}
    (<c> ^arg2 <a2> -^arg2 { <> <a2> <a*2> } ^action <a> ^arg1 <a1b>
          ^arg1 { > <a1b> <a1> } -^arg1 { <> <a1b> <> <a1> <a1c> })
    (<a> -^formatted <f*1>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name handle-action + ^action <a> + ^arg1 <a1b> + ^arg2 <a2> +
           ^arg1b <a1> + ^arg2b <a2> +)
}

sp {convert-parsed-format*propose*handle-action*2actions
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> ^action <a> ^arg2 <a2b> ^arg2 { > <a2b> <a2> } ^arg1 <a1b>
          ^arg1 { > <a1b> <a1> })
    (<a> -^formatted <f*1>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name handle-action + ^action <a> + ^arg1 <a1b> + ^arg2 <a2b> +
           ^arg1b <a1> + ^arg2b <a2> +)
}

sp {convert-parsed-format*propose*handle-action*2clause
    (state <s> ^name convert-parsed-format ^clause <c> ^clause { > <c> <c2> })
    (<c> ^action <a> ^arg2 <a2> ^arg1 <a1>)
    (<a> -^formatted <f*1>)
    (<c2> ^arg2 <a2b> ^arg1 <a1b> ^action <af>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name handle-action + ^action <a> + ^arg1 <a1b> + ^arg2 <a2b> +
           ^arg1b <a1> + ^arg2b <a2> +)
}

sp {convert-parsed-format*apply*handle-pref-action2*consider
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^consider 2 ^name handle-pref-action ^arg2b <a4> ^arg2 <a2>
          ^arg1b <a3> ^action2 <c2> ^arg1 <a1> ^action <c>)
    (<a4> ^item-type predicate ^2 <a44> ^handle <prep2>)
    (<a2> ^item-type predicate ^2 <a22> ^handle <prep>)
    (<a3> ^parameter-index <id3> ^formatted <p3>)
    (<p3> ^rtype <rtype3>)
    (<a44> ^parameter-index <id4> ^formatted <p4>)
    (<p4> ^rtype <rtype4>)
    (<a22> ^parameter-index <id2> ^formatted <p2>)
    (<p2> ^rtype <rtype2>)
    (<a1> ^parameter-index <id> ^formatted <p>)
    (<p> ^rtype <rtype>)
    (<c2> ^handle <name2>)
    (<c> ^handle <name>)
    -->
    (<c> ^formatted true +)
    (<s> ^consider <n12> + ^nlp <n> + ^nlp <n2> +)
    (<n12> ^1 <n> + ^2 <n2> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type concept +
           ^attribute action + ^rtype <rtype> + ^verb <prep> +)
    (<n2> ^name <name2> + ^args <ab> + ^parameter <parab> + ^type concept +
           ^attribute action + ^rtype <rtype3> + ^verb <prep2> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
    (<parab> ^1 <para3> + ^2 <para4> +)
    (<para3> ^param-id <id3> + ^type <rtype3> +)
    (<para4> ^param-id <id4> + ^type <rtype4> +)
}

sp {convert-parsed-format*apply*handle-pref-action*consider
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^consider single ^name handle-pref-action ^arg2 <a2> ^arg1 <a1>
          ^action <c>)
    (<a2> ^item-type predicate ^2 <a22> ^handle <prep>)
    (<a22> ^parameter-index <id2> ^formatted <p2>)
    (<p2> ^rtype <rtype2>)
    (<a1> ^parameter-index <id> ^formatted <p>)
    (<p> ^rtype <rtype>)
    (<c> ^handle <name>)
    -->
    (<c> ^formatted true +)
    (<s> ^consider <n12> + ^nlp <n> +)
    (<n12> ^1 <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type concept +
           ^attribute action + ^rtype <rtype> + ^verb <prep> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*propose*handle-pref-action*consider
    (state <s> ^name convert-parsed-format ^pref-action <c>)
    (<c> ^consider single ^action <a> ^arg2 <a2> ^arg1 <a1>)
    (<a> -^formatted <f*1>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name handle-pref-action + ^action <a> + ^consider single +
           ^arg1 <a1> + ^arg2 <a2> +)
}

sp {convert-parsed-format*propose*handle-pref-action2*consider
    (state <s> ^name convert-parsed-format ^pref-action <c>)
    (<c> ^consider 2 ^2 <c2> ^1 <c1>)
    (<c2> ^arg2 <a4> ^arg1 <a3> ^action <ab>)
    (<c1> ^action <a> ^arg2 <a2> ^arg1 <a1>)
    (<a> -^formatted <f*1>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name handle-pref-action + ^action <a> + ^action2 <ab> +
           ^consider 2 + ^arg1 <a1> + ^arg2 <a2> + ^arg1b <a3> + ^arg2b <a4> +)
}

sp {convert-parsed-format*apply*handle-pref-action2
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^prefer 2 ^name handle-pref-action ^arg2b <a4> ^arg2 <a2> ^arg1b <a3>
          ^action2 <c2> ^arg1 <a1> ^action <c>)
    (<a4> ^item-type predicate ^2 <a44> ^handle <prep2>)
    (<a2> ^item-type predicate ^2 <a22> ^handle <prep>)
    (<a3> ^parameter-index <id3> ^formatted <p3>)
    (<p3> ^rtype <rtype3>)
    (<a44> ^parameter-index <id4> ^formatted <p4>)
    (<p4> ^rtype <rtype4>)
    (<a22> ^parameter-index <id2> ^formatted <p2>)
    (<p2> ^rtype <rtype2>)
    (<a1> ^parameter-index <id> ^formatted <p>)
    (<p> ^rtype <rtype>)
    (<c2> ^handle <name2>)
    (<c> ^handle <name>)
    -->
    (<c> ^formatted true +)
    (<s> ^prefer <n12> + ^nlp <n> + ^nlp <n2> +)
    (<n12> ^1 <n> + ^2 <n2> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type concept +
           ^attribute action + ^rtype <rtype> + ^verb <prep> +)
    (<n2> ^name <name2> + ^args <ab> + ^parameter <parab> + ^type concept +
           ^attribute action + ^rtype <rtype3> + ^verb <prep2> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
    (<parab> ^1 <para3> + ^2 <para4> +)
    (<para3> ^param-id <id3> + ^type <rtype3> +)
    (<para4> ^param-id <id4> + ^type <rtype4> +)
}

sp {convert-parsed-format*apply*handle-pref-action*arg1
    (state <s> ^name convert-parsed-format -^modifier previously ^operator <o>)
    (<o> -^arg2 <a2> ^prefer single ^name handle-pref-action ^arg1 <a1>
          ^action <c>)
    (<a1> ^parameter-index <id> ^formatted <p>)
    (<p> ^rtype <rtype>)
    (<c> ^handle <name>)
    -->
    (<c> ^formatted true +)
    (<s> ^prefer <n12> + ^nlp <n> +)
    (<n12> ^1 <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type concept +
           ^attribute action + ^rtype <rtype> +)
    (<para> ^1 <para1> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
}

sp {convert-parsed-format*apply*handle-pref-action*avoid*arg1
    (state <s> ^name convert-parsed-format -^modifier previously ^operator <o>)
    (<o> -^arg2 <a2> ^avoid single ^name handle-pref-action ^arg1 <a1>
          ^action <c>)
    (<a1> ^parameter-index <id> ^formatted <p>)
    (<p> ^rtype <rtype>)
    (<c> ^handle <name>)
    -->
    (<c> ^formatted true +)
    (<s> ^avoid <n12> + ^nlp <n> +)
    (<n12> ^1 <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type concept +
           ^attribute action + ^rtype <rtype> +)
    (<para> ^1 <para1> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
}

sp {convert-parsed-format*apply*handle-pref-action*avoid*arg1*previously
    (state <s> ^modifier previously ^name convert-parsed-format ^operator <o>)
    (<o> -^arg2 <a2> ^avoid single ^name handle-pref-action ^arg1 <a1>
          ^action <c>)
    (<a1> ^parameter-index <id> ^formatted <p>)
    (<p> ^rtype <rtype>)
    (<c> ^handle <name>)
    -->
    (<c> ^formatted true +)
    (<s> ^avoid <n12> +)
    (<n12> ^1 <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type concept +
           ^attribute action + ^rtype <rtype> +)
    (<para> ^1 <para1> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
}

sp {convert-parsed-format*apply*handle-pref-action*arg1*previously
    (state <s> ^modifier previously ^name convert-parsed-format ^operator <o>)
    (<o> -^arg2 <a2> ^prefer single ^name handle-pref-action ^arg1 <a1>
          ^action <c>)
    (<a1> ^parameter-index <id> ^formatted <p>)
    (<p> ^rtype <rtype>)
    (<c> ^handle <name>)
    -->
    (<c> ^formatted true +)
    (<s> ^prefer <n12> +)
    (<n12> ^1 <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type concept +
           ^attribute action + ^rtype <rtype> +)
    (<para> ^1 <para1> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
}

sp {convert-parsed-format*apply*handle-pref-action*avoid
    (state <s> ^name convert-parsed-format -^modifier previously ^operator <o>)
    (<o> ^avoid single ^name handle-pref-action ^arg2 <a2> ^arg1 <a1>
          ^action <c>)
    (<a2> ^item-type predicate ^2 <a22> ^handle <prep>)
    (<a22> ^parameter-index <id2> ^formatted <p2>)
    (<p2> ^rtype <rtype2>)
    (<a1> ^parameter-index <id> ^formatted <p>)
    (<p> ^rtype <rtype>)
    (<c> ^handle <name>)
    -->
    (<c> ^formatted true +)
    (<s> ^avoid <n12> + ^nlp <n> +)
    (<n12> ^1 <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type concept +
           ^attribute action + ^rtype <rtype> + ^verb <prep> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*apply*handle-pref-action
    (state <s> ^name convert-parsed-format -^modifier previously ^operator <o>)
    (<o> ^prefer single ^name handle-pref-action ^arg2 <a2> ^arg1 <a1>
          ^action <c>)
    (<a2> ^item-type predicate ^2 <a22> ^handle <prep>)
    (<a22> ^parameter-index <id2> ^formatted <p2>)
    (<p2> ^rtype <rtype2>)
    (<a1> ^parameter-index <id> ^formatted <p>)
    (<p> ^rtype <rtype>)
    (<c> ^handle <name>)
    -->
    (<c> ^formatted true +)
    (<s> ^prefer <n12> + ^nlp <n> +)
    (<n12> ^1 <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type concept +
           ^attribute action + ^rtype <rtype> + ^verb <prep> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*propose*handle-pref-action*arg1
    (state <s> ^name convert-parsed-format ^pref-action <c>)
    (<c> -^arg2 <a2> ^prefer single ^action <a> ^arg1 <a1>)
    (<a> -^formatted <f*1>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name handle-pref-action + ^action <a> + ^prefer single +
           ^arg1 <a1> +)
}

sp {convert-parsed-format*propose*handle-pref-action*avoid*arg1
    (state <s> ^name convert-parsed-format ^pref-action <c>)
    (<c> -^arg2 <a2> ^avoid single ^action <a> ^arg1 <a1>)
    (<a> -^formatted <f*1>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name handle-pref-action + ^action <a> + ^avoid single + ^arg1 <a1> +)
}

sp {convert-parsed-format*propose*handle-pref-action*avoid
    (state <s> ^name convert-parsed-format ^pref-action <c>)
    (<c> ^avoid single ^action <a> ^arg2 <a2> ^arg1 <a1>)
    (<a> -^formatted <f*1>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name handle-pref-action + ^action <a> + ^avoid single + ^arg1 <a1> +
           ^arg2 <a2> +)
}

sp {convert-parsed-format*propose*handle-pref-action
    (state <s> ^name convert-parsed-format ^pref-action <c>)
    (<c> ^prefer single ^action <a> ^arg2 <a2> ^arg1 <a1>)
    (<a> -^formatted <f*1>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name handle-pref-action + ^action <a> + ^prefer single +
           ^arg1 <a1> + ^arg2 <a2> +)
}

sp {convert-parsed-format*propose*handle-pref-action2
    (state <s> ^name convert-parsed-format ^pref-action <c>)
    (<c> ^prefer 2 ^2 <c2> ^1 <c1>)
    (<c2> ^arg2 <a4> ^arg1 <a3> ^action <ab>)
    (<c1> ^action <a> ^arg2 <a2> ^arg1 <a1>)
    (<a> -^formatted <f*1>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name handle-pref-action + ^action <a> + ^action2 <ab> + ^prefer 2 +
           ^arg1 <a1> + ^arg2 <a2> + ^arg1b <a3> + ^arg2b <a4> +)
}

sp {convert-parsed-format*propose*handle-action
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> ^arg1 <a1> -^arg1 { <> <a1> <a3> } ^action <a> ^arg2 <a2>)
   -{ (<s> ^clause <c*1>)
      (<c*1> ^action { <> <a> <a4> })
      (<a4> -^handle is1)}
    (<a> -^formatted <f*1>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name handle-action + ^action <a> + ^arg1 <a1> + ^arg2 <a2> +)
}

sp {convert-parsed-format*apply*create-object*increment-object-count
    (state <s> ^name convert-parsed-format ^operator <o> -^indef <c>
          ^object-count <oc>)
    (<o> ^name create-object ^parameter <c>)
    (<c> -^parameter-index <p*1>)
    -->
    (<c> ^parameter-index <oc> +)
    (<s> ^object-count (+ 1 <oc>) + ^object-count <oc> -)
}

sp {convert-parsed-format*propose*create-object
    (state <s> ^name convert-parsed-format ^parameter <c>)
    (<c> -^formatted <f*1>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name create-object + ^parameter <c> +)
}

sp {convert-parsed-format*elaborate*arg2*parameter*indef
    (state <s> ^name convert-parsed-format ^clause <c>
          -^{ << input-object-1 input-object-2 output-object-1 >> <a*1> } <p>)
    (<c> ^predicate <p*1>)
    (<p*1> ^2 <p>)
   -{ (<s> ^clause { <> <c> <c4> })
      (<c4> ^arg1 <p> ^action <act>)}
   -{ (<s> ^clause { <> <c> <c4> })
      (<c4> ^arg2 <a*3> ^action <act>)
      (<a*3> ^2 <p>)}
   -{ (<s> ^clause { <> <c> <c3> })
      (<c3> ^predicate <p*5>)
      (<p*5> ^3 <p>)}
   -{ (<s> ^clause { <> <c> <c3> })
      (<c3> ^predicate <p*4>)
      (<p*4> ^2 <p>)}
   -{ (<p> ^relation <rr>)
      (<rr> ^2 <v*1>)}
   -{ (<s> ^parameter <pp>)
      (<pp> ^relation <r>)
      (<r> ^3 <p>)}
   -{ (<s> ^parameter <pp>)
      (<pp> ^relation <r>)
      (<r> ^2 <p>)}
   -{ (<s> ^clause <c2>)
      (<c2> ^{ << arg1 arg2 >> <a*2> } <p>)}
   -{ (<p> ^predicates <p*3>)
      (<p*3> ^number <n*1>)}
    (<p> ^predicates <p*2>)
    (<p*2> ^category <type>)
    -->
    (<s> ^indef <p> +)
}

sp {convert-parsed-format*elaborate*arg2*parameter
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> ^predicate <p>)
    (<p> ^{ << 2 3 >> <a*1> } <pp>)
    (<pp> ^predicates <p*1>)
    (<p*1> ^category <type>)
    -->
    (<s> ^parameter <pp> +)
}

sp {convert-parsed-format*elaborate*parameter*relation*parameter
    (state <s> ^name convert-parsed-format ^parameter <p>)
    (<p> ^relation <r>)
    (<r> ^{ << 2 3 >> <a*1> } <pp>)
    (<pp> ^predicates <p*1>)
    (<p*1> ^category <type>)
    -->
    (<s> ^parameter <pp> +)
}

sp {convert-parsed-format*elaborate*arg1*of-concept*parameter
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> ^{ << arg1 arg2 >> <a*1> } <a>)
    (<a> ^handle of1 ^2 <p>)
    -->
    (<s> ^predicate <a> +)
}

sp {convert-parsed-format*elaborate*arg1*relation*parameter
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> ^{ << arg1 arg2 >> <a*1> } <a>)
    (<a> ^2 <p>)
    (<p> ^predicates <p*1>)
    (<p*1> ^category <type>)
    -->
    (<s> ^parameter <p> +)
}

sp {convert-parsed-format*elaborate*predicate-objects*more
    (state <s> ^name convert-parsed-format ^predicate <c>)
    (<c> ^handle more-than1 ^2 <p2> ^1 <p1>)
    -->
    (<s> ^predicate <p1> + ^predicate <p2> +)
}

sp {convert-parsed-format*elaborate*predicate-objects*of*second
    (state <s> ^name convert-parsed-format ^predicate <c>)
    (<c> ^handle of1 ^2 <r>)
    (<r> ^2 <pp> ^handle <name>)
    (<pp> ^predicates <p*1>)
    (<p*1> ^category <type>)
    -->
    (<s> ^parameter <pp> +)
}

sp {convert-parsed-format*elaborate*predicate-objects*of*first
    (state <s> ^name convert-parsed-format ^predicate <c>)
    (<c> ^handle <name> ^relation <r> ^property <p*1>)
    (<r> ^handle of1 ^2 <pp>)
    (<pp> ^predicates <p*2>)
    (<p*2> ^category <type>)
    -->
    (<s> ^parameter <pp> +)
}

sp {convert-parsed-format*elaborate*predicate-objects
    (state <s> ^name convert-parsed-format ^predicate <c>)
    (<c> ^handle of1 ^2 <p2>)
    (<p2> ^2 <pp>)
    (<pp> ^predicates <p*1>)
    (<p*1> ^category <type>)
    -->
    (<s> ^parameter <pp> +)
}

sp {convert-parsed-format*elaborate*predicate*number*attribute
    (state <s> ^name convert-parsed-format ^parameter <c>)
    (<c> ^parameter-index <id2> ^formatted <f2> ^predicates <p*1>)
    (<p*1> ^number <num>)
    -->
    (<s> ^predicate <p> + ^predicate <pp> +)
    (<p> ^property <p*2> + ^handle <num> + ^equal-to <pp> +)
    (<p*2> ^handle number +)
    (<pp> ^handle of1 + ^2 <p2> + ^equal-to <p> +)
    (<p2> ^2 <c> + ^handle number1 +)
}

sp {convert-parsed-format*elaborate*predicate-is-predicate*more-than
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> ^predicate <pp> ^arg1 <p>)
    (<pp> ^item-type predicate ^handle more-than1)
    (<p> ^item-type predicate)
    -->
    (<c> ^formatted true +)
    (<s> ^predicate <pp> +)
    (<pp> ^1 <p> +)
}

sp {convert-parsed-format*elaborate*predicate*modifier
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> ^modifier <m> ^predicate <pp> ^arg1 <p>)
    -->
    (<pp> ^modifier <m> +)
}

sp {convert-parsed-format*elaborate*predicate-is-predicate
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> ^predicate <pp> ^arg1 <p>)
    (<pp> -^handle more-than1 ^item-type predicate)
    (<p> -^handle more-than1 ^item-type predicate)
    -->
    (<c> ^formatted true +)
    (<s> ^predicate <p> + ^predicate <pp> +)
    (<p> ^equal-to <pp> +)
    (<pp> ^equal-to <p> +)
}

sp {convert-parsed-format*elaborate*arg1*relation*parameterfg
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> ^arg1 <a*1> ^arg1 <p>)
    (<a*1> ^handle number1)
    (<p> ^relation <type>)
    -->
    (<s> ^numeric-predicate <p> +)
}

sp {convert-parsed-format*elaborate*arg1*parameter
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> ^{ << arg1 arg2 2 >> <a*1> } <p>)
    (<p> ^predicates <p*1>)
    (<p*1> ^category <type>)
    -->
    (<s> ^parameter <p> +)
}

sp {convert-parsed-format*elaborate*clause*subclause
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> ^{ << if-subclause subclause then-subclause >> <a*1> } <s1>)
    -->
    (<s> ^clause <s1> +)
}

sp {convert-parsed-format*elaborate*clause*consider2
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> ^action <a*1> ^subclause2 <sb2> ^subclause1 <sb>)
    (<a*1> ^handle consider)
    (<sb2> ^arg2 <a4> ^arg1 <a3> ^action <act2>)
    (<sb> ^arg2 <a2> ^arg1 <a1> ^action <act>)
    -->
    (<s> ^pref-action <sz> + ^clause <a2> + ^clause <a4> + ^parameter <a1> +
           ^parameter <a3> + ^preference-rule true +)
    (<sz> ^consider 2 + ^1 <sb> + ^2 <sb2> +)
}

sp {convert-parsed-format*elaborate*clause*prefer2
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> ^action <a*1> ^subclause2 <sb2> ^subclause1 <sb>)
    (<a*1> ^handle prefer)
    (<sb2> ^arg2 <a4> ^arg1 <a3> ^action <act2>)
    (<sb> ^arg2 <a2> ^arg1 <a1> ^action <act>)
    -->
    (<s> ^pref-action <sz> + ^clause <a2> + ^clause <a4> + ^parameter <a1> +
           ^parameter <a3> + ^preference-rule true +)
    (<sz> ^prefer 2 + ^1 <sb> + ^2 <sb2> +)
}

sp {convert-parsed-format*elaborate*clause*consider1
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> -^subclause2 <s*1> ^action <a*1> ^subclause1 <sb>)
    (<a*1> ^handle consider)
    (<sb> ^arg2 <a2> ^arg1 <a1> ^action <act>)
    -->
    (<s> ^pref-action <sb> + ^clause <a2> + ^parameter <a1> +
           ^preference-rule true +)
    (<sb> ^consider single +)
}

sp {convert-parsed-format*elaborate*clause*avoid1onearg
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> -^subclause2 <s*1> ^subclause1 <sb> ^action <a*1>)
    (<sb> -^arg2 <a*2> ^arg1 <a1> ^action <act>)
    (<a*1> ^handle avoid)
    -->
    (<s> ^pref-action <sb> + ^clause <a1> + ^parameter <a1> +
           ^preference-rule true +)
    (<sb> ^avoid single +)
}

sp {convert-parsed-format*elaborate*clause*prefer1onearg
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> -^subclause2 <s*1> ^subclause1 <sb> ^action <a*1>)
    (<sb> -^arg2 <a*2> ^arg1 <a1> ^action <act>)
    (<a*1> ^handle prefer)
    -->
    (<s> ^pref-action <sb> + ^clause <a1> + ^parameter <a1> +
           ^preference-rule true +)
    (<sb> ^prefer single +)
}

sp {convert-parsed-format*elaborate*clause*avoid1
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> -^subclause2 <s*1> ^action <a*1> ^subclause1 <sb>)
    (<a*1> ^handle avoid)
    (<sb> ^arg2 <a2> ^arg1 <a1> ^action <act>)
    -->
    (<s> ^pref-action <sb> + ^clause <a2> + ^parameter <a1> +
           ^preference-rule true +)
    (<sb> ^avoid single +)
}

sp {convert-parsed-format*elaborate*clause*prefer1
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> -^subclause2 <s*1> ^action <a*1> ^subclause1 <sb>)
    (<a*1> ^handle prefer)
    (<sb> ^arg2 <a2> ^arg1 <a1> ^action <act>)
    -->
    (<s> ^pref-action <sb> + ^clause <a2> + ^parameter <a1> +
           ^preference-rule true +)
    (<sb> ^prefer single +)
}

sp {convert-parsed-format*elaborate*sentence*subclause
    (state <s> ^name convert-parsed-format ^sentence <s2>)
    -->
    (<s> ^clause <s2> +)
}

sp {convert-parsed-format*elaborate*object-count
    (state <s> ^name convert-parsed-format)
    -->
    (<s> ^object-count 1 + ^action-count 1 + ^nlp-set <nps> +)
    (<nps> ^verb-structure <vs> +)
}

sp {convert-parsed-format*elaborate*input-object-2
    (state <s> ^name convert-parsed-format ^top-state <t*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^input-object-2 <np>)
    -->
    (<s> ^input-object-2 <np> +)
}

sp {convert-parsed-format*elaborate*output-object-1
    (state <s> ^name convert-parsed-format ^top-state <t*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^output-object-1 <np>)
    -->
    (<s> ^output-object-1 <np> +)
}

sp {convert-parsed-format*elaborate*input-object
    (state <s> ^name convert-parsed-format ^top-state <t*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^input-object-1 <np>)
    -->
    (<s> ^input-object-1 <np> +)
}

sp {convert-parsed-format*elaborate*learning-predicate
    (state <s> ^name convert-parsed-format ^top-state <t*1>)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^learning-predicate <np> ^learn-link <ll>)
    -->
    (<s> ^learning-predicate <np> + ^learn-link <ll> +)
}

sp {convert-parsed-format*elaborate*only-parameter
    (state <s> ^name convert-parsed-format ^sentence <s*1>)
    (<s*1> ^{ << if-subclause then-subclause subclause >> <a*1> } <c>)
    (<c> ^predicate <p>)
    (<p> ^predicates <p*1> ^item-type { << object location block >> <i*1> })
    (<p*1> ^category <type>)
    -->
    (<s> ^parameter <p> +)
}

sp {convert-parsed-format*elaborate*agent*opponent*then-clause*two
    :o-support
    (state <s> ^name convert-parsed-format ^nlp-set <nps> ^sentence <s*1>)
    (<s*1> ^then-subclause <t*1>)
    (<t*1> ^subclause <s*2>)
    (<s*2> ^agent <a*1>)
    (<a*1> ^predicates <p*1>)
    (<p*1> ^shape opponent1)
    -->
    (<nps> ^opponent true +)
}

sp {convert-parsed-format*elaborate*agent*opponent*then-clause
    :o-support
    (state <s> ^name convert-parsed-format ^nlp-set <nps> ^sentence <s*1>)
    (<s*1> ^then-subclause <t*1>)
    (<t*1> ^agent <a*1>)
    (<a*1> ^predicates <p*1>)
    (<p*1> ^shape opponent1)
    -->
    (<nps> ^opponent true +)
}

sp {convert-parsed-format*elaborate*agent*opponent*two
    :o-support
    (state <s> ^name convert-parsed-format ^clause <c*1> ^nlp-set <nps>)
    (<c*1> ^agent <a*1>)
    (<a*1> ^predicates <p*1>)
    (<p*1> ^shape opponent1)
    -->
    (<nps> ^opponent true +)
}

sp {convert-parsed-format*elaborate*agent*opponent
    :o-support
    (state <s> ^name convert-parsed-format ^nlp-set <nps> ^sentence <s*1>)
    (<s*1> ^agent <a*1>)
    (<a*1> ^predicates <p*1>)
    (<p*1> ^shape opponent1)
    -->
    (<nps> ^opponent true +)
}

sp {convert-parsed-format*elaborate*sentence
    (state <s> ^name convert-parsed-format ^superstate <s*1>)
    (<s*1> ^operator <sop>)
    (<sop> ^structure <t>)
    -->
    (<s> ^sentence <t> +)
}

sp {selection*select*success-evaluation-becomes-best-preference*tie*t1778-3
    (state <s1> ^desired <d1> ^operator <o2> + ^problem-space <p3>
          ^top-state <s2> ^world <n4>)
   -{ (<s1> ^operator <o*1>)
      (<o*1> ^name evaluate-operator)}
    (<d1> ^predicate <r1>)
    (<r1> ^type relation ^1 <n2> ^2 <n1> ^handle <c3>)
    (<o2> ^name initiate-pick-up1 ^arg1 <a1> ^name <c5>)
    (<a1> ^arg-type object ^id <n2>)
    (<n2> ^predicates <p1> ^item-type <c2>)
    (<p1> ^arm-status not-grabbed)
    (<p3> ^action-type composite ^name action ^name <c4>)
    (<n1> ^item-type <c1>)
    (<s2> ^agent-params <p4>)
    (<p4> ^domain arm)
    (<n4> ^objects <o1> ^predicates <p2>)
    (<p2> ^predicate <n3>)
    (<n3> ^handle <c3>)
    (<o1> ^object <n2> ^object <n1>)
    -->
    (<s1> ^operator <o2> > ^operator <o2> = 1)
}

sp {selection*select*success-evaluation-becomes-best-preference*tie*t1778-1
    (state <s1> ^operator <o2> + ^problem-space <p2> ^desired <d1> ^world <n5>)
    (<o2> ^name initiate-put-down1 ^arg2 <a2> ^arg1 <a1>)
    (<a2> ^arg-type predicate ^2 <n2> ^handle <c4>)
    (<a1> ^arg-type object ^id <n3>)
    (<p2> ^action-type composite ^name action ^name <c5>)
    (<d1> ^predicate <n1>)
    (<n1> ^type relation ^2 <n2> ^1 <n3> ^handle <c1>)
    (<n3> ^item-type <c2>)
    (<n2> ^item-type <c3>)
    (<n5> ^objects <o1> ^predicates <p1>)
    (<p1> ^predicate <n4>)
    (<n4> ^handle <c1>)
    (<o1> ^object <n2> ^object <n3>)
    -->
    (<s1> ^operator <o2> > ^operator <o2> = 1)
}

sp {learn-desired-elaboration-rule*apply*complete-learn-desired-elaboration-rule*t1069-1
    (state <s1> ^action-context <o5> ^superstate <s2> ^problem-space <p3>
          ^action-id <n6>)
    (<o5> ^action-type composite ^<c2> <a2> ^<c1> <a1>)
    (<s2> ^operator <o5>)
    (<p3> ^name action)
    (<n6> ^procedural <p2> ^goal <g2>)
    (<g2> ^predicate <g1> -^predicate { <> <g1> <pred2> })
    (<g1> ^type relation ^2 <o2> ^1 <o1> ^id <p1>)
    (<p2> ^<c2> <n1> ^<c2> <n5> ^{ > <c2> <c1> } <n4> ^<c1> <n3> ^<c1> <n2>)
    (<n1> ^arg-type object ^id <o1>)
    (<a2> ^arg-type object ^id <o4>)
   -{ (<o5> ^{ <> <c2> <> <c1> <arg3-name> } <arg3>)
      (<p2> ^<arg3-name> <parg3>)}
    (<n3> ^arg-type predicate ^2 <o2>)
    (<n2> ^arg-type predicate ^id <p1>)
    (<a1> ^arg-type predicate ^2 <o3> ^handle <c3>)
    -->
    (<s1> ^desired <d1> +)
    (<d1> ^predicate <r1> +)
    (<r1> ^type relation + ^handle <c3> + ^1 <o4> + ^2 <o3> +)
}

sp {soar-math*square-root*instance
    (state <s> ^name soar-math ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^type square-root ^args <args> ^parameter <p*1>)
    (<args> ^num 1 ^2 <a1>)
    (<p*1> ^num 2)
    (<a1> ^result <r*1>)
    (<r*1> ^set <s*2>)
    (<s*2> ^instance <i*1>)
    (<i*1> ^1 <value>)
    -->
    (<s> ^instance <pa> +)
    (<pa> ^2 <value> + ^1 (sqrt <value>) +)
}

sp {soar-math*abs*instance
    (state <s> ^name soar-math ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^type absolute-value ^args <args> ^parameter <p*1>)
    (<args> ^num 1 ^2 <a1>)
    (<p*1> ^num 2)
    (<a1> ^result <r*1>)
    (<r*1> ^set <s*2>)
    (<s*2> ^instance <i*1>)
    (<i*1> ^1 <value>)
    -->
    (<s> ^instance <pa> +)
    (<pa> ^2 <value> + ^1 (abs <value>) +)
}

sp {soar-math*subtract*instance
    (state <s> ^name soar-math ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^type subtract ^args <args> ^parameter <p*1>)
    (<args> ^num 2 ^2 <a1> ^3 <a2>)
    (<p*1> ^num { > 1 <n*1> })
    (<a2> ^result <r*2>)
    (<r*2> ^set <s*3>)
    (<s*3> ^instance <i*2>)
    (<i*2> ^1 <value1>)
    (<a1> ^result <r*1>)
    (<r*1> ^set <s*2>)
    (<s*2> ^instance <i*1>)
    (<i*1> ^1 <value>)
    -->
    (<s> ^instance <pa> +)
    (<pa> ^2 <value> + ^3 <value1> + ^1 (- <value> <value1>) +)
}

sp {soar-math*divide*instance
    (state <s> ^name soar-math ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^type divide ^args <args> ^parameter <p*1>)
    (<args> ^num 2 ^2 <a1> ^3 <a2>)
    (<p*1> ^num { > 1 <n*1> })
    (<a2> ^result <r*2>)
    (<r*2> ^set <s*3>)
    (<s*3> ^instance <i*2>)
    (<i*2> ^1 <value1>)
    (<a1> ^result <r*1>)
    (<r*1> ^set <s*2>)
    (<s*2> ^instance <i*1>)
    (<i*1> ^1 <value>)
    -->
    (<s> ^instance <pa> +)
    (<pa> ^2 <value> + ^3 <value1> + ^1 (|/| <value> <value1>) +)
}

sp {soar-math*add*instance
    (state <s> ^name soar-math ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^type add ^args <args> ^parameter <p*1>)
    (<args> ^num 2 ^2 <a1> ^3 <a2>)
    (<p*1> ^num { > 1 <n*1> })
    (<a2> ^result <r*2>)
    (<r*2> ^set <s*3>)
    (<s*3> ^instance <i*2>)
    (<i*2> ^1 <value1>)
    (<a1> ^result <r*1>)
    (<r*1> ^set <s*2>)
    (<s*2> ^instance <i*1>)
    (<i*1> ^1 <value>)
    -->
    (<s> ^instance <pa> +)
    (<pa> ^2 <value> + ^3 <value1> + ^1 (+ <value1> <value>) +)
}

sp {soar-math*multiply*instance
    (state <s> ^name soar-math ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^type multiply ^args <args> ^parameter <p*1>)
    (<args> ^num 2 ^2 <a1> ^3 <a2>)
    (<p*1> ^num { > 1 <n*1> })
    (<a2> ^result <r*2>)
    (<r*2> ^set <s*3>)
    (<s*3> ^instance <i*2>)
    (<i*2> ^1 <value1>)
    (<a1> ^result <r*1>)
    (<r*1> ^set <s*2>)
    (<s*2> ^instance <i*1>)
    (<i*1> ^1 <value>)
    -->
    (<s> ^instance <pa> +)
    (<pa> ^2 <value> + ^3 <value1> + ^1 (* <value1> <value>) +)
}

sp {soar-math*square-root
    (state <s> ^name soar-math ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^type square-root ^args <args> ^parameter <p*1>)
    (<args> ^num 1 ^2 <a1>)
    (<p*1> ^num { < 2 <n*1> })
    (<a1> ^result <r*1>)
    (<r*1> ^set <s*2>)
    (<s*2> ^instance <i*1>)
    (<i*1> ^1 <value>)
    -->
    (<s> ^instance <instancen> +)
    (<instancen> ^1 (sqrt <value>) +)
}

sp {soar-math*absolute-value
    (state <s> ^name soar-math ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^type absolute-value ^args <args> ^parameter <p*1>)
    (<args> ^num 1 ^2 <a1>)
    (<p*1> ^num { < 2 <n*1> })
    (<a1> ^result <r*1>)
    (<r*1> ^set <s*2>)
    (<s*2> ^instance <i*1>)
    (<i*1> ^1 <value>)
    -->
    (<s> ^instance <instancen> +)
    (<instancen> ^1 (abs <value>) +)
}

sp {soar-math*subtract
    (state <s> ^name soar-math ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^type subtract ^args <args> ^parameter <p*1>)
    (<args> ^num 2 ^2 <a1> ^3 <a2>)
    (<p*1> ^num { < 2 <n*1> })
    (<a2> ^result <r*2>)
    (<r*2> ^set <s*3>)
    (<s*3> ^instance <i*2>)
    (<i*2> ^1 <value1>)
    (<a1> ^result <r*1>)
    (<r*1> ^set <s*2>)
    (<s*2> ^instance <i*1>)
    (<i*1> ^1 <value>)
    -->
    (<s> ^instance <instancen> +)
    (<instancen> ^1 (- <value> <value1>) +)
}

sp {soar-math*divide
    (state <s> ^name soar-math ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^type divide ^args <args> ^parameter <p*1>)
    (<args> ^num 2 ^2 <a1> ^3 <a2>)
    (<p*1> ^num { < 2 <n*1> })
    (<a2> ^result <r*2>)
    (<r*2> ^set <s*3>)
    (<s*3> ^instance <i*2>)
    (<i*2> ^1 <value1>)
    (<a1> ^result <r*1>)
    (<r*1> ^set <s*2>)
    (<s*2> ^instance <i*1>)
    (<i*1> ^1 <value>)
    -->
    (<s> ^instance <instancen> +)
    (<instancen> ^1 (|/| <value> <value1>) +)
}

sp {soar-math*add
    (state <s> ^name soar-math ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^type add ^args <args> ^parameter <p*1>)
    (<args> ^num 2 ^2 <a1> ^3 <a2>)
    (<p*1> ^num { < 2 <n*1> })
    (<a2> ^result <r*2>)
    (<r*2> ^set <s*3>)
    (<s*3> ^instance <i*2>)
    (<i*2> ^1 <value1>)
    (<a1> ^result <r*1>)
    (<r*1> ^set <s*2>)
    (<s*2> ^instance <i*1>)
    (<i*1> ^1 <value>)
    -->
    (<s> ^instance <instancen> +)
    (<instancen> ^1 (+ <value> <value1>) +)
}

sp {soar-math*multiply
    (state <s> ^name soar-math ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^type multiply ^args <args> ^parameter <p*1>)
    (<args> ^num 2 ^2 <a1> ^3 <a2>)
    (<p*1> ^num { < 2 <n*1> })
    (<a2> ^result <r*2>)
    (<r*2> ^set <s*3>)
    (<s*3> ^instance <i*2>)
    (<i*2> ^1 <value1>)
    (<a1> ^result <r*1>)
    (<r*1> ^set <s*2>)
    (<s*2> ^instance <i*1>)
    (<i*1> ^1 <value>)
    -->
    (<s> ^instance <instancen> +)
    (<instancen> ^1 (* <value1> <value>) +)
}

sp {soar-math*apply*complete
    (state <s> ^name soar-math ^operator <op> ^instance <s1> ^superstate <s*1>)
    (<op> ^name complete ^instance <s1>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^result <r*1>)
    (<r*1> ^set <res>)
    -->
    (<res> ^instance <s1> +)
}

sp {soar-math*propose*complete
    (state <s> ^name soar-math ^instance <instance>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name complete + ^instance <instance> +)
}

sp {integer-range*propose*complete
    (state <s> ^name integer-range ^instance <instance> ^result <r*1>)
    (<r*1> ^set <res>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name complete + ^instance <instance> +)
}

sp {integer-range*elaborate*result
    (state <s> ^name integer-range)
    -->
    (<s> ^result <r*1> +)
    (<r*1> ^set <res> +)
}

sp {integer-range*elaborate*objectszz
    (state <s> ^name integer-range ^operator <op> ^instance <s1> ^c <r3>
          ^b <r2> ^a <r> ^superstate <s*1>)
    (<op> ^name complete ^instance <s1>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^result <r*1>)
    (<r*1> ^set <res>)
    -->
    (<res> ^instance <s1> +)
}

sp {integer-range*elaborate*objects
    (state <s> ^name integer-range ^c <r2> ^b <r> ^a <r3>)
    (<r3> ^result <r*3>)
    (<r*3> ^set <s*3>)
    (<s*3> ^instance <i*3>)
    (<i*3> ^1 <objc>)
    (<r2> ^result <r*2>)
    (<r*2> ^set <s*2>)
    (<s*2> ^instance <i*2>)
    (<i*2> ^1 { > <objc> <objb> })
    (<r> ^result <r*1>)
    (<r*1> ^set <s*1>)
    (<s*1> ^instance <i*1>)
    (<i*1> ^1 { < <objc> <obja> })
    -->
    (interrupt)
    (<s> ^instance <s1> +)
    (<s1> ^2 <obja> + ^3 <objb> + ^1 <objc> +)
}

sp {integer-range*propose*elaborate*args
    (state <s> ^name integer-range ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^name integer-range ^args <args> ^parameter <p>)
    (<args> ^num 3 ^2 <a2> ^3 <a3> ^1 <a1>)
    -->
    (<s> ^parameter <p> + ^a <a1> + ^b <a2> + ^c <a3> +)
}

sp {card-one-higher*propose*complete
    (state <s> ^name card-one-higher ^instance <instance> ^result <r*1>)
    (<r*1> ^set <res>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name complete + ^instance <instance> +)
}

sp {card-one-higher*elaborate*result
    (state <s> ^name card-one-higher)
    -->
    (<s> ^result <r*1> +)
    (<r*1> ^set <res> +)
}

sp {card-one-higher*elaborate*objectszz
    (state <s> ^name card-one-higher ^operator <op> ^instance <s1>
          ^superstate <s*1>)
    (<op> ^name complete ^instance <s1>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^result <r*1>)
    (<r*1> ^set <res>)
    -->
    (<res> ^instance <s1> +)
}

sp {card-one-higher*elaborate*objects
    (state <s> ^name card-one-higher ^linkstate <l*1> ^b <r2> ^a <r>)
    (<l*1> ^successive <s*1>)
    (<s*1> ^instance <p>)
    (<p> ^2 <val> ^1 <val2>)
    (<r2> ^result <r*2>)
    (<r*2> ^set <s*3>)
    (<s*3> ^instance <i*2>)
    (<i*2> ^1 <val2>)
    (<r> ^result <r*1>)
    (<r*1> ^set <s*2>)
    (<s*2> ^instance <i*1>)
    (<i*1> ^1 <val>)
    -->
    (<s> ^instance <s1> +)
    (<s1> ^1 <val> + ^2 <val2> +)
}

sp {card-one-higher*propose*elaborate*args
    (state <s> ^name card-one-higher ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^name card-one-higher ^args <args> ^parameter <p>)
    (<args> ^num 2 ^2 <a2> ^1 <a1>)
    -->
    (<s> ^parameter <p> + ^a <a1> + ^b <a2> +)
}

sp {try-different-instance*result
    (state <s> ^superstate <ss> ^superstate <s*1>)
    (<ss> ^operator <o>)
    (<o> ^name complete ^instance <i>)
    (<s*1> ^superstate <s*2>)
    (<s*2> ^name learn-condition)
    -->
    (<ss> ^operator <o> -)
}

sp {board-between*perference*complete*samey
    (state <s> ^name board-between ^operator <o1> + ^linkstate <ls>)
    (<o1> ^name complete ^instance <instance>)
    (<ls> ^diff-table <d*1>)
    (<d*1> ^diff <d1>)
    (<d1> ^pair <pa2> ^result { > 1 <r*1> })
    (<pa2> ^num <y> ^num { <> <y> <y2> })
    (<instance> ^2 <obja> ^3 <objb>)
    (<obja> ^predicates <pred1>)
    (<pred1> ^x <y> ^y <x>)
    (<objb> ^predicates <pred2>)
    (<pred2> ^y <x> ^x <y2>)
    -->
    (<s> ^operator <o1> >)
}

sp {board-between*perference*complete*samex
    (state <s> ^name board-between ^operator <o1> + ^linkstate <ls>)
    (<o1> ^name complete ^instance <instance>)
    (<ls> ^diff-table <d*1>)
    (<d*1> ^diff <d1>)
    (<d1> ^pair <pa2> ^result { > 1 <r*1> })
    (<pa2> ^num <y> ^num { <> <y> <y2> })
    (<instance> ^2 <obja> ^3 <objb>)
    (<obja> ^predicates <pred1>)
    (<pred1> ^y <y> ^x <x>)
    (<objb> ^predicates <pred2>)
    (<pred2> ^y <y2> ^x <x>)
    -->
    (<s> ^operator <o1> >)
}

sp {board-between*propose*complete
    (state <s> ^name board-between ^instance <instance>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name complete + ^instance <instance> +)
}

sp {numeric-between*propose*complete
    (state <s> ^name numeric-between ^instance <instance>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name complete + ^instance <instance> +)
}

sp {board-between*elaborate*instances*samex*inclusive
    (state <s> ^name board-between ^operator <op> ^c <r3> ^b <r2> ^a <r>
          ^superstate <s*2> ^superstate <s*1>)
    (<op> ^name complete ^instance <s1>)
    (<s1> ^2 <obja> ^3 <objb> ^1 <set>)
    (<obja> ^y <x> ^x <y2>)
    (<objb> ^y <x> ^x <y1>)
    (<r3> ^result <r*4>)
    (<r*4> ^set <s*6>)
    (<s*6> ^instance <i*3>)
    (<i*3> ^1 <objb>)
    (<r2> ^result <r*3>)
    (<r*3> ^set <s*5>)
    (<s*5> ^instance <i*2>)
    (<i*2> ^1 <obja>)
    (<r> ^result <r*2>)
    (<r*2> ^set <s*4>)
    (<s*4> ^instance <i*1>)
    (<i*1> ^1 <objc>)
   -{ (<objc> ^x { < <y1> <= <y2> <y> } ^x <y>)}
   -{ (<objc> ^x { > <y1> >= <y2> <y> } ^x <y>)}
    (<objc> ^y <x>)
    (<s*2> ^condition <c*1>)
    (<c*1> ^result <r*1>)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <s1>)
    (<s*1> ^operator <sop>)
    (<sop> ^name board-between ^type between-inclusive)
    -->
    (<set> ^object <objc> +)
}

sp {board-between*elaborate*instances*samey*inclusive
    (state <s> ^name board-between ^operator <op> ^c <r3> ^b <r2> ^a <r>
          ^superstate <s*2> ^superstate <s*1>)
    (<op> ^name complete ^instance <s1>)
    (<s1> ^2 <obja> ^3 <objb> ^1 <set>)
    (<obja> ^y <y2> ^x <x>)
    (<objb> ^x <x> ^y <y1>)
    (<r3> ^result <r*4>)
    (<r*4> ^set <s*6>)
    (<s*6> ^instance <i*3>)
    (<i*3> ^1 <objb>)
    (<r2> ^result <r*3>)
    (<r*3> ^set <s*5>)
    (<s*5> ^instance <i*2>)
    (<i*2> ^1 <obja>)
    (<r> ^result <r*2>)
    (<r*2> ^set <s*4>)
    (<s*4> ^instance <i*1>)
    (<i*1> ^1 <objc>)
   -{ (<objc> ^y { < <y1> <= <y2> <y> } ^y <y>)}
   -{ (<objc> ^y { > <y1> >= <y2> <y> } ^y <y>)}
    (<objc> ^x <x>)
    (<s*2> ^condition <c*1>)
    (<c*1> ^result <r*1>)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <s1>)
    (<s*1> ^operator <sop>)
    (<sop> ^name board-between ^type between-inclusive)
    -->
    (<set> ^object <objc> +)
}

sp {board-between*elaborate*instances*samexy*set
    (state <s> ^name board-between ^a <r> ^operator <op> ^c <r3> ^b <r2>
          ^superstate <s*2> ^superstate <s*1>)
    (<r> ^rtype set ^result <r*2>)
    (<op> ^name complete ^instance <s1>)
    (<s1> ^2 <obja> ^3 <objb> ^1 <set>)
    (<objb> ^predicates <pred2>)
    (<obja> ^predicates <pred1>)
    (<r3> ^result <r*4>)
    (<r*4> ^set <s*6>)
    (<s*6> ^instance <i*3>)
    (<i*3> ^1 <objb>)
    (<r2> ^result <r*3>)
    (<r*3> ^set <s*5>)
    (<s*5> ^instance <i*2>)
    (<i*2> ^1 <obja>)
    (<r*2> ^set <s*4>)
    (<s*4> ^instance <i*1>)
    (<i*1> ^1 <v*1>)
    (<s*2> ^condition <c*1>)
    (<c*1> ^result <r*1>)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <s1>)
    (<s*1> ^operator <sop>)
    (<sop> ^name board-between ^type between)
    (<pred2> ^{ << x y >> <xy> } <x> ^{ << x y >> <> <xy> <yx> } <y1>)
    (<pred1> ^<xy> <x> ^<yx> <y2>)
    (<v*1> ^<nobj> <objc>)
    (<objc> ^predicates <pred3>)
   -{ (<pred3> ^<yx> { < <y1> <= <y2> <y> } ^<yx> <y>)}
   -{ (<pred3> ^<yx> { > <y1> >= <y2> <y> } ^<yx> <y>)}
    (<pred3> ^<xy> <x>)
    -->
    (<set> ^object <objc> +)
}

sp {game-search*elaborate*diff-table
    (state <s> ^name game-search)
    -->
    (<s> ^diff-table <dtt> + ^integer-list <il> +)
    (<il> ^number 0 + ^number 1 + ^number 2 + ^number 3 + ^number 4 +
           ^number 5 + ^number 6 + ^number 7 + ^number 8 + ^number 9 +)
    (<dtt> ^diff <d1> + ^diff <d2> + ^diff <d3> +)
    (<d1> ^pair <p> + ^pair <p1> + ^pair <p2> + ^pair <p3> + ^pair <p4> +
           ^result 1 +)
    (<p> ^num 1 + ^num 2 +)
    (<p1> ^num 3 + ^num 2 +)
    (<p2> ^num 4 + ^num 3 +)
    (<p3> ^num 1 + ^num 0 +)
    (<p4> ^num 5 + ^num 4 +)
    (<d2> ^pair <pa> + ^pair <pa2> + ^pair <p21> + ^pair <p22> + ^result 2 +)
    (<pa> ^num 1 + ^num 3 +)
    (<pa2> ^num 0 + ^num 2 +)
    (<p21> ^num 4 + ^num 2 +)
    (<p22> ^num 5 + ^num 3 +)
    (<d3> ^pair <pab> + ^pair <pab2> + ^pair <pb21> + ^pair <pb22> +
           ^result 3 +)
    (<pab> ^num 1 + ^num 4 +)
    (<pab2> ^num 0 + ^num 3 +)
    (<pb21> ^num 2 + ^num 5 +)
    (<pb22> ^num 3 + ^num 6 +)
}

sp {learn-predicate*elaborate*diff-table
    (state <s> ^name learn-predicate)
    -->
    (<s> ^diff-table <dtt> + ^integer-list <il> +)
    (<il> ^number 0 + ^number 1 + ^number 2 + ^number 3 + ^number 4 +
           ^number 5 + ^number 6 + ^number 7 + ^number 8 + ^number 9 +)
    (<dtt> ^diff <d1> + ^diff <d2> + ^diff <d3> +)
    (<d1> ^pair <p> + ^pair <p1> + ^pair <p2> + ^pair <p3> + ^pair <p4> +
           ^result 1 +)
    (<p> ^num 1 + ^num 2 +)
    (<p1> ^num 3 + ^num 2 +)
    (<p2> ^num 4 + ^num 3 +)
    (<p3> ^num 1 + ^num 0 +)
    (<p4> ^num 5 + ^num 4 +)
    (<d2> ^pair <pa> + ^pair <pa2> + ^pair <p21> + ^pair <p22> + ^result 2 +)
    (<pa> ^num 1 + ^num 3 +)
    (<pa2> ^num 0 + ^num 2 +)
    (<p21> ^num 4 + ^num 2 +)
    (<p22> ^num 5 + ^num 3 +)
    (<d3> ^pair <pab> + ^pair <pab2> + ^pair <pb21> + ^pair <pb22> +
           ^result 3 +)
    (<pab> ^num 1 + ^num 4 +)
    (<pab2> ^num 0 + ^num 3 +)
    (<pb21> ^num 2 + ^num 5 +)
    (<pb22> ^num 3 + ^num 6 +)
}

sp {board-between*elaborate*instances*samex
    (state <s> ^name board-between ^a <r> ^operator <op> ^c <r3> ^b <r2>
          ^superstate <s*2> ^superstate <s*1>)
    (<r> ^rtype single ^result <r*2>)
    (<op> ^name complete ^instance <s1>)
    (<s1> ^2 <obja> ^3 <objb> ^1 <set>)
    (<objb> ^predicates <pred2>)
    (<pred2> ^y <x> ^x <y1>)
    (<obja> ^predicates <pred1>)
    (<pred1> ^y <x> ^x <y2>)
    (<r3> ^result <r*4>)
    (<r*4> ^set <s*6>)
    (<s*6> ^instance <i*3>)
    (<i*3> ^1 <objb>)
    (<r2> ^result <r*3>)
    (<r*3> ^set <s*5>)
    (<s*5> ^instance <i*2>)
    (<i*2> ^1 <obja>)
    (<r*2> ^set <s*4>)
    (<s*4> ^instance <i*1>)
    (<i*1> ^1 <objc>)
    (<objc> ^predicates <pred3>)
   -{ (<pred3> ^x { <= <y1> <= <y2> <y> } ^x <y>)}
   -{ (<pred3> ^x { >= <y1> >= <y2> <y> } ^x <y>)}
    (<pred3> ^y <x>)
    (<s*2> ^condition <c*1>)
    (<c*1> ^result <r*1>)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <s1>)
    (<s*1> ^operator <sop>)
    (<sop> ^name board-between ^type between)
    -->
    (<set> ^object <objc> +)
}

sp {board-between*elaborate*instances*samey
    (state <s> ^name board-between ^a <r> ^operator <op> ^c <r3> ^b <r2>
          ^superstate <s*2> ^superstate <s*1>)
    (<r> ^rtype single ^result <r*2>)
    (<op> ^name complete ^instance <s1>)
    (<s1> ^2 <obja> ^3 <objb> ^1 <set>)
    (<objb> ^predicates <pred2>)
    (<pred2> ^y <y1> ^x <x>)
    (<obja> ^predicates <pred1>)
    (<pred1> ^x <x> ^y <y2>)
    (<r3> ^result <r*4>)
    (<r*4> ^set <s*6>)
    (<s*6> ^instance <i*3>)
    (<i*3> ^1 <objb>)
    (<r2> ^result <r*3>)
    (<r*3> ^set <s*5>)
    (<s*5> ^instance <i*2>)
    (<i*2> ^1 <obja>)
    (<r*2> ^set <s*4>)
    (<s*4> ^instance <i*1>)
    (<i*1> ^1 <objc>)
    (<objc> ^predicates <pred3>)
   -{ (<pred3> ^y { <= <y1> <= <y2> <y> } ^y <y>)}
   -{ (<pred3> ^y { >= <y1> >= <y2> <y> } ^y <y>)}
    (<pred3> ^x <x>)
    (<s*2> ^condition <c*1>)
    (<c*1> ^result <r*1>)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <s1>)
    (<s*1> ^operator <sop>)
    (<sop> ^name board-between ^type between)
    -->
    (<set> ^object <objc> +)
}

sp {board-between*elaborate*instances*straight*single
    :o-support
    (state <s> ^name board-between ^a <r> ^linkstate <ls> ^c <r3> ^b <r2>
          ^superstate <s*3> ^superstate <s*2> ^superstate <s*1>)
    (<r> ^rtype single ^result <r*2>)
    (<ls> ^diff-table <dt>)
    (<dt> ^diff <d3> ^diff <d1>)
    (<d3> ^result 2 ^pair <p3>)
    (<d1> ^result 1 ^pair <p2> ^pair <p1>)
    (<p3> ^num <y3> ^num { <> <y3> <y2> })
    (<p2> ^num <y3> ^num { <> <y2> <> <y3> <y1> })
    (<p1> ^num <y2> ^num <y1>)
    (<r3> ^result <r*4>)
    (<r*4> ^set <s*6>)
    (<s*6> ^instance <i*3>)
    (<i*3> ^1 <objb>)
    (<objb> ^predicates <pred2>)
    (<r2> ^result <r*3>)
    (<r*3> ^set <s*5>)
    (<s*5> ^instance <i*2>)
    (<i*2> ^1 <obja>)
    (<obja> ^predicates <pred1>)
    (<pred2> ^{ << x y >> <yx> } <y3> ^<xy> <x1>)
    (<pred1> ^<yx> <y2> ^<xy> <x1>)
    (<r*2> ^set <s*4>)
    (<s*4> ^instance <i*1>)
    (<i*1> ^1 <objc>)
    (<objc> ^predicates <pred3>)
    (<pred3> ^<yx> <y1> ^{ << x y >> <> <yx> <xy> } <x1>)
    (<s*3> ^condition <c*2>)
    (<c*2> ^result <r*1>)
    (<r*1> ^set <rset>)
    (<s*2> ^condition <c*1>)
    (<c*1> ^rtype single)
    (<s*1> ^operator <sop>)
    (<sop> ^name board-between ^type between)
    -->
    (<rset> ^instance <s1> +)
    (<s1> ^2 <obja> + ^3 <objb> + ^1 <objc> +)
}

sp {board-between*elaborate*instances*diagonal*single
    :o-support
    (state <s> ^name board-between ^a <r> ^linkstate <ls> ^c <r3> ^b <r2>
          ^superstate <s*3> ^superstate <s*2> ^superstate <s*1>)
    (<r> ^rtype single ^result <r*2>)
    (<ls> ^diff-table <dt>)
    (<dt> ^diff <d2> ^diff <d1>)
    (<d2> ^result 2 ^pair <p6> ^pair <p5>)
    (<d1> ^result 1 ^pair <p4> ^pair <p3> ^pair <p2> ^pair <p1>)
    (<p6> ^num <y3> ^num { <> <y3> <y2> })
    (<p4> ^num <y3> ^num { <> <y2> <> <y3> <y1> })
    (<p5> ^num <x3> ^num { <> <x3> <x2> })
    (<p3> ^num <x3> ^num { <> <x2> <> <x3> <x1> })
    (<p2> ^num <y2> ^num <y1>)
    (<p1> ^num <x2> ^num <x1>)
    (<r3> ^result <r*4>)
    (<r*4> ^set <s*6>)
    (<s*6> ^instance <i*3>)
    (<i*3> ^1 <objb>)
    (<objb> ^predicates <pred2>)
    (<pred2> ^y <y3> ^x <x3>)
    (<r2> ^result <r*3>)
    (<r*3> ^set <s*5>)
    (<s*5> ^instance <i*2>)
    (<i*2> ^1 <obja>)
    (<obja> ^predicates <pred1>)
    (<pred1> ^y <y2> ^x <x2>)
    (<r*2> ^set <s*4>)
    (<s*4> ^instance <i*1>)
    (<i*1> ^1 <objc>)
    (<objc> ^predicates <pred3>)
    (<pred3> ^y <y1> ^x <x1>)
    (<s*3> ^condition <c*2>)
    (<c*2> ^result <r*1>)
    (<r*1> ^set <rset>)
    (<s*2> ^condition <c*1>)
    (<c*1> ^rtype single)
    (<s*1> ^operator <sop>)
    (<sop> ^name board-between ^type between)
    -->
    (<rset> ^instance <s1> +)
    (<s1> ^2 <obja> + ^3 <objb> + ^1 <objc> +)
}

sp {numeric-between*elaborate*instances*diagonal*single
    :o-support
    (state <s> ^name numeric-between ^linkstate <ls> ^c <r3> ^b <r2>
          ^superstate <s*3> ^superstate <s*2> ^superstate <s*1>)
    (<ls> ^integer-list <dt>)
    (<dt> ^number <n3>)
    (<r3> ^result <r*3>)
    (<r*3> ^set <s*5>)
    (<s*5> ^instance <i*2>)
    (<i*2> ^1 { >= <n3> <objb> })
    (<r2> ^result <r*2>)
    (<r*2> ^set <s*4>)
    (<s*4> ^instance <i*1>)
    (<i*1> ^1 { < <n3> <obja> })
    (<s*3> ^condition <c*2>)
    (<c*2> ^result <r*1>)
    (<r*1> ^set <rset>)
    (<s*2> ^condition <c*1>)
    (<c*1> ^rtype single)
    (<s*1> ^operator <sop>)
    (<sop> ^name numeric-between ^type between)
    -->
    (<rset> ^instance <s1> +)
    (<s1> ^2 <obja> + ^3 <objb> + ^1 <n3> +)
}

sp {board-between*elaborate*object*instance
    (state <s> ^name board-between ^operator <op> ^instance <s1>
          ^superstate <s*3> ^superstate <s*2> ^superstate <s*1>)
    (<op> ^name complete ^instance <s1>)
    (<s*3> ^condition <c*2>)
    (<c*2> ^result <r*1>)
    (<r*1> ^set <res>)
    (<s*2> ^condition <c*1>)
    (<c*1> ^rtype set)
    (<s*1> ^operator <o*1>)
    (<o*1> ^name board-between)
    -->
    (<res> ^instance <s1> +)
}

sp {board-between*elaborate*objects
    (state <s> ^name board-between ^c <r2> ^b <r> ^superstate <s*2>
          ^superstate <s*1>)
    (<r2> ^result <r*2>)
    (<r*2> ^set <s*4>)
    (<s*4> ^instance <i*2>)
    (<i*2> ^1 <objb>)
    (<r> ^result <r*1>)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 { <> <objb> <obja> })
    (<s*2> ^condition <c*1>)
    (<c*1> ^rtype set)
    (<s*1> ^operator <o*1>)
    (<o*1> ^name board-between)
    -->
    (<s> ^instance <s1> +)
    (<s1> ^2 <obja> + ^3 <objb> + ^1 <set> +)
}

sp {numeric-between*propose*elaborate*args
    (state <s> ^name numeric-between ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^name numeric-between ^args <args> ^parameter <p>)
    (<args> ^2 <a2> ^3 <a3>)
    -->
    (<s> ^parameter <p> + ^b <a2> + ^c <a3> +)
}

sp {board-between*propose*elaborate*args
    (state <s> ^name board-between ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^name board-between ^args <args> ^parameter <p>)
    (<args> ^num 3 ^2 <a2> ^3 <a3> ^1 <a1>)
    -->
    (<s> ^parameter <p> + ^a <a1> + ^b <a2> + ^c <a3> +)
}

sp {soar-compare*less*param-2
    (state <s> ^name soar-less ^superstate <s*2> ^superstate <s*1>)
    (<s*2> ^operator <o>)
    (<o> ^name soar-less ^args <args> ^parameter <p*1>)
    (<args> ^num 2 ^2 <a2> ^1 <a1>)
    (<p*1> ^num 2)
    (<a2> ^result <r*3>)
    (<r*3> ^set <s*4>)
    (<s*4> ^instance <i*2>)
    (<i*2> ^1 <value1>)
    (<a1> ^result <r*2>)
    (<r*2> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 { < <value1> <value> })
    (<s*1> ^condition <c*1>)
    (<c*1> ^result <r*1>)
    (<r*1> ^set <res>)
    -->
    (<res> ^instance <instance> +)
    (<instance> ^1 <value> + ^2 <value1> +)
}

sp {soar-compare*less
    (state <s> ^name soar-less ^superstate <s*2> ^superstate <s*1>)
    (<s*2> ^operator <o>)
    (<o> ^name soar-less ^args <args> ^parameter <p*1>)
    (<args> ^num 2 ^2 <a2> ^1 <a1>)
    (<p*1> ^num 1)
    (<a2> ^result <r*3>)
    (<r*3> ^set <s*4>)
    (<s*4> ^instance <i*2>)
    (<i*2> ^1 <value1>)
    (<a1> ^result <r*2>)
    (<r*2> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 { < <value1> <value> })
    (<s*1> ^condition <c*1>)
    (<c*1> ^result <r*1>)
    (<r*1> ^set <res>)
    -->
    (<res> ^instance <in1> +)
    (<in1> ^1 <value> +)
}

sp {soar-compare*greater-equal*param-2
    (state <s> ^name soar-greater-equal ^superstate <s*2> ^superstate <s*1>)
    (<s*2> ^operator <o>)
    (<o> ^name soar-greater-equal ^args <args> ^parameter <p*1>)
    (<args> ^num 2 ^2 <a2> ^1 <a1>)
    (<p*1> ^num 2)
    (<a2> ^result <r*3>)
    (<r*3> ^set <s*4>)
    (<s*4> ^instance <i*2>)
    (<i*2> ^1 <value1>)
    (<a1> ^result <r*2>)
    (<r*2> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 { >= <value1> <value> })
    (<s*1> ^condition <c*1>)
    (<c*1> ^result <r*1>)
    (<r*1> ^set <res>)
    -->
    (<res> ^instance <instance> +)
    (<instance> ^1 <value> + ^2 <value1> +)
}

sp {soar-compare*greater*param-2
    (state <s> ^name soar-greater ^superstate <s*2> ^superstate <s*1>)
    (<s*2> ^operator <o>)
    (<o> ^name soar-greater ^args <args> ^parameter <p*1>)
    (<args> ^num 2 ^2 <a2> ^1 <a1>)
    (<p*1> ^num 2)
    (<a2> ^result <r*3>)
    (<r*3> ^set <s*4>)
    (<s*4> ^instance <i*2>)
    (<i*2> ^1 <value1>)
    (<a1> ^result <r*2>)
    (<r*2> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 { > <value1> <value> })
    (<s*1> ^condition <c*1>)
    (<c*1> ^result <r*1>)
    (<r*1> ^set <res>)
    -->
    (<res> ^instance <instance> +)
    (<instance> ^1 <value> + ^2 <value1> +)
}

sp {soar-compare*greater-equal
    (state <s> ^name soar-greater-equal ^superstate <s*2> ^superstate <s*1>)
    (<s*2> ^operator <o>)
    (<o> ^name soar-greater-equal ^args <args> ^parameter <p*1>)
    (<args> ^num 2 ^2 <a2> ^1 <a1>)
    (<p*1> ^num 1)
    (<a2> ^result <r*3>)
    (<r*3> ^set <s*4>)
    (<s*4> ^instance <i*2>)
    (<i*2> ^1 <value1>)
    (<a1> ^result <r*2>)
    (<r*2> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 { >= <value1> <value> })
    (<s*1> ^condition <c*1>)
    (<c*1> ^result <r*1>)
    (<r*1> ^set <res>)
    -->
    (<res> ^instance <in1> +)
    (<in1> ^1 <value> +)
}

sp {soar-compare*greater
    (state <s> ^name soar-greater ^superstate <s*2> ^superstate <s*1>)
    (<s*2> ^operator <o>)
    (<o> ^name soar-greater ^args <args> ^parameter <p*1>)
    (<args> ^num 2 ^2 <a2> ^1 <a1>)
    (<p*1> ^num 1)
    (<a2> ^result <r*3>)
    (<r*3> ^set <s*4>)
    (<s*4> ^instance <i*2>)
    (<i*2> ^1 <value1>)
    (<a1> ^result <r*2>)
    (<r*2> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 { > <value1> <value> })
    (<s*1> ^condition <c*1>)
    (<c*1> ^result <r*1>)
    (<r*1> ^set <res>)
    -->
    (<res> ^instance <in1> +)
    (<in1> ^1 <value> +)
}

sp {soar-count*elaborate*rhs*1param*signle
    (state <s> ^name soar-count ^linkstate <ls> ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^name soar-count ^args <args> ^parameter <p*1>)
    (<args> ^num 1 ^2 <a1>)
    (<a1> ^rtype single ^result <r>)
    (<p*1> ^num { < 2 <n*1> })
    (<r> ^set <set>)
   -{ (<set> -^<something> <s*2>)
      (state <ls> ^<a*1> <v*1>)}
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 (size <set>) +)
}

sp {soar-count*elaborate*rhs*1param
    (state <s> ^name soar-count ^linkstate <ls> ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^name soar-count ^args <args> ^parameter <p*1>)
    (<args> ^num 1 ^2 <a1>)
    (<a1> ^rtype set ^result <r>)
    (<p*1> ^num { < 2 <n*1> })
    (<r> ^set <s*2>)
    (<s*2> ^instance <i*1>)
    (<i*1> ^1 <set>)
   -{ (<set> -^<something> <s*3>)
      (state <ls> ^<a*1> <v*1>)}
    -->
    (<s> ^instance <p> +)
    (<p> ^1 (size <set>) +)
}

sp {soar-count*elaborate*rhs*2params*single
    (state <s> ^name soar-count ^linkstate <ls> ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^name soar-count ^args <args> ^parameter <p*1>)
    (<args> ^num 1 ^2 <a1>)
    (<p*1> ^num 2)
    (<a1> ^rtype single ^result <r>)
    (<r> ^set <set>)
   -{ (<set> -^<something> <s*2>)
      (state <ls> ^<a*1> <v*1>)}
    -->
    (<s> ^instance <p> +)
    (<p> ^2 <set> + ^1 (size <set>) +)
}

sp {soar-count*elaborate*rhs*2params
    (state <s> ^name soar-count ^linkstate <ls> ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^name soar-count ^args <args> ^parameter <p*1>)
    (<args> ^num 1 ^2 <a1>)
    (<p*1> ^num 2)
    (<a1> ^rtype set ^result <r>)
    (<r> ^set <s*2>)
    (<s*2> ^instance <i*1>)
    (<i*1> ^1 <set>)
   -{ (<set> -^<something> <s*3>)
      (state <ls> ^<a*1> <v*1>)}
    -->
    (<s> ^instance <p> +)
    (<p> ^2 <set> + ^1 (size <set>) +)
}

sp {soar-count*apply*complete
    (state <s> ^name soar-count ^operator <op> ^instance <s1>
          ^superstate <s*1>)
    (<op> ^name complete ^instance <s1>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^result <r*1>)
    (<r*1> ^set <res>)
    -->
    (<res> ^instance <s1> +)
}

sp {soar-count*propose*complete
    (state <s> ^name soar-count ^instance <instance>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name complete + ^instance <instance> +)
}

sp {soar-sum*numeric-evaluate*value*instance
    (state <s> ^name soar-sum ^linkstate <ls> ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^name soar-sum ^args <args> ^parameter <p*1>)
    (<args> ^num 1 ^2 <a1>)
    (<p*1> ^num 2)
    (<a1> ^result <r*1>)
    (<r*1> ^set <s*2>)
    (<s*2> ^instance <i*1>)
    (<i*1> ^1 <obja>)
   -{ (<obja> -^<something> <s*3>)
      (state <ls> ^<a*1> <v*1>)}
    -->
    (<s> ^instance <instance> +)
    (<instance> ^2 <obja> + ^1 (sum <obja>) +)
}

sp {soar-sum*numeric-evaluate*value
    (state <s> ^name soar-sum ^linkstate <ls> ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^args <args> ^parameter <p*1>)
    (<args> ^num 1 ^2 <a1>)
    (<p*1> ^num { < 2 <n*1> })
    (<a1> ^result <r*1>)
    (<r*1> ^set <s*2>)
    (<s*2> ^instance <i*1>)
    (<i*1> ^1 <set>)
   -{ (<set> -^<something> <s*3>)
      (state <ls> ^<a*1> <v*1>)}
    -->
    (<s> ^instance <p> +)
    (<p> ^1 (sum <set>) +)
}

sp {soar-sum*apply*complete
    (state <s> ^name soar-sum ^operator <op> ^instance <s1> ^superstate <s*1>)
    (<op> ^name complete ^instance <s1>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^result <r*1>)
    (<r*1> ^set <res>)
    -->
    (<res> ^instance <s1> +)
}

sp {soar-sum*propose*complete
    (state <s> ^name soar-sum ^instance <instance>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name complete + ^instance <instance> +)
}

sp {soar-max*numeric-evaluate*set
    (state <s> ^name soar-max ^superstate <s*2> ^superstate <s*1>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^result <r*1>)
    (<r*1> ^set <res>)
    (<s*2> ^operator <o>)
    (<o> ^args <args> ^parameter <p*1>)
    (<args> ^num 1 ^2 <a1>)
    (<p*1> ^num 1)
    (<a1> ^rtype set ^result <r*2>)
    (<r*2> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 <rsp>)
    (<rsp> ^<something> <value> -^<something> { > <value> <value2> })
    -->
    (<res> ^instance <i> +)
    (<i> ^1 <value> +)
}

sp {soar-max*numeric-evaluate*single
    (state <s> ^name soar-max ^superstate <s*2> ^superstate <s*1>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^result <r*1>)
    (<r*1> ^set <res>)
    (<s*2> ^operator <o>)
    (<o> ^args <args> ^parameter <p*1>)
    (<args> ^num 1 ^2 <a1>)
    (<p*1> ^num 1)
    (<a1> -^rtype set ^result <r*2>)
    (<r*2> ^set <rsp>)
    (<rsp> ^instance <i*1>)
    (<i*1> ^1 <value>)
   -{ (<rsp> ^instance <i*2>)
      (<i*2> ^1 { > <value> <value2> })}
    -->
    (<res> ^instance <i> +)
    (<i> ^1 <value> +)
}

sp {has-attribute*apply*complete*instance
    (state <s> ^name has-attribute ^operator <op> ^superstate <s*1>)
    (<op> ^name complete ^instance <o>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^result <r*1>)
    (<r*1> ^set <res>)
    -->
    (<res> ^instance <o> +)
}

sp {has-attribute*propose*complete
    (state <s> ^name has-attribute ^instance <e>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name complete + ^instance <e> +)
}

sp {has-attribute*elaborate*results*instance*negative
    (state <s> ^name has-attribute ^superstate <s*2> ^superstate <s*1>)
    (<s*2> ^operator <o>)
    (<o> ^negative true ^args <args> ^parameter <p> ^type <name>)
    (<args> ^1 <a1>)
    (<a1> -^rtype set ^result <r*1>)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 <obja>)
    (<obja> ^predicates <pred>)
    (<pred> -^<name> <n*1>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype single)
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <obja> +)
}

sp {has-attribute*elaborate*results*instance*positive
    (state <s> ^name has-attribute ^superstate <s*2> ^superstate <s*1>)
    (<s*2> ^operator <o>)
    (<o> ^negative false ^args <args> ^parameter <p> ^type <name>)
    (<args> ^1 <a1>)
    (<a1> -^rtype set ^result <r*1>)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 <obja>)
    (<obja> ^predicates <pred>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype single)
    (<pred> ^<name> <n*1>)
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <obja> +)
}

sp {top-pair*with-type*2param*no-set*negative
    (state <s> ^name top-pair ^linkstate <ls> ^superstate <s*2>
          ^superstate <s*1>)
    (<ls> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <pa>)
    (<pa> ^handle <c3>)
    (<s*2> ^operator <o>)
    (<o> ^negative true ^type <c3> ^args <args> ^parameter <p*2>)
    (<args> ^num 2 ^2 <a2> ^1 <a1>)
    (<p*2> ^num 2)
    (<a2> -^rtype set ^result <r*2>)
    (<a1> -^rtype set ^result <r*1>)
    (<r*2> ^set <s*4>)
    (<s*4> ^instance <i*2>)
    (<i*2> ^1 <objb>)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 { <> <objb> <obja> })
   -{ (<pa> ^instance <instance1>)
      (<instance1> ^2 <objb> ^1 <obja>)}
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype single)
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <obja> + ^2 <objb> +)
}

sp {top-pair*with-type*1param*no-set*negative
    (state <s> ^name top-pair ^linkstate <ls> ^superstate <s*2>
          ^superstate <s*1>)
    (<ls> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <pa>)
    (<pa> ^handle <c3>)
    (<s*2> ^operator <o>)
    (<o> ^negative true ^type <c3> ^args <args> ^parameter <p*2>)
    (<args> ^num 2 ^1 <a1> ^2 <a2>)
    (<a1> -^rtype set ^result <r*1>)
    (<p*2> ^num { < 2 <n*1> })
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 <obja>)
   -{ (<pa> ^instance <instance>)
      (<instance> ^1 <obja> ^2 <objb>)
      (<a2> ^result <r*2>)
      (<r*2> ^set <s*4>)
      (<s*4> ^instance <i*2>)
      (<i*2> ^1 <objb>)}
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype single)
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <obja> +)
}

sp {top-pair*with-type*3param*no-set
    (state <s> ^name top-pair ^linkstate <ls> ^superstate <s*2>
          ^superstate <s*1>)
    (<ls> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <pa>)
    (<pa> ^instance <instance1> ^handle <c3>)
    (<instance1> ^2 <objb> ^3 <objc> ^1 <obja>)
    (<s*2> ^operator <o>)
    (<o> ^negative false ^type <c3> ^args <args> ^parameter <p*2>)
    (<args> ^num 3 ^2 <a2> ^3 <a3> ^1 <a1>)
    (<p*2> ^num 3)
    (<a2> -^rtype set ^result <r*2>)
    (<a3> -^rtype set ^result <r*3>)
    (<a1> -^rtype set ^result <r*1>)
    (<r*3> ^set <s*5>)
    (<s*5> ^instance <i*3>)
    (<i*3> ^1 <objc>)
    (<r*2> ^set <s*4>)
    (<s*4> ^instance <i*2>)
    (<i*2> ^1 <objb>)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 <obja>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype single)
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <obja> + ^2 <objb> + ^3 <objc> +)
}

sp {top-pair*with-type*2param*no-set
    (state <s> ^name top-pair ^linkstate <ls> ^superstate <s*2>
          ^superstate <s*1>)
    (<ls> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <pa>)
    (<pa> ^instance <instance1> ^handle <c3>)
    (<instance1> ^2 <objb> ^1 <obja>)
    (<s*2> ^operator <o>)
    (<o> ^negative false ^type <c3> ^args <args> ^parameter <p*2>)
    (<args> ^num 2 ^2 <a2> ^1 <a1>)
    (<p*2> ^num 2)
    (<a2> -^rtype set ^result <r*2>)
    (<a1> -^rtype set ^result <r*1>)
    (<r*2> ^set <s*4>)
    (<s*4> ^instance <i*2>)
    (<i*2> ^1 <objb>)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 <obja>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype single)
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <obja> + ^2 <objb> +)
}

sp {top-pair*with-type*1param*no-set
    (state <s> ^name top-pair ^linkstate <ls> ^superstate <s*2>
          ^superstate <s*1>)
    (<ls> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <pa>)
    (<pa> ^instance <instance1> ^handle <c3>)
    (<instance1> ^2 <objb> ^1 <obja>)
    (<s*2> ^operator <o>)
    (<o> ^negative false ^type <c3> ^args <args> ^parameter <p*2>)
    (<args> ^num 2 ^2 <a2> ^1 <a1>)
    (<a2> -^rtype set ^result <r*2>)
    (<a1> -^rtype set ^result <r*1>)
    (<p*2> ^num { < 2 <n*1> })
    (<r*2> ^set <s*4>)
    (<s*4> ^instance <i*2>)
    (<i*2> ^1 <objb>)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 <obja>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype single)
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <obja> +)
}

sp {top-pair*with-type*1param*set*noarg-set1*apply*noparam
    (state <s> ^name top-pair ^operator <op> ^linkstate <ls> ^superstate <s*4>
          ^superstate <s*2> ^superstate <s*1>)
    (<op> ^name complete)
    (<ls> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <pa>)
    (<pa> ^instance <instance1> ^handle <c3>)
    (<instance1> ^2 <objb> ^1 <obja>)
    (<s*4> ^operator <o>)
    (<o> ^negative false ^type <c3> ^args <args> ^parameter <p*2>)
    (<args> ^num 2 ^2 <a2> ^1 <a1>)
    (<a2> -^rtype set ^result <r*3>)
    (<a1> -^rtype set ^result <r*2>)
    (<p*2> ^num { < 2 <n*1> })
    (<r*3> ^set <s*6>)
    (<s*6> ^instance <i*2>)
    (<i*2> ^1 <objb>)
    (<r*2> ^set <s*5>)
    (<s*5> ^instance <i*1>)
    (<i*1> ^1 <obja>)
    (<s*2> ^condition <c*2>)
    (<c*2> ^result <r*1>)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <res>)
    (<res> ^1 <set>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype set)
    -->
    (<set> ^object <obja> +)
}

sp {top-pair*with-type*1param*set*noarg-set1*apply
    (state <s> ^name top-pair ^operator <op> ^linkstate <ls> ^superstate <s*4>
          ^superstate <s*2> ^superstate <s*1>)
    (<op> ^name complete)
    (<ls> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <pa>)
    (<pa> ^instance <instance1> ^handle <c3>)
    (<instance1> ^2 <objb> ^1 <obja>)
    (<s*4> ^operator <o>)
    (<o> ^negative false ^type <c3> ^args <args> ^parameter <p*2>)
    (<args> ^num 2 ^2 <a2> ^1 <a1>)
    (<p*2> ^num 2)
    (<a2> -^rtype set ^result <r*3>)
    (<a1> -^rtype set ^result <r*2>)
    (<r*3> ^set <s*6>)
    (<s*6> ^instance <i*2>)
    (<i*2> ^1 <objb>)
    (<r*2> ^set <s*5>)
    (<s*5> ^instance <i*1>)
    (<i*1> ^1 <obja>)
    (<s*2> ^condition <c*2>)
    (<c*2> ^result <r*1>)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <res>)
    (<res> ^2 <objb> ^1 <set>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype set)
    -->
    (<set> ^object <obja> +)
}

sp {top-pair*with-type*1param*set*noarg-set*noparam
    (state <s> ^name top-pair ^superstate <s*2> ^superstate <s*1>)
    (<s*2> ^operator <o>)
    (<o> ^negative false ^args <args> ^parameter <p*1>)
    (<args> ^num 2 ^2 <a2> ^1 <a1>)
    (<a2> -^rtype set)
    (<a1> -^rtype set)
    (<p*1> ^num { < 2 <n*1> })
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype set)
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <set> +)
}

sp {top-pair*with-type*1param*set*noarg-set
    (state <s> ^name top-pair ^superstate <s*2> ^superstate <s*1>)
    (<s*2> ^operator <o>)
    (<o> ^negative false ^args <args> ^parameter <p*1>)
    (<args> ^num 2 ^2 <a2> ^1 <a1>)
    (<p*1> ^num 2)
    (<a2> -^rtype set ^result <r*1>)
    (<a1> -^rtype set)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 <objb>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype set)
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <set> + ^2 <objb> +)
}

sp {top-pair*with-type*1param*set*1arg*apply
    (state <s> ^name top-pair ^linkstate <ls> ^superstate <s*2>
          ^superstate <s*1>)
    (<ls> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <pa>)
    (<pa> ^instance <i1> ^handle <c3>)
    (<i1> ^1 <set>)
   -{ (<set> -^<x1> <x*1>)
      (state <ls> ^<a*1> <v*1>)}
    (<s*2> ^operator <o>)
    (<o> ^negative false ^type <c3> ^args <args> ^parameter <p*2>)
    (<args> ^num 1 ^1 <a1>)
   -{ (<set> ^<elem> <obja>)
     -{ (<a1> ^result <r*1>)
        (<r*1> ^set <s*3>)
        (<s*3> ^instance <i*1>)
        (<i*1> ^1 <obja>)}}
    (<a1> -^rtype set)
    (<p*2> ^num { < 2 <n*1> })
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype set)
    -->
    (<s> ^instance <i6> +)
    (<i6> ^1 <set> +)
}

sp {top-pair*with-type*1param*set*negative
    (state <s> ^name top-pair ^linkstate <ls> ^superstate <s*2>
          ^superstate <s*1>)
    (<ls> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <pa>)
    (<pa> ^handle <c3>)
    (<s*2> ^operator <o>)
    (<o> ^negative true ^type <c3> ^args <args> ^parameter <p*2>)
    (<args> ^num 2 ^2 <a2> ^1 <a1>)
    (<p*2> ^num 1)
    (<a2> -^rtype set)
    (<a1> ^rtype set ^result <r*1>)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 <obja>)
   -{ (<pa> ^instance <instance1>)
      (<instance1> ^2 <objb> ^1 <e>)
      (<a2> ^result <r*2>)
      (<r*2> ^set <s*4>)
      (<s*4> ^instance <i*2>)
      (<i*2> ^1 <objb>)
      (<obja> ^<elem> <e>)}
   -{ (<obja> -^<x1> <x*1>)
      (state <ls> ^<a*1> <v*1>)}
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype set)
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <obja> +)
}

sp {top-pair*with-type*2param*set*set
    (state <s> ^name top-pair ^linkstate <ls> ^superstate <s*2>
          ^superstate <s*1>)
    (<ls> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <pa>)
    (<pa> ^handle <c3>)
    (<s*2> ^operator <o>)
    (<o> ^negative false ^type <c3> ^args <args> ^parameter <p*2>)
    (<args> ^num 2 ^2 <a2> ^1 <a1>)
    (<p*2> ^num 2)
    (<a2> ^rtype set ^result <r*2>)
    (<a1> ^rtype set ^result <r*1>)
    (<r*2> ^set <s*4>)
    (<s*4> ^instance <i*2>)
    (<i*2> ^1 <objb>)
   -{ (<objb> -^<x1> <x*2>)
      (state <ls> ^<a*2> <v*2>)}
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 <obja>)
   -{ (<objb> ^<elem> <e>)
     -{ (<pa> ^instance <instance1>)
        (<instance1> ^2 <e> ^1 <e2>)
        (<obja> ^<elem2> <e2>)}}
   -{ (<obja> ^<elem> <e>)
     -{ (<pa> ^instance <instance1>)
        (<instance1> ^1 <e> ^2 <e2>)
        (<objb> ^<elem2> <e2>)}}
   -{ (<obja> -^<x1> <x*1>)
      (state <ls> ^<a*1> <v*1>)}
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype set)
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <obja> + ^objb <objb> +)
}

sp {top-pair*with-type*1param*set*set
    (state <s> ^name top-pair ^linkstate <ls> ^superstate <s*2>
          ^superstate <s*1>)
    (<ls> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <pa>)
    (<pa> ^handle <c3>)
    (<s*2> ^operator <o>)
    (<o> ^negative false ^type <c3> ^args <args> ^parameter <p*2>)
    (<args> ^num 2 ^2 <a2> ^1 <a1>)
    (<p*2> ^num 1)
    (<a2> ^rtype set)
    (<a1> ^rtype set ^result <r*1>)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 <obja>)
   -{ (<obja> ^<elem> <e>)
     -{ (<pa> ^instance <instance1>)
        (<instance1> ^1 <e> ^2 <objb>)
        (<a2> ^result <r*2>)
        (<r*2> ^set <s*4>)
        (<s*4> ^instance <i*2>)
        (<i*2> ^1 <v*2>)
        (<v*2> ^<elem2> <objb>)}}
   -{ (<obja> -^<x1> <x*1>)
      (state <ls> ^<a*1> <v*1>)}
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype set)
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <obja> +)
}

sp {top-pair*with-type*2param*set*single
    (state <s> ^name top-pair ^linkstate <ls> ^superstate <s*2>
          ^superstate <s*1>)
    (<ls> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <pa>)
    (<pa> ^handle <c3>)
    (<s*2> ^operator <o>)
    (<o> ^negative false ^type <c3> ^args <args> ^parameter <p*2>)
    (<args> ^num 2 ^2 <a2> ^1 <a1>)
    (<p*2> ^num 2)
    (<a2> -^rtype set ^result <r*2>)
    (<a1> ^rtype set ^result <r*1>)
    (<r*2> ^set <s*4>)
    (<s*4> ^instance <i*2>)
    (<i*2> ^1 <objb>)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 <obja>)
   -{ (<obja> ^<elem> <e>)
     -{ (<pa> ^instance <instance1>)
        (<instance1> ^2 <objb> ^1 <e>)}}
   -{ (<obja> -^<x1> <x*1>)
      (state <ls> ^<a*1> <v*1>)}
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype set)
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <obja> + ^2 <objb> +)
}

sp {top-pair*with-type*1param*set
    (state <s> ^name top-pair ^linkstate <ls> ^superstate <s*2>
          ^superstate <s*1>)
    (<ls> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <pa>)
    (<pa> ^handle <c3>)
    (<s*2> ^operator <o>)
    (<o> ^negative false ^type <c3> ^args <args> ^parameter <p*2>)
    (<args> ^num 2 ^2 <a2> ^1 <a1>)
    (<p*2> ^num 1)
    (<a2> -^rtype set)
    (<a1> ^rtype set ^result <r*1>)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 <obja>)
   -{ (<obja> ^<elem> <e>)
     -{ (<pa> ^instance <instance1>)
        (<instance1> ^1 <e> ^2 <objb>)
        (<a2> ^result <r*2>)
        (<r*2> ^set <s*4>)
        (<s*4> ^instance <i*2>)
        (<i*2> ^1 <objb>)}}
   -{ (<obja> -^<x1> <x*1>)
      (state <ls> ^<a*1> <v*1>)}
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype set)
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <obja> +)
}

sp {top-pair*apply*complete
    (state <s> ^name top-pair ^operator <op> ^instance <s1> ^superstate <s*1>)
    (<op> ^name complete ^instance <s1>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^result <r*1>)
    (<r*1> ^set <res>)
    -->
    (<res> ^instance <s1> +)
}

sp {top-pair*propose*complete
    (state <s> ^name top-pair ^instance <instance>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name complete + ^instance <instance> +)
}

sp {top-pair*perference*complete*diff
    (state <s> ^name top-pair ^operator <o1> +)
    (<o1> ^name complete ^instance <instance>)
    -->
    (<s> ^operator <o1> >)
}

sp {with-attribute*apply*complete*instance*objects
    (state <s> ^name with-attribute ^operator <op> ^superstate <s*4>
          ^superstate <s*2> ^superstate <s*1>)
    (<op> ^name complete ^instance <oz>)
    (<oz> ^2 <name1> ^3 <attr1> ^1 <set>)
    (<s*2> ^condition <c*2>)
    (<c*2> ^result <r*1>)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <oz>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype set)
    (<s*4> ^operator <oper>)
    (<oper> ^args <args>)
    (<args> ^1 <a1> ^2 <a3> ^3 <a2>)
    (<a1> -^rtype set ^result <r*2>)
    (<a3> ^result <r*4>)
    (<r*4> ^set <s*7>)
    (<s*7> ^instance <i*3>)
    (<i*3> ^1 <name1>)
    (<a2> ^result <r*3>)
    (<r*3> ^set <s*6>)
    (<s*6> ^instance <i*2>)
    (<i*2> ^1 <attr1>)
    (<r*2> ^set <s*5>)
    (<s*5> ^instance <i*1>)
    (<i*1> ^1 <obja>)
    (<obja> ^predicates <p*1>)
    (<p*1> ^<attr1> <name1>)
    -->
    (<set> ^object <obja> +)
}

sp {with-attribute*apply*complete*instance
    (state <s> ^name with-attribute ^operator <op> ^superstate <s*1>)
    (<op> ^name complete ^instance <o>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^result <r*1>)
    (<r*1> ^set <res>)
    -->
    (<res> ^instance <o> +)
}

sp {with-attribute*propose*complete
    (state <s> ^name with-attribute ^instance <e>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name complete + ^instance <e> +)
}

sp {with-attribute*elaborate*results*2-paramb
    (state <s> ^name with-attribute ^superstate <s*2> ^superstate <s*1>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype single)
    (<s*2> ^operator <o>)
    (<o> ^parameter <pp> ^args <args>)
    (<pp> ^num 2 ^2 <p3>)
    (<args> ^2 <a3> ^3 <a2> ^1 <a1>)
    (<a3> ^result <r*3>)
    (<r*3> ^set <s*5>)
    (<s*5> ^instance <i*3>)
    (<i*3> ^1 <name>)
    (<a2> ^result <r*2>)
    (<r*2> ^set <s*4>)
    (<s*4> ^instance <i*2>)
    (<i*2> ^1 <attr>)
    (<a1> ^result <r*1>)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 <obja>)
    (<obja> ^predicates <p*1>)
    (<p*1> ^<attr> <name>)
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <obja> + ^2 <name> +)
}

sp {with-attribute*elaborate*results*2-parama
    (state <s> ^name with-attribute ^superstate <s*2> ^superstate <s*1>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype single)
    (<s*2> ^operator <o>)
    (<o> ^parameter <pp> ^args <args>)
    (<pp> ^num 2 ^3 <p2>)
    (<args> ^2 <a3> ^3 <a2> ^1 <a1>)
    (<a3> ^result <r*3>)
    (<r*3> ^set <s*5>)
    (<s*5> ^instance <i*3>)
    (<i*3> ^1 <name>)
    (<a2> ^result <r*2>)
    (<r*2> ^set <s*4>)
    (<s*4> ^instance <i*2>)
    (<i*2> ^1 <attr>)
    (<a1> ^result <r*1>)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 <obja>)
    (<obja> ^predicates <p*1>)
    (<p*1> ^<attr> <name>)
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <obja> + ^3 <attr> +)
}

sp {with-attribute*elaborate*results*3-param
    (state <s> ^name with-attribute ^superstate <s*2> ^superstate <s*1>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype single)
    (<s*2> ^operator <o>)
    (<o> ^parameter <pp> ^args <args>)
    (<pp> ^num 3)
    (<args> ^2 <a3> ^3 <a2> ^1 <a1>)
    (<a3> ^result <r*3>)
    (<r*3> ^set <s*5>)
    (<s*5> ^instance <i*3>)
    (<i*3> ^1 <name>)
    (<a2> ^result <r*2>)
    (<r*2> ^set <s*4>)
    (<s*4> ^instance <i*2>)
    (<i*2> ^1 <attr>)
    (<a1> ^result <r*1>)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 <obja>)
    (<obja> ^predicates <p*1>)
    (<p*1> ^<attr> <name>)
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <obja> + ^3 <attr> + ^2 <name> +)
}

sp {with-attribute*elaborate*results*1-param
    (state <s> ^name with-attribute ^superstate <s*2> ^superstate <s*1>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype single)
    (<s*2> ^operator <o>)
    (<o> ^args <args> ^parameter <pp>)
    (<pp> ^num { < 2 <n*1> })
    (<args> ^2 <a3> ^3 <a2> ^1 <a1>)
    (<a3> ^result <r*3>)
    (<r*3> ^set <s*5>)
    (<s*5> ^instance <i*3>)
    (<i*3> ^1 <name>)
    (<a2> ^result <r*2>)
    (<r*2> ^set <s*4>)
    (<s*4> ^instance <i*2>)
    (<i*2> ^1 <attr>)
    (<a1> ^result <r*1>)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 <obja>)
    (<obja> ^predicates <p*1>)
    (<p*1> ^<attr> <name>)
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <obja> +)
}

sp {with-attribute*elaborate*results*0-param
    (state <s> ^name with-attribute ^linkstate <l*1> ^superstate <s*2>
          ^superstate <s*1>)
    (<l*1> ^world <w*1>)
    (<w*1> ^objects <o*1>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype single)
    (<s*2> ^operator <o>)
    (<o> ^args <args>)
    (<args> -^1 <a1> ^2 <a3> ^3 <a2>)
    (<a3> ^result <r*2>)
    (<r*2> ^set <s*4>)
    (<s*4> ^instance <i*2>)
    (<i*2> ^1 <name>)
    (<a2> ^result <r*1>)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 <attr>)
    (<o*1> ^object <obja>)
    (<obja> ^predicates <p*1>)
    (<p*1> ^<attr> <name>)
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <obja> +)
}

sp {with-attribute*elaborate*results*0-param*primitive
    (state <s> ^name with-attribute ^linkstate <l*1> ^superstate <s*2>
          ^superstate <s*1>)
    (<l*1> ^world <w*1>)
    (<w*1> ^objects <o*1>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype single)
    (<s*2> ^operator <o>)
    (<o> ^args <args>)
    (<args> -^2 <v*1> -^1 <a1>)
    (<o*1> ^object <obja>)
    (<obja> -^handle self)
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <obja> +)
}

sp {with-attribute*apply*complete*instance*objects*set-set
    (state <s> ^name with-attribute ^operator <op> ^superstate <s*4>
          ^superstate <s*2> ^superstate <s*1>)
    (<op> ^name complete ^instance <oz>)
    (<oz> ^2 <name1> ^3 <attr1> ^1 <set>)
    (<s*2> ^condition <c*2>)
    (<c*2> ^result <r*1>)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <oz>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype set)
    (<s*4> ^operator <oper>)
    (<oper> ^args <args>)
    (<args> ^1 <a1> ^2 <a3> ^3 <a2>)
    (<a1> ^rtype set ^parameter <p*1> ^result <r*2>)
    (<p*1> ^num 0)
    (<a3> ^result <r*4>)
    (<r*4> ^set <s*7>)
    (<s*7> ^instance <i*3>)
    (<i*3> ^1 <name1>)
    (<a2> ^result <r*3>)
    (<r*3> ^set <s*6>)
    (<s*6> ^instance <i*2>)
    (<i*2> ^1 <attr1>)
    (<r*2> ^set <s*5>)
    (<s*5> ^instance <i*1>)
    (<i*1> ^1 <v*1>)
    (<v*1> ^object <obja>)
    (<obja> ^predicates <p*2>)
    (<p*2> ^<attr1> <name1>)
    -->
    (<set> ^object <obja> +)
}

sp {with-attribute*elaborate*results*set*instance*sets*no-param
    (state <s> ^name with-attribute ^superstate <s*2> ^superstate <s*1>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype set)
    (<s*2> ^operator <o>)
    (<o> ^args <args> ^parameter <p>)
    (<args> ^1 <a1> ^2 <a3> ^3 <a2>)
    (<a1> ^rtype set ^parameter <p*1>)
    (<p*1> ^num 0)
    (<a3> ^result <r*2>)
    (<r*2> ^set <s*4>)
    (<s*4> ^instance <i*2>)
    (<i*2> ^1 <name>)
    (<a2> ^result <r*1>)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 <attr>)
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <set> + ^3 <attr> + ^2 <name> +)
}

sp {with-attribute*elaborate*results*set*instance*sets
    (state <s> ^name with-attribute ^superstate <s*2> ^superstate <s*1>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype set)
    (<s*2> ^operator <o>)
    (<o> ^args <args> ^parameter <p>)
    (<args> ^1 <a1> ^2 <a3> ^3 <a2>)
   -{ (<a1> ^parameter <p*1>)
      (<p*1> ^num 0)}
    (<a1> ^rtype set ^result <r*1>)
    (<a3> ^result <r*3>)
    (<r*3> ^set <s*5>)
    (<s*5> ^instance <i*3>)
    (<i*3> ^1 <name>)
    (<a2> ^result <r*2>)
    (<r*2> ^set <s*4>)
    (<s*4> ^instance <i*2>)
    (<i*2> ^1 <attr>)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 <obja>)
   -{ (<obja> ^<elem> <e>)
     -{ (<e> ^predicates <p*2>)
        (<p*2> ^<attr> <name>)}}
   -{ (<obja> -^<x1> <x*1>)
      (state <ls> ^<a*1> <v*1>)}
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <obja> + ^3 <attr> + ^2 <name> +)
}

sp {with-attribute*elaborate*results*set*instance
    (state <s> ^name with-attribute ^superstate <s*2> ^superstate <s*1>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype set)
    (<s*2> ^operator <o>)
    (<o> ^args <args> ^parameter <p>)
    (<args> ^1 <a1> ^2 <a3> ^3 <a2>)
    (<a1> -^rtype set)
    (<a3> ^result <r*2>)
    (<r*2> ^set <s*4>)
    (<s*4> ^instance <p2>)
    (<p2> ^1 <name>)
    (<a2> ^result <r*1>)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <p1>)
    (<p1> ^1 <attr>)
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <set> + ^3 <attr> + ^2 <name> +)
}

sp {attribute-of*apply*complete*sets
    (state <s> ^name attribute-of ^operator <op> ^superstate <s*4>
          ^superstate <s*2> ^superstate <s*1>)
    (<op> ^name complete ^instance <instance>)
    (<instance> ^2 <set> ^1 <set2>)
    (<s*2> ^condition <c*2>)
    (<c*2> ^result <r*1>)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <instance>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype set)
    (<s*4> ^operator <o>)
    (<o> ^args <args> ^parameter <pn> ^type <type>)
    (<args> ^num 1 ^2 <a1>)
    (<a1> ^rtype set ^result <r*2>)
    (<r*2> ^set <s*5>)
    (<s*5> ^instance <i*1>)
    (<i*1> ^1 <set>)
    (<set> ^object <obj>)
    (<obj> ^predicates <p*1>)
    (<p*1> ^<type> <val>)
    -->
    (<set2> ^<random> <val> +)
}

sp {attribute-of*numeric-evaluate*value*instance*sets
    (state <s> ^name attribute-of ^superstate <s*2> ^superstate <s*1>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype set)
    (<s*2> ^operator <o>)
    (<o> ^args <args> ^parameter <pn>)
    (<args> ^num 1 ^2 <a1>)
    (<a1> ^rtype set ^result <r*1>)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 <set>)
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <set2> + ^2 <set> +)
}

sp {attribute-of*numeric-evaluate*value*instance*arg2*negative
    (state <s> ^name attribute-of ^superstate <s*2> ^superstate <s*1>)
    (<s*2> ^operator <o>)
    (<o> ^negative true ^args <args> ^parameter <p*1> ^type <type>)
    (<args> ^num 2 ^2 <a2> ^1 <a1>)
    (<p*1> ^num 2)
    (<a2> -^rtype set ^result <r*2>)
    (<r*2> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 <obja>)
    (<obja> ^predicates <p*2>)
    (<p*2> ^<type> <value>)
   -{ (<a1> ^result <r*3>)
      (<r*3> ^set <s*4>)
      (<s*4> ^instance <i*2>)
      (<i*2> ^1 <value>)}
    (<s*1> ^condition <c*1>)
    (<c*1> ^result <r*1>)
    (<r*1> ^set <res>)
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <value> + ^2 <obja> +)
}

sp {attribute-of*numeric-evaluate*value*instance*arg2
    (state <s> ^name attribute-of ^superstate <s*2> ^superstate <s*1>)
    (<s*2> ^operator <o>)
    (<o> ^negative false ^args <args> ^parameter <p*1> ^type <type>)
    (<args> ^num 2 ^2 <a2> ^1 <a1>)
    (<p*1> ^num 2)
    (<a2> -^rtype set ^result <r*3>)
    (<r*3> ^set <s*4>)
    (<s*4> ^instance <i*2>)
    (<i*2> ^1 <obja>)
    (<obja> ^predicates <p*2>)
    (<a1> ^result <r*2>)
    (<r*2> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 <value>)
    (<p*2> ^<type> <value>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^result <r*1>)
    (<r*1> ^set <res>)
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <value> + ^2 <obja> +)
}

sp {attribute-of*numeric-evaluate*value*instance
    (state <s> ^name attribute-of ^superstate <s*2> ^superstate <s*1>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^result <r*1>)
    (<r*1> ^set <res>)
    (<s*2> ^operator <o>)
    (<o> ^args <args> ^parameter <p*1> ^type <type>)
    (<args> ^num 1 ^2 <a1>)
    (<p*1> ^num 2)
    (<a1> -^rtype set ^result <r*2>)
    (<r*2> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 <obja>)
    (<obja> ^predicates <p*2>)
    (<p*2> ^<type> <value>)
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <value> + ^2 <obja> +)
}

sp {attribute-of*numeric-evaluate*value
    (state <s> ^name attribute-of ^superstate <s*2> ^superstate <s*1>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^result <r*1>)
    (<r*1> ^set <res>)
    (<s*2> ^operator <o>)
    (<o> ^args <args> ^parameter <p*1> ^type <type>)
    (<args> ^num 1 ^2 <a1>)
    (<a1> -^rtype set ^result <r*2>)
    (<p*1> ^num { < 2 <n*1> })
    (<r*2> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 <v*1>)
    (<v*1> ^predicates <p*2>)
    (<p*2> ^<type> <value>)
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <value> +)
}

sp {attribute-of*apply*complete
    (state <s> ^name attribute-of ^operator <op> ^instance <s1>
          ^superstate <s*1>)
    (<op> ^name complete ^instance <s1>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^result <r*1>)
    (<r*1> ^set <res>)
    -->
    (<res> ^instance <s1> +)
}

sp {attribute-of*propose*complete
    (state <s> ^name attribute-of ^instance <instance>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name complete + ^instance <instance> +)
}

sp {resolve-satisfaction-failure*apply*handle-unresolved-condition*try-another
    (state <s> ^name resolve-satisfaction-failure ^quiescence t ^operator <o>
          ^top-state <ts>)
    (<o> ^name handle-unresolved-condition ^condition <co> ^spelling <spell>)
    (<ts> ^smap <s*1>)
    (<co> ^name <n*1> ^name <name2>)
    (<s*1> ^<spell> { <> <n*1> <word2> })
    -->
    (<co> ^name <name2> - ^name <word2> +)
}

sp {resolve-satisfaction-failure*apply*handle-unresolved-condition
    (state <s> ^name resolve-satisfaction-failure ^quiescence t ^operator <o>
          ^linkstate <ls> ^top-state <ts> ^top-state <t*2> ^top-state <t*1>)
    (<o> ^name handle-unresolved-condition ^condition <co> ^spelling <spell>
          ^word <word>)
    (<ls> ^main-type <type> ^parsed-structure <ps> ^<type> <t>)
   -{ (<ts> ^smap <s*1>)
      (<s*1> ^<spell> <s*2>)}
    (<t*2> ^interaction <i*1>)
    (<i*1> ^changes <c>)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^learn-link <ll>)
    (<ll> ^argnum <an>)
    (<co> ^name { <> <word> <n*1> } ^name <name2>)
    (<t> ^formated <f*1> ^nlp-set <nlp>)
    -->
    (write (crlf) <spell>)
    (<ts> ^smap <sm> +)
    (<sm> ^<spell> <word> +)
    (<co> ^name <name2> - ^name <word> +)
    (<ll> ^argnum <an> -)
    (<c> ^new-segment-info <info> + ^outgoing-message <out-msg> +)
    (<info> ^purpose <p> + ^originator agent +)
    (<p> ^type process-unknown-word + ^parameters <p*1> +
           ^satisfaction <sat> +)
    (<p*1> ^word <word> +)
    (<sat> ^dialog-event <de> +)
    (<de> ^type process-unknown-word + ^originator instructor +)
    (<dc> ^learning-predicate <lp> +)
    (<lp> ^name <word> + ^spelling <spell> +)
    (<out-msg> ^type unknown-defined-word + ^fields <f*2> +)
    (<f*2> ^word <word> +)
    (<ps> ^learned-structure <nlp> +)
}

sp {resolve-satisfaction-failure*prefer*handle-unresolved-condition*concept
    (state <s> ^name resolve-satisfaction-failure ^operator <o2> +
          ^operator <o1> +)
   -{ (<o2> ^condition <c*2>)
      (<c*2> ^type concept)}
    (<o1> ^condition <c*1>)
    (<c*1> ^type concept)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {resolve-satisfaction-failure*propose*handle-unresolved-condition
    (state <s> ^name resolve-satisfaction-failure ^unresolved-condition <co>)
    (<co> ^name <name>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name handle-unresolved-condition +
           ^word (make-constant-symbol <name>) + ^spelling <name> +
           ^condition <co> +)
}

sp {resolve-satisfaction-failure*elaborate*unresolved
    (state <s> ^name resolve-satisfaction-failure ^superstate <s*1>)
    (<s*1> ^superstate <sss>)
    (<sss> ^condition <co>)
   -{ (<co> ^result <r*1>)
      (<r*1> ^set <s*2>)
      (<s*2> ^<x> <x*1>)}
    -->
    (<s> ^unresolved-condition <co> +)
}

sp {learn-condition*propose*resolve-satisfaction-failure
    (state <s> ^impasse no-change ^operator <o*1> ^superstate <s*1>)
    (<o*1> ^name wait)
    (<s*1> ^superstate <sss>)
    (<sss> ^name learn-condition)
    -->
    (<sss> ^operator <o> + ^operator <o> >)
    (<o> ^name resolve-satisfaction-failure +)
}

sp {retry-condition-setup*apply*complete
    (state <s> ^name retry-condition-setup ^quiescence t ^operator <o*1>
          ^linkstate <ls> ^top-state <t*2> ^top-state <ts> ^top-state <t*1>)
    (<o*1> ^name complete)
    (<ls> ^main-type <type> ^parsed-structure <ps> ^<type> <t>)
    (<t*2> ^interaction <i*1>)
    (<i*1> ^changes <c>)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^learn-link <ll>)
    (<ll> ^argnum <an>)
    (<t> ^formated <f*1> ^nlp-set <nlp>)
    -->
    (<ll> ^argnum <an> -)
    (<dc> ^needs-reset true +)
    (<c> ^new-segment-info <info> + ^outgoing-message <out-msg> +)
    (<info> ^purpose <p> + ^originator agent +)
    (<p> ^type process-reset-state + ^parameters <p*1> + ^satisfaction <sat> +)
    (<p*1> ^word <word> +)
    (<sat> ^dialog-event <de> +)
    (<de> ^type single-word-response + ^originator instructor +)
    (<out-msg> ^type reset-state + ^fields <f*2> +)
    (<f*2> ^word <type> +)
    (<ps> ^learned-structure <nlp> +)
}

sp {retry-condition-setup*propose*complete
    (state <s> ^name retry-condition-setup)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name complete +)
}

sp {learn-condition-impasse*propose*has-attribute
    (state <s> ^name learn-condition-impasse ^superstate <ss>)
    (<ss> ^condition <co>)
    (<co> ^type has-attribute ^args <args> ^negative <bool> ^parameter <p>
          ^name <type>)
    -->
    (<ss> ^operator <op> + ^operator <op> =)
    (<op> ^args <args> + ^name has-attribute + ^type <type> +
           ^negative <bool> + ^parameter <p> +)
}

sp {learn-condition-impasse*propose*attribute-of
    (state <s> ^name learn-condition-impasse ^superstate <ss>)
    (<ss> ^condition <co>)
    (<co> ^type attribute-of ^args <args> ^negative <bool> ^parameter <p>
          ^name <type>)
    -->
    (<ss> ^operator <op> + ^operator <op> =)
    (<op> ^args <args> + ^name attribute-of + ^type <type> +
           ^negative <bool> + ^parameter <p> +)
}

sp {learn-condition-impasse*propose*function
    (state <s> ^name learn-condition-impasse ^superstate <ss>)
    (<ss> ^condition <co>)
    (<co> ^type function ^function <func> ^args <args> ^negative <bool>
          ^parameter <p> ^name <name>)
    -->
    (<ss> ^operator <op> + ^operator <op> =)
    (<op> ^args <args> + ^name <func> + ^type <name> + ^negative <bool> +
           ^parameter <p> +)
}

sp {learn-condition-impasse*propose*top-pair
    (state <s> ^name learn-condition-impasse ^superstate <ss>)
    (<ss> ^condition <co>)
    (<co> ^type state-pair ^args <args> ^negative <bool> ^parameter <p>
          ^name <name> ^attribute <attr>)
    -->
    (<ss> ^operator <op> + ^operator <op> =)
    (<op> ^args <args> + ^name top-pair + ^type <name> + ^attribute <attr> +
           ^negative <bool> + ^parameter <p> +)
}

sp {learn-condition-impasse*propose*with-attribute*primitive-object
    (state <s> ^name learn-condition-impasse ^superstate <ss>)
    (<ss> ^condition <co>)
    (<co> ^name object ^type attribute ^attribute primitive ^args <args>
          ^negative <bool> ^parameter <p>)
    (<args> -^1 <a1>)
    -->
    (<ss> ^operator <op> + ^operator <op> =)
    (<op> ^args <args2> + ^name with-attribute + ^negative <bool> +
           ^parameter <p> +)
}

sp {learn-condition-impasse*propose*with-attribute22
    (state <s> ^name learn-condition-impasse ^superstate <ss>)
    (<ss> ^condition <co>)
    (<co> -^name object ^type attribute ^args <args> ^negative <bool>
          ^parameter <p> ^name <name> ^attribute <attr>)
    (<args> -^1 <a1>)
    -->
    (<ss> ^operator <op> + ^operator <op> =)
    (<op> ^args <args2> + ^name with-attribute + ^negative <bool> +
           ^parameter <p> +)
    (<args2> ^3 <a2> + ^2 <a3> +)
    (<a2> ^name number + ^args <ag2> + ^rtype single + ^result <r*1> +
           ^return-type number +)
    (<r*1> ^set <s*1> +)
    (<s*1> ^instance <a22> +)
    (<a22> ^1 <attr> +)
    (<a3> ^name number + ^args <ag3> + ^rtype single + ^result <r*2> +
           ^return-type number +)
    (<r*2> ^set <s*2> +)
    (<s*2> ^instance <a33> +)
    (<a33> ^1 <name> +)
}

sp {learn-condition-impasse*propose*with-attribute
    (state <s> ^name learn-condition-impasse ^superstate <ss>)
    (<ss> ^condition <co>)
    (<co> ^type attribute ^args <args> ^negative <bool> ^parameter <p>
          ^name <name> ^attribute <attr>)
    (<args> ^1 <a1>)
    -->
    (<ss> ^operator <op> + ^operator <op> =)
    (<op> ^args <args2> + ^name with-attribute + ^negative <bool> +
           ^parameter <p> +)
    (<args2> ^3 <a2> + ^2 <a3> + ^1 <a1> +)
    (<a2> ^name number + ^args <ag2> + ^rtype single + ^result <r*1> +
           ^return-type number +)
    (<r*1> ^set <s*1> +)
    (<s*1> ^instance <a22> +)
    (<a22> ^1 <attr> +)
    (<a3> ^name number + ^args <ag3> + ^rtype single + ^result <r*2> +
           ^return-type number +)
    (<r*2> ^set <s*2> +)
    (<s*2> ^instance <a33> +)
    (<a33> ^1 <name> +)
}

sp {learn-condition*impasse
    (state <s> ^choices none ^impasse no-change ^attribute state
          ^superstate <s*1> ^superstate <s*2>)
    (<s*1> ^name learn-condition)
    (<s*2> ^condition <co>)
    -->
    (<s> ^name learn-condition-impasse + ^condition <co> +)
}

sp {learn-condition*elaborate*conditions
    (state <s> ^name learn-condition ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^condition <co>)
    -->
    (<s> ^condition <co> +)
}

sp {resolve-conditions*prefer*learn-condition*reject-complete*number
    (state <s> ^name resolve-conditions ^operator <o> +)
    (<o> ^name learn-condition ^condition <co>)
    (<co> ^return-type number ^result <r*1>)
    (<r*1> ^set <s*1>)
    (<s*1> ^instance <i*1>)
    (<i*1> ^1 <something>)
    -->
    (<s> ^operator <o> -)
}

sp {resolve-conditions*prefer*learn-condition*reject-complete
    (state <s> ^name resolve-conditions ^operator <o> + ^linkstate <ls>)
    (<o> ^name learn-condition ^condition <co>)
    (<co> ^result <r*1>)
    (<r*1> ^set <s*1>)
    (<s*1> ^instance <i*1>)
    (<i*1> ^1 <a>)
   -{ (<a> -^<something> <s*2>)
      (state <ls> ^<a*1> <v*1>)}
    -->
    (<s> ^operator <o> -)
}

sp {resolve-conditions*prefer*learn-condition*childresults-under
    (state <s> ^name resolve-conditions ^operator <o> +)
    (<o> ^name learn-condition ^condition <co>)
    (<co> ^args <a*1>)
    (<a*1> ^{ << 1 2 3 4 5 6 7 8 9 10 >> <a*2> } <c1>)
    (<c1> -^return-type number)
   -{ (<c1> ^result <r*1>)
      (<r*1> ^set <s*1>)
      (<s*1> ^instance <i*1>)
      (<i*1> ^1 <v*1>)
      (<v*1> ^<something> <s*2>)}
    -->
    (<s> ^operator <o> <)
}

sp {resolve-conditions*prefer*learn-condition*childresults
    (state <s> ^name resolve-conditions ^operator <o> +)
    (<o> ^name learn-condition ^condition <co>)
    (<co> ^args <a*1>)
    (<a*1> ^{ << 1 2 3 4 5 6 7 8 9 10 >> <a*2> } <c1>)
   -{ (<c1> ^result <r*1>)
      (<r*1> ^set <s*1>)
      (<s*1> ^instance <i*1>)
      (<i*1> ^1 <v*1>)}
    -->
    (<s> ^operator <o> <)
}

sp {resolve-conditions*disprefer*input-args
    (state <s> ^name resolve-conditions ^operator <o> +)
    (<o> ^name learn-condition ^condition <co>)
    (<co> ^attribute input-arg)
    -->
    (<s> ^operator <o> <)
}

sp {resolve-conditions*disprefer*concepts
    (state <s> ^name resolve-conditions ^operator <o> +)
    (<o> ^name learn-condition ^condition <co>)
    (<co> ^type concept)
    -->
    (<s> ^operator <o> <)
}

sp {resolve-conditions*prefer*retrieve-predicate-structure*overlearn-condition
    (state <s> ^name resolve-conditions ^operator <o> + ^operator <o2> +)
    (<o> ^name learn-condition)
    (<o2> ^name retrieve-predicate-structure)
    -->
    (<s> ^operator <o2> > <o>)
}

sp {resolve-conditions*propose*learn-condition
    (state <s> ^name resolve-conditions ^condition <co>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name learn-condition + ^condition <co> +)
}

sp {resolve-conditions*propose*retrieve-predicate-structure
    (state <s> ^name learn-predicate ^gtype <gtype> ^<gtype> <g>)
    (<g> ^condition <co>)
   -{ (<s> ^predicate <p*1>)
      (<p*1> ^link <co>)}
    (<co> ^type concept ^attribute predicate ^name <name>)
    -->
    (<s> ^operator <o> + ^operator <o> = ^operator <o> >)
    (<o> ^name chunk-predicate-structure + ^<gtype> <g*1> + ^gtype <gtype> +)
    (<g*1> ^condition <co> +)
}

sp {resolve-conditions*elaborate*nlp-set
    (state <s> ^name resolve-conditions ^linkstate <ts>)
    (<ts> ^{ << action goal predicate failure heuristic >> <type> } <t*1>)
    (<t*1> ^condition <c>)
    -->
    (<s> ^condition <c> +)
}

sp {resolve-conditions*elaborate*type
    (state <s> ^name resolve-conditions)
    -->
    (<s> ^type action + ^type goal + ^type failure +)
}

sp {all-states*elaborate*linkstate
    (state <s> ^superstate <ts>)
    (<ts> ^linkstate <ss>)
    -->
    (<s> ^linkstate <ss> +)
}

sp {chunk-parameters*preference*disprefer*two-operators*1args1
    (state <s> ^name learn-heuristic ^linkstate <ss>)
    (<ss> ^heuristic <pred> ^operator <o2> + ^operator <o1> +)
    (<pred> ^ntype heuristic ^disprefer <pref> ^parameter-set <ps>)
    (<pref> ^2 <co2> ^1 <co1>)
    (<co2> ^type concept ^attribute action ^parameter <pa2> ^verb <vp>
          ^name <name> ^result <r*2>)
    (<pa2> ^num 1 ^1 <v*4>)
    (<co1> ^type concept ^attribute action ^verb <vp> ^parameter <pa1>
          ^name <name> ^result <r*1>)
    (<pa1> ^num 1 ^1 <v*3>)
    (<ps> ^set <set>)
    (<v*4> ^param-id <i2>)
    (<v*3> ^param-id <i1>)
    (<r*2> ^set <s*2>)
    (<s*2> ^instance <set2>)
    (<o2> ^parameters <set2> ^verb-structure <v*2>)
    (<v*2> ^1 <vs2>)
    (<vs2> ^verb-prep <vp> ^verb-name <name> ^1 <v2>)
    (<set> ^<i2> <obj2> ^<i1> <obj1>)
    (<set2> ^<v2> <obj2>)
    (<r*1> ^set <s*1>)
    (<s*1> ^instance <set1>)
    (<o1> ^parameters <set1> ^verb-structure <v*1>)
    (<v*1> ^1 <vs>)
    (<vs> ^verb-prep <vp> ^verb-name <name> ^1 <v1>)
    (<set1> ^<v1> <obj1>)
    -->
    (<ss> ^operator <o1> > <o2>)
}

sp {chunk-parameters*preference*prefer*two-operators*1args1
    (state <s> ^name learn-heuristic ^linkstate <ss>)
    (<ss> ^heuristic <pred> ^operator <o2> + ^operator <o1> +)
    (<pred> ^ntype heuristic ^parameter-set <ps> ^prefer <pref>)
    (<ps> ^set <set>)
    (<pref> ^2 <co2> ^1 <co1>)
    (<co2> ^type concept ^attribute action ^parameter <pa2> ^verb <vp>
          ^name <name> ^result <r*2>)
    (<pa2> ^num 1 ^1 <v*4>)
    (<co1> ^type concept ^attribute action ^verb <vp> ^parameter <pa1>
          ^name <name> ^result <r*1>)
    (<pa1> ^num 1 ^1 <v*3>)
    (<v*4> ^param-id <i2>)
    (<v*3> ^param-id <i1>)
    (<r*2> ^set <s*2>)
    (<s*2> ^instance <set2>)
    (<o2> ^parameters <set2> ^verb-structure <v*2>)
    (<v*2> ^1 <vs2>)
    (<vs2> ^verb-prep <vp> ^verb-name <name> ^1 <v2>)
    (<set> ^<i2> <obj2> ^<i1> <obj1>)
    (<set2> ^<v2> <obj2>)
    (<r*1> ^set <s*1>)
    (<s*1> ^instance <set1>)
    (<o1> ^parameters <set1> ^verb-structure <v*1>)
    (<v*1> ^1 <vs>)
    (<vs> ^verb-prep <vp> ^verb-name <name> ^1 <v1>)
    (<set1> ^<v1> <obj1>)
    -->
    (<ss> ^operator <o1> > <o2>)
}

sp {chunk-parameters*preference*prefer*two-operators*1args2
    (state <s> ^name learn-heuristic ^linkstate <ss>)
    (<ss> ^heuristic <pred> ^operator <o2> + ^operator <o1> +)
    (<pred> ^ntype heuristic ^parameter-set <ps> ^prefer <pref>)
    (<ps> ^set <set>)
    (<pref> ^2 <co2> ^1 <co1>)
    (<co2> ^type concept ^attribute action ^parameter <pa2> ^verb <vp>
          ^name <name> ^result <r*2>)
    (<pa2> ^num 2 ^2 <v*5> ^1 <v*4>)
    (<co1> ^type concept ^attribute action ^verb <vp> ^parameter <pa1>
          ^name <name> ^result <r*1>)
    (<pa1> ^num 1 ^1 <v*3>)
    (<v*5> ^param-id <i4>)
    (<v*4> ^param-id <i3>)
    (<v*3> ^param-id <i1>)
    (<r*2> ^set <s*2>)
    (<s*2> ^instance <set2>)
    (<o2> ^parameters <set2> ^verb-structure <v*2>)
    (<v*2> ^1 <vs2>)
    (<vs2> ^verb-prep <vp> ^verb-name <name> ^2 <v4> ^1 <v3>)
    (<set> ^<i4> <obj4> ^<i3> <obj3> ^<i1> <obj1>)
    (<set2> ^<v4> <obj4> ^<v3> <obj3>)
    (<r*1> ^set <s*1>)
    (<s*1> ^instance <set1>)
    (<o1> ^parameters <set1> ^verb-structure <v*1>)
    (<v*1> ^1 <vs>)
    (<vs> ^verb-prep <vp> ^verb-name <name> ^1 <v1>)
    (<set1> ^<v1> <obj1>)
    -->
    (<ss> ^operator <o1> > <o2>)
}

sp {chunk-parameters*preference*disprefer*two-operators*1args2
    (state <s> ^name learn-heuristic ^linkstate <ss>)
    (<ss> ^heuristic <pred> ^operator <o2> + ^operator <o1> +)
    (<pred> ^ntype heuristic ^disprefer <pref> ^parameter-set <ps>)
    (<pref> ^2 <co2> ^1 <co1>)
    (<co2> ^type concept ^attribute action ^parameter <pa2> ^verb <vp>
          ^name <name> ^result <r*2>)
    (<pa2> ^num 2 ^2 <v*5> ^1 <v*4>)
    (<co1> ^type concept ^attribute action ^verb <vp> ^parameter <pa1>
          ^name <name> ^result <r*1>)
    (<pa1> ^num 1 ^1 <v*3>)
    (<ps> ^set <set>)
    (<v*5> ^param-id <i4>)
    (<v*4> ^param-id <i3>)
    (<v*3> ^param-id <i1>)
    (<r*2> ^set <s*2>)
    (<s*2> ^instance <set2>)
    (<o2> ^parameters <set2> ^verb-structure <v*2>)
    (<v*2> ^1 <vs2>)
    (<vs2> ^verb-prep <vp> ^verb-name <name> ^2 <v4> ^1 <v3>)
    (<set> ^<i4> <obj4> ^<i3> <obj3> ^<i1> <obj1>)
    (<set2> ^<v4> <obj4> ^<v3> <obj3>)
    (<r*1> ^set <s*1>)
    (<s*1> ^instance <set1>)
    (<o1> ^parameters <set1> ^verb-structure <v*1>)
    (<v*1> ^1 <vs>)
    (<vs> ^verb-prep <vp> ^verb-name <name> ^1 <v1>)
    (<set1> ^<v1> <obj1>)
    -->
    (<ss> ^operator <o1> < <o2>)
}

sp {chunk-parameters*apply*wait*complete*select*one
    (state <s> ^quiescence t ^superstate <ss> ^operator <o*1>)
    (<ss> ^name learn-heuristic ^quiescence t ^linkstate <sss>)
    (<sss> ^quiescence t ^operator <o> +)
    (<o*1> ^name wait)
    -->
    (<sss> ^operator <o> + ^operator <o> =)
}

sp {chunk-parameters*preference*prefer*two-operators*2args1
    (state <s> ^name learn-heuristic ^linkstate <ss>)
    (<ss> ^heuristic <pred> ^operator <o2> + ^operator <o1> +)
    (<pred> ^ntype heuristic ^parameter-set <ps> ^prefer <pref>)
    (<ps> ^set <set>)
    (<pref> ^2 <co2> ^1 <co1>)
    (<co2> ^type concept ^attribute action ^parameter <pa2> ^verb <vp>
          ^name <name> ^result <r*2>)
    (<pa2> ^num 1 ^1 <v*5>)
    (<co1> ^type concept ^attribute action ^verb <vp> ^parameter <pa1>
          ^name <name> ^result <r*1>)
    (<pa1> ^num 2 ^2 <v*4> ^1 <v*3>)
    (<v*4> ^param-id <i2>)
    (<v*5> ^param-id <i3>)
    (<v*3> ^param-id <i1>)
    (<r*2> ^set <s*2>)
    (<s*2> ^instance <set2>)
    (<o2> ^parameters <set2> ^verb-structure <v*2>)
    (<v*2> ^1 <vs2>)
    (<vs2> ^verb-prep <vp> ^verb-name <name> ^1 <v3>)
    (<set> ^<i3> <obj3> ^<i2> <obj2> ^<i1> <obj1>)
    (<set2> ^<v3> <obj3>)
    (<r*1> ^set <s*1>)
    (<s*1> ^instance <set1>)
    (<o1> ^parameters <set1> ^verb-structure <v*1>)
    (<v*1> ^1 <vs>)
    (<vs> ^verb-prep <vp> ^verb-name <name> ^2 <v2> ^1 <v1>)
    (<set1> ^<v2> <obj2> ^<v1> <obj1>)
    -->
    (<ss> ^operator <o1> > <o2>)
}

sp {chunk-parameters*preference*disprefer*two-operators*2args1
    (state <s> ^name learn-heuristic ^linkstate <ss>)
    (<ss> ^heuristic <pred> ^operator <o2> + ^operator <o1> +)
    (<pred> ^ntype heuristic ^disprefer <pref> ^parameter-set <ps>)
    (<pref> ^2 <co2> ^1 <co1>)
    (<co2> ^type concept ^attribute action ^parameter <pa2> ^verb <vp>
          ^name <name> ^result <r*2>)
    (<pa2> ^num 1 ^1 <v*5>)
    (<co1> ^type concept ^attribute action ^verb <vp> ^parameter <pa1>
          ^name <name> ^result <r*1>)
    (<pa1> ^num 2 ^2 <v*4> ^1 <v*3>)
    (<ps> ^set <set>)
    (<v*4> ^param-id <i2>)
    (<v*5> ^param-id <i3>)
    (<v*3> ^param-id <i1>)
    (<r*2> ^set <s*2>)
    (<s*2> ^instance <set2>)
    (<o2> ^parameters <set2> ^verb-structure <v*2>)
    (<v*2> ^1 <vs2>)
    (<vs2> ^verb-prep <vp> ^verb-name <name> ^1 <v3>)
    (<set> ^<i3> <obj3> ^<i2> <obj2> ^<i1> <obj1>)
    (<set2> ^<v3> <obj3>)
    (<r*1> ^set <s*1>)
    (<s*1> ^instance <set1>)
    (<o1> ^parameters <set1> ^verb-structure <v*1>)
    (<v*1> ^1 <vs>)
    (<vs> ^verb-prep <vp> ^verb-name <name> ^2 <v2> ^1 <v1>)
    (<set1> ^<v2> <obj2> ^<v1> <obj1>)
    -->
    (<ss> ^operator <o1> < <o2>)
}

sp {chunk-parameters*preference*disprefer*two-operators*2args2
    (state <s> ^name learn-heuristic ^linkstate <ss>)
    (<ss> ^heuristic <pred> ^operator <o2> + ^operator <o1> +)
    (<pred> ^ntype heuristic ^disprefer <pref> ^parameter-set <ps>)
    (<pref> ^2 <co2> ^1 <co1>)
    (<co2> ^type concept ^attribute action ^parameter <pa2> ^verb <vp>
          ^name <name> ^result <r*2>)
    (<pa2> ^num 2 ^2 <v*6> ^1 <v*5>)
    (<co1> ^type concept ^attribute action ^verb <vp> ^parameter <pa1>
          ^name <name> ^result <r*1>)
    (<pa1> ^num 2 ^2 <v*4> ^1 <v*3>)
    (<ps> ^set <set>)
    (<v*6> ^param-id <i4>)
    (<v*4> ^param-id <i2>)
    (<v*5> ^param-id <i3>)
    (<v*3> ^param-id <i1>)
    (<r*2> ^set <s*2>)
    (<s*2> ^instance <set2>)
    (<o2> ^parameters <set2> ^verb-structure <v*2>)
    (<v*2> ^1 <vs2>)
    (<vs2> ^verb-prep <vp> ^verb-name <name> ^2 <v4> ^1 <v3>)
    (<set> ^<i4> <obj4> ^<i3> <obj3> ^<i2> <obj2> ^<i1> <obj1>)
    (<set2> ^<v4> <obj4> ^<v3> <obj3>)
    (<r*1> ^set <s*1>)
    (<s*1> ^instance <set1>)
    (<o1> ^parameters <set1> ^verb-structure <v*1>)
    (<v*1> ^1 <vs>)
    (<vs> ^verb-prep <vp> ^verb-name <name> ^2 <v2> ^1 <v1>)
    (<set1> ^<v2> <obj2> ^<v1> <obj1>)
    -->
    (<ss> ^operator <o1> < <o2>)
}

sp {chunk-parameters*preference*prefer*two-operators*2args2
    (state <s> ^name learn-heuristic ^linkstate <ss>)
    (<ss> ^heuristic <pred> ^operator <o2> + ^operator <o1> +)
    (<pred> ^ntype heuristic ^parameter-set <ps> ^prefer <pref>)
    (<ps> ^set <set>)
    (<pref> ^2 <co2> ^1 <co1>)
    (<co2> ^type concept ^attribute action ^parameter <pa2> ^verb <vp>
          ^name <name> ^result <r*2>)
    (<pa2> ^num 2 ^2 <v*6> ^1 <v*5>)
    (<co1> ^type concept ^attribute action ^verb <vp> ^parameter <pa1>
          ^name <name> ^result <r*1>)
    (<pa1> ^num 2 ^2 <v*4> ^1 <v*3>)
    (<v*6> ^param-id <i4>)
    (<v*4> ^param-id <i2>)
    (<v*5> ^param-id <i3>)
    (<v*3> ^param-id <i1>)
    (<r*2> ^set <s*2>)
    (<s*2> ^instance <rset2>)
    (<r*1> ^set <s*1>)
    (<s*1> ^instance <rset1>)
    (<o2> ^verb-structure <v*2> ^parameters <set2>)
    (<v*2> ^1 <vs2>)
    (<vs2> ^verb-prep <vp> ^verb-name <name> ^2 <v4> ^1 <v3>)
    (<set> ^<i4> <obj4> ^<i3> <obj3> ^<i2> <obj2> ^<i1> <obj1>)
    (<rset2> ^<v4> <obj4> ^<v3> <obj3>)
    (<set2> ^<v4> <obj4> ^<v3> <obj3>)
    (<o1> ^verb-structure <v*1> ^parameters <set1>)
    (<v*1> ^1 <vs>)
    (<vs> ^verb-prep <vp> ^verb-name <name> ^2 <v2> ^1 <v1>)
    (<rset1> ^<v2> <obj2> ^<v1> <obj1>)
    (<set1> ^<v2> <obj2> ^<v1> <obj1>)
    -->
    (<ss> ^operator <o1> > <o2>)
}

sp {chunk-parameters*preference*disprefer*single-operators*1args*any
    (state <s> ^name learn-heuristic ^linkstate <ss>)
    (<ss> ^heuristic <pred> ^operator <o1> +)
    (<pred> ^ntype heuristic ^disprefer <pref> ^parameter-set <ps>)
    (<pref> -^2 <v*1> ^1 <co>)
    (<co> ^type concept ^attribute action ^parameter <pa1> ^verb <vp>
          ^result <r*1> ^name <name>)
    (<pa1> ^num 1 ^1 <v*3>)
    (<ps> ^set <set>)
    (<v*3> ^param-id <i1>)
    (<r*1> ^set <s*1>)
    (<s*1> ^instance <set1>)
    (<o1> ^parameters <set1> ^verb-structure <v*2>)
    (<v*2> ^1 <vs>)
    (<vs> ^verb-prep <vp> ^verb-name <name> ^1 <v1>)
    (<set> ^<i1> <obj1>)
    (<set1> ^<v1> <obj1>)
    -->
    (<ss> ^operator <o1> <)
}

sp {chunk-parameters*preference*disprefer*single-operators*2args
    (state <s> ^name learn-heuristic ^linkstate <ss>)
    (<ss> ^heuristic <pred> ^operator <o1> +)
    (<pred> ^ntype heuristic ^disprefer <pref> ^parameter-set <ps>)
    (<pref> -^2 <v*1> ^1 <co>)
    (<co> ^type concept ^attribute action ^parameter <pa1> ^verb <vp>
          ^result <r*1> ^name <name>)
    (<pa1> ^num 2 ^2 <v*4> ^1 <v*3>)
    (<ps> ^set <set>)
    (<v*4> ^param-id <i2>)
    (<v*3> ^param-id <i1>)
    (<r*1> ^set <s*1>)
    (<s*1> ^instance <set1>)
    (<o1> ^parameters <set1> ^verb-structure <v*2>)
    (<v*2> ^1 <vs>)
    (<vs> ^verb-prep <vp> ^verb-name <name> ^2 <v2> ^1 <v1>)
    (<set> ^<i2> <obj2> ^<i1> <obj1>)
    (<set1> ^<v2> <obj2> ^<v1> <obj1>)
    -->
    (<ss> ^operator <o1> <)
}

sp {chunk-parameters*preference*prefer*single-operators*1args
    (state <s> ^name learn-heuristic ^linkstate <ss>)
    (<ss> ^heuristic <pred> ^operator <o1> +)
    (<pred> ^ntype heuristic ^prefer <pref> ^parameter-set <ps>)
    (<pref> -^2 <v*1> ^1 <co>)
    (<co> ^type concept ^attribute action ^parameter <pa1> ^verb <vp>
          ^result <r*1> ^name <name>)
    (<pa1> ^num 1 ^1 <v*3>)
    (<ps> ^set <set>)
    (<v*3> ^param-id <i1>)
    (<r*1> ^set <s*1>)
    (<s*1> ^instance <set1>)
    (<o1> ^parameters <set1> ^verb-structure <v*2>)
    (<v*2> ^1 <vs>)
    (<vs> ^verb-prep <vp> ^verb-name <name> ^1 <v1>)
    (<set> ^<i1> <obj1>)
    (<set1> ^<v1> <obj1>)
    -->
    (<ss> ^operator <o1> >)
}

sp {chunk-parameters*preference*prefer*single-operators*2args
    (state <s> ^name learn-heuristic ^linked-heuristic <pred> ^linkstate <ss>)
    (<pred> ^ntype heuristic ^prefer <pref> ^parameter-set <ps>)
    (<ss> ^heuristic <pred> ^operator <o2> + ^operator <o1> +)
    (<pref> -^2 <v*1> ^1 <co>)
    (<co> ^type concept ^attribute action ^parameter <pa1> ^verb <vp>
          ^result <r*1> ^name <name>)
    (<pa1> ^num 2 ^2 <v*8> ^1 <v*7>)
    (<o2> ^type action -^parameters <set1>)
    (<ps> ^set <set>)
    (<v*8> ^param-id <i2>)
    (<v*7> ^param-id <i1>)
    (<r*1> ^set <s*1>)
    (<s*1> ^instance <set1>)
    (<o1> ^verb-structure <v*2> ^parameters <set3>)
    (<v*2> ^1 <vs>)
    (<vs> ^verb-prep <vp> ^verb-name <name> ^2 <v2> ^1 <v1>)
    (<set> ^<i2> <i*2> ^<i1> <i*1>)
    (<i*2> ^handle <obj2>)
    (<set1> ^<v2> <v*6> ^<v1> <v*5>)
    (<v*6> ^handle <obj2>)
    (<set3> ^<v2> <v*4> ^<v1> <v*3>)
    (<v*4> ^handle <obj2>)
    (<i*1> ^handle <obj1>)
    (<v*5> ^handle <obj1>)
    (<v*3> ^handle <obj1>)
    -->
    (<ss> ^operator <o1> > <o2>)
}

sp {chunk-previous*preference*avoid*single-operators*1args*moved
    (state <s> ^name chunk-previous ^linked-heuristic <pred> ^linkstate <ss>)
    (<pred> ^modifier previously ^ntype heuristic ^moved <mov>
          ^parameter-set <ps> ^avoid <pref>)
    (<mov> ^type concept ^attribute action ^parameter <para2>)
    (<ps> ^argnum 1 ^set <set>)
    (<para2> -^2 <v*2> ^1 <v*3>)
    (<pref> -^2 <v*4> ^1 <co>)
    (<co> -^verb <v*7> ^type concept ^attribute action ^parameter <pa1>
          ^name <name>)
    (<pa1> -^2 <v*8> ^1 <v*9>)
    (<ss> ^operator <o1> + ^superstate <su>)
    (<o1> -^duplicate-of <d*1> ^verb-structure <v*5> ^parameters <set1>)
    (<v*9> ^param-id <i1>)
    (<v*5> ^1 <vs>)
    (<vs> ^verb-name <name> ^1 <v1>)
    (<v*3> ^param-id <v1>)
    (<su> ^superstate <sss> ^operator <o*1>)
    (<sss> ^heuristic <pred>)
    (<o*1> ^superoperator <sso>)
    (<sso> ^parameters <pset4>)
    (<set> ^<i1> <i*1>)
    (<i*1> ^handle <obj1>)
    (<set1> ^<v1> <v*6>)
    (<v*6> ^handle <obj1>)
    (<pset4> ^<v1> <v*1>)
    (<v*1> ^handle <obj1>)
    -->
    (<ss> ^operator <o1> -)
}

sp {chunk-previous*preference*prefer*single-operators*1args*moved
    (state <s> ^name chunk-previous ^linked-heuristic <pred> ^linkstate <ss>)
    (<pred> ^modifier previously ^ntype heuristic ^moved <mov>
          ^parameter-set <ps> ^prefer <pref>)
    (<mov> ^type concept ^attribute action ^parameter <para2>)
    (<ps> ^argnum 1 ^set <set>)
    (<para2> -^2 <v*2> ^1 <v*3>)
    (<pref> -^2 <v*4> ^1 <co>)
    (<co> -^verb <v*7> ^type concept ^attribute action ^parameter <pa1>
          ^name <name>)
    (<pa1> -^2 <v*8> ^1 <v*9>)
    (<ss> ^operator <o2> + ^superstate <s*2> ^superstate <s*1>
          ^operator <o1> +)
    (<o2> ^type action -^parameters <set1>)
    (<v*9> ^param-id <i1>)
    (<v*3> ^param-id <v1>)
    (<s*1> ^superstate <sss>)
    (<sss> ^heuristic <pred>)
    (<s*2> ^operator <o*1>)
    (<o*1> ^superoperator <sso>)
    (<sso> ^parameters <pset4>)
    (<o1> ^parameters <set1> ^verb-structure <v*5>)
    (<v*5> ^1 <vs>)
    (<vs> ^verb-name <name> ^1 <v1>)
    (<set> ^<i1> <i*1>)
    (<i*1> ^handle <obj1>)
    (<set1> ^<v1> <v*6>)
    (<v*6> ^handle <obj1>)
    (<pset4> ^<v1> <v*1>)
    (<v*1> ^handle <obj1>)
    -->
    (<ss> ^operator <o1> > <o2>)
}

sp {chunk-previous*preference*avoid*single-operators*1args
    (state <s> ^name chunk-previous ^linked-heuristic <pred> ^linkstate <ss>)
    (<pred> -^moved <m*1> ^modifier previously ^ntype heuristic
          ^parameter-set <ps> ^avoid <pref>)
    (<ps> ^argnum 1 ^set <set>)
    (<pref> -^2 <v*1> ^1 <co>)
    (<co> -^verb <v*4> ^type concept ^attribute action ^parameter <pa1>
          ^name <name>)
    (<pa1> -^2 <v*5> ^1 <v*6>)
    (<ss> ^operator <o1> + ^superstate <s*1>)
    (<o1> -^duplicate-of <d*1> ^verb-structure <v*2> ^parameters <set1>)
    (<v*6> ^param-id <i1>)
    (<v*2> ^1 <vs>)
    (<vs> ^verb-name <name> ^1 <v1>)
    (<s*1> ^superstate <sss>)
    (<sss> ^heuristic <pred>)
    (<set> ^<i1> <i*1>)
    (<i*1> ^handle <obj1>)
    (<set1> ^<v1> <v*3>)
    (<v*3> ^handle <obj1>)
    -->
    (<ss> ^operator <o1> -)
}

sp {chunk-previous*preference*prefer*single-operators*1args
    (state <s> ^name chunk-previous ^linked-heuristic <pred> ^linkstate <ss>)
    (<pred> -^moved <m*1> ^modifier previously ^ntype heuristic
          ^parameter-set <ps> ^prefer <pref>)
    (<ps> ^argnum 1 ^set <set>)
    (<pref> -^2 <v*1> ^1 <co>)
    (<co> -^verb <v*4> ^type concept ^attribute action ^parameter <pa1>
          ^name <name>)
    (<pa1> -^2 <v*5> ^1 <v*6>)
    (<ss> ^operator <o2> + ^superstate <s*1> ^operator <o1> +)
    (<o2> ^type action -^parameters <set1>)
    (<v*6> ^param-id <i1>)
    (<s*1> ^superstate <sss>)
    (<sss> ^heuristic <pred>)
    (<o1> ^parameters <set1> ^verb-structure <v*2>)
    (<v*2> ^1 <vs>)
    (<vs> ^verb-name <name> ^1 <v1>)
    (<set> ^<i1> <i*1>)
    (<i*1> ^handle <obj1>)
    (<set1> ^<v1> <v*3>)
    (<v*3> ^handle <obj1>)
    -->
    (<ss> ^operator <o1> > <o2>)
}

sp {chunk-prefer-consider*considerence*consider*single-operators*2args
    (state <s> ^name chunk-prefer-consider ^lo-heuristic <pred>
          ^linkstate <ss>)
    (<pred> ^ntype heuristic ^consider <pref> ^parameter-set <ps>)
    (<pref> -^2 <v*1> ^1 <co>)
    (<co> ^type concept ^attribute action ^parameter <pa1> ^verb <vp>
          ^name <name> ^result <r*1>)
    (<pa1> ^num 2 ^2 <v*8> ^1 <v*7>)
    (<ss> ^superstate <s*1> ^operator <o1> +)
    (<s*1> ^heuristic <pred>)
    (<o1> ^name evaluate-operator ^superoperator <so>)
    (<ps> ^set <set>)
    (<so> ^verb-structure <v*2> ^parameters <set3>)
    (<v*2> ^1 <vs>)
    (<vs> ^verb-prep <vp> ^verb-name <name> ^2 <v2> ^1 <v1>)
    (<v*8> ^param-id <i2>)
    (<v*7> ^param-id <i1>)
    (<r*1> ^set <s*2>)
    (<s*2> ^instance <set1>)
    (<set> ^<i2> <i*2> ^<i1> <i*1>)
    (<i*2> ^handle <obj2>)
    (<set1> ^<v2> <v*6> ^<v1> <v*5>)
    (<v*6> ^handle <obj2>)
    (<set3> ^<v2> <v*4> ^<v1> <v*3>)
    (<v*4> ^handle <obj2>)
    (<i*1> ^handle <obj1>)
    (<v*5> ^handle <obj1>)
    (<v*3> ^handle <obj1>)
    -->
    (<ss> ^operator <o1> >)
}

sp {learn-heuristic*chunk-parameters*propose*new-operator*snc*t71-4
    (state <s1> ^gtype action ^list <l1> ^action <p1>)
    (<l1> ^game <g1>)
    (<p1> ^parameter-set <p2> ^potential-args <p3> ^verb-structure <v*1>)
    (<p2> ^tested calculate3 ^tested calculate6 ^tested calculate4
          ^tested calculate5 ^tested calculate2 ^tested calculate1 ^set <s2>)
    (<v*1> ^1 <vs>)
    (<vs> ^2 <v2> ^1 <v1>)
    (<s2> ^<v2> <ob2> ^<v1> <ob1>)
    -->
    (<p1> ^instance <s4> +)
    (<s4> ^1 <ob1> + ^2 <ob2> +)
}

sp {chunk-prefer-consider*eval-condition*impasse*consider*chunk-pause
    (state <s> ^impasse tie ^attribute operator ^superstate <ss>)
    (<ss> ^name selection ^superstate <s*1>)
    (<s*1> ^heuristic <pred>)
    (<pred> -^avoid <a*1> -^prefer <p*1> ^ntype heuristic)
    -->
    (<s> ^operator-selection not-indifferent + ^name chunk-prefer-consider +
           ^lo-heuristic <pred> + ^linkstate <ss> +)
}

sp {learn-heuristic*eval-condition*impasse*consider*force-learn
    (state <s> ^impasse tie ^attribute operator ^superstate <ss>)
    (<ss> ^name selection ^superstate <s*1>)
    (<s*1> ^heuristic <pred>)
    (<pred> -^avoid <a*1> -^prefer <p*1> ^ntype heuristic)
    -->
    (force-learn <s>)
}

sp {learn-heuristic*apply*action*learn-heuristic
    (state <s> ^ntype heuristic ^name evaluate-operator ^name learn-predicate
          ^operator <o> ^superstate <s*1>)
    (<o> -^duplicate-of <d*1> ^type action)
    (<s*1> ^superstate <ss>)
    (<ss> ^name learn-predicate ^operator <so> +)
    -->
    (<ss> ^operator <so> > ^operator <so> =)
}

sp {learn-heuristic*apply*indifferent*complete
    (state <s> ^name learn-heuristic ^quiescence t ^superstate <ss>)
    (<ss> ^non-numeric <so> ^superstate <sss>)
    (<sss> ^operator <so> +)
    -->
    (<sss> ^operator <so> > ^operator <so> =)
}

sp {learn-heuristic*apply*chunk-previous-delay*complete
    (state <s> ^name chunk-previous ^quiescence t ^superstate <s*1>
          -^non-numeric <op>)
    (<s*1> ^superstate <ss>)
    (<ss> ^operator <op> + ^operator { <> <op> <so> } +)
    -->
    (<ss> ^operator <so> > ^operator <so> =)
}

sp {learn-heuristic*apply*evaluate-operator
    (state <s> ^operator-selection not-indifferent ^name selection
          ^quiescence t ^impasse tie ^attribute operator ^superstate <ss>
          ^operator <o>)
    (<ss> ^name learn-predicate ^heuristic <pred> ^operator <so> +)
    (<pred> ^ntype heuristic ^consider <c*1>)
    (<o> ^name evaluate-operator ^superoperator <so>)
    -->
    (<ss> ^operator <so> > ^operator <so> =)
}

sp {learn-predicate*heuristic*previous*action*copy*heuristicntype
    (state <s> ^name learn-predicate ^superstate <ss>)
    (<ss> ^name selection ^retrieve-action <rh>)
    -->
    (<s> ^ntype heuristic + ^list <li> +)
    (<li> ^game <g1> +)
}

sp {learn-predicate*heuristic*previous*action*copy
    (state <s> ^name learn-predicate ^superstate <ss>)
    (<ss> ^name selection ^retrieve-action <rh>)
    -->
    (<s> ^retrieve-handle <rh> +)
}

sp {learn-predicate*heuristic*elaborate*previous-action
    (state <s> ^name selection ^impasse tie ^attribute operator
          ^superstate <ss>)
    (<ss> ^name learn-predicate ^heuristic <pred> ^retrieve-handle <rh>)
    (<pred> ^modifier previously ^ntype heuristic)
    -->
    (<s> ^retrieve-action <rh> +)
}

sp {selection*learn-heuristic*elaborate*operator-selection*not-indifferent
    (state <s> ^name selection ^impasse tie ^attribute operator
          ^superstate <ss>)
    (<ss> ^name learn-predicate ^heuristic <pred>)
    (<pred> -^avoid <a*1> -^prefer <p*1> ^ntype heuristic)
    -->
    (<s> ^operator-selection not-indifferent +)
}

sp {learn-predicate*apply*simulate
    (state <s> ^name learn-predicate ^operator <o> ^deep-copy-world <d*1>
          ^world <w*1>)
    (<o> ^type action ^verb-structure <v*1> ^parameters <p> ^name <cname>)
    (<d*1> ^copy-objects-map <com>)
    (<com> ^entry <e2> ^entry <e1>)
    (<e2> ^copy <objb> ^source <obj1>)
    (<e1> ^copy <obja> ^source <obj>)
    (<obj> ^handle <ha>)
    (<w*1> ^predicates <p2>)
    (<p2> ^predicate <prep2> ^predicate <prep>)
    (<prep2> ^handle on1 ^instance <instance2>)
    (<instance2> ^1 <obja>)
    (<prep> ^handle below1 ^instance <instance>)
    (<instance> ^2 <obja>)
    (<p> ^<i2> <obj1> ^<i1> <obj>)
    (<v*1> ^<num> <v1>)
    (<v1> ^verb-prep on1 ^2 <i2> ^1 <i1>)
    -->
    (<s> ^simulated true + ^gtype action +)
    (<prep> ^instance <instance> - ^instance <instance3> +)
    (<prep2> ^instance <instance2> - ^instance <instance4> +)
    (<instance3> ^1 <objb> + ^2 <obja> +)
    (<instance4> ^1 <obja> + ^2 <objb> +)
}

sp {chunk-delay*elaborate*learn-heuristic
    (state <s> ^choices none ^impasse no-change ^attribute state
          ^superstate <ss>)
    (<ss> ^name chunk-delay ^linked-heuristic <pred> ^linkstate <ls>)
    -->
    (<s> ^name learn-heuristic + ^linked-heuristic <pred> + ^linkstate <ls> +)
}

sp {selection*impasse*prefer*chunk-delay
    (state <s> ^impasse tie ^attribute operator ^superstate <ss>)
    (<ss> ^heuristic <pred> ^list <l*1>)
    (<pred> -^modifier <m*1> -^consider <c*1> ^ntype heuristic)
    (<l*1> ^game <g*1>)
    -->
    (<s> ^name chunk-delay + ^linked-heuristic <pred> + ^linkstate <ss> +)
}

sp {chunk-previous-delay*elaborate*chunk-previous
    (state <s> ^choices none ^impasse no-change ^attribute state
          ^superstate <ss>)
    (<ss> ^name chunk-previous-delay ^linked-heuristic <pred> ^linkstate <ls>)
    -->
    (<s> ^name chunk-previous + ^linked-heuristic <pred> + ^linkstate <ls> +)
}

sp {selection*impasse*chunk-previous-delay
    (state <s> ^impasse tie ^attribute operator ^superstate <ss>)
    (<ss> ^list <l*1> ^superstate <s*1>)
    (<l*1> ^game <g*1>)
    (<s*1> ^superstate <s*2>)
    (<s*2> ^heuristic <pred>)
    (<pred> -^consider <c*1> ^modifier previously ^ntype heuristic)
    -->
    (<s> ^name chunk-previous-delay + ^linked-heuristic <pred> +
           ^linkstate <ss> +)
}

sp {selection*impasse*heuristic*chunk-previous*force-learn
    (state <s> ^impasse tie ^attribute operator ^superstate <ss>)
    (<ss> ^superstate <s*1> ^list <l*1>)
    (<s*1> ^problemspace game-heuristics)
    (<l*1> ^game <g*1>)
    -->
    (force-learn <s>)
}

sp {selection*impasse*heuristic*prefer*force-learn
    (state <s> ^impasse tie ^attribute operator ^linked-heuristic <pred>
          ^superstate <ss>)
    (<pred> -^modifier <m*1> -^consider <c*1> ^ntype heuristic)
    (<ss> -^problemspace games ^heuristic <pred> ^list <l*1>)
    (<l*1> ^game <g*1>)
    -->
    (force-learn <s>)
}

sp {learn-predicate*elaborate*learned-actions
    (state <s> ^ntype heuristic ^name learn-predicate ^top-state <t*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^structure <s*1>)
    (<s*1> ^actions <a*1>)
    (<a*1> ^retrieve-handle <name>)
    -->
    (<s> ^gtype action + ^retrieve-handle <name> +)
}

sp {retrieve-game-structure*apply*complete*opponent
    (state <s> ^name retrieve-game-structure ^smem <s*1> ^superstate <ss>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <pred>)
    (<pred> ^opponent <r> ^retrieve-handle <r>)
    -->
    (<ss> ^retrieve-handle <r> + ^opponent <r> +)
}

sp {retrieve-game-structure*apply*complete
    (state <s> ^name retrieve-game-structure ^smem <s*1> ^superstate <ss>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <pred>)
    (<pred> ^retrieve-handle <r> -^opponent <r>)
    -->
    (<ss> ^retrieve-handle <r> +)
}

sp {retrieve-game-structure*apply*complete*start-search-depth
    (state <s> ^name retrieve-game-structure ^smem <s*1> ^superstate <ss>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <pred>)
    (<pred> ^start-search-depth <r>)
    -->
    (<ss> ^start-search-depth <r> +)
}

sp {retrieve-game-structure*elaborate*smem-query
    (state <s> ^name retrieve-game-structure ^smem <s*1> ^superstate <s*2>)
    (<s*1> ^command <c>)
    (<s*2> ^operator <o*1>)
    (<o*1> ^handle <handle>)
    -->
    (<c> ^query <cue> +)
    (<cue> ^handle <handle> + ^retrieve game +)
}

sp {transfer-action-goal*learn-predicate*goal
    :o-support
    (state <s> ^gtype goal ^name transfer-action-goal
          ^retrieve-handle <handle> ^top-state <ts>)
    (<ts> ^dialog-context <dc> ^interaction <i*2> ^interaction <i*1>)
    (<dc> ^structure <pred>)
    (<pred> ^goals <act>)
    (<i*2> ^changes <changes>)
    (<i*1> ^status <status>)
    -->
    (<act> ^retrieve-handle <handle> +)
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type already-learned-goal +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <de> +)
    (<de> ^type game-name + ^originator agent +)
}

sp {transfer-action-goal*learn-predicate*failure
    :o-support
    (state <s> ^gtype failure ^name transfer-action-goal
          ^retrieve-handle <handle> ^top-state <ts>)
    (<ts> ^dialog-context <dc> ^interaction <i*2> ^interaction <i*1>)
    (<dc> ^structure <pred>)
    (<pred> ^failures <act>)
    (<i*2> ^changes <changes>)
    (<i*1> ^status <status>)
    -->
    (<act> ^retrieve-handle <handle> +)
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type already-learned-failure +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <de> +)
    (<de> ^type game-name + ^originator agent +)
}

sp {transfer-action-goal*learn-predicate*action
    :o-support
    (state <s> ^gtype action ^name transfer-action-goal
          ^retrieve-handle <handle> ^top-state <ts>)
    (<ts> ^dialog-context <dc> ^interaction <i*2> ^interaction <i*1>)
    (<dc> ^structure <pred>)
    (<pred> ^actions <act>)
    (<i*2> ^changes <changes>)
    (<i*1> ^status <status>)
    -->
    (<act> ^retrieve-handle <handle> +)
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type already-learned-action +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <de> +)
    (<de> ^type game-name + ^originator agent +)
}

sp {transfer-action-goal*elaborate*super-operator
    (state <s> ^name transfer-action-goal ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^handle-name <handle> ^structure <st> ^type <type>)
    (<st> ^from <game>)
   -{ (<s> ^top-state <t*2>)
      (<t*2> ^dialog-context <d*2>)
      (<d*2> ^name <game>)}
   -{ (<st> ^from { < <game> <game2> })
     -{ (<s> ^top-state <t*1>)
        (<t*1> ^dialog-context <d*1>)
        (<d*1> ^name <game2>)}}
    -->
    (<s> ^gtype <type> + ^game <game> + ^retrieve-handle <handle> +)
}

sp {transfer-predicate-structure*apply*complete*smem-query*result
    (state <s> ^name transfer-predicate-structure ^operator <o*1>
          ^nlp-functions <nf> ^nlp-relationships <gr> ^top-state <t*3>
          ^top-state <t*2> ^top-state <t*1> ^smem <s*3> ^superstate <s*1>)
    (<o*1> ^name complete)
    (<t*3> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<t*2> ^interaction <i*1>)
    (<t*1> ^dialog-context <dc>)
    (<i*1> ^status <status>)
    (<s*3> ^result <r*1>)
    (<r*1> ^retrieved <pred>)
    (<pred> ^predicate-structure <ps> ^handle <name>)
    (<s*1> ^superstate <s*2>)
    (<s*2> ^game <game>)
    -->
    (<dc> ^transfering <tf> + ^learning-predicate <lp> +)
    (<lp> ^name <name> +)
    (<tf> ^name <name> + ^lti <pred> + ^to <game> +)
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type transfer-concept + ^fields <f> +)
    (<f> ^relationships <gr> + ^concept-name <name> + ^functions <nf> +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <de> +)
    (<de> ^type game + ^originator agent +)
}

sp {BAD-TRANSFER*transfer-predicate-structure*elaborate*smem-query*unknown
    (state <s> ^name transfer-predicate-structure ^smem <s*1> ^superstate <ss>)
    (<s*1> ^result <r*1>)
    (<r*1> ^failure <f*1>)
    -->
    (halt)
    (<ss> ^unknown true +)
}

sp {transfer-predicate-structure*propose*complete
    (state <s> ^name transfer-predicate-structure ^smem <s*1>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <pred>)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete +)
}

sp {transfer-predicate-structure*propose*convert-NLP-to-language
    (state <s> ^name transfer-predicate-structure -^nlp-relationships <n*1>
          ^smem <s*1>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <r*2>)
    (<r*2> ^predicate-structure <ps>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name convert-NLP-to-language + ^structure <ps> +)
}

sp {transfer-predicate-structure*elaborate*smem-query
    (state <s> ^name transfer-predicate-structure ^handle <handle> ^smem <s*1>)
    (<s*1> ^command <c>)
    -->
    (<c> ^query <cue> + ^depth 15 +)
    (<cue> ^handle <handle> + ^item-type predicate +)
}

sp {transfer-predicate-structure*elaborate*predicate-lti
    (state <s> ^name transfer-predicate-structure ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^predicate-lti <lti>)
    -->
    (<s> ^predicate-lti <lti> +)
}

sp {transfer-predicate-structure*elaborate*condition
    :interrupt
    (state <s> ^name transfer-predicate-structure ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^condition <co>)
    -->
    (<s> ^condition <co> +)
}

sp {transfer-predicate-structure*elaborate*predicate-handle
    :interrupt
    (state <s> ^name transfer-predicate-structure ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^handle <handle>)
    -->
    (<s> ^handle <handle> +)
}

sp {chunk-puzzle-impasse*propose*complete
    (state <s> ^name chunk-puzzle-impasse)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete +)
}

sp {chunk-game-impasse*propose*complete
    (state <s> ^name chunk-game-impasse)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete +)
}

sp {chunk-puzzle-impasse*apply*complete
    (state <s> ^name chunk-puzzle-impasse ^operator <o*1> ^retrieve-handle <r>
          ^superstate <ss>)
    (<o*1> ^name complete)
    -->
    (<ss> ^retrieve-handle <r> +)
}

sp {chunk-puzzle-impasse*apply*complete*start-search-depth
    (state <s> ^name chunk-puzzle-impasse ^operator <o*1>
          ^start-search-depth <r> ^superstate <ss>)
    (<o*1> ^name complete)
    -->
    (<ss> ^start-search-depth <r> +)
}

sp {chunk-game-impasse*apply*complete*start-search-depth
    (state <s> ^name chunk-game-impasse ^operator <o*1>
          ^start-search-depth <r> ^superstate <ss>)
    (<o*1> ^name complete)
    -->
    (<ss> ^start-search-depth <r> +)
}

sp {chunk-game-impasse*apply*complete*opponent
    (state <s> ^name chunk-game-impasse ^opponent <r> ^retrieve-handle <r>
          ^superstate <ss> ^operator <o*1>)
    (<ss> ^opponent true)
    (<o*1> ^name complete)
    -->
    (<ss> ^retrieve-handle <r> +)
}

sp {chunk-game-impasse*apply*complete
    (state <s> ^name chunk-game-impasse ^retrieve-handle <r> -^opponent <r>
          ^superstate <ss> ^operator <o*1>)
    (<ss> ^opponent false)
    (<o*1> ^name complete)
    -->
    (<ss> ^retrieve-handle <r> +)
}

sp {chunk-puzzle-impasse*propose*retrieve-predicate-structure*action
    (state <s> ^name chunk-puzzle-impasse -^retrieve-handle <r*1>
          ^handle <name>)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name retrieve-game-structure + ^handle <name> +)
}

sp {chunk-game-impasse*propose*retrieve-predicate-structure*action
    (state <s> ^name chunk-game-impasse -^retrieve-handle <r*1> ^handle <name>)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name retrieve-game-structure + ^handle <name> +)
}

sp {chunk-puzzle-structure*impasse*actiongoal
    (state <s> ^choices none ^impasse no-change ^attribute state
          ^superstate <ss>)
    (<ss> -^opponent <o*1> ^retrieve-game <handle>)
    -->
    (force-learn <s>)
    (<s> ^name chunk-puzzle-impasse + ^linkstate <ss> + ^handle <handle> +)
}

sp {chunk-game-structure*impasse*actiongoal
    (state <s> ^choices none ^impasse no-change ^attribute state
          ^superstate <ss>)
    (<ss> ^opponent <o*1> ^retrieve-game <handle>)
    -->
    (force-learn <s>)
    (<s> ^name chunk-game-impasse + ^linkstate <ss> + ^handle <handle> +)
}

sp {chunk-game-structure*elaborate*opponent
    (state <s> ^name chunk-game-structure ^superstate <s*1>)
    (<s*1> ^opponent <op>)
    -->
    (<s> ^opponent <op> +)
}

sp {chunk-game-structure*elaborate*predicate-handle
    (state <s> ^name chunk-game-structure ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^predicate-handle <handle>)
    -->
    (<s> ^retrieve-game <handle> +)
}

sp {chunk-predicate-impasse*apply*complete*action
    (state <s> ^name chunk-predicate-impasse ^operator <o*1>
          ^gtype { << action goal failure heuristic >> <type> } ^handle <h>
          ^superstate <ss> ^<type> <p>)
    (<o*1> ^name complete)
    -->
    (<ss> ^<type> <p> +)
}

sp {chunk-predicate-impasse*apply*complete
    (state <s> ^name chunk-predicate-impasse -^handle <h*1> ^operator <o*1>
          ^gtype <gtype> ^predicate <p> ^<gtype> <g*1> ^superstate <ss>)
    (<o*1> ^name complete)
    (<p> ^link <co>)
    (<co> ^type concept ^attribute predicate)
    (<g*1> ^condition <co>)
    -->
    (<ss> ^predicate <p> + ^gtype predicate +)
}

sp {chunk-predicate-impasse*propose*complete
    (state <s> ^name chunk-predicate-impasse)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete +)
}

sp {chunk-predicate-impasse*propose*transfer-predicate-structure
    (state <s> ^name chunk-predicate-structure -^handle <h*1> ^unknown <u*1>
          ^gtype <gtype> ^<gtype> <g*1>)
    (<g*1> ^condition <co>)
    (<co> ^type concept ^attribute predicate ^name <name>)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name transfer-predicate-structure + ^condition <co> +
           ^handle <name> +)
}

sp {chunk-predicate-impasse*elaborate*dont-learn
    (state <s> ^name chunk-predicate-impasse ^unknown <u*1> ^superstate <ss>)
    -->
    (<ss> ^unknown true +)
}

sp {chunk-predicate-impasse*propose*retrieve-predicate-structure
    (state <s> ^name chunk-predicate-impasse -^unknown <u*1> -^handle <h*1>
          ^gtype <gtype> ^<gtype> <g*1>)
    (<g*1> ^condition <co>)
   -{ (<s> ^predicate <p*1>)
      (<p*1> ^link <co>)}
    (<co> ^type concept ^attribute predicate ^name <name>)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name retrieve-predicate-structure + ^condition <co> +
           ^handle <name> +)
}

sp {chunk-predicate-impasse*propose*retrieve-predicate-structure*action
    (state <s> ^name chunk-predicate-impasse -^goal <g*1> -^failure <f*1>
          -^heuristic <h*1> -^action <a*1> ^gtype <gtype> ^handle <name>)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name retrieve-predicate-structure + ^handle <name> +)
}

sp {chunk-predicate-structure*impasse454
    (state <s> ^choices none -^world <w*1> ^impasse no-change ^attribute state
          ^superstate <ss>)
    (<ss> ^gtype <t> ^<t> <a>)
    -->
    (<s> ^name chunk-predicate-impasse + ^linkstate <ss> + ^condition <co> +
           ^<t> <a> + ^gtype <t> +)
}

sp {chunk-predicate-structure*impasse
    (state <s> ^choices none -^world <w*1> ^impasse no-change ^attribute state
          ^superstate <ss>)
    (<ss> ^gtype <t> ^<t> <a>)
    -->
    (force-learn <s>)
}

sp {chunk-predicate-structure*impasse*actiongoal2323
    (state <s> ^choices none -^world <w*1> ^impasse no-change ^attribute state
          ^superstate <ss>)
    (<ss> ^gtype <t> ^retrieve-handle <handle>)
    -->
    (force-learn <s>)
}

sp {chunk-predicate-structure*impasse*actiongoal
    (state <s> ^choices none -^world <w*1> ^impasse no-change ^attribute state
          ^superstate <ss>)
    (<ss> ^gtype <t> ^retrieve-handle <handle>)
    -->
    (<s> ^name chunk-predicate-impasse + ^linkstate <ss> + ^handle <handle> +
           ^gtype <t> +)
}

sp {chunk-predicate-structure*elaborate*predicate-handle
    (state <s> ^name chunk-predicate-structure ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^gtype <gtype> ^predicate-handle <handle>)
    -->
    (<s> ^gtype <gtype> + ^retrieve-handle <handle> +)
}

sp {chunk-predicate-structure*elaborate*gtype
    (state <s> ^name chunk-predicate-structure ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^gtype <gtype> ^<gtype> <a>)
    -->
    (<s> ^gtype <gtype> + ^<gtype> <a> +)
}

sp {chunk-predicate-structure*elaborate*unknown
    :o-support
    (state <s> ^name check-smem-concept ^smem <s*1> ^superstate <ss>)
    (<s*1> ^result <r*1>)
    (<r*1> ^failure <f*1>)
    -->
    (<ss> ^unknown true +)
}

sp {check-smem-concept*elaborate*known*stored
    (state <s> ^stored true ^name check-smem-concept ^operator <o*1>
          ^superstate <ss>)
    (<o*1> ^name store-smem-transfer)
    -->
    (<ss> ^known true +)
}

sp {chunk-predicate-structure*elaborate*known-store
    :o-support
    (state <s> ^name store-smem-transfer ^smem <s*1> ^superstate <ss>)
    (<s*1> ^command <sc>)
    (<ss> ^re-store-game <r>)
    -->
    (<sc> ^store <r> +)
    (<ss> ^stored true +)
}

sp {chunk-predicate-structure*elaborate*from
    (state <s> ^name check-smem-concept ^operator <o*1> ^smem <s*1>
          ^superstate <ss>)
    (<o*1> ^name store-smem-transfer)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <r>)
    (<ss> ^game <game> ^superstate <s*2>)
    (<s*2> ^superstate <s*3>)
    (<s*3> ^name transfer-action-goal)
    -->
    (<s> ^re-store-game <r> +)
    (<r> ^from <game> +)
}

sp {chunk-predicate-structure*elaborate*known
    :o-support
    (state <s> ^name check-smem-concept ^superstate <ss> ^smem <s*1>)
   -{ (<ss> ^superstate <s*2>)
      (<s*2> ^superstate <s*3>)
      (<s*3> ^name transfer-action-goal)}
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <r*2>)
    -->
    (<ss> ^known true +)
}

sp {chunk-predicate-structure*elaborate*smem-query*auto-transfer
    (state <s> ^name check-smem-concept ^smem <s*1> ^superstate <ss>)
    (<s*1> ^command <c>)
    (<ss> ^gtype <gtype> ^<gtype> <g*1>)
    (<g*1> ^condition <co>)
    (<co> ^type concept ^attribute predicate ^name <name>)
    -->
    (<c> ^query <cue> + ^depth 1 +)
    (<cue> ^handle <name> + ^item-type predicate +)
}

sp {check-smem-concept*propose*complete
    (state <s> ^name check-smem-concept ^superstate <s*1>)
    (<s*1> ^superstate <s*2>)
    (<s*2> ^superstate <s*3>)
    (<s*3> ^name transfer-action-goal)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name store-smem-transfer +)
}

sp {chunk-predicate-structure*propose*check-smem-concept
    (state <s> ^name chunk-predicate-structure -^known <k*1> -^unknown <u*1>
          -^retrieve-handle <r*1>)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name check-smem-concept +)
}

sp {chunk-predicate-structure*propose*complete
    (state <s> ^name chunk-predicate-structure ^gtype <t>
          ^retrieve-handle <r*1> ^<t> <p>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name complete +)
}

sp {chunk-predicate-structure*elaborate*result*actiongoal
    (state <s> ^name chunk-predicate-structure ^operator <o*1> ^gtype <t>
          ^retrieve-handle <r*1> ^superstate <ss> ^<t> <p>)
    (<o*1> ^name complete)
    -->
    (<ss> ^<t> <p> +)
}

sp {chunk-predicate-structure*elaborate*result
    (state <s> ^name chunk-predicate-structure ^gtype <gtype> ^predicate <p>
          ^superstate <ss> ^<gtype> <g*1>)
    (<p> ^handle <name>)
    (<g*1> ^condition <c*1>)
    (<c*1> ^name <name>)
    -->
    (<ss> ^predicate <p> + ^gtype predicate +)
}

sp {satisfy-predicate-conditions*elaborate*potential-argument
    (state <s1> ^list <l1> ^gtype <c2> ^<c2> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^potential-args <p1> ^parameter-set <p2> ^condition <c1>)
    (<c1> ^parameter <p3> ^result <r1>)
    (<r1> ^set <s2>)
    (<s2> ^instance <p5>)
    (<p5> ^1 <o2> ^<c4> <o1>)
   -{ (<o2> -^<wme> <w*1>)
      (<s1> ^list <l*1>)}
    (<p3> ^{ << 1 2 3 4 5 >> <c4> } <p4>)
    (<p4> ^param-id <c6>)
    -->
    (<p1> ^<c6> <o1> +)
}

sp {satisfy-predicate-conditions*elaborate*potential-argument*number
    (state <s1> ^list <l1> ^gtype <c1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^condition <c3> ^potential-args <p1> ^parameter-set <p2>)
    (<c3> ^return-type number ^rtype single ^parameter <p3> ^result <r1>)
    (<r1> ^set <s2>)
    (<s2> ^instance <p5>)
    (<p5> ^1 <v*1> ^<c4> <c7>)
    (<p3> ^<c4> <p4>)
    (<p4> ^param-id <c6>)
    -->
    (<p1> ^<c6> <c7> +)
}

sp {satisfy-predicate-conditions*elaborate*negative-condition-instance*1-argument
    (state <s1> ^list <l1> ^gtype <c2> ^<c2> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1> ^condition <c1>)
    (<p2> ^tested calculate3)
    (<c1> ^parameter <p3> ^result <r1>)
    (<p3> ^<c6> <p4>)
    (<p4> ^param-id <c4>)
    (<p1> ^<c4> <o1>)
   -{ (<r1> ^set <s*1>)
      (<s*1> ^instance <p*1>)
      (<p*1> ^<c6> <o1>)}
    -->
    (<p2> ^neg <n1> +)
    (<n1> ^<c4> <o1> +)
}

sp {satisfy-predicate-conditions*elaborate*negative-condition-instance*3-arguments
    (state <s1> ^list <l1> ^gtype <c19> ^<c19> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p1> ^potential-args <p2> ^condition <c1>)
    (<p1> ^tested calculate3)
    (<c1> ^parameter <p3> ^result <r1>)
    (<p3> ^num 3 ^2 <*2> ^3 <*1> ^1 <*3>)
    (<*2> ^param-id <ar1>)
    (<*1> ^param-id <ar2>)
    (<*3> ^param-id <ar3>)
    (<p2> ^<ar1> <*6> ^<ar2> <*5> ^<ar3> <*4>)
   -{ (<r1> ^set <s2>)
      (<s2> ^instance <p4>)
      (<p4> ^2 <*6> ^3 <*5> ^1 <*4>)}
    -->
    (<p1> ^negpair3 <n1> +)
    (<n1> ^<ar1> <*6> + ^<ar2> <*5> + ^<ar3> <*4> +)
}

sp {satisfy-predicate-conditions*elaborate*negative-condition-instance*2-arguments
    (state <s1> ^list <l1> ^gtype <c2> ^<c2> <p1>)
    (<l1> ^game <g1>)
    (<p1> ^parameter-set <p2> ^potential-args <p3> ^condition <c1>)
    (<p2> ^tested calculate3)
    (<c1> ^parameter <p4> ^result <r1>)
    (<p4> ^num 2 ^2 <*1> ^1 <*2>)
    (<*1> ^param-id <x1>)
    (<*2> ^param-id <x2>)
    (<p3> ^<x1> <*4> ^<x2> <*3>)
   -{ (<r1> ^set <s2>)
      (<s2> ^instance <p5>)
      (<p5> ^2 <*4> ^1 <*3>)}
    -->
    (<p2> ^negpair <n1> +)
    (<n1> ^<x2> <*3> + ^<x1> <*4> +)
}

sp {satisfy-predicate-conditions*elaborate*initial-set*1-arguments
    (state <s1> ^list <l1> ^gtype <c1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate6 ^argnum 1)
    (<p1> ^1 <o1>)
   -{ (<p2> ^neg <n1>)
      (<n1> ^1 <o1>)}
    -->
    (<p2> ^iset <i1> +)
    (<i1> ^1 <o1> +)
}

sp {satisfy-predicate-conditions*elaborate*initial-set*4-arguments
    (state <s1> ^list <l1> ^gtype <c1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate6 ^argnum 4)
    (<p1> ^4 <o4> ^2 <o2> ^3 <o3> ^1 <o1>)
   -{ (<p2> ^neg <n4>)
      (<n4> ^4 <o4>)}
   -{ (<p2> ^negpair <pair5>)
      (<pair5> ^4 <o4> ^2 <o2>)}
   -{ (<p2> ^neg <n2>)
      (<n2> ^2 <o2>)}
   -{ (<p2> ^negpair <pair6>)
      (<pair6> ^4 <o4> ^3 <o3>)}
   -{ (<p2> ^negpair <pair4>)
      (<pair4> ^2 <o2> ^3 <o3>)}
   -{ (<p2> ^neg <n3>)
      (<n3> ^3 <o3>)}
   -{ (<p2> ^negpair <pair3>)
      (<pair3> ^4 <o4> ^1 <o1>)}
   -{ (<p2> ^negpair <pair2>)
      (<pair2> ^3 <o3> ^1 <o1>)}
   -{ (<p2> ^negpair <pair1>)
      (<pair1> ^2 <o2> ^1 <o1>)}
   -{ (<p2> ^neg <n1>)
      (<n1> ^1 <o1>)}
    -->
    (<p2> ^iset <i1> +)
    (<i1> ^4 <o4> + ^1 <o1> + ^2 <o2> + ^3 <o3> +)
}

sp {satisfy-predicate-conditions*elaborate*initial-set*16-arguments
    (state <s1> ^list <l1> ^gtype <c1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate6 ^argnum 16)
    (<p1> ^16 <o16> ^15 <o15> ^14 <o14> ^13 <o13> ^12 <o12> ^11 <o11> ^9 <o9>
          ^8 <o8> ^7 <o7> ^6 <o6> ^4 <o4> ^2 <o2> ^10 <o10> ^5 <o5> ^3 <o3>
          ^1 <o1>)
   -{ (<p2> ^neg <n16>)
      (<n16> ^16 <o16>)}
   -{ (<p2> ^negpair <pair5>)
      (<pair5> ^16 <o16> ^15 <o15>)}
   -{ (<p2> ^neg <n15>)
      (<n15> ^15 <o15>)}
   -{ (<p2> ^negpair <pair5>)
      (<pair5> ^16 <o16> ^14 <o14>)}
   -{ (<p2> ^negpair <pair4>)
      (<pair4> ^15 <o15> ^14 <o14>)}
   -{ (<p2> ^neg <n14>)
      (<n14> ^14 <o14>)}
   -{ (<p2> ^negpair <pair5>)
      (<pair5> ^16 <o16> ^13 <o13>)}
   -{ (<p2> ^negpair <pair4>)
      (<pair4> ^15 <o15> ^13 <o13>)}
   -{ (<p2> ^negpair <pair3>)
      (<pair3> ^14 <o14> ^13 <o13>)}
   -{ (<p2> ^neg <n13>)
      (<n13> ^13 <o13>)}
   -{ (<p2> ^negpair <pair5>)
      (<pair5> ^16 <o16> ^12 <o12>)}
   -{ (<p2> ^negpair <pair4>)
      (<pair4> ^15 <o15> ^12 <o12>)}
   -{ (<p2> ^negpair <pair3>)
      (<pair3> ^14 <o14> ^12 <o12>)}
   -{ (<p2> ^negpair <pair2>)
      (<pair2> ^13 <o13> ^12 <o12>)}
   -{ (<p2> ^neg <n12>)
      (<n12> ^12 <o12>)}
   -{ (<p2> ^negpair <pair5>)
      (<pair5> ^16 <o16> ^11 <o11>)}
   -{ (<p2> ^negpair <pair4>)
      (<pair4> ^15 <o15> ^11 <o11>)}
   -{ (<p2> ^negpair <pair3>)
      (<pair3> ^14 <o14> ^11 <o11>)}
   -{ (<p2> ^negpair <pair2>)
      (<pair2> ^13 <o13> ^11 <o11>)}
   -{ (<p2> ^negpair <pair1>)
      (<pair1> ^12 <o12> ^11 <o11>)}
   -{ (<p2> ^neg <n11>)
      (<n11> ^11 <o11>)}
   -{ (<p2> ^negpair <pair5>)
      (<pair5> ^16 <o16> ^9 <o9>)}
   -{ (<p2> ^negpair <pair4>)
      (<pair4> ^15 <o15> ^9 <o9>)}
   -{ (<p2> ^negpair <pair3>)
      (<pair3> ^14 <o14> ^9 <o9>)}
   -{ (<p2> ^negpair <pair2>)
      (<pair2> ^13 <o13> ^9 <o9>)}
   -{ (<p2> ^negpair <pair1>)
      (<pair1> ^12 <o12> ^9 <o9>)}
   -{ (<p2> ^negpair <pair7>)
      (<pair7> ^11 <o11> ^9 <o9>)}
   -{ (<p2> ^neg <n9>)
      (<n9> ^9 <o9>)}
   -{ (<p2> ^negpair <pair5>)
      (<pair5> ^16 <o16> ^8 <o8>)}
   -{ (<p2> ^negpair <pair4>)
      (<pair4> ^15 <o15> ^8 <o8>)}
   -{ (<p2> ^negpair <pair3>)
      (<pair3> ^14 <o14> ^8 <o8>)}
   -{ (<p2> ^negpair <pair2>)
      (<pair2> ^13 <o13> ^8 <o8>)}
   -{ (<p2> ^negpair <pair1>)
      (<pair1> ^12 <o12> ^8 <o8>)}
   -{ (<p2> ^negpair <pair7>)
      (<pair7> ^11 <o11> ^8 <o8>)}
   -{ (<p2> ^negpair <pair6>)
      (<pair6> ^9 <o9> ^8 <o8>)}
   -{ (<p2> ^neg <n8>)
      (<n8> ^8 <o8>)}
   -{ (<p2> ^negpair <pair5>)
      (<pair5> ^16 <o16> ^7 <o7>)}
   -{ (<p2> ^negpair <pair4>)
      (<pair4> ^15 <o15> ^7 <o7>)}
   -{ (<p2> ^negpair <pair3>)
      (<pair3> ^14 <o14> ^7 <o7>)}
   -{ (<p2> ^negpair <pair2>)
      (<pair2> ^13 <o13> ^7 <o7>)}
   -{ (<p2> ^negpair <pair1>)
      (<pair1> ^12 <o12> ^7 <o7>)}
   -{ (<p2> ^negpair <pair7>)
      (<pair7> ^11 <o11> ^7 <o7>)}
   -{ (<p2> ^negpair <pair6>)
      (<pair6> ^9 <o9> ^7 <o7>)}
   -{ (<p2> ^negpair <pair7>)
      (<pair7> ^8 <o8> ^7 <o7>)}
   -{ (<p2> ^neg <n7>)
      (<n7> ^7 <o7>)}
   -{ (<p2> ^negpair <pair5>)
      (<pair5> ^16 <o16> ^6 <o6>)}
   -{ (<p2> ^negpair <pair4>)
      (<pair4> ^15 <o15> ^6 <o6>)}
   -{ (<p2> ^negpair <pair3>)
      (<pair3> ^14 <o14> ^6 <o6>)}
   -{ (<p2> ^negpair <pair2>)
      (<pair2> ^13 <o13> ^6 <o6>)}
   -{ (<p2> ^negpair <pair1>)
      (<pair1> ^12 <o12> ^6 <o6>)}
   -{ (<p2> ^negpair <pair7>)
      (<pair7> ^11 <o11> ^6 <o6>)}
   -{ (<p2> ^negpair <pair6>)
      (<pair6> ^9 <o9> ^6 <o6>)}
   -{ (<p2> ^negpair <pair7>)
      (<pair7> ^8 <o8> ^6 <o6>)}
   -{ (<p2> ^negpair <pair6>)
      (<pair6> ^7 <o7> ^6 <o6>)}
   -{ (<p2> ^neg <n6>)
      (<n6> ^6 <o6>)}
   -{ (<p2> ^negpair <pair5>)
      (<pair5> ^16 <o16> ^4 <o4>)}
   -{ (<p2> ^negpair <pair4>)
      (<pair4> ^15 <o15> ^4 <o4>)}
   -{ (<p2> ^negpair <pair3>)
      (<pair3> ^14 <o14> ^4 <o4>)}
   -{ (<p2> ^negpair <pair2>)
      (<pair2> ^13 <o13> ^4 <o4>)}
   -{ (<p2> ^negpair <pair1>)
      (<pair1> ^12 <o12> ^4 <o4>)}
   -{ (<p2> ^negpair <pair7>)
      (<pair7> ^11 <o11> ^4 <o4>)}
   -{ (<p2> ^negpair <pair6>)
      (<pair6> ^9 <o9> ^4 <o4>)}
   -{ (<p2> ^negpair <pair7>)
      (<pair7> ^8 <o8> ^4 <o4>)}
   -{ (<p2> ^negpair <pair6>)
      (<pair6> ^7 <o7> ^4 <o4>)}
   -{ (<p2> ^negpair <pair5>)
      (<pair5> ^6 <o6> ^4 <o4>)}
   -{ (<p2> ^neg <n4>)
      (<n4> ^4 <o4>)}
   -{ (<p2> ^negpair <pair5>)
      (<pair5> ^16 <o16> ^2 <o2>)}
   -{ (<p2> ^negpair <pair4>)
      (<pair4> ^15 <o15> ^2 <o2>)}
   -{ (<p2> ^negpair <pair3>)
      (<pair3> ^14 <o14> ^2 <o2>)}
   -{ (<p2> ^negpair <pair2>)
      (<pair2> ^13 <o13> ^2 <o2>)}
   -{ (<p2> ^negpair <pair1>)
      (<pair1> ^12 <o12> ^2 <o2>)}
   -{ (<p2> ^negpair <pair7>)
      (<pair7> ^11 <o11> ^2 <o2>)}
   -{ (<p2> ^negpair <pair6>)
      (<pair6> ^9 <o9> ^2 <o2>)}
   -{ (<p2> ^negpair <pair7>)
      (<pair7> ^8 <o8> ^2 <o2>)}
   -{ (<p2> ^negpair <pair6>)
      (<pair6> ^7 <o7> ^2 <o2>)}
   -{ (<p2> ^negpair <pair5>)
      (<pair5> ^6 <o6> ^2 <o2>)}
   -{ (<p2> ^negpair <pair3>)
      (<pair3> ^4 <o4> ^2 <o2>)}
   -{ (<p2> ^neg <n2>)
      (<n2> ^2 <o2>)}
   -{ (<p2> ^negpair <pair5>)
      (<pair5> ^16 <o16> ^10 <o10>)}
   -{ (<p2> ^negpair <pair4>)
      (<pair4> ^15 <o15> ^10 <o10>)}
   -{ (<p2> ^negpair <pair3>)
      (<pair3> ^14 <o14> ^10 <o10>)}
   -{ (<p2> ^negpair <pair2>)
      (<pair2> ^13 <o13> ^10 <o10>)}
   -{ (<p2> ^negpair <pair1>)
      (<pair1> ^12 <o12> ^10 <o10>)}
   -{ (<p2> ^negpair <pair7>)
      (<pair7> ^11 <o11> ^10 <o10>)}
   -{ (<p2> ^negpair <pair7>)
      (<pair7> ^9 <o9> ^10 <o10>)}
   -{ (<p2> ^negpair <pair7>)
      (<pair7> ^8 <o8> ^10 <o10>)}
   -{ (<p2> ^negpair <pair7>)
      (<pair7> ^7 <o7> ^10 <o10>)}
   -{ (<p2> ^negpair <pair7>)
      (<pair7> ^6 <o6> ^10 <o10>)}
   -{ (<p2> ^negpair <pair7>)
      (<pair7> ^4 <o4> ^10 <o10>)}
   -{ (<p2> ^negpair <pair7>)
      (<pair7> ^2 <o2> ^10 <o10>)}
   -{ (<p2> ^neg <n10>)
      (<n10> ^1 <o10>)}
   -{ (<p2> ^negpair <pair5>)
      (<pair5> ^16 <o16> ^5 <o5>)}
   -{ (<p2> ^negpair <pair4>)
      (<pair4> ^15 <o15> ^5 <o5>)}
   -{ (<p2> ^negpair <pair3>)
      (<pair3> ^14 <o14> ^5 <o5>)}
   -{ (<p2> ^negpair <pair2>)
      (<pair2> ^13 <o13> ^5 <o5>)}
   -{ (<p2> ^negpair <pair1>)
      (<pair1> ^12 <o12> ^5 <o5>)}
   -{ (<p2> ^negpair <pair7>)
      (<pair7> ^11 <o11> ^5 <o5>)}
   -{ (<p2> ^negpair <pair7>)
      (<pair7> ^10 <o10> ^5 <o5>)}
   -{ (<p2> ^negpair <pair6>)
      (<pair6> ^9 <o9> ^5 <o5>)}
   -{ (<p2> ^negpair <pair7>)
      (<pair7> ^8 <o8> ^5 <o5>)}
   -{ (<p2> ^negpair <pair6>)
      (<pair6> ^7 <o7> ^5 <o5>)}
   -{ (<p2> ^negpair <pair5>)
      (<pair5> ^6 <o6> ^5 <o5>)}
   -{ (<p2> ^negpair <pair4>)
      (<pair4> ^4 <o4> ^5 <o5>)}
   -{ (<p2> ^negpair <pair4>)
      (<pair4> ^2 <o2> ^5 <o5>)}
   -{ (<p2> ^neg <n5>)
      (<n5> ^5 <o5>)}
   -{ (<p2> ^negpair <pair5>)
      (<pair5> ^16 <o16> ^3 <o3>)}
   -{ (<p2> ^negpair <pair4>)
      (<pair4> ^15 <o15> ^3 <o3>)}
   -{ (<p2> ^negpair <pair3>)
      (<pair3> ^14 <o14> ^3 <o3>)}
   -{ (<p2> ^negpair <pair2>)
      (<pair2> ^13 <o13> ^3 <o3>)}
   -{ (<p2> ^negpair <pair1>)
      (<pair1> ^12 <o12> ^3 <o3>)}
   -{ (<p2> ^negpair <pair7>)
      (<pair7> ^11 <o11> ^3 <o3>)}
   -{ (<p2> ^negpair <pair7>)
      (<pair7> ^10 <o10> ^3 <o3>)}
   -{ (<p2> ^negpair <pair6>)
      (<pair6> ^9 <o9> ^3 <o3>)}
   -{ (<p2> ^negpair <pair7>)
      (<pair7> ^8 <o8> ^3 <o3>)}
   -{ (<p2> ^negpair <pair6>)
      (<pair6> ^7 <o7> ^3 <o3>)}
   -{ (<p2> ^negpair <pair5>)
      (<pair5> ^6 <o6> ^3 <o3>)}
   -{ (<p2> ^negpair <pair4>)
      (<pair4> ^5 <o5> ^3 <o3>)}
   -{ (<p2> ^negpair <pair3>)
      (<pair3> ^4 <o4> ^3 <o3>)}
   -{ (<p2> ^negpair <pair2>)
      (<pair2> ^2 <o2> ^3 <o3>)}
   -{ (<p2> ^neg <n3>)
      (<n3> ^3 <o3>)}
   -{ (<p2> ^negpair <pair5>)
      (<pair5> ^16 <o16> ^1 <o1>)}
   -{ (<p2> ^negpair <pair4>)
      (<pair4> ^15 <o15> ^1 <o1>)}
   -{ (<p2> ^negpair <pair3>)
      (<pair3> ^14 <o14> ^1 <o1>)}
   -{ (<p2> ^negpair <pair2>)
      (<pair2> ^13 <o13> ^1 <o1>)}
   -{ (<p2> ^negpair <pair1>)
      (<pair1> ^12 <o12> ^1 <o1>)}
   -{ (<p2> ^negpair <pair7>)
      (<pair7> ^11 <o11> ^1 <o1>)}
   -{ (<p2> ^negpair <pair7>)
      (<pair7> ^10 <o10> ^1 <o1>)}
   -{ (<p2> ^negpair <pair6>)
      (<pair6> ^9 <o9> ^1 <o1>)}
   -{ (<p2> ^negpair <pair7>)
      (<pair7> ^8 <o8> ^1 <o1>)}
   -{ (<p2> ^negpair <pair6>)
      (<pair6> ^7 <o7> ^1 <o1>)}
   -{ (<p2> ^negpair <pair5>)
      (<pair5> ^6 <o6> ^1 <o1>)}
   -{ (<p2> ^negpair <pair4>)
      (<pair4> ^5 <o5> ^1 <o1>)}
   -{ (<p2> ^negpair <pair3>)
      (<pair3> ^4 <o4> ^1 <o1>)}
   -{ (<p2> ^negpair <pair2>)
      (<pair2> ^3 <o3> ^1 <o1>)}
   -{ (<p2> ^negpair <pair1>)
      (<pair1> ^2 <o2> ^1 <o1>)}
   -{ (<p2> ^neg <n1>)
      (<n1> ^1 <o1>)}
    -->
    (<p2> ^iset <i1> +)
    (<i1> ^8 <o8> + ^7 <o7> + ^6 <o6> + ^5 <o5> + ^4 <o4> + ^1 <o1> +
           ^2 <o2> + ^3 <o3> + ^9 <o9> + ^10 <o10> + ^16 <o16> + ^15 <o15> +
           ^14 <o14> + ^13 <o13> + ^12 <o12> + ^11 <o11> +)
}

sp {satisfy-predicate-conditions*elaborate*initial-set*8-arguments
    (state <s1> ^list <l1> ^gtype <c1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate6 ^argnum 8)
    (<p1> ^8 <o8> ^7 <o7> ^6 <o6> ^4 <o4> ^2 <o2> ^5 <o5> ^3 <o3> ^1 <o1>)
   -{ (<p2> ^neg <n8>)
      (<n8> ^8 <o8>)}
   -{ (<p2> ^neg <n7>)
      (<n7> ^5 <o7>)}
   -{ (<p2> ^negpair <pair29>)
      (<pair29> ^8 <o8> ^6 <o6>)}
   -{ (<p2> ^negpair <pair28>)
      (<pair28> ^7 <o7> ^6 <o6>)}
   -{ (<p2> ^neg <n6>)
      (<n6> ^6 <o6>)}
   -{ (<p2> ^negpair <pair24>)
      (<pair24> ^8 <o8> ^4 <o4>)}
   -{ (<p2> ^negpair <pair23>)
      (<pair23> ^7 <o7> ^4 <o4>)}
   -{ (<p2> ^negpair <pair22>)
      (<pair22> ^6 <o6> ^4 <o4>)}
   -{ (<p2> ^neg <n4>)
      (<n4> ^4 <o4>)}
   -{ (<p2> ^negpair <pair30>)
      (<pair30> ^8 <o8> ^7 <o2>)}
   -{ (<p2> ^negpair <pair13>)
      (<pair13> ^8 <o8> ^2 <o2>)}
   -{ (<p2> ^negpair <pair12>)
      (<pair12> ^7 <o7> ^2 <o2>)}
   -{ (<p2> ^negpair <pair11>)
      (<pair11> ^6 <o6> ^2 <o2>)}
   -{ (<p2> ^negpair <pair9>)
      (<pair9> ^4 <o4> ^2 <o2>)}
   -{ (<p2> ^neg <n2>)
      (<n2> ^2 <o2>)}
   -{ (<p2> ^negpair <pair27>)
      (<pair27> ^8 <o8> ^5 <o5>)}
   -{ (<p2> ^negpair <pair26>)
      (<pair26> ^7 <o7> ^5 <o5>)}
   -{ (<p2> ^negpair <pair25>)
      (<pair25> ^6 <o6> ^5 <o5>)}
   -{ (<p2> ^negpair <pair21>)
      (<pair21> ^4 <o4> ^5 <o5>)}
   -{ (<p2> ^negpair <pair10>)
      (<pair10> ^2 <o2> ^5 <o5>)}
   -{ (<p2> ^neg <n5>)
      (<n5> ^5 <o5>)}
   -{ (<p2> ^negpair <pair18>)
      (<pair18> ^8 <o8> ^3 <o3>)}
   -{ (<p2> ^negpair <pair17>)
      (<pair17> ^7 <o7> ^3 <o3>)}
   -{ (<p2> ^negpair <pair16>)
      (<pair16> ^6 <o6> ^3 <o3>)}
   -{ (<p2> ^negpair <pair15>)
      (<pair15> ^5 <o5> ^3 <o3>)}
   -{ (<p2> ^negpair <pair14>)
      (<pair14> ^4 <o4> ^3 <o3>)}
   -{ (<p2> ^negpair <pair8>)
      (<pair8> ^2 <o2> ^3 <o3>)}
   -{ (<p2> ^neg <n3>)
      (<n3> ^3 <o3>)}
   -{ (<p2> ^negpair <pair7>)
      (<pair7> ^8 <o8> ^1 <o1>)}
   -{ (<p2> ^negpair <pair6>)
      (<pair6> ^7 <o7> ^1 <o1>)}
   -{ (<p2> ^negpair <pair5>)
      (<pair5> ^6 <o6> ^1 <o1>)}
   -{ (<p2> ^negpair <pair4>)
      (<pair4> ^5 <o5> ^1 <o1>)}
   -{ (<p2> ^negpair <pair3>)
      (<pair3> ^4 <o4> ^1 <o1>)}
   -{ (<p2> ^negpair <pair2>)
      (<pair2> ^3 <o3> ^1 <o1>)}
   -{ (<p2> ^negpair <pair1>)
      (<pair1> ^2 <o2> ^1 <o1>)}
   -{ (<p2> ^neg <n1>)
      (<n1> ^1 <o1>)}
    -->
    (<p2> ^iset <i1> +)
    (<i1> ^8 <o8> + ^7 <o7> + ^6 <o6> + ^5 <o5> + ^4 <o4> + ^1 <o1> +
           ^2 <o2> + ^3 <o3> +)
}

sp {satisfy-predicate-conditions*elaborate*initial-set*6-arguments
    (state <s1> ^list <l1> ^gtype <c1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate6 ^argnum 6)
    (<p1> ^6 <o6> ^4 <o4> ^2 <o2> ^5 <o5> ^3 <o3> ^1 <o1>)
   -{ (<p2> ^neg <n6>)
      (<n6> ^6 <o6>)}
   -{ (<p2> ^negpair <pair22>)
      (<pair22> ^6 <o6> ^4 <o4>)}
   -{ (<p2> ^neg <n4>)
      (<n4> ^4 <o4>)}
   -{ (<p2> ^negpair <pair11>)
      (<pair11> ^6 <o6> ^2 <o2>)}
   -{ (<p2> ^negpair <pair9>)
      (<pair9> ^4 <o4> ^2 <o2>)}
   -{ (<p2> ^neg <n2>)
      (<n2> ^2 <o2>)}
   -{ (<p2> ^negpair <pair25>)
      (<pair25> ^6 <o6> ^5 <o5>)}
   -{ (<p2> ^negpair <pair21>)
      (<pair21> ^4 <o4> ^5 <o5>)}
   -{ (<p2> ^negpair <pair10>)
      (<pair10> ^2 <o2> ^5 <o5>)}
   -{ (<p2> ^neg <n5>)
      (<n5> ^5 <o5>)}
   -{ (<p2> ^negpair <pair16>)
      (<pair16> ^6 <o6> ^3 <o3>)}
   -{ (<p2> ^negpair <pair15>)
      (<pair15> ^5 <o5> ^3 <o3>)}
   -{ (<p2> ^negpair <pair14>)
      (<pair14> ^4 <o4> ^3 <o3>)}
   -{ (<p2> ^negpair <pair8>)
      (<pair8> ^2 <o2> ^3 <o3>)}
   -{ (<p2> ^neg <n3>)
      (<n3> ^3 <o3>)}
   -{ (<p2> ^negpair <pair5>)
      (<pair5> ^6 <o6> ^1 <o1>)}
   -{ (<p2> ^negpair <pair4>)
      (<pair4> ^5 <o5> ^1 <o1>)}
   -{ (<p2> ^negpair <pair3>)
      (<pair3> ^4 <o4> ^1 <o1>)}
   -{ (<p2> ^negpair <pair2>)
      (<pair2> ^3 <o3> ^1 <o1>)}
   -{ (<p2> ^negpair <pair1>)
      (<pair1> ^2 <o2> ^1 <o1>)}
   -{ (<p2> ^neg <n1>)
      (<n1> ^1 <o1>)}
    -->
    (<p2> ^iset <i1> +)
    (<i1> ^6 <o6> + ^5 <o5> + ^4 <o4> + ^1 <o1> + ^2 <o2> + ^3 <o3> +)
}

sp {satisfy-predicate-conditions*elaborate*initial-set*5-arguments
    (state <s1> ^list <l1> ^gtype <c1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate6 ^argnum 5)
    (<p1> ^4 <o4> ^2 <o2> ^5 <o5> ^3 <o3> ^1 <o1>)
   -{ (<p2> ^neg <n4>)
      (<n4> ^4 <o4>)}
   -{ (<p2> ^negpair <pair9>)
      (<pair9> ^4 <o4> ^2 <o2>)}
   -{ (<p2> ^neg <n2>)
      (<n2> ^2 <o2>)}
   -{ (<p2> ^negpair <pair21>)
      (<pair21> ^4 <o4> ^5 <o5>)}
   -{ (<p2> ^negpair <pair10>)
      (<pair10> ^2 <o2> ^5 <o5>)}
   -{ (<p2> ^neg <n5>)
      (<n5> ^5 <o5>)}
   -{ (<p2> ^negpair <pair15>)
      (<pair15> ^5 <o5> ^3 <o3>)}
   -{ (<p2> ^negpair <pair14>)
      (<pair14> ^4 <o4> ^3 <o3>)}
   -{ (<p2> ^negpair <pair8>)
      (<pair8> ^2 <o2> ^3 <o3>)}
   -{ (<p2> ^neg <n3>)
      (<n3> ^3 <o3>)}
   -{ (<p2> ^negpair <pair4>)
      (<pair4> ^5 <o5> ^1 <o1>)}
   -{ (<p2> ^negpair <pair3>)
      (<pair3> ^4 <o4> ^1 <o1>)}
   -{ (<p2> ^negpair <pair2>)
      (<pair2> ^3 <o3> ^1 <o1>)}
   -{ (<p2> ^negpair <pair1>)
      (<pair1> ^2 <o2> ^1 <o1>)}
   -{ (<p2> ^neg <n1>)
      (<n1> ^1 <o1>)}
    -->
    (<p2> ^iset <i1> +)
    (<i1> ^5 <o5> + ^4 <o4> + ^1 <o1> + ^2 <o2> + ^3 <o3> +)
}

sp {satisfy-predicate-conditions*elaborate*initial-set*2-arguments
    (state <s1> ^list <l1> ^gtype <c1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate6 ^argnum 2)
    (<p1> ^2 <o2> ^1 <o1>)
   -{ (<p2> ^neg <n2>)
      (<n2> ^2 <o2>)}
   -{ (<p2> ^negpair <pair1>)
      (<pair1> ^2 <o2> ^1 <o1>)}
   -{ (<p2> ^neg <n1>)
      (<n1> ^1 <o1>)}
    -->
    (<p2> ^iset <i1> +)
    (<i1> ^1 <o1> + ^2 <o2> +)
}

sp {satisfy-predicate-conditions*elaborate*initial-set*3-arguments
    (state <s1> ^list <l1> ^gtype <c1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate6 ^argnum 3)
    (<p1> ^2 <o2> ^3 <o3> ^1 <o1>)
   -{ (<p2> ^neg <n2>)
      (<n2> ^2 <o2>)}
   -{ (<p2> ^negpair <pair8>)
      (<pair8> ^2 <o2> ^3 <o3>)}
   -{ (<p2> ^neg <n3>)
      (<n3> ^3 <o3>)}
   -{ (<p2> ^negpair <pair2>)
      (<pair2> ^3 <o3> ^1 <o1>)}
   -{ (<p2> ^negpair <pair1>)
      (<pair1> ^2 <o2> ^1 <o1>)}
   -{ (<p2> ^neg <n1>)
      (<n1> ^1 <o1>)}
    -->
    (<p2> ^iset <i1> +)
    (<i1> ^1 <o1> + ^2 <o2> + ^3 <o3> +)
}

sp {satisfy-predicate-conditions*elaborate*result*set
    (state <s1> ^list <l1> ^gtype <c1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate3 ^tested calculate6 ^tested calculate4
          ^tested calculate5 ^tested calculate2 ^tested calculate1 ^iset <i1>)
   -{ (<i1> ^<ind1> { <=> <i1> <obja> } ^<ind1> <obja>
            ^{ <> <ind1> <ind2> } <obja>)}
   -{ (<p2> ^negpair <pair>)
      (<i1> ^<ind1> <obja> ^{ <> <ind1> <ind2> } <objb>)
      (<pair> ^<ind1> <obja> ^<ind2> <objb>)}
   -{ (<p2> ^negpair3 <pair3>)
      (<i1> ^<ind1> <obja> ^{ <> <ind1> <ind2> } <objb>
            ^{ <> <ind2> <> <ind1> <ind3> } <objc>)
      (<pair3> ^<ind1> <obja> ^<ind2> <objb> ^<ind3> <objc>)}
   -{ (<p2> ^neg <neg1>)
      (<i1> ^<ind4> <obj3>)
      (<neg1> ^<ind4> <obj3>)}
    -->
    (<p2> ^set <i1> +)
}

sp {satisfy-predicate-conditions*elaborate*instance*from-predicate-results
    (state <s1> ^gtype predicate ^list <l1> ^predicate <p1>)
    (<l1> ^game <g1>)
    (<p1> ^parameter-set <p2> ^potential-args <p3>)
    (<p2> ^tested calculate6 ^tested calculate5 ^tested calculate2
          ^tested calculate1 ^set <s2>)
    -->
    (<p1> ^instance <s2> +)
}

sp {satisfy-predicate-conditions*elaborate*calculate1
    (state <s1> ^simulated true ^list <l1> ^gtype <c1> ^<c1> <a1>)
   -{ (<a1> ^condition <c2>)
      (<c2> -^return-type number ^result <r*2>)
      (<r*2> ^set <rset2>)
     -{ (<rset2> ^instance <i*2>)
        (<i*2> ^1 <v*3>)
        (<v*3> ^<elem> <e*1>)}}
   -{ (<a1> ^condition <c>)
      (<c> ^return-type number ^result <r*1>)
      (<r*1> ^set <rset>)
     -{ (<rset> ^instance <i*1>)
        (<i*1> ^1 <v*2>)}}
    (<a1> ^potential-args <p1> ^parameter-set <p2>)
   -{ (<p1> -^<asdf> <a*2>)
      (state <s1> ^<a*1> <v*1>)}
    (<l1> ^game <g1>)
    -->
    (<p2> ^tested calculate1 +)
}

sp {satisfy-predicate-conditions*elaborate*calculate2
    (state <s1> ^list <l1> ^gtype <c1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate1)
    -->
    (<p2> ^tested calculate2 + ^tested calculate3 +)
}

sp {satisfy-predicate-conditions*elaborate*calculate4
    (state <s1> ^list <l1> ^gtype <c1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate3 ^tested calculate2)
    -->
    (<p2> ^tested calculate4 +)
}

sp {satisfy-predicate-conditions*elaborate*calculate5
    (state <s1> ^list <l1> ^gtype <c1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate3 ^tested calculate4)
    -->
    (<p2> ^tested calculate5 +)
}

sp {satisfy-predicate-conditions*elaborate*calculate6
    (state <s1> ^list <l1> ^gtype <c1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate4 ^tested calculate5)
    -->
    (<p2> ^tested calculate6 +)
}

sp {satisfy-predicate-conditions*action*results*no-verb
    (state <s> ^gtype heuristic ^gtype action ^list <l1> ^heuristic <p>
          ^action <t>)
    (<p> ^condition <c>)
    (<c> -^verb <v*1> ^type concept ^attribute action ^name <name>
          ^result <r1>)
    (<t> ^verb-structure <v1> ^instance <in>)
    (<v1> ^1 <vs>)
    (<vs> ^verb-name <name>)
    (<r1> ^set <rset>)
    -->
    (<rset> ^instance <in> +)
}

sp {satisfy-predicate-conditions*action*results
    (state <s> ^gtype heuristic ^gtype action ^list <l1> ^heuristic <p>
          ^action <t>)
    (<p> ^condition <c>)
    (<c> ^type concept ^attribute action ^verb <verb> ^name <name>
          ^result <r1>)
    (<t> ^verb-structure <v1> ^instance <in>)
    (<v1> ^1 <vs>)
    (<vs> ^verb-prep <verb> ^verb-name <name>)
    (<r1> ^set <rset>)
    -->
    (<rset> ^instance <in> +)
}

sp {satisfy-predicate-conditions*elaborate*condition-instance*action
    (state <s1> ^list <l1> ^gtype <c3> ^action <t1> ^<c3> <a1>)
    (<l1> ^game <g1>)
    (<t1> ^nlp-set <n1> ^instance <i1>)
    (<n1> ^aname <c2>)
    (<a1> ^condition <c4>)
    (<c4> ^name <c2> ^type concept ^attribute action ^result <r1>)
    (<r1> ^set <s2>)
    -->
    (<s2> ^instance <i1> +)
}

sp {satisfy-predicate-conditions*elaborate*condition-instance*action*any
    (state <s1> ^list <l1> ^gtype <c3> ^action <t1> ^<c3> <a1>)
    (<l1> ^game <g1>)
    (<t1> ^nlp-set <n1> ^instance <i1>)
    (<a1> ^condition <c4>)
    (<c4> ^name any ^type concept ^attribute action ^result <r1>)
    (<r1> ^set <s2>)
    -->
    (<s2> ^instance <i1> +)
}

sp {satisfy-predicate-conditions*elaborate*condition-instance*single-to-set*copy-objects
    (state <s1> ^list <l1> ^gtype <c3> ^<c3> <a1> ^<c1> <t1>)
    (<l1> ^game <g1>)
    (<a1> ^condition <c4>)
    (<c4> ^rtype set ^type concept ^args <a*1> ^parameter <p*2> ^result <r1>
          ^name <c2> ^attribute <c1>)
    (<p*2> ^num { < 2 <n*1> })
    (<a*1> ^1 <v*1>)
    (<v*1> ^parameter <p*1>)
    (<p*1> ^num 0)
    (<r1> ^set <s*1>)
    (<s*1> ^instance <i*1>)
    (<i*1> ^1 <set>)
    (<t1> ^primary-rtype single ^link <c4> ^nlp-set <n1> ^instance <i*2>)
    (<n1> ^aname <c2>)
    (<i*2> ^1 <obj>)
    -->
    (<set> ^<object> <obj> +)
}

sp {satisfy-predicate-conditions*elaborate*condition-instance*single-to-set
    (state <s1> ^list <l1> ^gtype <c3> ^<c3> <a1> ^<c1> <t1>)
    (<l1> ^game <g1>)
    (<a1> ^condition <c4>)
    (<c4> ^rtype set ^type concept ^args <a*1> ^parameter <p*2> ^result <r1>
          ^name <c2> ^attribute <c1>)
    (<p*2> ^num { < 2 <n*1> })
    (<a*1> ^1 <v*1>)
    (<v*1> ^parameter <p*1>)
    (<p*1> ^num 0)
    (<r1> ^set <s2>)
   -{ (<t1> -^instance <i*1>)
      (state <s1> ^<a*2> <v*2>)}
    (<t1> ^primary-rtype single ^link <c4> ^nlp-set <n1>)
    (<n1> ^aname <c2>)
    -->
    (<s2> ^instance <i1> +)
    (<i1> ^1 <set> +)
}

sp {satisfy-predicate-conditions*elaborate*condition-instance*single-to-set*parameters
    (state <s1> ^list <l1> ^gtype <c3> ^<c3> <a1> ^<c1> <t1>)
    (<l1> ^game <g1>)
    (<a1> ^condition <c4>)
    (<c4> ^rtype set ^type concept ^args <a*1> ^parameter <p*2>
          ^parameter <p*1> ^result <r1> ^name <c2> ^attribute <c1>)
    (<a*1> ^1 <arg>)
    (<arg> ^rtype set ^parameter <p*3> ^result <r*1>)
    (<p*2> ^num { < 2 <n*1> })
    (<p*3> ^1 <v*2>)
    (<v*2> ^param-id <pid>)
    (<p*1> ^1 <v*1>)
    (<v*1> ^param-id <pid>)
    (<r*1> ^set <s*1>)
    (<s*1> ^instance <i*1>)
    (<i*1> ^1 <set>)
   -{ (<set> -^<something> <s*2>)
      (state <s1> ^<a*2> <v*3>)}
    (<r1> ^set <s2>)
   -{ (<set> ^object <obj>)
     -{ (<t1> ^instance <i1>)
        (<i1> ^1 <obj>)}}
    (<t1> ^primary-rtype single ^link <c4> ^nlp-set <n1>)
    (<n1> ^aname <c2>)
    -->
    (<s2> ^instance <i1> +)
    (<i1> ^1 <set> +)
}

sp {satisfy-predicate-conditions*elaborate*condition-instance
    (state <s1> ^list <l1> ^gtype <c3> ^<c3> <a1> ^<c1> <t1>)
    (<l1> ^game <g1>)
    (<a1> ^condition <c4>)
    (<c4> ^type concept ^rtype <rtype> ^result <r1> ^name <c2> ^attribute <c1>)
    (<r1> ^set <s2>)
    (<t1> ^primary-rtype <rtype> ^link <c4> ^nlp-set <n1> ^instance <i1>)
    (<n1> ^aname <c2>)
    -->
    (<s2> ^instance <i1> +)
}

sp {finished-learning*apply*complete*send-message*goal-state*demo
    (state <s1> ^name finished-learning ^operator <o*1> ^top-state <t*3>
          ^top-state <t*2> ^top-state <t*1>)
    (<o*1> ^name complete)
    (<t*3> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<t*2> ^interaction <i*1>)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^goal-relationships <gs> ^attend <at> ^structure <s*1>)
    (<s*1> ^goals <act>)
    (<i*1> ^status <status>)
    (<act> ^goal <a>)
    (<a> ^handle <name>)
    -->
    (<act> ^goal <a> - ^retrieve-handle <name> +)
    (<dc> ^attend <at> -)
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type describe-final-goal-state + ^fields <f> +)
    (<f> ^relationships <gs> + ^definitive no +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <de> +)
    (<de> ^type game + ^originator agent +)
}

sp {finished-learning*apply*complete*send-message*failure
    (state <s1> ^name finished-learning ^operator <o*1> ^top-state <t*3>
          ^top-state <t*2> ^top-state <t*1>)
    (<o*1> ^name complete)
    (<t*3> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<t*2> ^interaction <i*1>)
    (<t*1> ^dialog-context <dc>)
    (<dc> -^learning-predicate <l*1> ^structure <s*1>)
    (<s*1> ^failures <act>)
    (<act> ^failure <a>)
    (<a> ^handle <name>)
    (<i*1> ^status <status>)
    -->
    (<act> ^failure <a> - ^retrieve-handle <name> +)
    (<dc> ^finalize-chunk <name> +)
}

sp {finished-learning*apply*complete*send-message*goal
    (state <s1> ^name finished-learning ^operator <o*1> ^top-state <t*3>
          ^top-state <t*2> ^top-state <t*1>)
    (<o*1> ^name complete)
    (<t*3> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<t*2> ^interaction <i*1>)
    (<t*1> ^dialog-context <dc>)
    (<dc> -^learning-predicate <l*1> -^goal-relationships <g*1>
          ^structure <s*1>)
    (<s*1> ^goals <act>)
    (<i*1> ^status <status>)
    (<act> ^goal <a>)
    (<a> ^handle <name>)
    -->
    (<act> ^goal <a> - ^retrieve-handle <name> +)
    (<dc> ^finalize-chunk <name> +)
}

sp {finished-learning*apply*complete*send-message*action
    (state <s1> ^name finished-learning ^operator <o*1> ^top-state <t*1>
          ^superstate <ss>)
    (<o*1> ^name complete)
    (<t*1> ^dialog-context <dc>)
    (<dc> -^learning-predicate <l*1> ^structure <s*1>)
    (<s*1> ^actions <act>)
    (<act> ^action <a>)
    (<a> ^handle <name>)
    -->
    (<act> ^action <a> - ^retrieve-handle <name> +)
    (<dc> ^finalize-chunk <name> +)
}

sp {finished-learning*apply*complete*send-message*heuristic
    (state <s1> ^name finished-learning ^store-link <sl> ^operator <o*1>
          ^top-state <t*1>)
    (<sl> ^ntype heuristic ^handle <name>)
    (<o*1> ^name complete)
    (<t*1> ^dialog-context <dc>)
    (<dc> -^learning-predicate <l*1> ^structure <s*1>)
    (<s*1> ^heuristics <act>)
    -->
    (<act> ^retrieve-handle <name> +)
    (<dc> ^finalize-chunk <name> +)
}

sp {finished-learning*apply*complete*send-message*predicate
    (state <s1> ^name finished-learning ^operator <o*1> ^top-state <t*3>
          ^top-state <t*2> ^top-state <t*1>)
    (<o*1> ^name complete)
    (<t*3> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<t*2> ^interaction <i*1>)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^learning-predicate <lp> ^learn-link <l*1>)
    (<l*1> ^handle <word>)
    (<lp> ^name <word>)
    (<i*1> ^status <status>)
    -->
    (<dc> ^learning-predicate <lp> -)
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type learned-unknown-word + ^fields <f*1> +)
    (<f*1> ^word <word> +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <de> +)
    (<de> ^type game + ^originator agent +)
}

sp {finished-learning*apply*complete*input-object-2
    (state <s1> ^name finished-learning ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name complete)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^input-object-2 <lp>)
    -->
    (<dc> ^input-object-2 <lp> -)
}

sp {finished-learning*apply*complete*input-object-1
    (state <s1> ^name finished-learning ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name complete)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^input-object-1 <lp>)
    -->
    (<dc> ^input-object-1 <lp> -)
}

sp {finished-learning*apply*complete*output-object-1
    (state <s1> ^name finished-learning ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name complete)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^output-object-1 <lp>)
    -->
    (<dc> ^output-object-1 <lp> -)
}

sp {satisfy-purpose*clean*dialog-world
    (state <s1> ^name satisfy-purpose ^operator <o*1> ^top-state <ts>)
    (<o*1> ^name wait-for-response)
    (<ts> ^dialog-world <d*1>)
    (<d*1> ^{ << objects predicates >> <a*1> } <dw>)
    (<dw> ^<something> <obj>)
    -->
    (<dw> ^<something> <obj> -)
}

sp {satisfy-purpose*clean*dialog-object-list-saved
    (state <s1> ^name satisfy-purpose ^operator <o*1> ^top-state <ts>)
    (<o*1> ^name wait-for-response)
    (<ts> ^dialog-object-list-saved { <=> <s1> <dol> })
    -->
    (<ts> ^dialog-object-list-saved <dol> - ^dialog-object-list-saved nil +)
}

sp {satisfy-purpose*clean*dialog-object-list
    (state <s1> ^name satisfy-purpose ^operator <o*1> ^top-state <ts>)
    (<o*1> ^name wait-for-response)
    (<ts> ^dialog-object-list { <=> <s1> <dol> })
    -->
    (<ts> ^dialog-object-list <dol> - ^dialog-object-list nil +)
}

sp {satisfy-purpose*finished-learning*apply*complete*remove-learn-link
    (state <s1> ^name interaction ^operator <o> ^top-state <t*1>)
   -{ (<o> ^event <e*3>)
      (<e*3> ^dialog-event <d*2>)
      (<d*2> ^type process-sentence)}
   -{ (<o> ^event <e*2>)
      (<e*2> ^dialog-event <d*1>)
      (<d*1> ^type process-unknown-word)}
   -{ (<o> ^event <e*1>)
      (<e*1> ^learning-event <l*1>)
      (<l*1> ^type game-name)}
    (<o> ^name performed-event)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^learn-link <ll>)
    (<ll> ^argnum <a>)
    -->
    (<dc> ^learn-link <ll> -)
}

sp {finished-learning*apply*complete*remove-learn-link
    (state <s1> ^name finished-learning ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name complete)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^store-learn-link <ll> ^learn-link { <> <ll> <l2> })
    -->
    (<dc> ^store-learn-link <ll> - ^learn-link <ll> + ^learn-link <l2> -)
}

sp {finished-learning*propose*complete
    (state <s> ^name finished-learning)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete +)
}

sp {finished-learning*apply*store-next-level2
    (state <s> ^name finished-learning ^operator <o> ^to-store <ts>
          ^smem <s*1>)
    (<o> ^name store-game-level)
    (<s*1> ^command <sc>)
    (<ts>
          ^{ <> final <> goal-state <> initial <something> } { <=> <s> <something2> })
    -->
    (<s> ^to-store <something2> +)
    (<sc> ^store <something2> +)
}

sp {finished-learning*apply*store-next-level*finished
    (state <s> ^name finished-learning ^operator <o>)
   -{ (<s> ^to-store <t*1> -^to-store <t2>)
      (<t*1> ^<something> { <=> <s> <t2> })}
    (<o> ^name store-game-level)
    -->
    (<s> ^all-stored true +)
}

sp {finished-learning*propose*store-next-level
    (state <s> ^name finished-learning -^all-stored <a*1> ^store-link <ts>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name store-game-level + ^to-store <ts> +)
}

sp {finished-learning*propose*store*primary*rtype
    (state <s> ^operator <o*1> ^store-link <ll>)
    (<o*1> ^name finished-learning)
    (<ll> ^predicate-structure <p*1>)
    (<p*1> ^conditions <c*1>)
    (<c*1> ^parameter <p*2>)
    (<p*2> ^<num> <p>)
    (<p> ^param-id 1 ^type <rtype>)
    -->
    (<ll> ^primary-rtype <rtype> +)
}

sp {finished-learning*store*predicate*concept
    (state <s> ^name finished-learning ^smem <s*1> ^superstate <s*2>)
    (<s*1> ^command <sc>)
    (<s*2> ^store-link <ll>)
    -->
    (<s> ^store-link <ll> + ^to-store <ll> +)
    (<sc> ^store <ll> +)
}

sp {satisfy-predicate-conditions*apply*finished-learning*remove-instance5
    (state <s1> ^operator <o*1> ^store-link <ll> ^top-state <t*1>)
    (<o*1> ^name finished-learning)
    (<ll> ^predicate-structure <p*1>)
    (<p*1> ^conditions <c*1>)
    (<c*1> ^args <a*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learning true)
    (<a*1> ^<n> <n*1>)
    (<n*1> ^args <a*2>)
    (<a*2> ^<n1> <n*2>)
    (<n*2> ^args <a*3>)
    (<a*3> ^<n2> <n*3>)
    (<n*3> ^args <a*4>)
    (<a*4> ^<n3> <c>)
    (<c> -^name number ^result <r*1>)
    (<r*1> ^set <res>)
    (<res> ^instance <i>)
    -->
    (<res> ^instance <i> -)
}

sp {satisfy-predicate-conditions*apply*finished-learning*remove-instance4
    (state <s1> ^operator <o*1> ^store-link <ll> ^top-state <t*1>)
    (<o*1> ^name finished-learning)
    (<ll> ^predicate-structure <p*1>)
    (<p*1> ^conditions <c*1>)
    (<c*1> ^args <a*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learning true)
    (<a*1> ^<n> <n*1>)
    (<n*1> ^args <a*2>)
    (<a*2> ^<n1> <n*2>)
    (<n*2> ^args <a*3>)
    (<a*3> ^<n2> <c>)
    (<c> -^name number ^result <r*1>)
    (<r*1> ^set <res>)
    (<res> ^instance <i>)
    -->
    (<res> ^instance <i> -)
}

sp {satisfy-predicate-conditions*apply*finished-learning*remove-instance3
    (state <s1> ^operator <o*1> ^store-link <ll> ^top-state <t*1>)
    (<o*1> ^name finished-learning)
    (<ll> ^predicate-structure <p*1>)
    (<p*1> ^conditions <c*1>)
    (<c*1> ^args <a*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learning true)
    (<a*1> ^<n> <n*1>)
    (<n*1> ^args <a*2>)
    (<a*2> ^<n1> <c>)
    (<c> -^name number ^result <r*1>)
    (<r*1> ^set <res>)
    (<res> ^instance <i>)
    -->
    (<res> ^instance <i> -)
}

sp {satisfy-predicate-conditions*apply*finished-learning*remove-instance2
    (state <s1> ^operator <o*1> ^store-link <ll> ^top-state <t*1>)
    (<o*1> ^name finished-learning)
    (<ll> ^predicate-structure <p*1>)
    (<p*1> ^conditions <c*1>)
    (<c*1> ^args <a*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learning true)
    (<a*1> ^<n> <c>)
    (<c> -^name number ^result <r*1>)
    (<r*1> ^set <res>)
    (<res> ^instance <i>)
    -->
    (<res> ^instance <i> -)
}

sp {satisfy-predicate-conditions*apply*finished-learning*remove-instance
    (state <s1> ^operator <o*1> ^store-link <ll> ^top-state <t*1>)
    (<o*1> ^name finished-learning)
    (<ll> ^predicate-structure <p*1>)
    (<p*1> ^conditions <c>)
    (<c> -^name number ^result <r*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learning true)
    (<r*1> ^set <res>)
    (<res> ^instance <i>)
    -->
    (<res> ^instance <i> -)
}

sp {satisfy-predicate-conditions*apply*finished-learning*elaborate*source
    (state <s1> ^operator <o*1> ^store-link <ll> ^top-state <t*1>)
    (<o*1> ^name finished-learning)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^learning true ^name <name>)
    -->
    (<ll> ^from <name> +)
}

sp {satisfy-predicate-conditions*apply*finished-learning*elab-store-link
    (state <s1> ^operator <o*1> ^top-state <t*2> ^top-state <t*1>)
    (<o*1> ^name finished-learning)
    (<t*2> ^dialog-context <d*2>)
    (<d*2> ^learn-link <ll>)
    (<ll> ^predicate-structure <p*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learning true)
    -->
    (<s1> ^store-link (deep-copy <ll>) +)
}

sp {satisfy-predicate-conditions*elaborate-finished-learning*goal
    (state <s1> ^operator <o> ^main-type { << goal failure >> <type> }
          ^top-state <t*1> ^superstate <ss> ^superstate <s*1> ^<type> <a1>)
    (<o> -^duplicate-of <d*2> ^type <type>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learning true)
    (<s*1> ^superstate <sss>)
    (<a1> ^parameter-set <p1> ^handle <c1>)
    (<p1> ^set <i1>)
    -->
    (<sss> ^finished-learning <type> +)
    (<ss> ^finished-learning <type> +)
}

sp {satisfy-predicate-conditions*elaborate-finished-learning*heuristic
    (state <s1> ^operator <o> ^main-type { << heuristic >> <type> }
          ^top-state <t*1> ^superstate <ss> ^<type> <a1>)
    (<o> -^duplicate-of <d*2> ^type action)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learning true)
    (<a1> ^parameter-set <p1> ^handle <c1>)
    (<p1> ^set <i1>)
    -->
    (<ss> ^finished-learning <type> +)
}

sp {satisfy-predicate-conditions*elaborate-finished-learning
    (state <s1> ^operator <o> ^main-type { << action >> <type> }
          ^top-state <t*1> ^superstate <ss> ^<type> <a1>)
    (<o> -^duplicate-of <d*2> ^type <type>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learning true)
    (<a1> ^parameter-set <p1> ^handle <c1>)
    (<p1> ^set <i1>)
    -->
    (<ss> ^finished-learning <type> +)
}

sp {satisfy-predicate-conditions*propose*finished-learning
    (state <s1> ^main-type predicate ^gtype predicate ^list <l1>
          ^predicate <a1> ^top-state <t*1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p1> ^handle <c1>)
    (<p1> ^set <i1>)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^learning true ^learn-link <l*1>)
    (<l*1> ^handle <c1>)
    -->
    (<s1> ^operator <o1> + ^operator <o1> =)
    (<o1> ^name finished-learning + ^type predicate +)
}

sp {satisfy-predicate-conditions*propose*predicate-operator*action
    (state <s1> ^list <l1> -^main-type heuristic ^gtype { << action >> <c2> }
          ^<c2> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^aname <c1> ^parameter-set <p1> ^verb-structure <vs>)
    (<p1> ^set <i1>)
    -->
    (<s1> ^operator <o1> +)
    (<o1> ^type <c2> + ^name <c1> + ^parameters <i1> + ^verb-structure <vs> +)
}

sp {satisfy-predicate-conditions*propose*predicate-operator*action*heuristic
    (state <s1> ^main-type heuristic ^list <l1> ^gtype { << action >> <c2> }
          ^<c2> <a1>)
   -{ (<s1> ^heuristic <h*1>)
      (<h*1> ^condition <con>)
     -{ (<con> ^result <r*1>)
        (<r*1> ^set <s*1>)
        (<s*1> ^instance <i*1>)}}
    (<l1> ^game <g1>)
    (<a1> ^aname <c1> ^parameter-set <p1> ^verb-structure <vs>)
    (<p1> ^set <i1>)
    -->
    (<s1> ^operator <o1> +)
    (<o1> ^type <c2> + ^name <c1> + ^parameters <i1> + ^verb-structure <vs> +)
}

sp {satisfy-predicate-conditions*propose*predicate-operator*failure
    (state <s1> ^list <l1> ^gtype { << failure >> <c2> } ^<c2> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^aname <c1> ^parameter-set <p1>)
    (<p1> ^set <i1>)
    -->
    (<s1> ^operator <o1> +)
    (<o1> ^type <c2> + ^name <c1> + ^parameters <i1> +)
}

sp {satisfy-predicate-conditions*propose*predicate-operator*goal
    (state <s1> ^list <l1> ^gtype { << goal >> <c2> } ^<c2> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^aname <c1> ^parameter-set <p1>)
    (<p1> ^set <i1>)
    -->
    (<s1> ^operator <o1> +)
    (<o1> ^type <c2> + ^name <c1> + ^parameters <i1> +)
}

sp {topstate*elaborate*game-state-input*object
    (state <s> ^superstate nil ^world <w*1> ^io <i*1>)
    (<w*1> ^objects <objs>)
    (<i*1> ^input-link <i*2>)
    (<i*2> ^game-state <gs>)
    (<gs> ^relationships <rels> ^objects <o*1>)
    (<o*1> ^object <obj>)
    -->
    (<objs> ^object <obj> +)
    (<obj> ^category block + ^primitive object +)
}

sp {topstate*elaborate*game-state-input*predicate*instance
    (state <s> ^superstate nil ^world <w*1> ^io <i*1>)
    (<w*1> ^predicates <ps>)
    (<ps> ^predicate <p>)
    (<p> ^handle <name>)
    (<i*1> ^input-link <i*2>)
    (<i*2> ^game-state <gs>)
    (<gs> ^relationships <r*1> ^objects <objs>)
    (<r*1> ^prep <rels>)
    (<rels> ^name <name> ^pair <pa>)
    (<pa> ^|2| <id2> ^|1| <id1>)
    (<objs> ^object <o2> ^object <o1>)
    (<o2> ^id <id2>)
    (<o1> ^id <id1>)
    -->
    (<p> ^instance <i> +)
    (<i> ^1 <o1> + ^2 <o2> +)
}

sp {topstate*elaborate*game-state-input
    (state <s> ^superstate nil ^world <w*1> ^io <i*1>)
    (<w*1> ^predicates <ps>)
    (<i*1> ^input-link <i*2>)
    (<i*2> ^game-state <gs>)
    (<gs> ^relationships <r*1> ^objects <obsj>)
    (<r*1> ^prep <rels>)
    (<rels> ^name <name>)
    -->
    (<ps> ^predicate <p> +)
    (<p> ^handle <name> +)
}

sp {store-predicate-structure*elaborate*top-state*dialogue-context*multiplayer
    (state <s> ^name store-predicate-structure ^operator <o*1>
          ^multiplayer <mult> ^top-state <ts>)
    (<o*1> ^name complete)
    (<ts> ^dialog-context <dc>)
    (<dc> ^structure <pred>)
    -->
    (<pred> ^multiplayer <mult> +)
}

sp {store-predicate-structure*elaborate*found-transferable-knowledge*false
    :o-support
    (state <s> ^name store-predicate-structure ^smem <s*1>)
    (<s*1> ^result <r*1>)
    (<r*1> ^failure <f*1>)
    -->
    (<s> ^found-transferable-knowledge false +)
}

sp {store-predicate-structure*propose*transfer-action-goal
    (state <s> ^found-transferable-knowledge true ^storing name
          ^name store-predicate-structure ^ptype <type> ^handle <handle>
          ^smem <s*1>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <struc>)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name transfer-action-goal + ^type <type> + ^structure <struc> +
           ^handle-name <handle> +)
}

sp {store-predicate-structure*elaborate*found-transferable-knowledge*true
    :o-support
    (state <s> ^name store-predicate-structure ^smem <s*1>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <r*2>)
    -->
    (<s> ^found-transferable-knowledge true +)
}

sp {store-predicate-structure*elaborate*query*find-transferable*knowlege
    (state <s> ^storing name ^name store-predicate-structure
          ^ptype { << action goal failure >> <p*1> } ^message <m*1>
          ^handle <handle> ^smem <s*1>)
    (<m*1> ^predicate <pred2>)
    (<s*1> ^command <sc>)
    -->
    (<sc> ^query <pred2> + ^depth 1 +)
    (<pred2> ^handle <handle> + ^item-type predicate +)
}

sp {store-predicate-structure*elaborate*top-state*dialogue-context*action
    (state <s> ^found-transferable-knowledge false ^ptype action ^storing name
          ^name store-predicate-structure ^operator <o*1> ^message <m*1>
          ^handle <handle> ^top-state <ts>)
    (<o*1> ^name complete)
    (<m*1> ^predicate <pred2>)
    (<ts> ^dialog-context <dc>)
    (<dc> ^structure <pred>)
    (<pred> ^actions <act>)
    -->
    (<act> ^action <pred2> +)
    (<pred2> ^predicate-structure <ps> + ^type action +)
    (<dc> ^learn-link <pred2> +)
}

sp {store-predicate-structure*elaborate*top-state*dialogue-context*failure
    (state <s> ^found-transferable-knowledge false ^ptype failure
          ^storing name ^name store-predicate-structure ^operator <o*1>
          ^message <m*1> ^handle <handle> ^top-state <ts>)
    (<o*1> ^name complete)
    (<m*1> ^predicate <pred2>)
    (<ts> ^dialog-context <dc>)
    (<dc> ^structure <pred>)
    (<pred> ^failures <go>)
    -->
    (<go> ^failure <pred2> +)
    (<pred2> ^predicate-structure <ps> + ^type failure +)
    (<dc> ^learn-link <pred2> + ^needs-failure-setup true +)
}

sp {store-predicate-structure*elaborate*top-state*dialogue-context*goal
    (state <s> ^found-transferable-knowledge false ^ptype goal ^storing name
          ^name store-predicate-structure ^operator <o*1> ^message <m*1>
          ^handle <handle> ^top-state <ts>)
    (<o*1> ^name complete)
    (<m*1> ^predicate <pred2>)
    (<ts> ^dialog-context <dc>)
    (<dc> ^structure <pred>)
    (<pred> ^goals <go>)
    -->
    (<go> ^goal <pred2> +)
    (<pred2> ^predicate-structure <ps> + ^type goal +)
    (<dc> ^learn-link <pred2> + ^needs-goal-setup true +)
}

sp {store-predicate-structure*elaborate*top-state*dialogue-context*game
    (state <s> ^ptype game ^storing name ^name store-predicate-structure
          ^operator <o*1> ^message <m*1> ^handle <handle> ^top-state <ts>)
    (<o*1> ^name complete)
    (<m*1> ^predicate <pred>)
    -->
    (<ts> ^dialog-context <dc> +)
    (<dc> ^type game-learning + ^name <handle> + ^structure <pred> +
           ^learning true + ^needs-setup true +)
    (<pred> ^actions <act> + ^goals <go> + ^failures <fa> +
           ^heuristics <heu> + ^multiplayer true + ^task-type game +)
}

sp {store-predicate-structure*elaborate*top-state*dialogue-context*puzzle
    (state <s> ^ptype puzzle ^storing name ^name store-predicate-structure
          ^operator <o*1> ^message <m*1> ^handle <handle> ^top-state <ts>)
    (<o*1> ^name complete)
    (<m*1> ^predicate <pred>)
    -->
    (<ts> ^dialog-context <dc> +)
    (<dc> ^type game-learning + ^name <handle> + ^structure <pred> +
           ^learning true + ^needs-setup true +)
    (<pred> ^actions <act> + ^goals <go> + ^failures <fa> +
           ^heuristics <heu> + ^multiplayer false + ^task-type puzzle +)
}

sp {store-predicate-structure*apply*complete*remove-learn-link
    (state <s> ^storing name ^name store-predicate-structure ^operator <o*1>
          ^top-state <ts>)
    (<o*1> ^name complete)
    (<ts> ^dialog-context <dc>)
    (<dc> ^learn-link <ll>)
   -{ (<s> ^message <m*1>)
      (<m*1> ^predicate <ll>)}
    -->
    (<dc> ^learn-link <ll> -)
}

sp {store-predicate-structure*apply*complete*action-goal-failure-transfer
    (state <s> ^found-transferable-knowledge true
          ^name store-predicate-structure ^operator <o*1> ^copied <r>
          ^ptype { << action goal failure >> <ptype> } ^handle <handle>
          ^top-state <t*2> ^top-state <t*1>)
    (<o*1> ^name complete)
    (<t*2> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type already-know + ^fields <f> +)
    (<f> ^concept-name <handle> + ^type <ptype> +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <de> +)
    (<de> ^type game + ^originator agent +)
}

sp {store-predicate-structure*apply*complete*action-name
    (state <s> ^found-transferable-knowledge false ^ptype action
          ^name store-predicate-structure ^operator <o*1> ^top-state <t*2>
          ^top-state <t*1>)
    (<o*1> ^name complete)
    (<t*2> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type describe-action +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <de> +)
    (<de> ^type game-name + ^originator agent +)
}

sp {store-predicate-structure*apply*complete*failure-name
    (state <s> ^found-transferable-knowledge false ^ptype failure
          ^name store-predicate-structure ^operator <o*1> ^top-state <t*2>
          ^top-state <t*1>)
    (<o*1> ^name complete)
    (<t*2> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type setup-failure +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <de> +)
    (<de> ^type game-name + ^originator agent +)
}

sp {store-predicate-structure*apply*complete*goal-name
    (state <s> ^found-transferable-knowledge false ^ptype goal
          ^name store-predicate-structure ^operator <o*1> ^top-state <t*2>
          ^top-state <t*1>)
    (<o*1> ^name complete)
    (<t*2> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type setup-goal +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <de> +)
    (<de> ^type game-name + ^originator agent +)
}

sp {store-predicate-structure*apply*complete*puzzle-name
    (state <s> ^ptype puzzle ^name store-predicate-structure ^operator <o*1>
          ^top-state <t*2> ^top-state <t*1>)
    (<o*1> ^name complete)
    (<t*2> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type describe-puzzle +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <de> +)
    (<de> ^type game + ^originator agent +)
}

sp {store-predicate-structure*apply*complete*game-name
    (state <s> ^ptype game ^name store-predicate-structure ^operator <o*1>
          ^top-state <t*2> ^top-state <t*1>)
    (<o*1> ^name complete)
    (<t*2> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type describe-game +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <de> +)
    (<de> ^type game + ^originator agent +)
}

sp {store-predicate-structure*propose*complete
    (state <s> ^name store-predicate-structure)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name complete +)
}

sp {store-predicate-structure*elaborate*multiplayer
    (state <s> ^name store-predicate-structure ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^multiplayer <m>)
    -->
    (<s> ^multiplayer <m> +)
}

sp {store-predicate-structure*elaborate*attributes
    (state <s> ^name store-predicate-structure ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^storing <t> ^message <msg> ^handle <h> ^type <y>)
    -->
    (<s> ^storing <t> + ^handle <h> + ^message <msg> + ^ptype <y> +)
}

sp {retrieve-predicate-structure*copy*stucture
    (state <s> ^name retrieve-predicate-structure ^smem <s*1>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <pred>)
    -->
    (<s> ^copy-structure <copy> +)
    (<copy> ^source <pred> + ^destination <pred> +)
}

sp {retrieve-predicate-structure*apply*complete*smem-query*result
    (state <s> ^name retrieve-predicate-structure ^operator <o*1>
          ^copy-structure <c*1> ^condition <co> ^smem <s*1> ^superstate <ss>)
    (<o*1> ^name complete)
    (<c*1> ^destination <dest>)
    (<dest> ^primary-rtype <rtype> ^argnum <an> ^predicate-structure <p2>
          ^handle <name>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <pred>)
    -->
    (<ss> ^predicate <p> + ^gtype predicate +)
    (<p> ^handle <name> + ^aname <name> + ^nlp-set <p2> +
           ^primary-rtype <rtype> + ^formated predicate +
           ^parameter-set <P124> + ^potential-args <P125> + ^link <co> +)
    (<P124> ^argnum <an> +)
    (<p2> ^aname <name> +)
}

sp {retrieve-predicate-structure*apply*complete*smem-query*result*no-condition-link*failure
    (state <s> ^name retrieve-predicate-structure ^superstate <ss>
          ^operator <o*1> ^copy-structure <c*1> ^smem <s*1>)
    (<ss> ^gtype failure)
    (<o*1> ^name complete)
    (<c*1> ^destination <dest>)
    (<dest> ^type failure ^primary-rtype <rtype> ^argnum <an>
          ^predicate-structure <ps> ^handle <name>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <pred>)
    -->
    (<ss> ^failure <p> +)
    (<p> ^handle <name> + ^aname <name> + ^nlp-set <ps> +
           ^primary-rtype <rtype> + ^formated predicate +
           ^parameter-set <P124> + ^potential-args <P125> +)
    (<P124> ^argnum <an> +)
    (<dest> ^aname <name> +)
    (<ps> ^aname <name> +)
}

sp {retrieve-predicate-structure*apply*complete*smem-query*result*no-condition-link*goal
    (state <s> ^name retrieve-predicate-structure ^superstate <ss>
          ^operator <o*1> ^copy-structure <c*1> ^smem <s*1>)
    (<ss> ^gtype goal)
    (<o*1> ^name complete)
    (<c*1> ^destination <dest>)
    (<dest> ^type goal ^primary-rtype <rtype> ^argnum <an>
          ^predicate-structure <ps> ^handle <name>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <pred>)
    -->
    (<ss> ^goal <p> +)
    (<p> ^handle <name> + ^aname <name> + ^nlp-set <ps> +
           ^primary-rtype <rtype> + ^formated predicate +
           ^parameter-set <P124> + ^potential-args <P125> +)
    (<P124> ^argnum <an> +)
    (<dest> ^aname <name> +)
    (<ps> ^aname <name> +)
}

sp {retrieve-predicate-structure*apply*complete*smem-query*result*no-condition-link*heuristic*consider*moved*modifier
    (state <s> ^name retrieve-predicate-structure ^superstate <ss>
          ^operator <o*1> ^copy-structure <c*1> ^smem <s*1>)
    (<ss> ^gtype heuristic)
    (<o*1> ^name complete)
    (<c*1> ^destination <dest>)
    (<dest> ^ntype heuristic ^primary-rtype <rtype> ^argnum <an>
          ^modifier <mod> ^moved <mo> ^predicate-structure <ps>
          ^consider <pref> ^handle <name>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <pred>)
    -->
    (<ss> ^heuristic <p> +)
    (<p> ^handle <name> + ^aname <name> + ^nlp-set <ps> +
           ^primary-rtype <rtype> + ^formated predicate +
           ^parameter-set <P124> + ^potential-args <P125> + ^ntype heuristic +
           ^consider <pref> + ^moved <mo> + ^modifier <mod> +)
    (<P124> ^argnum <an> +)
    (<dest> ^aname <name> +)
    (<ps> ^aname <name> +)
}

sp {retrieve-predicate-structure*apply*complete*smem-query*result*no-condition-link*heuristic*consider*moved
    (state <s> ^name retrieve-predicate-structure ^superstate <ss>
          ^operator <o*1> ^copy-structure <c*1> ^smem <s*1>)
    (<ss> ^gtype heuristic)
    (<o*1> ^name complete)
    (<c*1> ^destination <dest>)
    (<dest> -^modifier <m*1> ^ntype heuristic ^primary-rtype <rtype>
          ^argnum <an> ^moved <mo> ^predicate-structure <ps> ^consider <pref>
          ^handle <name>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <pred>)
    -->
    (<ss> ^heuristic <p> +)
    (<p> ^handle <name> + ^aname <name> + ^nlp-set <ps> +
           ^primary-rtype <rtype> + ^formated predicate +
           ^parameter-set <P124> + ^potential-args <P125> + ^ntype heuristic +
           ^consider <pref> + ^moved <mo> +)
    (<P124> ^argnum <an> +)
    (<dest> ^aname <name> +)
    (<ps> ^aname <name> +)
}

sp {retrieve-predicate-structure*apply*complete*smem-query*result*no-condition-link*heuristic*avoid*moved*modifier
    (state <s> ^name retrieve-predicate-structure ^superstate <ss>
          ^operator <o*1> ^copy-structure <c*1> ^smem <s*1>)
    (<ss> ^gtype heuristic)
    (<o*1> ^name complete)
    (<c*1> ^destination <dest>)
    (<dest> ^ntype heuristic ^primary-rtype <rtype> ^argnum <an>
          ^modifier <mod> ^moved <mo> ^predicate-structure <ps> ^avoid <pref>
          ^handle <name>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <pred>)
    -->
    (<ss> ^heuristic <p> +)
    (<p> ^handle <name> + ^aname <name> + ^nlp-set <ps> +
           ^primary-rtype <rtype> + ^formated predicate +
           ^parameter-set <P124> + ^potential-args <P125> + ^ntype heuristic +
           ^avoid <pref> + ^moved <mo> + ^modifier <mod> +)
    (<P124> ^argnum <an> +)
    (<dest> ^aname <name> +)
    (<ps> ^aname <name> +)
}

sp {retrieve-predicate-structure*apply*complete*smem-query*result*no-condition-link*heuristic*avoid*moved
    (state <s> ^name retrieve-predicate-structure ^superstate <ss>
          ^operator <o*1> ^copy-structure <c*1> ^smem <s*1>)
    (<ss> ^gtype heuristic)
    (<o*1> ^name complete)
    (<c*1> ^destination <dest>)
    (<dest> -^modifier <m*1> ^ntype heuristic ^primary-rtype <rtype>
          ^argnum <an> ^moved <mo> ^predicate-structure <ps> ^avoid <pref>
          ^handle <name>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <pred>)
    -->
    (<ss> ^heuristic <p> +)
    (<p> ^handle <name> + ^aname <name> + ^nlp-set <ps> +
           ^primary-rtype <rtype> + ^formated predicate +
           ^parameter-set <P124> + ^potential-args <P125> + ^ntype heuristic +
           ^avoid <pref> + ^moved <mo> +)
    (<P124> ^argnum <an> +)
    (<dest> ^aname <name> +)
    (<ps> ^aname <name> +)
}

sp {retrieve-predicate-structure*apply*complete*smem-query*result*no-condition-link*heuristic*moved*modifier
    (state <s> ^name retrieve-predicate-structure ^superstate <ss>
          ^operator <o*1> ^copy-structure <c*1> ^smem <s*1>)
    (<ss> ^gtype heuristic)
    (<o*1> ^name complete)
    (<c*1> ^destination <dest>)
    (<dest> ^ntype heuristic ^primary-rtype <rtype> ^argnum <an>
          ^modifier <mod> ^moved <mo> ^predicate-structure <ps> ^prefer <pref>
          ^handle <name>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <pred>)
    -->
    (<ss> ^heuristic <p> +)
    (<p> ^handle <name> + ^aname <name> + ^nlp-set <ps> +
           ^primary-rtype <rtype> + ^formated predicate +
           ^parameter-set <P124> + ^potential-args <P125> + ^ntype heuristic +
           ^prefer <pref> + ^moved <mo> + ^modifier <mod> +)
    (<P124> ^argnum <an> +)
    (<dest> ^aname <name> +)
    (<ps> ^aname <name> +)
}

sp {retrieve-predicate-structure*apply*complete*smem-query*result*no-condition-link*heuristic*moved
    (state <s> ^name retrieve-predicate-structure ^superstate <ss>
          ^operator <o*1> ^copy-structure <c*1> ^smem <s*1>)
    (<ss> ^gtype heuristic)
    (<o*1> ^name complete)
    (<c*1> ^destination <dest>)
    (<dest> -^modifier <m*1> ^ntype heuristic ^primary-rtype <rtype>
          ^argnum <an> ^moved <mo> ^predicate-structure <ps> ^prefer <pref>
          ^handle <name>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <pred>)
    -->
    (<ss> ^heuristic <p> +)
    (<p> ^handle <name> + ^aname <name> + ^nlp-set <ps> +
           ^primary-rtype <rtype> + ^formated predicate +
           ^parameter-set <P124> + ^potential-args <P125> + ^ntype heuristic +
           ^prefer <pref> + ^moved <mo> +)
    (<P124> ^argnum <an> +)
    (<dest> ^aname <name> +)
    (<ps> ^aname <name> +)
}

sp {retrieve-predicate-structure*apply*complete*smem-query*result*no-condition-link*heuristic*consider*modifier
    (state <s> ^name retrieve-predicate-structure ^superstate <ss>
          ^operator <o*1> ^copy-structure <c*1> ^smem <s*1>)
    (<ss> ^gtype heuristic)
    (<o*1> ^name complete)
    (<c*1> ^destination <dest>)
    (<dest> -^moved <m*1> ^ntype heuristic ^primary-rtype <rtype> ^argnum <an>
          ^modifier <mod> ^predicate-structure <ps> ^consider <pref>
          ^handle <name>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <pred>)
    -->
    (<ss> ^heuristic <p> +)
    (<p> ^handle <name> + ^aname <name> + ^nlp-set <ps> +
           ^primary-rtype <rtype> + ^formated predicate +
           ^parameter-set <P124> + ^potential-args <P125> + ^ntype heuristic +
           ^consider <pref> + ^modifier <mod> +)
    (<P124> ^argnum <an> +)
    (<dest> ^aname <name> +)
    (<ps> ^aname <name> +)
}

sp {retrieve-predicate-structure*apply*complete*smem-query*result*no-condition-link*heuristic*avoid*modifier
    (state <s> ^name retrieve-predicate-structure ^superstate <ss>
          ^operator <o*1> ^copy-structure <c*1> ^smem <s*1>)
    (<ss> ^gtype heuristic)
    (<o*1> ^name complete)
    (<c*1> ^destination <dest>)
    (<dest> -^moved <m*1> ^ntype heuristic ^primary-rtype <rtype> ^argnum <an>
          ^modifier <mod> ^predicate-structure <ps> ^avoid <pref>
          ^handle <name>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <pred>)
    -->
    (<ss> ^heuristic <p> +)
    (<p> ^handle <name> + ^aname <name> + ^nlp-set <ps> +
           ^primary-rtype <rtype> + ^formated predicate +
           ^parameter-set <P124> + ^potential-args <P125> + ^ntype heuristic +
           ^avoid <pref> + ^modifier <mod> +)
    (<P124> ^argnum <an> +)
    (<dest> ^aname <name> +)
    (<ps> ^aname <name> +)
}

sp {retrieve-predicate-structure*apply*complete*smem-query*result*no-condition-link*heuristic*modifier
    (state <s> ^name retrieve-predicate-structure ^superstate <ss>
          ^operator <o*1> ^copy-structure <c*1> ^smem <s*1>)
    (<ss> ^gtype heuristic)
    (<o*1> ^name complete)
    (<c*1> ^destination <dest>)
    (<dest> -^moved <m*1> ^ntype heuristic ^primary-rtype <rtype> ^argnum <an>
          ^modifier <mod> ^predicate-structure <ps> ^prefer <pref>
          ^handle <name>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <pred>)
    -->
    (<ss> ^heuristic <p> +)
    (<p> ^handle <name> + ^aname <name> + ^nlp-set <ps> +
           ^primary-rtype <rtype> + ^formated predicate +
           ^parameter-set <P124> + ^potential-args <P125> + ^ntype heuristic +
           ^prefer <pref> + ^modifier <mod> +)
    (<P124> ^argnum <an> +)
    (<dest> ^aname <name> +)
    (<ps> ^aname <name> +)
}

sp {retrieve-predicate-structure*apply*complete*smem-query*result*no-condition-link*heuristic*consider
    (state <s> ^name retrieve-predicate-structure ^superstate <ss>
          ^operator <o*1> ^copy-structure <c*1> ^smem <s*1>)
    (<ss> ^gtype heuristic)
    (<o*1> ^name complete)
    (<c*1> ^destination <dest>)
    (<dest> -^modifier <m*2> -^moved <m*1> ^ntype heuristic
          ^primary-rtype <rtype> ^argnum <an> ^predicate-structure <ps>
          ^consider <pref> ^handle <name>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <pred>)
    -->
    (<ss> ^heuristic <p> +)
    (<p> ^handle <name> + ^aname <name> + ^nlp-set <ps> +
           ^primary-rtype <rtype> + ^formated predicate +
           ^parameter-set <P124> + ^potential-args <P125> + ^ntype heuristic +
           ^consider <pref> +)
    (<P124> ^argnum <an> +)
    (<dest> ^aname <name> +)
    (<ps> ^aname <name> +)
}

sp {retrieve-predicate-structure*apply*complete*smem-query*result*no-condition-link*heuristic*avoid
    (state <s> ^name retrieve-predicate-structure ^superstate <ss>
          ^operator <o*1> ^copy-structure <c*1> ^smem <s*1>)
    (<ss> ^gtype heuristic)
    (<o*1> ^name complete)
    (<c*1> ^destination <dest>)
    (<dest> -^modifier <m*2> -^moved <m*1> ^ntype heuristic
          ^primary-rtype <rtype> ^argnum <an> ^predicate-structure <ps>
          ^avoid <pref> ^handle <name>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <pred>)
    -->
    (<ss> ^heuristic <p> +)
    (<p> ^handle <name> + ^aname <name> + ^nlp-set <ps> +
           ^primary-rtype <rtype> + ^formated predicate +
           ^parameter-set <P124> + ^potential-args <P125> + ^ntype heuristic +
           ^avoid <pref> +)
    (<P124> ^argnum <an> +)
    (<dest> ^aname <name> +)
    (<ps> ^aname <name> +)
}

sp {retrieve-predicate-structure*apply*complete*smem-query*result*no-condition-link*heuristic
    (state <s> ^name retrieve-predicate-structure ^superstate <ss>
          ^operator <o*1> ^copy-structure <c*1> ^smem <s*1>)
    (<ss> ^gtype heuristic)
    (<o*1> ^name complete)
    (<c*1> ^destination <dest>)
    (<dest> -^modifier <m*2> -^moved <m*1> ^ntype heuristic
          ^primary-rtype <rtype> ^argnum <an> ^predicate-structure <ps>
          ^prefer <pref> ^handle <name>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <pred>)
    -->
    (<ss> ^heuristic <p> +)
    (<p> ^handle <name> + ^aname <name> + ^nlp-set <ps> +
           ^primary-rtype <rtype> + ^formated predicate +
           ^parameter-set <P124> + ^potential-args <P125> + ^ntype heuristic +
           ^prefer <pref> +)
    (<P124> ^argnum <an> +)
    (<dest> ^aname <name> +)
    (<ps> ^aname <name> +)
}

sp {retrieve-predicate-structure*apply*complete*smem-query*result*no-condition-link*opponent
    (state <s> ^name retrieve-predicate-structure ^superstate <ss>
          ^operator <o*1> ^copy-structure <c*1> ^smem <s*1>)
    (<ss> ^gtype action)
    (<o*1> ^name complete)
    (<c*1> ^destination <dest>)
    (<dest> ^primary-rtype <rtype> ^argnum <an> ^verb-structure <vs>
          ^opponent <o> ^predicate-structure <ps> ^handle <name>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <pred>)
    -->
    (<ss> ^action <p> +)
    (<p> ^opponent <o> + ^handle <name> + ^aname <name> +
           ^verb-structure <vs> + ^nlp-set <ps> + ^primary-rtype <rtype> +
           ^formated predicate + ^parameter-set <P124> +
           ^potential-args <P125> +)
    (<P124> ^argnum <an> +)
    (<dest> ^aname <name> +)
    (<ps> ^aname <name> +)
}

sp {retrieve-predicate-structure*apply*complete*smem-query*result*no-condition-link
    (state <s> ^name retrieve-predicate-structure ^superstate <ss>
          ^operator <o*1> ^copy-structure <c*1> ^smem <s*1>)
    (<ss> ^gtype action)
    (<o*1> ^name complete)
    (<c*1> ^destination <dest>)
    (<dest> -^opponent <o*2> ^primary-rtype <rtype> ^argnum <an>
          ^verb-structure <vs> ^predicate-structure <ps> ^handle <name>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <pred>)
    -->
    (<ss> ^action <p> +)
    (<p> ^handle <name> + ^aname <name> + ^verb-structure <vs> +
           ^nlp-set <ps> + ^primary-rtype <rtype> + ^formated predicate +
           ^parameter-set <P124> + ^potential-args <P125> +)
    (<P124> ^argnum <an> +)
    (<dest> ^aname <name> +)
    (<ps> ^aname <name> +)
}

sp {retrieve-predicate-structure*propose*complete
    (state <s> ^name retrieve-predicate-structure ^smem <s*1>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <pred>)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete +)
}

sp {retrieve-predicate-structure*elaborate*smem-query
    (state <s> ^name retrieve-predicate-structure ^handle <handle> ^smem <s*1>)
    (<s*1> ^command <c>)
    -->
    (<c> ^query <cue> + ^link-to-ltm no + ^depth 15 +)
    (<cue> ^handle <handle> + ^item-type predicate +)
}

sp {retrieve-predicate-structure*elaborate*predicate-lti
    (state <s> ^name retrieve-predicate-structure ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^predicate-lti <lti>)
    -->
    (<s> ^predicate-lti <lti> +)
}

sp {retrieve-predicate-structure*elaborate*condition
    (state <s> ^name retrieve-predicate-structure ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^condition <co>)
    -->
    (<s> ^condition <co> +)
}

sp {retrieve-predicate-structure*elaborate*predicate-handle
    (state <s> ^name retrieve-predicate-structure ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^handle <handle>)
    -->
    (<s> ^handle <handle> +)
}

sp {format-conditions*apply*calculate1*parameter-set*argnum
    (state <s> ^name format-conditions ^parameter-set <ps> ^operator <o*1>
          ^condition <co>)
    (<ps> -^argnum <a*1>)
    (<o*1> ^name calculate1)
    (<co> ^parameter <p*1>)
    (<p*1> ^{ << 1 2 3 4 5 6 7 8 9 >> <arg2> } <a*2>)
    (<a*2> ^param-id <num>)
   -{ (<s> ^condition <c*1>)
      (<c*1> ^parameter <p*2>)
      (<p*2> ^{ << 1 2 3 4 5 6 7 8 9 >> <arg> } <a*3>)
      (<a*3> ^param-id { > <num> <p*3> })}
    -->
    (<ps> ^argnum <num> +)
}

sp {format-conditions*apply*calculate1*arg-num
    (state <s> ^name format-conditions ^operator <o*1> ^condition <co>)
    (<o*1> ^name calculate2)
    (<co> ^args <a>)
    (<a> -^num <n*1> ^<something> <s*1>)
    -->
    (<a> ^num (size <a>) +)
}

sp {format-conditions*apply*calculate1*parameter-num2
    (state <s> ^name format-conditions ^operator <o*1> ^condition <co>)
    (<o*1> ^name calculate1)
    (<co> ^parameter <p>)
    (<p> -^result <r*1> -^num <n*1>)
    -->
    (<p> ^num (size <p>) +)
}

sp {format-conditions*apply*calculate1*location-block*no-obj
    (state <s> ^name format-conditions ^operator <o*1> ^condition <co>)
    (<o*1> ^name calculate2)
    (<co> ^args <a1> ^rtype <type> ^name { << location block >> <n*1> })
    (<a1> -^<something> <s*1>)
    -->
    (<a1> ^num 1 + ^1 <c2> +)
    (<c2> ^name object + ^args <a3> + ^negative false + ^result <r*1> +
           ^rtype single + ^parameter <p*1> + ^type attribute +
           ^attribute primitive +)
    (<r*1> ^set <res> +)
    (<p*1> ^num 0 +)
}

sp {format-conditions*apply*calculate2*paramlinking
    (state <s> ^name format-conditions ^condition <co> ^operator <o*1>)
    (<co> -^attribute input-arg -^result <r*1> ^parameter <p*1>)
    (<o*1> ^name calculate2)
    (<p*1> ^num <n*1>)
    -->
    (<co> ^result <r*2> +)
    (<r*2> ^set <p> +)
}

sp {format-conditions*apply*calculate1*empty-parameter
    (state <s> ^name format-conditions ^condition <co> ^operator <o*1>)
    (<co> -^parameter <p*1>)
    (<o*1> ^name calculate2)
    -->
    (<co> ^parameter <p*2> +)
    (<p*2> ^num 0 +)
}

sp {format-conditions*apply*calculate1*empty-args
    (state <s> ^name format-conditions ^condition <co> ^operator <o*1>)
    (<co> -^args <a*1>)
    (<o*1> ^name calculate1)
    -->
    (<co> ^args <a1> +)
}

sp {format-conditions*apply*calculate1*type2
    (state <s> ^name format-conditions ^condition <co> ^operator <o*1>)
    (<co> ^rtype <type> ^parameter <p>)
    (<p> ^num <arg2> ^<arg2> <a1>)
    (<a1> -^type <t*1>)
    (<o*1> ^name { << calculate1 calculate2 >> <n*1> })
    -->
    (<a1> ^type <type> +)
}

sp {format-conditions*apply*calculate1*type
    (state <s> ^name format-conditions ^condition <co> ^operator <o*1>)
    (<co> ^args <a*1> ^parameter <p>)
    (<p> ^num <arg2> ^{ <> <arg2> << 1 2 3 4 5 6 7 8 9 10 >> <arg> } <a1>)
    (<o*1> ^name { << calculate1 calculate2 >> <n*1> })
    (<a1> -^type <t*1>)
    (<a*1> ^<arg> <a*2>)
    (<a*2> ^rtype <type>)
    -->
    (<a1> ^type <type> +)
}

sp {format-conditions*apply*calculate1*rtype*no-type
    (state <s> ^name format-conditions ^condition <co> ^operator <o*1>)
    (<co> -^parameter <p*1> -^rtype <r*1> ^args <a*1>)
    (<a*1> ^1 <v*1>)
    (<v*1> ^rtype <type>)
    (<o*1> ^name { << calculate1 calculate2 >> <n*1> })
    -->
    (<co> ^rtype <type> +)
}

sp {format-conditions*apply*calculate1*rtype
    (state <s> ^name format-conditions ^condition <co> ^operator <o*1>)
    (<co> -^rtype <r*1> ^parameter <p*1>)
    (<p*1> ^1 <v*1>)
    (<v*1> ^type <type>)
    (<o*1> ^name { << calculate1 calculate2 >> <n*1> })
    -->
    (<co> ^rtype <type> +)
}

sp {format-conditions*apply*calculate1*negative-test
    (state <s> ^name format-conditions ^condition <co> ^operator <o*1>)
    (<co> -^negative <n*1>)
    (<o*1> ^name calculate1)
    -->
    (<co> ^negative false +)
}

sp {format-conditions*apply*calculate2*default
    (state <s> ^name format-conditions ^operator <o*1>)
   -{ (<s> ^condition <c>)
      (<c> -^attribute input-arg -^result <r*1>)}
    (<o*1> ^name calculate2)
    -->
    (<s> ^tested calculate2 +)
}

sp {format-conditions*apply*calculate1*default
    (state <s> ^name format-conditions ^operator <o*1>)
   -{ (<s> ^condition <c>)
      (<c> -^rtype <r*1>)}
    (<o*1> ^name calculate1)
    -->
    (<s> ^tested calculate1 +)
}

sp {format-conditions*apply*complete*condition
    (state <s> ^name format-conditions ^operator <o*1> ^condition-set <cs>
          ^parameter-set <ps> ^superstate <ss>)
    (<o*1> ^name complete)
    (<ss> ^operator <o*2> ^<type> <t>)
    (<o*2> ^type <type>)
    -->
    (<t> ^condition <cs> +)
}

sp {format-conditions*apply*complete*parameter-set
    (state <s> ^name format-conditions ^operator <o*1> ^parameter-set <ps>
          ^superstate <ss>)
    (<o*1> ^name complete)
    (<ps> ^argnum <num>)
    (<ss> ^operator <o*2> ^<type> <t>)
    (<o*2> ^type <type>)
    (<t> ^parameter-set <ps2>)
    -->
    (<ps2> ^argnum <num> +)
    (<t> ^formated <type> +)
}

sp {format-conditions*propose*complete
    (state <s> ^tested calculate2 ^tested calculate1 ^name format-conditions)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name complete +)
}

sp {format-conditions*propose*calculate2
    (state <s> ^tested calculate1 -^tested calculate2 ^name format-conditions)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name calculate2 +)
}

sp {format-conditions*propose*calculate1
    (state <s> ^name format-conditions -^tested calculate1)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name calculate1 +)
}

sp {format-conditions*elaborate*sub-conditions
    (state <s> ^name format-conditions ^condition <co>)
    (<co> ^args <a*1>)
    (<a*1> ^{ << 1 2 3 4 5 6 7 8 9 10 >> <arg> } <cond>)
    (<cond> ^name <name>)
    -->
    (<s> ^condition <cond> +)
}

sp {format-conditions*elaborate*operator*condition
    (state <s> ^name format-conditions ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^nlp-set <n*1>)
    (<n*1> ^nlp <nlp>)
    -->
    (<s> ^condition <nlp> + ^condition-set <nlp> +)
}

sp {format-conditions*elaborate*parameter-set
    (state <s> ^name format-conditions)
    -->
    (<s> ^parameter-set <ps> +)
}

sp {evaluate-predicate*elaborate*problemspace*game-heuristics
    (state <s> ^superstate <ss>)
    (<ss> ^problemspace game-heuristics ^name learn-predicate)
    -->
    (<s> ^problemspace game-heuristics +)
}

sp {evaluate-predicate*elaborate*problemspace*games
    (state <s> ^superstate <s*1>)
    (<s*1> ^problemspace { << games >> <ps> })
    -->
    (<s> ^problemspace <ps> +)
}

sp {evaluate-predicate*propose*resolve-conditions
    (state <s> ^name evaluate-predicate)
   -{ (<s> ^result <r*1>)
      (<r*1> ^set <set>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name resolve-conditions +)
}

sp {evaluate-predicate*eval-condition*impasse
    (state <s> ^choices none ^impasse no-change ^attribute state
          ^superstate <ss>)
    (<ss> ^list <l*1>)
    (<l*1> ^game <g*1>)
    -->
    (force-learn <s>)
    (<s> ^name evaluate-predicate + ^linkstate <ss> + ^result <r> +)
}

sp {learn-predicate*elaborate*nlp-set*verb-structure
    (state <s> ^gtype action ^name learn-predicate ^action <t>)
    (<t> ^nlp-set <n*1>)
    (<n*1> ^verb-structure <vs>)
    -->
    (<t> ^verb-structure <vs> +)
}

sp {learn-predicate*elaborate*sub-conditions*actiongoal
    (state <s> ^name learn-predicate ^superstate <s*1>
          ^gtype { << action goal failure >> <gtype> } ^<gtype> <t>)
    (<s*1> ^name transfer-action-goal)
    (<t> ^nlp-set <n*1>)
    (<n*1> ^conditions <cond>)
    -->
    (<t> ^condition <cond> +)
}

sp {learn-predicate*elaborate*sub-conditions*heuristic
    (state <s> ^gtype action ^ntype heuristic ^name learn-predicate
          ^action <t>)
    (<t> ^nlp-set <n*1>)
    (<n*1> ^conditions <cond>)
    -->
    (<t> ^condition <cond> +)
}

sp {learn-predicate*elaborate*sub-conditions*predicate
    (state <s> ^name learn-predicate
          ^gtype { << predicate heuristic >> <type> } ^<type> <t>)
    (<t> ^nlp-set <n*1>)
    (<n*1> ^conditions <cond>)
    -->
    (<t> ^condition <cond> +)
}

sp {learn-predicate*elaborate*simulated-true
    (state <s> ^name learn-predicate ^gtype <type> ^<type> <t>)
    (<t> ^condition <co>)
    -->
    (<s> ^simulated true +)
}

sp {learn-predicate*elaborate*sub-conditions
    (state <s> ^name learn-predicate ^gtype <type> ^<type> <t>)
    (<t> ^condition <co>)
    (<co> ^args <a*1>)
    (<a*1> ^{ << 1 2 3 4 5 6 7 8 9 10 >> <arg> } <cond>)
    (<cond> ^name <name>)
    -->
    (<t> ^condition <cond> +)
}

sp {learn-predicate*propose*formate-conditions
    (state <s> ^name learn-predicate ^main-type <type> ^<type> <t>)
    (<t> -^formated <f*1> ^nlp-set <nlp>)
    -->
    (<s> ^operator <o> + ^operator <o> = ^operator <o> >)
    (<o> ^name format-conditions + ^type <type> + ^nlp-set <nlp> +)
}

sp {learn-predicate*elaborate*handlename
    (state <s> ^name learn-predicate ^main-type <type> ^<type> <t>)
    (<t> ^handle <aname>)
    -->
    (<t> ^aname <aname> +)
}

sp {learn-predicate*elaborate*opponent
    (state <s> ^name learn-predicate ^gtype <type> ^<type> <t>)
    (<t> ^nlp-set <n*1>)
    (<n*1> ^opponent <o>)
    -->
    (<t> ^opponent <o> +)
}

sp {learn-predicate*elaborate*actiongoalname
    (state <s> ^name learn-predicate ^gtype <type> ^<type> <t>)
    (<t> ^nlp-set <n*1>)
    (<n*1> ^aname <aname>)
    -->
    (<t> ^aname <aname> + ^handle <aname> +)
}

sp {learn-predicate*elaborate*game-name
    (state <s> ^name learn-predicate ^top-state <t*1> ^superstate <s*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^name <name>)
    (<s*1> ^operator <op>)
    (<op> ^message <m*1> ^type <type>)
    -->
    (<s> ^game <name> +)
}

sp {learn-predicate*elaborate*list-games
    (state <s> ^name learn-predicate ^main-type <type2> ^top-state <t*1>
          ^<type2> <gt> ^superstate <s*1>)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^learn-link <l*1> ^name <name>)
    (<l*1> ^handle <pname>)
    (<gt> ^handle <pname> ^formated <f*1>)
    (<s*1> ^operator <op>)
    (<op> ^type <type>)
    -->
    (<s> ^list <l*2> + ^objects <o> + ^current <g> +)
    (<l*2> ^game <g> +)
    (<g> ^game <name> + ^type <type> + ^type predicate +)
}

sp {learn-predicate*store*structure*learned-predicate*conditions
    :o-support
    (state <s> ^name learn-predicate
          ^main-type { << predicate heuristic >> <type> } ^gtype <type>
          ^top-state <t*1> ^<type> <t>)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^type game-learning ^learn-link <ll>)
    (<ll> ^predicate-structure <ps> ^handle <name>)
    (<t> ^handle <name> ^formated <f*1> ^nlp-set <n*1>)
    (<n*1> ^nlp <nlp>)
    -->
    (<ps> ^conditions <nlp> +)
}

sp {learn-predicate*store*structure*learned-predicate
    :o-support
    (state <s> ^name learn-predicate
          ^main-type { << predicate heuristic >> <type> } ^gtype <type>
          ^top-state <t*1> ^<type> <t>)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^type game-learning ^learn-link <ll>)
    (<ll> ^handle <name>)
    (<t> ^handle <name> ^parameter-set <p*1> ^formated <f*1> ^nlp-set <nl>)
    (<p*1> ^argnum <an>)
    -->
    (<ll> ^predicate-structure <ps> + ^argnum <an> +)
}

sp {learn-predicate*store*structure*heuristic
    :o-support
    (state <s> ^main-type heuristic ^gtype heuristic ^name learn-predicate
          ^heuristic <t> ^top-state <t*1>)
    (<t> ^parameter-set <p*1> ^formated <f*1> ^nlp-set <nl> ^handle <name>)
    (<p*1> ^argnum <an>)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^type game-learning ^learn-link <ll>)
    (<ll> ^ntype heuristic ^handle <name>)
    -->
    (<s> ^ntype heuristic +)
    (<t> ^ntype heuristic +)
}

sp {learn-predicate*store*structure*argnum
    :o-support
    (state <s> ^name learn-predicate
          ^main-type { << action goal failure heuristic >> <gtype> }
          ^top-state <t*1> ^<gtype> <t>)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^type game-learning ^learn-link <ll>)
    (<ll> ^handle <n>)
    (<t> ^handle <n> ^parameter-set <p*1>)
    (<p*1> ^argnum <an>)
    -->
    (<ll> ^argnum <an> +)
}

sp {learn-predicate*store*opponent
    :o-support
    (state <s> ^name learn-predicate
          ^gtype { << action goal failure heuristic >> <gtype> }
          ^top-state <t*1> ^<gtype> <t>)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^type game-learning ^learn-link <ll>)
    (<ll> ^handle <n>)
    (<t> ^handle <n> ^formated <f*1> ^nlp-set <n*1>)
    (<n*1> ^opponent <o>)
    -->
    (<ll> ^opponent <o> +)
}

sp {learn-predicate*store*consider
    :o-support
    (state <s> ^name learn-predicate ^gtype { << heuristic >> <gtype> }
          ^top-state <t*1> ^<gtype> <t>)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^type game-learning ^learn-link <ll>)
    (<t> ^formated <f*1> ^consider <nlp>)
    -->
    (<ll> ^consider <nlp> +)
    (<s> ^problemspace games +)
}

sp {learn-predicate*store*modifier
    :o-support
    (state <s> ^name learn-predicate ^gtype { << heuristic >> <gtype> }
          ^top-state <t*1> ^<gtype> <t>)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^type game-learning ^learn-link <ll>)
    (<t> ^modifier <m> ^formated <f*1>)
    -->
    (<ll> ^modifier <m> +)
    (<s> ^problemspace game-heuristics +)
}

sp {learn-predicate*store*moved
    :o-support
    (state <s> ^name learn-predicate ^gtype { << heuristic >> <gtype> }
          ^top-state <t*1> ^<gtype> <t>)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^type game-learning ^learn-link <ll>)
    (<t> ^moved <nlp> ^formated <f*1>)
    -->
    (<ll> ^moved <nlp> +)
}

sp {learn-predicate*store*avoid
    :o-support
    (state <s> ^name learn-predicate ^gtype { << heuristic >> <gtype> }
          ^top-state <t*1> ^<gtype> <t>)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^type game-learning ^learn-link <ll>)
    (<t> ^formated <f*1> ^avoid <nlp>)
    -->
    (<ll> ^avoid <nlp> +)
}

sp {learn-predicate*store*prefer
    :o-support
    (state <s> ^name learn-predicate ^gtype { << heuristic >> <gtype> }
          ^top-state <t*1> ^<gtype> <t>)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^type game-learning ^learn-link <ll>)
    (<t> ^formated <f*1> ^prefer <nlp>)
    -->
    (<ll> ^prefer <nlp> +)
}

sp {learn-predicate*store*structure
    :o-support
    (state <s> ^name learn-predicate
          ^gtype { << action goal failure heuristic >> <gtype> }
          ^top-state <t*1> ^<gtype> <t>)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^type game-learning ^learn-link <ll>)
    (<ll> ^predicate-structure <ps>)
    (<t> ^formated <f*1> ^nlp-set <n*1>)
    (<n*1> ^nlp <nlp>)
    -->
    (<ps> ^conditions <nlp> +)
}

sp {learn-predicate*store*verb-structure
    :o-support
    (state <s> ^name learn-predicate ^verb-structure <vs> ^action <t>
          ^top-state <t*1>)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^type game-learning ^learn-link <ll>)
    -->
    (<ll> ^verb-structure <vs> +)
}

sp {learn-predicate*propose*convert-language-format
    (state <s> ^name learn-predicate -^tcn <t*1> ^gtype <gtype>
          ^parsed-structure <t>)
   -{ (<s> ^<gtype> <g*1>)
      (<g*1> ^nlp-set <n*1>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name convert-parsed-format + ^structure <t> +)
}

sp {learn-predicate*apply*convert-language-format*clean-old-structures
    (state <s> ^name learn-predicate -^tcn <t*2> ^gtype <gtype> ^operator <o>
          ^parsed-structure <t> ^top-state <t*1>)
   -{ (<s> ^<gtype> <g*1>)
      (<g*1> ^nlp-set <n*1>)}
    (<o> ^name convert-parsed-format)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learn-link <ll>)
    (<ll> ^predicate-structure <ps>)
    (<ps> ^conditions <nlp>)
    -->
    (<ps> ^conditions <nlp> -)
}

sp {learn-predicate*elaborate*tcn*nlp-set*stored
    (state <s> ^name learn-predicate ^quiescence t ^superstate <s*1>)
    (<s*1> ^operator <op>)
    (<op> ^message <t>
          ^type { << predicate action goal failure heuristic >> <type> })
    (<t> ^learned-structure <nps>)
    -->
    (<s> ^parsed-structure <t2> + ^gtype <type> + ^main-type <type> +
           ^<type> <act> +)
    (<act> ^parameter-set <ps> + ^nlp-set <nps> + ^potential-args <po> +)
}

sp {learn-predicate*elaborate*tcn*nlp-set
    (state <s> ^name learn-predicate ^superstate <s*1>)
    (<s*1> ^operator <op>)
    (<op> ^nlp-set <nps>
          ^type { << predicate action goal failure heuristic >> <type> })
    -->
    (<s> ^parsed-structure <t> + ^gtype <type> + ^main-type <type> +
           ^<type> <act> +)
    (<act> ^parameter-set <ps> + ^nlp-set <nps> + ^potential-args <po> +)
}

sp {learn-predicate*elaborate*tcn
    (state <s> ^name learn-predicate ^superstate <s*1>)
    (<s*1> ^operator <op>)
    (<op> ^message <t>
          ^type { << predicate action goal failure heuristic >> <type> })
    (<t> -^learned-structure <l*1>)
    -->
    (<s> ^parsed-structure <t> + ^gtype <type> + ^main-type <type> +
           ^<type> <act> +)
    (<act> ^parameter-set <ps> + ^potential-args <po> +)
}

sp {learn-predicate*elaborate*problem-space*world
    (state <s> ^name learn-predicate ^superstate <ss>)
    (<ss> ^name selection ^superstate <ts>)
    (<ts> ^name learn-predicate ^world <world2>)
    -->
    (<s> ^problem-space <ps> +)
    (<ps> ^world <world> + ^dont-copy-anything true + ^name game +)
    (<world> ^source <world2> + ^copy-type deep +)
}

sp {learn-predicate*elaborate*problem-space*predicate-structure
    (state <s> ^name learn-predicate ^top-state <t*1>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name selection)}
    (<t*1> ^world <world2>)
    -->
    (<s> ^problem-space <ps> +)
    (<ps> ^world <world> + ^name game +)
    (<world> ^source <world2> + ^copy-type deep +)
}

sp {learn-predicate*elaborate*input-args*object
    (state <s> ^name learn-predicate ^predicate <T5> ^top-state <t*1>
          ^world <w*1>)
    (<T5> ^formated predicate ^condition <c> ^potential-args <P125>
          ^parameter-set <P124> ^nlp-set <nlps>)
    (<c> ^attribute input-arg ^result <r*1>)
    (<nlps> ^aname <name>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learning-predicate <l*1>)
    (<l*1> ^name <name>)
    (<w*1> ^objects <o*1>)
    (<r*1> ^set <res>)
    (<o*1> ^object <obj>)
    -->
    (<res> ^instance <in> +)
    (<in> ^1 <obj> +)
}

sp {learn-predicate*elaborate*input-args*learning-predicate
    (state <s> ^name learn-predicate ^predicate <T5> ^top-state <t*1>)
    (<T5> ^formated predicate ^condition <c> ^potential-args <P125>
          ^parameter-set <P124> ^nlp-set <nlps>)
    (<c> ^attribute input-arg)
    (<nlps> ^aname <name>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learning-predicate <l*1>)
    (<l*1> ^name <name>)
    -->
    (<c> ^result <r*1> +)
    (<r*1> ^set <res> +)
}

sp {learn-predicate*elaborate*input-args*set-to-single*objects
    (state <s> ^name learn-predicate ^predicate <T5> ^gtype <gtype>
          ^<gtype> <g*1>)
    (<T5> ^formated predicate ^link <co> ^condition <c> ^nlp-set <nlps>
          ^potential-args <P125> ^parameter-set <P124>)
    (<co> ^type concept ^attribute predicate ^name <name> ^args <args>)
    (<c> ^rtype single ^attribute input-arg ^parameter <p*1> ^result <r*2>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^dialog-context <d*1>)
      (<d*1> ^learning-predicate <l*1>)
      (<l*1> ^name <name>)}
    (<nlps> ^aname <name>)
    (<args> ^num { > 0 <n*1> } ^<a1> <c1>)
    (<g*1> ^condition <co>)
    (<p*1> ^1 <v*2>)
    (<v*2> ^param-id <a1>)
    (<c1> ^rtype set ^result <r*1>)
    (<r*2> ^set <res>)
    (<r*1> ^set <s*1>)
    (<s*1> ^instance <i*1>)
    (<i*1> ^1 <v*1>)
    (<v*1> ^<elem> <obj>)
    -->
    (<res> ^instance <i15> +)
    (<i15> ^1 <obj> +)
}

sp {learn-predicate*elaborate*input-args
    (state <s> ^name learn-predicate ^predicate <T5> ^gtype <gtype>
          ^<gtype> <g*1>)
    (<T5> ^formated predicate ^link <co> ^condition <c> ^handle <name>
          ^potential-args <P125> ^parameter-set <P124> ^nlp-set <nlps>)
    (<co> ^type concept ^attribute predicate ^name <name> ^args <args>)
    (<c> ^attribute input-arg ^rtype <rtype> ^parameter <p*1> ^result <r*2>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^dialog-context <d*1>)
      (<d*1> ^learning-predicate <l*1>)
      (<l*1> ^name <name>)}
    (<args> ^num { > 0 <n*1> } ^<a1> <c1>)
    (<g*1> ^condition <co>)
    (<p*1> ^1 <v*1>)
    (<v*1> ^param-id <a1>)
    (<c1> ^rtype <rtype> ^result <r*1>)
    (<r*2> ^set <res2>)
    (<r*1> ^set <s*1>)
    (<s*1> ^instance <in1>)
    -->
    (<res2> ^instance <in1> +)
}

sp {learn-predicate*elaborate*verb-structure
    :o-support
    (state <s> ^gtype action ^name learn-predicate ^verb-structure <vs>
          ^action <a>)
    -->
    (<a> ^verb-structure <vs> +)
}

sp {perception-monitor*elaborate*object*volume
    (state <s> ^superstate nil ^perception-monitor <p*1>)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^object-info <obj>)
    (<obj> ^differences <d*1> ^wm-obj <wmobj>)
    (<d*1> ^belief-vol <bv>)
    (<bv> ^type volume ^result <r*1>)
    (<wmobj> ^predicates <p>)
    (<r*1> ^record <r*2>)
    (<r*2> ^value <vol>)
    -->
    (<p> ^volume <vol> +)
}

sp {satisfy-purpose*apply*wait-for-response*missing-object*stop-asking
    (state <s> ^name satisfy-purpose ^purpose <p*1> ^operator <o*1>
          ^purpose <p*2> ^top-state <t*1>)
    (<p*1> ^type find-missing-object)
    (<o*1> ^name wait-for-response)
    (<p*2> ^parameters <p*3>)
    (<p*3> ^stop-asking true)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <chgs>)
    -->
    (<chgs> ^terminate-segment true +)
}

sp {wait-for-response*reject*attend-to-scene-change*missing-object
    (state <s> ^name wait-for-response ^operator <o> + ^superstate <s*1>)
    (<o> ^name attend-to-scene-change ^change <c*1>)
    (<c*1> ^object-info <o*1>)
    (<o*1> ^wm-obj <obj>)
    (<s*1> ^purpose <p>)
    (<p> ^missing-object <obj> ^type find-missing-object)
    -->
    (<s> ^operator <o> -)
}

sp {wait-for-response*elaborate*attend-to-all-scene-changes
    (state <s> ^name wait-for-response)
    -->
    (<s> ^problem-space <ps> +)
    (<ps> ^perception <p*1> +)
    (<p*1> ^attend-to-all-perception yes +)
}

sp {satisfy-purpose*reject*dialog-event*waiting-for-response
    (state <s> ^name satisfy-purpose ^purpose <p*2> ^operator <o> +
          ^purpose <p*1>)
    (<p*2> ^originator agent)
    (<o> ^name dialog-event)
    (<p*1> ^satisfaction <s*1>)
    (<s*1> ^dialog-event <d*1>)
    (<d*1> ^type <type>)
    -->
    (<s> ^operator <o> -)
}

sp {satisfy-purpose*propose*wait-for-response
    (state <s> ^name satisfy-purpose ^purpose <p*2> ^purpose <p*1>)
    (<p*2> ^originator agent)
    (<p*1> ^satisfaction <s*1>)
    (<s*1> ^dialog-event <d*1>)
    (<d*1> ^type <type>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name wait-for-response +)
}

sp {equate-objects*apply*complete-equate-objects*send*ok
    (state <s> ^name equate-objects ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name complete-equate-objects)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <c>)
    -->
    (<c> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type ok +)
}

sp {equate-objects*apply*complete-equate-objects*report-performed
    (state <s> ^name equate-objects ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name complete-equate-objects)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <l*1> +)
    (<l*1> ^type object +)
}

sp {equate-objects*propose*complete-equate-objects
    (state <s> ^name equate-objects)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete-equate-objects +)
}

sp {equate-objects*learn-storage-info*elaborate*link*and*store
    (state <s> ^category learn-storage-info ^name equate-objects
          ^link-tail-smem <tail> ^link-head-smem <head> ^link-name <name>
          ^smem <s*1>)
    (<s*1> ^command <cmd>)
    -->
    (<head> ^<name> <tail> +)
    (<cmd> ^store <head> +)
}

sp {equate-objects*learn-storage-info*copy*smem-query*result*object2*link-tail-smem
    :o-support
    (state <s> ^category learn-storage-info ^name equate-objects
          ^link-tail-object <l*1> ^smem-query <s*1>)
    (<l*1> ^handle <h>)
    (<s*1> ^result <res>)
    (<res> ^handle <h>)
    -->
    (<s> ^link-tail-smem <res> +)
}

sp {equate-objects*learn-storage-info*smem-query*object2*smem
    (state <s> ^category learn-storage-info -^link-tail-smem <l*1>
          ^name equate-objects ^link-tail-object <obj>)
    (<obj> ^in-smem true ^handle <h>)
    -->
    (<s> ^smem-query <s*1> +)
    (<s*1> ^cue <c*1> +)
    (<c*1> ^handle <h> +)
}

sp {equate-objects*elaborate*link-tail-smem
    (state <s> ^category learn-storage-info ^name equate-objects
          ^link-tail-object <obj>)
    (<obj> ^object-instance true)
    -->
    (<s> ^link-tail-smem <obj> +)
}

sp {equate-objects*learn-storage-info*copy*smem-query*result*object2*link-head-smem
    :o-support
    (state <s> ^category learn-storage-info ^name equate-objects
          ^link-head-object <l*1> ^smem-query <s*1>)
    (<l*1> ^handle <h>)
    (<s*1> ^result <res>)
    (<res> ^handle <h>)
    -->
    (<s> ^link-head-smem <res> +)
}

sp {equate-objects*learn-storage-info*smem-query*head*smem
    (state <s> ^category learn-storage-info -^link-head-smem <l*1>
          ^name equate-objects ^link-head-object <obj>)
    (<obj> ^in-smem true ^handle <h>)
    -->
    (<s> ^smem-query <s*1> +)
    (<s*1> ^cue <c*1> +)
    (<c*1> ^handle <h> +)
}

sp {equate-objects*elaborate*link-head-smem*object-info
    (state <s> ^category learn-storage-info ^name equate-objects
          ^link-head-object <obj>)
    (<obj> -^in-smem <i*1> -^object-instance <o*1> ^predicates <p*1>)
    (<p*1> ^{ << spatial-shape shape >> <att> } <val>)
    -->
    (<s> ^link-head-smem <new> +)
    (<new> ^item-type object-info + ^shape <val> +)
}

sp {equate-objects*elaborate*link-head-smem
    (state <s> ^category learn-storage-info ^name equate-objects
          ^link-head-object <obj>)
    (<obj> ^object-instance true)
    -->
    (<s> ^link-head-smem <obj> +)
}

sp {equate-objects*elaborate*category*learn-storage-info
    (state <s> ^name equate-objects ^object1 <obj1> ^object2 <obj2>)
    (<obj1> ^relations <rel> ^predicates <p*1>)
    (<rel> ^handle of1 ^2 <rel-obj>)
    (<p*1> ^{ << spatial-shape modifier1 >> <att> } <val>)
    -->
    (<s> ^category learn-storage-info + ^link-head-object <rel-obj> +
           ^link-name <val> + ^link-tail-object <obj2> +)
}

sp {equate-objects*elaborate*objects*superoperator
    (state <s> ^name equate-objects ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^object1 <obj1> ^object2 <obj2>)
    -->
    (<s> ^object1 <obj1> + ^object2 <obj2> +)
}

sp {learn-relation*apply*complete-learn-relation*performed
    (state <s> ^name learn-relation ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name complete-learn-relation)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <l*1> +)
    (<l*1> ^type relation +)
}

sp {learn-relation*apply*complete-learn-relation*add
    (state <s> ^name learn-relation ^operator <o*1> ^obj2 <o*3> ^obj1 <o*2>
          ^predicate-handle <h> ^top-state <t*2> ^top-state <t*1>)
    (<o*1> ^name complete-learn-relation)
    (<o*3> ^handle <h2>)
    (<o*2> ^handle <h1>)
    (<t*2> ^world <w*2>)
    (<w*2> ^predicates <p*1>)
    (<p*1> ^predicate <p>)
    (<p> ^handle <h>)
    (<t*1> ^world <w*1>)
    (<w*1> ^objects <objs>)
    (<objs> ^object <obj2> ^object <obj1>)
    (<obj2> ^handle <h2>)
   -{ (<p> ^instance <cur-i>)
      (<cur-i> ^2 <obj2> ^1 <obj1>)}
    (<obj1> ^handle <h1>)
    -->
    (<p> ^instance <i> +)
    (<i> ^1 <obj1> + ^2 <obj2> +)
}

sp {learn-relation*propose*complete-learn-relation
    (state <s> ^name learn-relation)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete-learn-relation +)
}

sp {learn-relation*apply*add-object-to-world
    (state <s> ^name learn-relation ^operator <o> ^top-state <t*1>)
    (<o> ^name add-object-to-world ^source <obj> ^type <type>)
    (<t*1> ^perception-monitor <p*1>)
    (<p*1> ^changes <chgs>)
    -->
    (<chgs> ^change <c> +)
    (<c> ^type new-object + ^<type> <obj> +)
}

sp {learn-relation*propose*add-object-to-world*imagined
    (state <s> ^name learn-relation ^{ << obj1 obj2 >> <a*1> } <obj>)
    (<obj> -^object-instance true ^handle <h>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^world <w*1>)
      (<w*1> ^objects <o*1>)
      (<o*1> ^object <o*2>)
      (<o*2> ^handle <h>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name add-object-to-world + ^type imagined-obj + ^source <obj> +)
}

sp {learn-relation*propose*add-object-to-world*smem
    (state <s> ^name learn-relation ^{ << obj1 obj2 >> <a*1> } <obj>)
    (<obj> ^object-instance true ^handle <h>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^world <w*1>)
      (<w*1> ^objects <o*1>)
      (<o*1> ^object <o*2>)
      (<o*2> ^handle <h>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name add-object-to-world + ^type smem-obj + ^source <obj> +)
}

sp {learn-relation*prefer*attend*over*others
    (state <s> ^name learn-relation ^operator <o2> + ^operator <o1> +)
    (<o2> ^name add-object-to-world)
    (<o1> ^name attend-to-scene-change)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {learn-relation*elaborate*predicate-handle
    (state <s> ^name learn-relation ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^handle <h>)
    -->
    (<s> ^predicate-handle <h> +)
}

sp {learn-relation*elaborate*obj2
    (state <s> ^name learn-relation ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^2 <obj2>)
    -->
    (<s> ^obj2 <obj2> +)
}

sp {learn-relation*elaborate*obj1
    (state <s> ^name learn-relation ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^1 <obj1>)
    -->
    (<s> ^obj1 <obj1> +)
}

sp {learn-relation*elaborate*problem-space
    (state <s> ^name learn-relation)
    -->
    (<s> ^problem-space <ps> +)
    (<ps> ^perception <p*1> +)
    (<p*1> ^attend-to-all-perception yes +)
}

sp {learning-event*propose*learn-relation
    (state <s> ^name learning-event ^purpose <p>)
    (<p> ^type teach-relation ^parameters <params>)
    (<params> ^relation <rel> ^object <obj1>)
    (<rel> ^2 <obj2> ^handle <handle>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name learn-relation + ^handle <handle> + ^1 <obj1> + ^2 <obj2> +)
}

sp {retrospective-learning*apply*copy-action-operator*copy*predicate*arg
    (state <s> ^name retrospective-learning ^operator <o>
          ^action-operator <operator> ^world <w*1>)
    (<o> ^name copy-action-operator ^action-operator <a*1>)
    (<w*1> ^objects <o*1>)
    (<a*1> ^<arg-name> <arg>)
    (<arg> ^arg-type predicate ^2 <v*1> ^handle <pred-handle>)
    (<v*1> ^handle <obj2-handle>)
    (<o*1> ^object <obj2>)
    (<obj2> ^handle <obj2-handle>)
    -->
    (<operator> ^<arg-name> <new-arg> +)
    (<new-arg> ^arg-type predicate + ^handle <pred-handle> + ^2 <obj2> +)
}

sp {retrospective-learning*apply*copy-action-operator*copy*concept*arg
    (state <s> ^name retrospective-learning ^operator <o>
          ^action-operator <operator>)
    (<o> ^name copy-action-operator ^action-operator <a*1>)
    (<a*1> ^<arg-name> <arg>)
    (<arg> ^arg-type concept ^handle <concept-handle>)
    -->
    (<operator> ^<arg-name> <new-arg> +)
    (<new-arg> ^arg-type concept + ^handle <concept-handle> +)
}

sp {retrospective-learning*apply*copy-action-operator*copy*object*arg
    (state <s> ^name retrospective-learning ^operator <o>
          ^action-operator <operator> ^world <w*1>)
    (<o> ^name copy-action-operator ^action-operator <a*1>)
    (<w*1> ^objects <o*1>)
    (<a*1> ^<arg-name> <arg>)
    (<arg> ^arg-type object ^id <i*1>)
    (<i*1> ^handle <obj-handle>)
    (<o*1> ^object <obj>)
    (<obj> ^handle <obj-handle>)
    -->
    (<operator> ^<arg-name> <new-arg> +)
    (<new-arg> ^arg-type object + ^id <obj> +)
}

sp {retrospective-learning*apply*copy-action-operator*copy*merged*info
    (state <s> ^name retrospective-learning ^operator <o>
          ^action-operator <operator>)
    (<o> ^name copy-action-operator ^action-operator <a*1>)
    (<a*1> ^merged <m>)
    (<m> ^object1 <o*1> ^object2 <o*2>)
    (<o*2> ^handle <handle2>)
    (<o*1> ^handle <handle1>)
    -->
    (<operator> ^merged <m*1> +)
    (<m*1> ^<handle1> <handle2> +)
}

sp {retrospective-learning*apply*copy-action-operator*mark*copied
    (state <s> ^name retrospective-learning ^operator <o*1>
          ^action-operator <c>)
    (<o*1> ^name copy-action-operator)
    -->
    (<s> ^copied-action-operator true +)
}

sp {retrospective-learning*apply*copy-action-operator*create*operator
    (state <s> ^name retrospective-learning ^operator <o>)
    (<o> ^name copy-action-operator ^action-operator <operator>)
    (<operator> ^action-handle <handle> ^name <op-name>)
    -->
    (<s> ^action-operator <operator-copy> +)
    (<operator-copy> ^action-handle <handle> + ^name <op-name> +)
}

sp {retrospective-learning*propose*copy-action-operator
    (state <s> ^name retrospective-learning -^copied-action-operator <c*1>
          ^world <w> ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^action-operator <operator>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name copy-action-operator + ^action-operator <operator> +)
}

sp {learn-proposal-rule*prefer*deduce-task-goal*over*action*operator
    (state <s> ^name learn-proposal-rule ^operator <o1> + ^operator <o2> +)
    (<o1> ^name deduce-task-goal)
    (<o2> ^action-handle <any>)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {learn-proposal-rule*prefer*smem-query*over*action*operator
    (state <s> ^name learn-proposal-rule ^operator <o1> + ^operator <o2> +)
    (<o1> ^name smem-query)
    (<o2> ^action-handle <any>)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {learn-proposal-rule*elaborate*action-id*from*smem-query*result
    :o-support
    (state <s> ^name learn-proposal-rule ^smem-query <query>
          ^action-operator <a*1>)
    (<a*1> ^action-handle <action-handle>)
    (<query> ^cue <c*1> ^result <id>)
    (<c*1> ^handle <action-handle>)
    -->
    (<s> ^action-id <id> +)
}

sp {learn-proposal-rule*elaborate*smem-query*retrieve-action-id
    (state <s> ^name learn-proposal-rule -^action-id <a*2>
          ^action-operator <a*1>)
    (<a*1> ^action-handle <action-handle>)
    -->
    (<s> ^smem-query <query> +)
    (<query> ^cue <cue> + ^depth 8 +)
    (<cue> ^handle <action-handle> +)
}

sp {retrospective-learning*prefer*report-success*over*all*others
    (state <s> ^name learn-proposal-rule ^operator <o1> + ^operator <o2> +)
    (<o1> ^name report-success)
    (<o2> ^name { <> report-success <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {retrospective-learning*learn-proposal-rule*apply*report-success
    (state <s> ^name learn-proposal-rule ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name report-success)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <l*1> +)
    (<l*1> ^type retrospective +)
}

sp {retrospective-learning*learn-proposal-rule*propose*report-success
    (state <s> ^name learn-proposal-rule ^desired <des>)
    (<des> ^satisfied true)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name report-success +)
}

sp {learn-proposal-rule*propose*composite-action
    (state <s> ^name learn-proposal-rule ^action-operator <o>)
    -->
    (<s> ^operator <o> + ^operator <o> >)
}

sp {retrospective-learning*state*no-change*elaborate*action-operator
    (state <s> ^impasse no-change ^attribute state ^superstate <s*1>
          ^superstate <s*2>)
    (<s*1> ^name retrospective-learning)
    (<s*2> ^action-operator <op>)
    -->
    (<s> ^action-operator <op> +)
}

sp {learn-proposal-rule*elaborate*problem-space
    (state <s> ^name learn-proposal-rule)
    -->
    (<s> ^problem-space <ps> +)
    (<ps> ^name action + ^action <action> + ^world <world> +
           ^learning <learn> + ^subactions <subs> +)
    (<action> ^type simulate +)
    (<world> ^copy-type shallow +)
    (<learn> ^type retrospective +)
    (<subs> ^copy-type shallow +)
}

sp {retrospective-learning*state-no-change*elaborate*name*learn-proposal-rule
    (state <s> ^impasse no-change ^attribute state ^superstate <s*1>)
    (<s*1> ^name retrospective-learning)
    -->
    (<s> ^name learn-proposal-rule +)
}

sp {retrospective*learning*selection*no-subaction*apply*report-failure
    (state <s> ^name selection ^quiescence t ^operator <o*1>
          ^problem-space <p*1> ^top-state <t*1> ^problem-space <p*2>)
    (<o*1> ^name report-failure)
    (<p*1> ^name action)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    (<p*2> ^learning <l*1>)
    (<l*1> ^type retrospective)
    -->
    (<status> ^failure <f> +)
    (<f> ^type retrospective-learning-failure +)
}

sp {retrospective*learning*selection*no-subaction*propose*report-failure
    (state <s> ^name selection ^subactions <s*1> ^problem-space <p*1>
          ^problem-space <p*2>)
    (<s*1> ^next none)
    (<p*1> ^name action)
    (<p*2> ^learning <l*1>)
    (<l*1> ^type retrospective)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name report-failure +)
}

sp {retrospective-learning*prefer*copy*subaction*over*retrieve
    (state <s> ^name retrospective-learning ^operator <o2> + ^operator <o1> +)
    (<o2> ^name retrieve-subaction-episode)
    (<o1> ^name copy-subaction-info)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {retrospective-learning*prefer*copy-operator*over*subactions
    (state <s> ^name retrospective-learning ^operator <o1> + ^operator <o2> +)
    (<o1> ^name copy-action-operator)
    (<o2> ^name { << copy-subaction-info retrieve-subaction-episode >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {retrospective-learning*apply*copy-subaction-info*cleanup
    (state <s> ^name retrospective-learning ^operator <o>
          ^subaction-episode <ep> ^subaction-info <info>)
    (<o> ^name copy-subaction-info ^subaction-episode <ep>)
    (<info> ^action-handle <handle>)
    -->
    (<s> ^subaction-episode <ep> - ^subaction-info <info> -)
}

sp {retropsective-learning*apply*copy-subaction-info*copy*until-clause*relation*predicate
    (state <s> ^name retrospective-learning ^operator <o>
          ^subaction-info <sub-info>)
    (<o> ^name copy-subaction-info ^argument-info <arg-info>)
    (<arg-info> ^arg-type until-clause ^source <s*1> ^arg-name <arg-name>)
    (<s*1> ^predicate <pred>)
    (<pred> ^type relation ^info1 <i*1> ^info2 <i*2> ^handle <pred-handle>)
    (<i*1> ^object-id <obj1>)
    (<i*2> ^object-id <obj2>)
    -->
    (<sub-info> ^<arg-name> <arg-copy> +)
    (<arg-copy> ^arg-type until-clause + ^predicate <new-pred> +)
    (<new-pred> ^type relation + ^handle <pred-handle> + ^1 <obj1> +
           ^2 <obj2> +)
}

sp {retropsective-learning*apply*copy-subaction-info*copy*until-clause*state*predicate
    (state <s> ^name retrospective-learning ^operator <o>
          ^subaction-info <sub-info>)
    (<o> ^name copy-subaction-info ^argument-info <arg-info>)
    (<arg-info> ^arg-type until-clause ^source <s*1> ^arg-name <arg-name>)
    (<s*1> ^predicate <pred>)
    (<pred> ^type state ^info1 <i*1> ^property-handle <prop-handle>
          ^handle <pred-handle>)
    (<i*1> ^object-id <obj1>)
    -->
    (<sub-info> ^<arg-name> <arg-copy> +)
    (<arg-copy> ^arg-type until-clause + ^predicate <new-pred> +)
    (<new-pred> ^type state + ^handle <pred-handle> +
           ^property-handle <prop-handle> + ^1 <obj1> +)
}

sp {retropsective-learning*apply*copy-subaction-info*copy*predicate*arg
    (state <s> ^name retrospective-learning ^operator <o>
          ^subaction-info <sub-info>)
    (<o> ^name copy-subaction-info ^argument-info <arg-info>)
    (<arg-info> ^arg-type predicate ^info2 <i*1> ^source <s*1>
          ^arg-name <arg-name>)
    (<i*1> ^object-id <obj2>)
    (<s*1> ^handle <pred-handle>)
    -->
    (<sub-info> ^<arg-name> <arg-copy> +)
    (<arg-copy> ^arg-type predicate + ^handle <pred-handle> + ^2 <obj2> +)
}

sp {retropsective-learning*apply*copy-subaction-info*copy*concept*arg
    (state <s> ^name retrospective-learning ^operator <o>
          ^subaction-info <sub-info>)
    (<o> ^name copy-subaction-info ^argument-info <arg-info>)
    (<arg-info> ^arg-type concept ^source <s*1> ^arg-name <arg-name>)
    (<s*1> ^handle <concept-handle>)
    -->
    (<sub-info> ^<arg-name> <arg-copy> +)
    (<arg-copy> ^arg-type concept + ^handle <concept-handle> +)
}

sp {retropsective-learning*apply*copy-subaction-info*copy*object*arg
    (state <s> ^name retrospective-learning ^operator <o>
          ^subaction-info <sub-info>)
    (<o> ^name copy-subaction-info ^argument-info <arg-info>)
    (<arg-info> ^arg-type object ^object-id <obj> ^arg-name <arg-name>)
    -->
    (<sub-info> ^<arg-name> <arg-copy> +)
    (<arg-copy> ^arg-type object + ^id <obj> +)
}

sp {retrospective-learning*apply*copy-subaction-info*copy*name
    (state <s> ^name retrospective-learning ^operator <o>
          ^subaction-info <info>)
    (<o> ^name copy-subaction-info ^subaction-episode <s*1>)
    (<s*1> ^action-stack <a*1>)
    (<a*1> ^top <t*1>)
    (<t*1> ^execution-operator <e*1>)
    (<e*1> ^action-handle <action-handle>)
    -->
    (<info> ^action-handle <action-handle> +)
}

sp {retrospective-learning*apply*copy-subaction-info
    (state <s> ^name retrospective-learning -^subaction-info <s*1>
          ^operator <o*1> ^subactions <subs>)
    (<o*1> ^name copy-subaction-info)
    (<subs> ^next <next>)
    -->
    (<s> ^subaction-info <info> +)
    (<info> ^next <next> +)
    (<subs> ^next <next> - ^next <info> +)
}

sp {retropsective-learning*elaborate*copy-subaction-info*object*object-id*matches-abstract
    (state <s> ^name retrospective-learning ^operator <o> +)
    (<o> ^name copy-subaction-info ^argument-info <arg-info>)
    (<arg-info> -^matches-world <m*1> ^arg-type object ^matches-abstract <obj>)
    -->
    (<arg-info> ^object-id <obj> +)
}

sp {retropsective-learning*elaborate*copy-subaction-info*object*object-id*matches-world
    (state <s> ^name retrospective-learning ^operator <o> +)
    (<o> ^name copy-subaction-info ^argument-info <arg-info>)
    (<arg-info> ^arg-type object ^matches-world <obj>)
    -->
    (<arg-info> ^object-id <obj> +)
}

sp {retropsective-learning*elaborate*copy-subaction-info*object*matches-abstract*predicates
    (state <s> ^name retrospective-learning ^operator <o>)
    (<o> ^name copy-subaction-info ^argument-info <arg-info>)
    (<arg-info> ^arg-type object ^matches-abstract <m*1> ^source <s*1>)
    (<m*1> ^predicates <preds>)
    (<s*1> ^id <i*1>)
    (<i*1> ^predicates <p*1>)
    (<p*1> ^<prop-name> <pred-name>)
    -->
    (<preds> ^<prop-name> <pred-name> +)
}

sp {retropsective-learning*elaborate*copy-subaction-info*object*matches-abstract*o-support
    (state <s> ^name retrospective-learning ^operator <o>)
    (<o> ^name copy-subaction-info ^argument-info <arg-info>)
    (<arg-info> ^arg-type object ^matches-abstract <obj>)
    (<obj> ^predicates <preds> ^handle <obj-handle>)
    -->
    (<obj> ^handle <obj-handle> + ^item-type object + ^predicates <preds> +)
}

sp {retropsective-learning*elaborate*copy-subaction-info*object*matches-abstract
    (state <s> ^name retrospective-learning ^operator <o> +)
    (<o> ^name copy-subaction-info ^argument-info <arg-info>)
    (<arg-info> ^arg-type object ^source <s*1>)
    (<s*1> ^id <i*1>)
    (<i*1> ^handle <obj-handle>)
    -->
    (<arg-info> ^matches-abstract <obj> +)
    (<obj> ^handle <obj-handle> + ^item-type object + ^predicates <preds> +)
}

sp {retrospective-learning*elaborate*copy-subaction-info*argument-info*object*matches-world*linked
    (state <s> ^name retrospective-learning ^operator <o> +
          ^current-action <c*1> ^world <w*1>)
    (<o> ^name copy-subaction-info ^argument-info <arg-info>)
   -{ (<arg-info> ^source <s*1>)
      (<s*1> ^id <i*1>)
      (<i*1> ^predicates <p*1>)
      (<p*1> ^category message)}
    (<arg-info> ^arg-type object ^source <s*2>)
    (<c*1> ^added <obj>)
    (<obj> ^linked-to <l*1> ^handle <obj-handle>)
    (<l*1> ^handle <link-handle>)
    (<s*2> ^id <i*2>)
    (<i*2> ^handle <obj-handle>)
    (<w*1> ^objects <o*1>)
    (<o*1> ^object <link-obj>)
    (<link-obj> ^handle <link-handle>)
    -->
    (<arg-info> ^matches-world <link-obj> +)
}

sp {retrospective-learning*elaborate*copy-subaction-info*argument-info*object*matches-world
    (state <s> ^name retrospective-learning ^operator <o> + ^world <w*1>)
    (<o> ^name copy-subaction-info ^argument-info <arg-info>)
    (<arg-info> ^arg-type object ^source <s*1>)
    (<w*1> ^objects <o*1>)
    (<s*1> ^id <i*1>)
    (<i*1> ^handle <obj-handle>)
    (<o*1> ^object <wm-obj>)
    (<wm-obj> ^handle <obj-handle>)
    -->
    (<arg-info> ^matches-world <wm-obj> +)
}

sp {retrospective-learning*elaborate*copy-subaction-info*argument-info*until-clause*relation
    (state <s> ^name retrospective-learning ^operator <o> +)
    (<o> ^name copy-subaction-info ^argument-info <pred-info>)
    (<pred-info> ^arg-type until-clause ^source <s*1>)
    (<s*1> ^predicate <pred>)
    (<pred> ^type relation ^2 <obj2> ^1 <obj1>)
    -->
    (<o> ^argument-info <obj1-info> + ^argument-info <obj2-info> +)
    (<obj1-info> ^arg-type object + ^source <s*2> +)
    (<s*2> ^id <obj1> +)
    (<obj2-info> ^arg-type object + ^source <s*3> +)
    (<s*3> ^id <obj2> +)
    (<pred> ^info1 <obj1-info> + ^info2 <obj2-info> +)
}

sp {retrospective-learning*elaborate*copy-subaction-info*argument-info*until-clause*state
    (state <s> ^name retrospective-learning ^operator <o> +)
    (<o> ^name copy-subaction-info ^argument-info <pred-info>)
    (<pred-info> ^arg-type until-clause ^source <s*1>)
    (<s*1> ^predicate <pred>)
    (<pred> ^type state ^1 <obj1>)
    -->
    (<o> ^argument-info <obj1-info> +)
    (<obj1-info> ^arg-type object + ^source <s*2> +)
    (<s*2> ^id <obj1> +)
    (<pred> ^info1 <obj1-info> +)
}

sp {retrospective-learning*elaborate*copy-subaction-info*argument-info*predicate*object
    (state <s> ^name retrospective-learning ^operator <o> +)
    (<o> ^name copy-subaction-info ^argument-info <pred-info>)
    (<pred-info> ^arg-type predicate ^source <s*1>)
    (<s*1> ^2 <obj2>)
    -->
    (<o> ^argument-info <obj-info> +)
    (<obj-info> ^arg-type object + ^source <s*2> +)
    (<s*2> ^id <obj2> +)
    (<pred-info> ^info2 <obj-info> +)
}

sp {retrospective-learning*elaborate*copy-subaction-info*argument-info
    (state <s> ^name retrospective-learning ^operator <o> +)
    (<o> ^name copy-subaction-info ^subaction-episode <s*1>)
    (<s*1> ^action-stack <a*1>)
    (<a*1> ^top <t*1>)
    (<t*1> ^execution-operator <e*1>)
    (<e*1> ^<arg-name> <arg>)
    (<arg> ^arg-type <type>)
    -->
    (<o> ^argument-info <arg-info> +)
    (<arg-info> ^arg-name <arg-name> + ^arg-type <type> + ^source <arg> +)
}

sp {retrospective-learning*propose*copy-subaction-info
    (state <s> ^name retrospective-learning ^subaction-episode <ep>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name copy-subaction-info + ^subaction-episode <ep> +)
}

sp {retrospective-learning*elaborate*problem-space*world
    (state <s> ^name retrospective-learning ^initial-episode <i*1>
          ^problem-space <p*1>)
    (<i*1> ^world <source>)
    (<p*1> ^world <world>)
    -->
    (<world> ^source <source> + ^copy-type deep +)
}

sp {retrospective-learning*elaborate*problem-space
    (state <s> ^name retrospective-learning)
    -->
    (<s> ^problem-space <ps> +)
    (<ps> ^name retrospective-learning + ^action <action> + ^world <world> +
           ^learning <learning> +)
}

sp {retrospective-learning*apply*report-failure*terminate-segment
    (state <s> ^name retrospective-learning ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name report-failure)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <c>)
    -->
    (<c> ^terminate-segment true +)
}

sp {retrospective-learning*propose*report-failure*no-initial-episode
    (state <s> ^initial-episode none ^name retrospective-learning)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name report-failure + ^type no-initial-episode +)
}

sp {retrospective-learning*apply*retrieve-subaction-episode*failure*no*match
    (state <s> ^name retrospective-learning ^operator <o*1> ^subactions <subs>
          ^epmem <epmem>)
    (<o*1> ^name retrieve-subaction-episode)
    (<epmem> ^result <r*1> ^command <cmd>)
    (<r*1> ^failure <f*1>)
    (<cmd> ^query <q>)
    -->
    (<subs> ^retrieved-all true +)
    (<cmd> ^query <q> -)
}

sp {retrospective-learning*apply*retrieve-subaction-episode*failure*no*perfect*match
    (state <s> ^name retrospective-learning ^operator <o*1> ^subactions <subs>
          ^epmem <epmem>)
    (<o*1> ^name retrieve-subaction-episode)
    (<epmem> ^result <r*1> ^command <cmd>)
    (<r*1> ^normalized-match-score { < 1.000000 <n*1> })
    (<cmd> ^query <q>)
    -->
    (<subs> ^retrieved-all true +)
    (<cmd> ^query <q> -)
}

sp {retrospective-learning*apply*retrieve-subaction-episode*success
    (state <s> ^name retrospective-learning ^operator <o*1> ^subactions <subs>
          ^epmem <epmem>)
    (<o*1> ^name retrieve-subaction-episode)
    (<subs> ^max-episode-id <old-max>)
    (<epmem> ^result <res> ^command <cmd> ^result <r*1>)
    (<res> ^normalized-match-score 1.000000 ^success <q> ^memory-id <ep-id>
          ^retrieved <episode>)
    (<cmd> ^query <q>)
    (<r*1> ^retrieved <episode>)
    -->
    (<subs> ^max-episode-id <old-max> - ^max-episode-id (- <ep-id> 5) +)
    (<s> ^subaction-episode <episode> +)
    (<cmd> ^query <q> -)
}

sp {retrospective-learning*apply*retrieve-subaction-episode*create*cue
    (state <s> ^name retrospective-learning ^operator <o> ^subactions <subs>
          ^epmem <e*1>)
    (<o> ^name retrieve-subaction-episode)
    (<subs> ^min-episode-id <min-id> ^max-episode-id <max-id>)
    (<e*1> ^command <cmd>)
    -->
    (<cmd> ^query <q> + ^after <min-id> + ^before <max-id> +)
    (<q> ^action-stack <a*1> +)
    (<a*1> ^top <top> +)
    (<top> ^start-of-execution true + ^task-subaction true +)
}

sp {retrospective-learning*propose*retrieve-subaction-episode
    (state <s> ^name retrospective-learning ^subactions <subs>)
    (<subs> -^retrieved-all true ^max-episode-id <ep-id>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name retrieve-subaction-episode + ^after-episode-id <ep-id> +)
}

sp {retrospective-learning*elaborate*world*predicate*on*top-state
    (state <s> ^name retrospective-learning ^initial-episode <i*1>
          ^top-state <t*1> ^world <w*3>)
    (<w*3> ^predicates <cur-preds>)
    (<t*1> ^world <w*2>)
    (<w*2> ^predicates <p*1>)
    (<p*1> ^predicate <pred>)
    (<pred> ^handle <pred-handle>)
    (<i*1> ^world <w*1>)
    (<w*1> ^predicates <preds>)
   -{ (<preds> ^predicate <p*2>)
      (<p*2> ^handle <pred-handle>)}
    -->
    (<cur-preds> ^predicate <new-pred> +)
    (<new-pred> ^handle <pred-handle> +)
}

sp {retrospective-learning*apply*retrieve-initial-episode*failure*no*match
    (state <s> ^name retrospective-learning ^operator <o*1> ^epmem <epmem>)
    (<o*1> ^name retrieve-initial-episode)
    (<epmem> ^result <r*1> ^command <cmd>)
    (<r*1> ^failure <f*1>)
    (<cmd> ^query <q>)
    -->
    (<s> ^initial-episode none +)
    (<cmd> ^query <q> -)
}

sp {retrospective-learning*apply*retrieve-initial-episode*failure*no*exact*match
    (state <s> ^name retrospective-learning ^operator <o*1> ^epmem <epmem>)
    (<o*1> ^name retrieve-initial-episode)
    (<epmem> ^result <r*1> ^command <cmd>)
    (<r*1> ^normalized-match-score { < 1.000000 <n*1> })
    (<cmd> ^query <q>)
    -->
    (<s> ^initial-episode none +)
    (<cmd> ^query <q> -)
}

sp {retrospective-learning*apply*retrieve-initial-episode*success
    (state <s> ^name retrospective-learning ^operator <o*1>
          ^present-id <present-id> ^epmem <epmem>)
    (<o*1> ^name retrieve-initial-episode)
    (<epmem> ^result <res> ^command <cmd> ^result <r*1>)
    (<res> ^normalized-match-score 1.000000 ^success <q> ^memory-id <ep-id>
          ^retrieved <episode>)
    (<cmd> ^query <q>)
    (<r*1> ^retrieved <episode>)
    -->
    (<s> ^initial-episode <episode> + ^subactions <subs> +)
    (<subs> ^max-episode-id <present-id> + ^min-episode-id (+ <ep-id> 5) +
           ^next none +)
    (<cmd> ^query <q> -)
}

sp {retrospective-learning*apply*retrieve-initial-episode
    (state <s> ^name retrospective-learning ^operator <o*1> ^epmem <e*1>
          ^superstate <s*1>)
    (<o*1> ^name retrieve-initial-episode)
    (<e*1> ^command <cmd>)
    (<s*1> ^operator <o*2>)
    (<o*2> ^action-operator <a*1>)
    (<a*1> ^action-handle <action-handle>)
    -->
    (<cmd> ^query <q> +)
    (<q> ^action-stack <a*2> +)
    (<a*2> ^top <top> +)
    (<top> ^start-of-execution true + ^execution-operator <e*2> +)
    (<e*2> ^action-handle <action-handle> +)
}

sp {retrospective-learning*propose*retrieve-initial-episode
    (state <s> ^name retrospective-learning -^initial-episode <i*1>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name retrieve-initial-episode +)
}

sp {retrospective-learning*elaborate*subactions*answer
    (state <s> ^name retrospective-learning ^subactions <subs>
          ^current-action <c*1>)
    (<c*1> ^answer <a*1>)
    (<a*1> ^handle <h>)
    -->
    (<subs> ^answer <h> +)
}

sp {retrospective-learning*elaborate*current-action
    (state <s> ^name retrospective-learning ^superstate <s*1>)
    (<s*1> ^purpose <p*1>)
    (<p*1> ^parameters <p*2>)
    (<p*2> ^action <action>)
    -->
    (<s> ^current-action <action> +)
}

sp {retrospective-learning*elaborate*present-id
    (state <s> ^name retrospective-learning ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^present-id <id>)
    -->
    (<s> ^present-id <id> +)
}

sp {learn-goal-definition*apply*add-predicate-to-world
    (state <s> ^name learn-goal-definition ^operator <o> ^top-state <t*1>)
    (<o> ^name add-predicate-to-world ^predicate-handle <pred-handle>)
    (<t*1> ^world <w*1>)
    (<w*1> ^predicates <preds>)
    -->
    (<preds> ^predicate <new-pred> +)
    (<new-pred> ^handle <pred-handle> +)
}

sp {learn-goal-definition*propose*add-predicate-to-world
    (state <s> ^name learn-goal-definition ^goal-predicate <pred>
          ^top-state <t*1>)
    (<pred> ^type relation ^handle <pred-handle>)
    (<t*1> ^world <w*1>)
    (<w*1> ^predicates <preds>)
   -{ (<preds> ^predicate <p*1>)
      (<p*1> ^handle <pred-handle>)}
    -->
    (<s> ^operator <o> + ^operator <o> = ^operator <o> >)
    (<o> ^name add-predicate-to-world + ^predicate-handle <pred-handle> +)
}

sp {learn-goal-definition*apply*create-new-goal-predicate*copy*predicate*structure*relation
    (state <s> ^name learn-goal-definition ^operator <o>
          ^goal-structure <goal>)
    (<o> ^name create-new-goal-predicate ^predicate-info <info>)
    (<info> ^type relation ^2 <v*2> ^1 <v*1> ^id <i*1>)
    (<v*2> ^generalized-rep <obj2>)
    (<v*1> ^generalized-rep <obj1>)
    (<i*1> ^generalized-rep <pred>)
    -->
    (<goal> ^predicate <new-pred> +)
    (<new-pred> ^type relation + ^id <pred> + ^1 <obj1> + ^2 <obj2> +)
    (<info> ^added true +)
}

sp {learn-goal-definition*apply*create-new-goal-predicate*copy*predicate*structure*state
    (state <s> ^name learn-goal-definition ^operator <o>
          ^goal-structure <goal>)
    (<o> ^name create-new-goal-predicate ^predicate-info <info>)
    (<info> ^type state ^1 <v*1> ^id <i*1>)
    (<v*1> ^generalized-rep <obj1>)
    (<i*1> ^generalized-rep <pred>)
    -->
    (<goal> ^predicate <new-pred> +)
    (<new-pred> ^type state + ^id <pred> + ^1 <obj1> +)
    (<info> ^added true +)
}

sp {learn-goal-definition*propose*create-new-goal-predicate*relation
    (state <s> ^name learn-goal-definition ^goal-predicate-info <info>)
    (<info> -^added <a*1> ^type relation ^2 <v*2> ^1 <v*1> ^id <i*1>)
    (<v*2> ^generalized-rep <obj2>)
    (<v*1> ^generalized-rep <obj1>)
    (<i*1> ^generalized-rep <pred>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name create-new-goal-predicate + ^predicate-info <info> +)
}

sp {learn-goal-definition*propose*create-new-goal-predicate*state
    (state <s> ^name learn-goal-definition ^goal-predicate-info <info>)
    (<info> -^added <a*1> ^type state ^1 <v*1> ^id <i*1>)
    (<v*1> ^generalized-rep <obj1>)
    (<i*1> ^generalized-rep <pred>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name create-new-goal-predicate + ^predicate-info <info> +)
}

sp {learn-goal-definition*elaborate*predicate-id*smem-query-cue*retrieved
    (state <s> ^name learn-goal-definition ^goal-predicate-info <g*1>
          ^smem-query <query>)
    (<g*1> ^predicate <pred>)
    (<pred> ^handle <pred-handle>)
    (<query> ^cue <c*1> ^result <id>)
    (<c*1> ^handle <pred-handle>)
    -->
    (<pred> ^predicate-id <id> +)
}

sp {learn-goal-definition*elaborate*smem-query-cue*predicate
    (state <s> ^name learn-goal-definition ^goal-predicate-info <g*1>)
    (<g*1> ^predicate <p*1>)
    (<p*1> ^handle <pred-handle>)
    -->
    (<s> ^smem-query <query> +)
    (<query> ^cue <cue> + ^depth 2 +)
    (<cue> ^handle <pred-handle> +)
}

sp {learn-goal-definition*elaborate*action-id*smem-query-cue
    (state <s> ^name learn-goal-definition ^smem-query <query>
          ^action-operator <a*1>)
    (<a*1> ^action-handle <action-handle>)
    (<query> ^cue <c*1> ^result <lti>)
    (<c*1> ^handle <action-handle>)
    -->
    (<s> ^action-id <lti> +)
}

sp {learn-goal-definition*elaborate*smem-query*action
    (state <s> ^name learn-goal-definition ^action-operator <a*1>)
    (<a*1> ^action-handle <action-handle>)
    -->
    (<s> ^smem-query <query> +)
    (<query> ^cue <cue> + ^depth 8 +)
    (<cue> ^handle <action-handle> +)
}

sp {learn-goal-definition*prefer*smem*operators
    (state <s> ^name learn-goal-definition ^operator <o2> + ^operator <o1> +)
    (<o2>
          ^name { << create-goal-structure create-new-goal-predicate update-goal-predicate store-goal >> <n*2> })
    (<o1> ^name { << smem-query >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {learn-goal-definition*update-goal-predicate*prefer*better*matches
    (state <s> ^name learn-goal-definition ^operator <o2> + ^operator <o1> +)
    (<o2> ^name update-goal-predicate ^match <m*1>)
    (<o1> ^name update-goal-predicate ^match { > <m*1> <m1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {learn-goal-definition*prefer*update*over*create*goal-predicate
    (state <s> ^name learn-goal-definition ^operator <o2> + ^operator <o1> +)
    (<o2> ^name create-new-goal-predicate)
    (<o1> ^name update-goal-predicate)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {learn-goal-definition*prefer*add-goal-predicate*over*store
    (state <s> ^name learn-goal-definition ^operator <o2> + ^operator <o1> +)
    (<o2> ^name store-goal)
    (<o1>
          ^name { << create-new-goal-predicate update-goal-predicate >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {learn-goal-definition*prefer*create-goal-structure*over*create*predicates
    (state <s> ^name learn-goal-definition ^operator <o1> + ^operator <o2> +)
    (<o1> ^name create-goal-structure)
    (<o2>
          ^name { << create-new-goal-predicate update-goal-predicate >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {learn-goal-definition*apply*report-success
    (state <s> ^name learn-goal-definition ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name report-success)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <l*1> +)
    (<l*1> ^type goal +)
}

sp {learn-goal-definition*propose*report-success
    (state <s> ^name learn-goal-definition ^goal-structure <goal>
          ^stored <goal>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name report-success +)
}

sp {learn-goal-definition*apply*store-goal*predicate*arg*imagined
    (state <s> ^name learn-goal-definition ^operator <o> ^smem <s*1>)
    (<o> ^name store-goal ^goal <g*1>)
    (<s*1> ^command <cmd>)
    (<g*1> ^predicate <p*1>)
    (<p*1> ^{ << id 1 2 3 4 5 >> <a*1> } <v*1>)
    (<v*1> ^imagined <img>)
    -->
    (<cmd> ^store <img> +)
}

sp {learn-goal-definition*apply*store-goal*predicate*arg*default
    (state <s> ^name learn-goal-definition ^operator <o> ^smem <s*1>)
    (<o> ^name store-goal ^goal <g*1>)
    (<s*1> ^command <cmd>)
    (<g*1> ^predicate <p*1>)
    (<p*1> ^{ << id 1 2 3 4 5 >> <a*1> } <v*1>)
    (<v*1> ^default <def>)
    -->
    (<cmd> ^store <def> +)
}

sp {learn-goal-definition*apply*store-goal*predicate*arg
    (state <s> ^name learn-goal-definition ^operator <o> ^smem <s*1>)
    (<o> ^name store-goal ^goal <g*1>)
    (<s*1> ^command <cmd>)
    (<g*1> ^predicate <p*1>)
    (<p*1> ^{ << id 1 2 3 4 5 >> <a*1> } <arg>)
    -->
    (<cmd> ^store <arg> +)
}

sp {learn-goal-definition*apply*store-goal*predicate
    (state <s> ^name learn-goal-definition ^operator <o> ^smem <s*1>)
    (<o> ^name store-goal ^goal <g*1>)
    (<s*1> ^command <cmd>)
    (<g*1> ^predicate <pred>)
    -->
    (<cmd> ^store <pred> +)
}

sp {learn-goal-definition*apply*store-goal
    (state <s> ^name learn-goal-definition ^operator <o> ^action-id <action>
          ^smem <s*1>)
    (<o> ^name store-goal ^goal <goal>)
    (<s*1> ^command <cmd>)
    -->
    (<action> ^goal <goal> +)
    (<cmd> ^store <goal> + ^store <action> +)
    (<s> ^stored <goal> +)
}

sp {learn-goal-definition*propose*store-goal
    (state <s> ^name learn-goal-definition ^generalized-goal <goal>
          -^stored <goal>)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name store-goal + ^goal <goal> +)
}

sp {learn-goal-definition*apply*report-failure
    (state <s> ^name learn-goal-definition ^operator <o> ^top-state <t*1>)
    (<o> ^name report-failure ^failure-type <type>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^failure <f*1> +)
    (<f*1> ^type <type> +)
}

sp {learn-goal-definition*propose*report-failure*no*action
    (state <s> ^name learn-goal-definition -^action-id <a*1>)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name report-failure + ^failure-type no-action-context-for-goal +)
}

sp {learn-goal-definition*elaborate*generalized-goal*from*generalize-argument
    (state <s> ^name learn-goal-definition ^generalize-argument <arg>)
    (<arg> ^arg-type predicate-set ^generalized-rep <rep>)
    -->
    (<s> ^generalized-goal <rep> +)
}

sp {learn-goal-definition*elaborate*goal-predicate*superoperator
    (state <s> ^name learn-goal-definition ^generalize-argument <arg>
          ^superstate <s*1>)
    (<arg> ^arg-type predicate-set ^instance <i>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^goal-predicate <pred>)
    -->
    (<i> ^predicate <pred> +)
}

sp {learn-goal-definition*elaborate*generalize-argument*predicate-set
    (state <s> ^name learn-goal-definition)
    -->
    (<s> ^generalize-argument <arg> +)
    (<arg> ^arg-type predicate-set + ^instance <i> +)
}

sp {learn-goal-definition*elaborate*action-operator*from*top-state*action-stack
    (state <s> ^name learn-goal-definition ^top-state <t*1>)
    (<t*1> ^action-stack <a*1>)
    (<a*1> ^top <t*2>)
    (<t*2> ^execution-operator <op>)
    -->
    (<s> ^action-operator <op> +)
}

sp {learn-goal-definition*elaborate*goal-structure*from*action-id
    (state <s> ^name learn-goal-definition ^action-id <a*1>)
    (<a*1> ^goal <goal>)
    -->
    (<s> ^goal-structure <goal> +)
}

sp {learn-location*apply*report-failure
    (state <s> ^name learn-location ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name report-failure)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^failure <f*1> +)
    (<f*1> ^type learn-location-failure +)
}

sp {learn-location*propose*report-failure
    (state <s> ^name learn-location -^current-waypoint <c*1>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name report-failure +)
}

sp {learn-location*apply*learn-location-waypoint*report*success
    (state <s> ^name learn-location ^operator <o> ^top-state <t*1> ^smem <s*1>)
    (<o> ^name learn-location-waypoint ^location-id <loc>)
    (<t*1> ^interaction <i*1>)
    (<s*1> ^result <r*1>)
    (<r*1> ^success <loc>)
    (<i*1> ^status <status>)
    -->
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <l*1> +)
    (<l*1> ^type location +)
}

sp {learn-location*apply*learn-location-waypoint*add*current-location*world
    (state <s> ^name learn-location ^operator <o> ^top-state <t*1>)
    (<o> ^name learn-location-waypoint ^location-id <loc>)
    (<t*1> ^world <w*1>)
    (<w*1> ^robot <robot>)
    -->
    (<robot> ^current-location <loc> +)
}

sp {learn-location*apply*learn-location-waypoint*say*ok
    (state <s> ^name learn-location ^operator <o> ^top-state <t*1> ^smem <s*1>)
    (<o> ^name learn-location-waypoint ^location-id <loc>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <changes>)
    (<s*1> ^result <r*1>)
    (<r*1> ^success <loc>)
    -->
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type ok +)
}

sp {learn-location*apply*learn-location-waypoint*store
    (state <s> ^name learn-location ^operator <o> ^smem <s*1>)
    (<o> ^name learn-location-waypoint ^location-id <loc>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^store <loc> +)
}

sp {learn-location*apply*learn-location-waypoint*add
    (state <s> ^name learn-location ^operator <o>)
    (<o> ^name learn-location-waypoint ^location-id <loc> ^waypoint <w*1>)
    (<w*1> ^handle <wp-handle>)
    -->
    (<loc> ^waypoint <wp-handle> +)
}

sp {learn-location*propose*learn-location-waypoint
    (state <s> ^name learn-location ^current-waypoint <wp> ^location-id <loc>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name learn-location-waypoint + ^location-id <loc> + ^waypoint <wp> +)
}

sp {learn-location*elaborate*current-waypoint*from*top-state
    (state <s> ^name learn-location ^top-state <t*1>)
    (<t*1> ^world <w*1>)
    (<w*1> ^robot <r*1>)
    (<r*1> ^current-waypoint <wp>)
    -->
    (<s> ^current-waypoint <wp> +)
}

sp {learn-location*elaborate*location-id*from*superoperator
    (state <s> ^name learn-location ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^location-id <id>)
    -->
    (<s> ^location-id <id> +)
}

sp {learn-predicate-info*apply*update-smem*stored*mark*performed
    (state <s> ^name learn-predicate-info ^operator <o*1> ^predicate-id <pred>
          ^top-state <t*1> ^smem <s*1>)
    (<o*1> ^name update-smem)
    (<t*1> ^interaction <i*1>)
    (<s*1> ^result <r*1>)
    (<r*1> ^success <pred>)
    (<i*1> ^status <status>)
    -->
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <l*1> +)
    (<l*1> ^type predicate +)
}

sp {learn-predicate-info*apply*update-smem*store
    (state <s> ^name learn-predicate-info ^operator <o*1> ^predicate-id <pred>
          ^smem <s*1>)
    (<o*1> ^name update-smem)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^store <pred> +)
}

sp {learn-predicate-info*apply*update-smem*create*property*link
    (state <s> ^name learn-predicate-info ^operator <o*1> ^property-id <prop>
          ^predicate-id <pred>)
    (<o*1> ^name update-smem)
    -->
    (<pred> ^property <prop> +)
}

sp {learn-predicate-info*propose*update-smem
    (state <s> ^name learn-predicate-info ^property-id <prop>
          ^predicate-id <pred>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name update-smem +)
}

sp {learn-predicate-info*elaborate*property-id
    (state <s> ^name learn-predicate-info ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^property-id <prop>)
    -->
    (<s> ^property-id <prop> +)
}

sp {learn-predicate-info*elaborate*predicate-id
    (state <s> ^name learn-predicate-info ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^predicate-id <pred>)
    -->
    (<s> ^predicate-id <pred> +)
}

sp {learning-event*elaborate*purpose
    (state <s> ^name learning-event ^superstate <s*1>)
    (<s*1> ^purpose <purp>)
    -->
    (<s> ^purpose <purp> +)
}

sp {learning-event*elaborate*retrospective-learning*present-id
    (state <s> ^name learning-event ^operator <o> + ^purpose <p*1>)
    (<o> ^name retrospective-learning)
    (<p*1> ^parameters <p*2>)
    (<p*2> ^present-id <id>)
    -->
    (<o> ^present-id <id> +)
}

sp {learning-event*apply*retrospective-learning*copy*present-id
    (state <s> ^name learning-event ^operator <o*1> ^purpose <p*1>
          ^epmem <e*1>)
    (<o*1> ^name retrospective-learning)
    (<p*1> ^parameters <params>)
    (<params> -^present-id <p*2>)
    (<e*1> ^present-id <present-id>)
    -->
    (<params> ^present-id <present-id> +)
}

sp {learning-event*propose*retrospective-learning
    (state <s> ^name learning-event ^purpose <p*1> ^purpose <p*2>)
    (<p*1> ^type retrospective-learning)
    (<p*2> ^parameters <p*3>)
    (<p*3> ^action <a*1>)
    (<a*1> ^execution-operator <operator>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name retrospective-learning + ^action-operator <operator> +)
}

sp {learning-event*elaborate*learn-goal-definition*goal-predicate
    (state <s> ^name learning-event ^operator <o> + ^purpose <p>)
    (<o> ^name learn-goal-definition)
    (<p> ^parameters <p*1>)
    (<p*1> ^goal-predicate <pred>)
    -->
    (<o> ^goal-predicate <pred> +)
}

sp {learning-event*propose*learn-predicate*property
    (state <s> ^name learning-event ^purpose <p>)
    (<p> ^type learn-property-predicate ^parameters <p*1>)
    (<p*1> ^message <msg>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name learn-predicate + ^message <msg> + ^type predicate +)
}

sp {learning-event*propose*learn-predicate*heuristic
    (state <s> ^name learning-event -^finished-learning heuristic ^purpose <p>)
    (<p> ^type learn-heuristic-predicate ^parameters <p*1>)
    (<p*1> ^message <msg>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name learn-predicate + ^message <msg> + ^type heuristic +)
}

sp {learning-event*apply*chunk-predicate-structure*finished*failure
    :o-support
    (state <s> ^finished-learning failure ^name learning-event
          ^finished-learning <type> ^top-state <ts> ^<type> <t*1>)
    (<ts> ^dialog-context <dc> ^interaction <i*2> ^interaction <i*1>)
    (<dc> ^finalize-chunk <name>)
    (<i*2> ^changes <changes>)
    (<i*1> ^status <status>)
    (<t*1> ^handle <h>)
    -->
    (<dc> ^finalize-chunk <name> -)
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type learned-failure +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <de> +)
    (<de> ^type game + ^originator agent +)
}

sp {learning-event*apply*chunk-predicate-structure*finished*goal
    :o-support
    (state <s> ^finished-learning goal ^name learning-event
          ^finished-learning <type> ^top-state <ts> ^<type> <t*1>)
    (<ts> ^dialog-context <dc> ^interaction <i*2> ^interaction <i*1>)
    (<dc> ^finalize-chunk <name>)
    (<i*2> ^changes <changes>)
    (<i*1> ^status <status>)
    (<t*1> ^handle <h>)
    -->
    (<dc> ^finalize-chunk <name> -)
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type learned-goal +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <de> +)
    (<de> ^type game + ^originator agent +)
}

sp {learning-event*apply*chunk-predicate-structure*finished*action
    :o-support
    (state <s> ^finished-learning action ^name learning-event
          ^finished-learning <type> ^top-state <ts> ^<type> <t*1>)
    (<ts> ^dialog-context <dc> ^interaction <i*2> ^interaction <i*1>)
    (<dc> ^finalize-chunk <name>)
    (<i*2> ^changes <changes>)
    (<i*1> ^status <status>)
    (<t*1> ^handle <h>)
    -->
    (<dc> ^finalize-chunk <name> -)
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type learned-action +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <de> +)
    (<de> ^type game + ^originator agent +)
}

sp {learning-event*apply*chunk-predicate-structure*finished*heuristic
    :o-support
    (state <s> ^finished-learning heuristic ^name learning-event
          ^finished-learning <type> ^top-state <ts> ^<type> <t*1>)
    (<ts> ^dialog-context <dc> ^interaction <i*2> ^interaction <i*1>)
    (<dc> ^finalize-chunk <name>)
    (<i*2> ^changes <changes>)
    (<i*1> ^status <status>)
    (<t*1> ^handle <h>)
    -->
    (<dc> ^finalize-chunk <name> -)
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type learned-heuristic +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <de> +)
    (<de> ^type game + ^originator agent +)
}

sp {learning-event*propose*chunk-predicate-structure
    (state <s> ^name learning-event ^finished-learning <type> ^purpose <p>
          ^top-state <t*2>)
    (<t*2> ^dialog-context <d*1>)
    (<d*1> ^finalize-chunk <h>)
   -{ (<s> ^<type> <t*1>)
      (<t*1> ^handle <h>)}
    (<p>
          ^type { << learn-action-predicate learn-heuristic-predicate learn-goal-predicate learn-failure-predicate >> <t*3> })
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name chunk-predicate-structure + ^gtype <type> +
           ^predicate-handle <h> +)
}

sp {learning-event*apply*chunk-predicate-structure
    (state <s> ^name learning-event ^operator <o*1> ^store-link <dd>)
    (<o*1> ^name chunk-predicate-structure)
    -->
    (<s> ^store-link <dd> -)
}

sp {learning-event*propose*learn-predicate*action
    (state <s> ^name learning-event -^finished-learning action ^purpose <p>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^dialog-context <d*1>)
      (<d*1> ^finalize-chunk <f*1>)}
    (<p> ^type learn-action-predicate ^parameters <p*1>)
    (<p*1> ^message <msg>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name learn-predicate + ^message <msg> + ^type action +)
}

sp {learning-event*apply*learn-search-depth*2
    :o-support
    (state <s> ^name learning-event ^operator <o> ^top-state <ts>)
    (<o> ^name learn-search-depth ^message <msg>)
    (<msg> ^action <a*1> ^agent <a*2> ^arg1 <a*3>)
    (<a*1> ^handle has)
    (<a*2> ^predicates <p*1>)
    (<p*1> ^category solution1)
    (<a*3> ^predicates <p>)
    (<p> ^shape steps1 ^number <n2>)
    (<ts> ^dialog-context <dc> ^interaction <i*2> ^interaction <i*1>)
    (<dc> ^structure <st>)
    (<i*2> ^changes <changes>)
    (<i*1> ^status <status>)
    -->
    (<st> ^start-search-depth <n2> +)
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type ok +)
    (<status> ^performed <p*2> +)
    (<p*2> ^learning-event <de> +)
    (<de> ^type game +)
}

sp {learning-event*apply*learn-search-depth
    :o-support
    (state <s> ^name learning-event ^operator <o> ^top-state <ts>)
    (<o> ^name learn-search-depth ^message <msg>)
    (<msg> ^agent <a*2> ^action <a*1> ^arg1 <a*3>)
    (<a*2> ^handle solution1)
    (<a*1> ^handle has)
    (<a*3> ^predicates <p>)
    (<p> ^shape steps1 ^number <n2>)
    (<ts> ^dialog-context <dc> ^interaction <i*2> ^interaction <i*1>)
    (<dc> ^structure <st>)
    (<i*2> ^changes <changes>)
    (<i*1> ^status <status>)
    -->
    (<st> ^start-search-depth <n2> +)
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type ok +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <de> +)
    (<de> ^type game +)
}

sp {learning-event*propose*learn-search-depth
    (state <s> ^name learning-event ^purpose <p>)
    (<p> ^type learn-start-depth ^parameters <p*1>)
    (<p*1> ^message <msg>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name learn-search-depth + ^message <msg> +)
}

sp {learning-event*apply*learn-predicate*failure*clean-setup
    (state <s> ^name learning-event ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name learn-predicate)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^parsed-failure <m> ^needs-failure-setup <t>)
    -->
    (<dc> ^needs-failure-setup <t> - ^parsed-failure <m> -)
}

sp {learning-event*apply*learn-predicate*goal*clean-setup
    (state <s> ^name learning-event ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name learn-predicate)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^parsed-goal <m> ^needs-goal-setup <t>)
    -->
    (<dc> ^needs-goal-setup <t> - ^parsed-goal <m> -)
}

sp {learning-event*propose*learn-predicate*failure
    (state <s> ^name learning-event -^finished-learning failure ^purpose <p>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^dialog-context <d*1>)
      (<d*1> ^finalize-chunk <f*1>)}
    (<p> ^type learn-failure-predicate ^parameters <p*1>)
    (<p*1> ^message <msg>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name learn-predicate + ^message <msg> + ^type failure +)
}

sp {learning-event*propose*learn-predicate*goal
    (state <s> ^name learning-event -^finished-learning goal ^purpose <p>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^dialog-context <d*1>)
      (<d*1> ^finalize-chunk <f*1>)}
    (<p> ^type learn-goal-predicate ^parameters <p*1>)
    (<p*1> ^message <msg>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name learn-predicate + ^message <msg> + ^type goal +)
}

sp {learning-event*propose*finished-learning
    (state <s> ^name learning-event ^finished-learning <type>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^dialog-context <d*1>)
      (<d*1> ^finalize-chunk <f*1>)}
    -->
    (<s> ^operator <o1> + ^operator <o1> >)
    (<o1> ^name finished-learning + ^type <type> +)
}

sp {learning-event*propose*learn-failure-name
    (state <s> ^name learning-event ^purpose <p>)
    (<p> ^type learn-failure-name ^parameters <p*1>)
    (<p*1> ^message <msg>)
    (<msg> ^predicate <p*2>)
    (<p*2> ^handle <name>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name store-predicate-structure + ^type failure + ^storing name +
           ^handle <name> + ^message <msg> +)
}

sp {learning-event*propose*learn-goal-name
    (state <s> ^name learning-event ^purpose <p>)
    (<p> ^type learn-goal-name ^parameters <p*1>)
    (<p*1> ^message <msg>)
    (<msg> ^predicate <p*2>)
    (<p*2> ^handle <name>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name store-predicate-structure + ^type goal + ^storing name +
           ^handle <name> + ^message <msg> +)
}

sp {learning-event*propose*learn-action-name
    (state <s> ^name learning-event ^purpose <p>)
    (<p> ^type learn-action-name ^parameters <p*1>)
    (<p*1> ^message <msg>)
    (<msg> ^predicate <p*2>)
    (<p*2> ^handle <name>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name store-predicate-structure + ^type action + ^storing name +
           ^handle <name> + ^message <msg> +)
}

sp {learning-event*propose*learn-puzzle-name
    (state <s> ^name learning-event -^retrieve-handle <r*1> ^purpose <p>
          ^retrieve-game <name>)
    (<p> ^type learn-puzzle-name ^parameters <p*1>)
    (<p*1> ^message <msg>)
    (<msg> ^predicate <p*2>)
    (<p*2> ^handle <name>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name store-predicate-structure + ^type puzzle + ^storing name +
           ^handle <name> + ^message <msg> +)
}

sp {learning-event*elaborate*puzzle-retrieval
    (state <s> ^name learning-event ^purpose <p>)
    (<p> ^type learn-puzzle-name ^parameters <p*1>)
    (<p*1> ^message <msg>)
    (<msg> ^predicate <p*2>)
    (<p*2> ^handle <name>)
    -->
    (<s> ^retrieve-game <name> + ^multiplayer false +)
}

sp {learning-event*elaborate*game-retrieval
    (state <s> ^name learning-event ^purpose <p>)
    (<p> ^type learn-game-name ^parameters <p*1>)
    (<p*1> ^message <msg>)
    (<msg> ^predicate <p*2>)
    (<p*2> ^handle <name>)
    -->
    (<s> ^retrieve-game <name> + ^opponent false + ^multiplayer true +)
}

sp {learning-event*propose*learn-game-name
    (state <s> ^name learning-event -^retrieve-handle <r*1> ^purpose <p>
          ^retrieve-game <name>)
    (<p> ^type learn-game-name ^parameters <p*1>)
    (<p*1> ^message <msg>)
    (<msg> ^predicate <p*2>)
    (<p*2> ^handle <name>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name store-predicate-structure + ^type game + ^storing name +
           ^handle <name> + ^message <msg> +)
}

sp {learning-event*propose*finished-game-teaching*learned
    (state <s> ^name learning-event ^purpose <p>)
    (<p> ^type finished-game-learning ^parameters <p*1>)
    (<p*1> ^message <yesno>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name finished-game-teaching + ^response <yesno> +)
}

sp {learning-event*propose*finished-game-teaching
    (state <s> ^name learning-event ^purpose <p>)
    (<p> ^type finished-game-teaching)
    -->
    (<s> ^operator <o> +)
    (<o> ^name finished-game-teaching + ^type game +)
}

sp {learning-event*propose*finished-game-teaching*retrieval
    (state <s> ^name learning-event ^retrieve-handle <r*1>
          ^retrieve-game <name> ^multiplayer <mult> ^purpose <p>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name finished-game-teaching + ^multiplayer <mult> +
           ^game-name <name> + ^type replay-game +)
}

sp {learning-event*propose*learn-goal-demonstration*final
    (state <s> ^name learning-event ^purpose <p>)
    (<p> ^type learn-goal-final-state)
    -->
    (<s> ^operator <o> +)
    (<o> ^name learn-goal-demonstration + ^type final +)
}

sp {learning-event*propose*learn-goal-demonstration*initial
    (state <s> ^name learning-event ^purpose <p>)
    (<p> ^type learn-goal-initial-state)
    -->
    (<s> ^operator <o> +)
    (<o> ^name learn-goal-demonstration + ^type initial +)
}

sp {learning-event*apply*learn-teacher-name*send-message
    (state <s> ^name learning-event ^operator <o> ^top-state <ts>)
    (<o> ^name learn-teacher-name ^predicate <p>)
    (<p> ^word-structure <w*1>)
    (<w*1> ^spelling <word>)
    (<ts> ^interaction <i>)
    (<i> ^changes <changes> ^status <status>)
    -->
    (<ts> ^teacher-name <word> +)
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type learned-teacher-name + ^fields <f*1> +)
    (<f*1> ^word <word> +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <de> +)
    (<de> ^type game + ^originator agent +)
}

sp {learning-event*propose*learn-teacher-name
    (state <s> ^name learning-event ^purpose <p>)
    (<p> ^type learn-teacher-name ^parameters <p*1>)
    (<p*1> ^message <msg>)
    (<msg> ^predicate <p>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name learn-teacher-name + ^predicate <p> +)
}

sp {learning-event*apply*modify-attend-ignore-list*send-message
    (state <s> ^name learning-event ^operator <o*1> ^top-state <t*2>
          ^top-state <t*1>)
    (<o*1> ^name modify-attend-ignore-list)
    (<t*2> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type ok +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <de> +)
    (<de> ^type game + ^originator agent +)
}

sp {learning-event*apply*modify-attend-ignore-list*object*direct
    (state <s> ^name learning-event ^operator <o> ^top-state <t*1>)
    (<o> ^name modify-attend-ignore-list ^message <msg> ^type <type>)
    (<msg> ^arg1 <obj>)
    (<obj> ^item-type { << object block location >> <i*1> })
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^<type> <at>)
    -->
    (<at> ^object <obj> +)
}

sp {learning-event*apply*modify-attend-ignore-list*object
    (state <s> ^name learning-event ^operator <o> ^top-state <t*1>)
    (<o> ^name modify-attend-ignore-list ^message <msg> ^type <type>)
    (<msg> ^arg1 <a*1>)
    (<a*1> ^2 <obj>)
    (<obj> ^item-type { << object block location >> <i*1> })
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^<type> <at>)
    -->
    (<at> ^object <obj> +)
}

sp {learning-event*apply*modify-attend-ignore-list*relation
    (state <s> ^name learning-event ^operator <o> ^top-state <t*1>)
    (<o> ^name modify-attend-ignore-list ^message <msg> ^type <type>)
    (<msg> ^arg1 <arg1>)
    (<arg1> ^handle relation ^relation <r>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^<type> <at>)
    (<r> ^handle named ^2 <name>)
    -->
    (<at> ^relation <name> +)
}

sp {learning-event*apply*modify-attend-ignore-list*modified-true
    (state <s> ^name learning-event ^operator <o> ^top-state <t*1>)
    (<o> ^name modify-attend-ignore-list)
    (<t*1> ^dialog-context <dc>)
    -->
    (<dc> ^modified true +)
}

sp {learning-event*propose*modify-attend-ignore-list*ignore
    (state <s> ^name learning-event ^purpose <p>)
    (<p> ^type modify-ignore-list ^parameters <p*1>)
    (<p*1> ^message <msg>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name modify-attend-ignore-list + ^type ignore + ^message <msg> +)
}

sp {learning-event*propose*modify-attend-ignore-list*attend
    (state <s> ^name learning-event ^purpose <p>)
    (<p> ^type modify-attend-list ^parameters <p*1>)
    (<p*1> ^message <msg>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name modify-attend-ignore-list + ^type attend + ^message <msg> +)
}

sp {learning-event*propose*learn-goal-definition
    (state <s> ^name learning-event ^purpose <p>)
    (<p> ^type learn-goal-definition)
    -->
    (<s> ^operator <o> +)
    (<o> ^name learn-goal-definition +)
}

sp {learning-event*propose*learn-predicate-info
    (state <s> ^name learning-event ^purpose <p>)
    (<p> ^type learn-predicate-info ^parameters <params>)
    (<params> ^property-id <prop> ^predicate-id <pred>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name learn-predicate-info + ^predicate-id <pred> +
           ^property-id <prop> +)
}

sp {learning-event*propose*learn-preposition
    (state <s> ^name learning-event ^purpose <p>)
    (<p> ^type teach-relation ^parameters <params>)
    (<params> ^relation <rel> ^object <obj>)
    (<rel> ^arg2 <obj2> ^id <lti-rel>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name learn-preposition + ^relation-lti <lti-rel> + ^arg1 <obj> +
           ^arg2 <obj2> +)
}

sp {learning-event*propose*equate-objects
    (state <s> ^name learning-event ^purpose <p>)
    (<p> ^type equate-objects ^parameters <params>)
    (<params> ^object1 <obj1> ^object2 <obj2>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name equate-objects + ^object1 <obj1> + ^object2 <obj2> +)
}

sp {learning-event*propose*learn-location
    (state <s> ^name learning-event ^purpose <p>)
    (<p> ^type teach-location ^parameters <p*1>)
    (<p*1> ^location-id <loc>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name learn-location + ^location-id <loc> +)
}

sp {learning-event*elaborate*train-on-object*predicate
    (state <s> ^name learning-event ^operator <o> + ^purpose <p*1>)
    (<o> ^name train-on-object)
    (<p*1> ^parameters <p*2>)
    (<p*2> ^predicate <pred>)
    -->
    (<o> ^predicate <pred> +)
}

sp {learning-event*propose*train-on-object
    (state <s> ^name learning-event ^purpose <p>)
    (<p> ^type train-on-object ^parameters <p*1>)
    (<p*1> ^object <obj>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name train-on-object + ^object <obj> +)
}

sp {train-on-object*apply*complete-train-on-object*store
    (state <s> ^name train-on-object ^operator <o*1> ^example-object <e*1>
          ^top-state <t*1>)
    (<o*1> ^name complete-train-on-object)
    (<e*1> ^smem-rep <obj>)
    (<t*1> ^smem <s*1>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^store <obj> +)
}

sp {train-on-object*apply*complete-train-on-object*mark*performed
    (state <s> ^name train-on-object ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name complete-train-on-object)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <l*1> +)
    (<l*1> ^type object +)
}

sp {train-on-object*propose*complete-train-on-object
    (state <s> ^name train-on-object)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete-train-on-object +)
}

sp {train-predicate-apply*report-unknown-predicate
    (state <s> ^name train-predicate ^operator <o> ^top-state <t*1>)
    (<o> ^name report-unknown-predicate ^predicate <pred>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^failure <f> +)
    (<f> ^type unknown-predicate + ^predicate <pred> +)
}

sp {train-predicate*propose*report-unknown-predicate
    (state <s> ^name train-predicate ^predicate <pred>)
    (<pred> -^property <p*1> ^handle <pred-handle>)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name report-unknown-predicate + ^predicate <pred> +)
}

sp {train-predicate*elaborate*retrieve*predicate
    (state <s> ^name train-predicate ^predicate <pred>)
    -->
    (<s> ^smem-retrieve <ret> +)
    (<ret> ^identifier <pred> + ^depth 2 +)
}

sp {train-predicate*apply*complete-train-predicate
    (state <s> ^name train-predicate ^operator <o*1> ^predicate <pred>
          ^superstate <ss>)
    (<o*1> ^name complete-train-predicate)
    -->
    (<ss> ^trained <pred> +)
}

sp {train-predicate*propose*complete-train-predicate
    (state <s> ^name train-predicate)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete-train-predicate +)
}

sp {train-predicate*apply*send-training-example*send*example
    (state <s> ^name train-predicate ^operator <o*1> ^example-object <e*1>
          ^predicate <pred> ^io <i*1>)
    (<o*1> ^name send-training-example)
    (<pred> ^handle <pred-handle> ^property <prop>)
    (<e*1> ^handle <obj-handle>)
    (<i*1> ^output-link <ol>)
    (<prop> ^type visual ^handle <prop-handle>)
    -->
    (<ol> ^send-training-label <stl> +)
    (<stl> ^object-handle <obj-handle> + ^label <pred-handle> +
           ^property-handle <prop-handle> +)
}

sp {train-predicate*apply*send-training-example*mark*trained
    (state <s> ^name train-predicate ^operator <o*1>)
    (<o*1> ^name send-training-example)
    -->
    (<s> ^trained true +)
}

sp {train-predicate*propose*send-training-example
    (state <s> ^name train-predicate -^trained <t*1> ^example-object <obj>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name send-training-example +)
}

sp {train-predicate*prefer*measure-object*over*send-training-example
    (state <s> ^name train-predicate ^operator <o2> + ^operator <o1> +)
    (<o2> ^name send-training-example)
    (<o1> ^name measure-object)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {train-predicate*elaborate*predicate
    (state <s> ^name train-predicate ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^predicate <pred>)
    -->
    (<s> ^predicate <pred> +)
}

sp {train-predicate*elaborate*object
    (state <s> ^name train-predicate ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^example-object <obj>)
    -->
    (<s> ^example-object <obj> +)
}

sp {train-on-object*propose*train-predicate
    (state <s> ^name train-on-object ^predicate <pred> -^trained <pred>
          ^example-object <obj>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name train-predicate + ^example-object <obj> + ^predicate <pred> +)
}

sp {train-on-object*copy*object
    (state <s> ^name train-on-object ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^object <obj>)
    -->
    (<s> ^example-object <obj> +)
}

sp {train-on-object*elaborate*predicate
    (state <s> ^name train-on-object ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^predicate <pred>)
    -->
    (<s> ^predicate <pred> +)
}

sp {dialog-event*apply*failed-parse
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name failed-parse)
    (<ts> ^interaction <i*2> ^io <i*1>)
    (<i*2> ^status <status>)
    (<i*1> ^output-link <out>)
    -->
    (<out> ^send-message <msg> +)
    (<msg> ^type parse-failure-response + ^fields <f> +)
    (<status> ^performed <p*1> +)
    (<p*1> ^dialog-event <de> +)
    (<de> ^type parse-failure-response + ^originator agent +)
}

sp {dialog-event*propose*failed-parse
    (state <s> ^name dialog-event ^purpose <p*1>)
    (<p*1> ^type failed-parse)
    -->
    (<s> ^operator <o> +)
    (<o> ^name failed-parse +)
}

sp {answer-property-question*apply*complete-answer-property-question*store
    (state <s> ^name answer-property-question ^operator <o*1>
          ^this-object <t*2> ^top-state <t*1>)
    (<o*1> ^name complete-answer-property-question)
    (<t*2> ^smem-rep <obj>)
    (<t*1> ^smem <s*1>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^store <obj> +)
}

sp {answer-property-question*apply*complete-answer-property-question*mark*performed
    (state <s> ^name answer-property-question ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name complete-answer-property-question)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^performed <p*1> +)
    (<p*1> ^dialog-event <de> +)
    (<de> ^type single-word-response + ^originator agent +)
}

sp {answer-property-question*apply*complete-answer-property-question*send-message
    (state <s> ^name answer-property-question ^operator <o*1> ^answer <word>
          ^io <i*1>)
    (<o*1> ^name complete-answer-property-question)
    (<i*1> ^output-link <out>)
    -->
    (<out> ^send-message <msg> +)
    (<msg> ^type single-word-response + ^fields <f*1> +)
    (<f*1> ^word <word> +)
}

sp {answer-property-question*propose*complete-answer-property-question
    (state <s> ^name answer-property-question)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete-answer-property-question +)
}

sp {answer-property-question*elaborate*answer*dontknow
    (state <s> ^name answer-property-question -^answer { <> dontknow <a*1> })
    -->
    (<s> ^answer dontknow +)
}

sp {answer-property-question*elaborate*answer*existing
    (state <s> ^name answer-property-question ^this-object <t*1>
          ^property <p*1>)
    (<t*1> ^property <prop>)
    (<prop> ^word <word> ^name <prop-name>)
    (<p*1> ^name <prop-name>)
    -->
    (<s> ^answer <word> +)
}

sp {answer-property-question*elaborate*answer*retrieval
    (state <s> ^name answer-property-question ^sense <s*1>)
    (<s*1> ^word <w*1>)
    (<w*1> ^word <word>)
    -->
    (<s> ^answer <word> +)
}

sp {answer-property-question*smem-retrieve*word
    (state <s> ^name answer-property-question ^sense <s*1>)
    (<s*1> ^word <word>)
    -->
    (<s> ^retrieve-lti <word> +)
}

sp {answer-property-question*elaborate*sense
    (state <s> ^name answer-property-question ^retrieved-lti-cue <r*1>)
    (<r*1> ^retrieved-lti <lti>)
    (<lti> ^wme-type sense)
    -->
    (<s> ^sense <lti> +)
}

sp {answer-property-question*smem-query*lookup-label
    (state <s> ^name answer-property-question ^this-object <t*1>
          ^property <smem-prop>)
    (<t*1> ^property <prop>)
    (<prop> -^word <w*1> ^label <label> ^name <prop-name>)
    (<smem-prop> ^name <prop-name>)
    -->
    (<s> ^smem-query-cue <cue> +)
    (<cue> ^wme-type sense + ^label <label> + ^property <smem-prop> +)
}

sp {answer-property-question*best-pref*attend-to-scene-change
    (state <s> ^name answer-property-question ^operator <o> +)
    (<o> ^name attend-to-scene-change)
    -->
    (<s> ^operator <o> >)
}

sp {answer-property-question*attend*to*object*property
    (state <s> ^name answer-property-question ^this-object <t*1>
          ^property <p*1>)
    (<t*1> ^id <id>)
    (<p*1> ^name <prop-name>)
    -->
    (<s> ^attend-to-object <id> + ^attend-to-property-type <prop-name> +)
}

sp {answer-property-question*elaborate*property
    (state <s> ^name answer-property-question ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^property <prop>)
    -->
    (<s> ^property <prop> +)
}

sp {answer-property-question*elaborate*this-object
    (state <s> ^name answer-property-question ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^object <obj>)
    -->
    (<s> ^this-object <obj> +)
}

sp {dialog-event*propose*answer-property-question
    (state <s> ^name dialog-event ^purpose <p>)
    (<p> ^type property-question ^parameters <p*2> ^parameters <p*1>)
    (<p*2> ^indexable <obj-index>)
    (<obj-index> ^type object ^result <obj>)
    (<p*1> ^indexable <prop-index>)
    (<prop-index> ^type property ^result <prop>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name answer-property-question + ^object <obj> + ^property <prop> +)
}

sp {answer-is-question*apply*store*object
    (state <s> ^name answer-is-question ^operator <o*1>
          ^relation-question <r*1> ^top-state <t*1>)
    (<o*1> ^name find-relations)
    (<r*1> ^object1 <o*2>)
    (<t*1> ^smem <s*1>)
    (<o*2> ^result <r*2>)
    (<r*2> ^smem-rep <obj>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^store <obj> +)
}

sp {answer-is-question*apply*find-relations*no
    (state <s> ^name answer-is-question ^operator <o*1> ^relationships <rels>
          ^relation-question <q> ^top-state <t*1> ^io <i*2>)
    (<o*1> ^name find-relations)
    (<rels> ^with <id1> ^preposition <prep>)
    (<q> ^object1 <o*2> ^object2 <o*3> ^preposition <prep>)
    (<o*2> ^result <r*1>)
    (<r*1> ^id <id1>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    (<o*3> ^result <r*2>)
    (<r*2> ^id <id2>)
   -{ (<rels> ^relations <r*3>)
      (<r*3> ^obj <id2>)}
    (<i*2> ^output-link <out>)
    -->
    (<out> ^send-message <msg> +)
    (<msg> ^type single-word-response + ^fields <f*1> +)
    (<f*1> ^word no +)
    (<status> ^performed <p*1> +)
    (<p*1> ^dialog-event <de> +)
    (<de> ^type single-word-response + ^originator agent +)
}

sp {answer-is-question*apply*find-relations*yes
    (state <s> ^name answer-is-question ^operator <o*1> ^relationships <rels>
          ^relation-question <q> ^top-state <t*1> ^io <i*2>)
    (<o*1> ^name find-relations)
    (<rels> ^relations <r*3> ^with <id1> ^preposition <prep>)
    (<r*3> ^obj <id2>)
    (<q> ^object1 <o*2> ^object2 <o*3> ^preposition <prep>)
    (<o*2> ^result <r*1>)
    (<r*1> ^id <id1>)
    (<o*3> ^result <r*2>)
    (<r*2> ^id <id2>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    (<i*2> ^output-link <out>)
    -->
    (<out> ^send-message <msg> +)
    (<msg> ^type single-word-response + ^fields <f*1> +)
    (<f*1> ^word yes +)
    (<status> ^performed <p*1> +)
    (<p*1> ^dialog-event <de> +)
    (<de> ^type single-word-response + ^originator agent +)
}

sp {answer-is-question*propose*find-relations
    (state <s> ^name answer-is-question ^relation-question <q>)
    (<q> ^object1 <o*1> ^preposition <prep>)
    (<o*1> ^result <r*1>)
    (<r*1> ^id <id1>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name find-relations + ^prep <prep> + ^obj <id1> + ^ind 1 +)
}

sp {dialog-event*apply*answer-is-question*send*answer
    (state <s> ^name dialog-event ^operator <o> ^top-state <t*1> ^io <i*1>)
    (<o> ^name answer-is-question ^answer <ans>)
    (<t*1> ^interaction <i*2>)
    (<i*2> ^status <status>)
    (<i*1> ^output-link <out>)
    -->
    (<out> ^send-message <msg> +)
    (<msg> ^type single-word-response + ^fields <f*1> +)
    (<f*1> ^word <ans> +)
    (<status> ^performed <p*1> +)
    (<p*1> ^dialog-event <de> +)
    (<de> ^type single-word-response + ^originator agent +)
}

sp {dialog-event*elaborate*answer-is-question*default*no
    (state <s> ^name dialog-event ^operator <o> +)
    (<o> -^answer yes ^name answer-is-question ^questioned <q>)
    -->
    (<o> ^answer no +)
}

sp {dialog-event*elaborate*answer-is-question*yes*name
    (state <s> ^name dialog-event ^operator <o> +)
    (<o> ^name answer-is-question ^indexed-object <obj> ^questioned <q*2>
          ^questioned <q*1>)
    (<q*1> ^sense <s*1>)
    (<q*2> ^word <name>)
    (<obj> ^property <p*2>)
    (<p*2> ^word <name>)
    (<s*1> ^property <p*1>)
    (<p*1> ^name name)
    -->
    (<o> ^answer yes +)
}

sp {dialog-event*elaborate*answer-is-question*yes*generic
    (state <s> ^name dialog-event ^operator <o> +)
    (<o> ^name answer-is-question ^questioned <q*1>)
    (<q*1> ^sense <s*1>)
    (<s*1> ^property <p*1>)
    (<p*1> ^name generic)
    -->
    (<o> ^answer yes +)
}

sp {dialog-event*elaborate*answer-is-question*yes*word*match
    (state <s> ^name dialog-event ^operator <o> +)
    (<o> ^name answer-is-question ^indexed-object <obj> ^questioned <q*1>)
    (<q*1> ^sense <s*1>)
    (<s*1> ^label <label>)
    (<obj> ^property <p*1>)
    (<p*1> ^label <label>)
    -->
    (<o> ^answer yes +)
}

sp {dialog-event*elaborate*answer-is-question*indexed-object
    (state <s> ^name dialog-event ^operator <o> + ^purpose <p*1>)
    (<o> ^name answer-is-question)
    (<p*1> ^parameters <p*2>)
    (<p*2> ^indexable <i>)
    (<i> ^type object ^result <obj>)
    -->
    (<o> ^indexed-object <obj> +)
}

sp {dialog-event*elaborate*answer-is-question*questioned
    (state <s> ^name dialog-event ^operator <o> + ^purpose <p*5>
          ^purpose <p*3>)
   -{ (<s> ^purpose <p*1>)
      (<p*1> ^parameters <p*2>)
      (<p*2> ^relation-question <r*1>)}
    (<o> ^name answer-is-question)
    (<p*5> ^parameters <p*6>)
    (<p*6> ^indexable <i>)
    (<i> ^type object ^indexable <i*1>)
    (<p*3> ^parameters <p*4>)
    (<p*4> ^questioned <adj>)
    (<i*1> ^result <word>)
    (<word> ^word <adj>)
    -->
    (<o> ^questioned <word> +)
}

sp {answer-is-question*elaborate*relation-question
    (state <s> ^name answer-is-question ^superstate <s*1>)
    (<s*1> ^purpose <p*1>)
    (<p*1> ^parameters <p*2>)
    (<p*2> ^relation-question <rel>)
    -->
    (<s> ^relation-question <rel> +)
}

sp {dialog-event*propose*answer-is-question
    (state <s> ^name dialog-event ^purpose <p*1>)
    (<p*1> ^type is-question)
    -->
    (<s> ^operator <o> +)
    (<o> ^name answer-is-question +)
}

sp {game-heuristics-finished-message*propose*finish-failures
    (state <s> ^name dialog-event ^purpose <p>)
    (<p> ^type game-heuristics-finished-message ^parameters <param>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name finish-failures + ^parameter <type> + ^category svs +)
}

sp {game-params-finished-message*propose*finish-game-params
    (state <s> ^name dialog-event ^purpose <p>)
    (<p> ^type game-params-finished-message ^parameters <param>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name finish-game-params + ^parameter <type> + ^category svs +)
}

sp {game-over-message*propose*game-over
    (state <s> ^name dialog-event ^purpose <p>)
    (<p> ^type game-over-message ^parameters <param>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name game-over + ^category svs +)
}

sp {verbs-finished-message*propose*finish-verbs
    (state <s> ^name dialog-event ^purpose <p>)
    (<p> ^type verbs-finished-message ^parameters <param>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name finish-verbs + ^parameter <type> + ^category svs +)
}

sp {actions-finished-message*propose*finish-actions
    (state <s> ^name dialog-event ^purpose <p>)
    (<p> ^type actions-finished-message ^parameters <param>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name finish-actions + ^parameter <type> + ^category svs +)
}

sp {parameters-finished-message*apply*finish-parameters*finish-conditions
    (state <s> ^name dialog-event ^operator <o> ^top-state <t*1>)
    (<o> ^name finish-parameters)
    (<t*1> ^current-game <c*1>)
    (<c*1> ^learning <l>)
    (<l> ^type { << condition >> <cond> })
    -->
    (<l> ^type <cond> - ^type parameter +)
}

sp {parameters-finished-message*propose*finish-parameters
    (state <s> ^name dialog-event ^purpose <p>)
    (<p> ^type parameters-finished-message)
    -->
    (<s> ^operator <o> +)
    (<o> ^name finish-parameters + ^category svs +)
}

sp {failure-name-message*propose*learn-failure
    (state <s> ^name dialog-event ^purpose <p>)
    (<p> ^type failure-name-message ^parameters <param>)
    (<param> ^failure-name <name>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name learn-failure + ^failure-name <name> + ^category svs +)
}

sp {goal-name-message*propose*learn-goal
    (state <s> ^name dialog-event ^purpose <p>)
    (<p> ^type goal-name-message ^parameters <param>)
    (<param> ^goal-name <name>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name learn-goal + ^goal-name <name> + ^category svs +)
}

sp {heuristic-message*propose*learn-heuristic
    (state <s> ^name dialog-event ^purpose <p>)
    (<p> ^type heuristic-message ^parameters <param>)
    (<param> ^type action ^action2 <action2> ^action1 <action1>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name learn-heuristic + ^type action + ^action1 <action1> +
           ^action2 <action2> + ^category svs +)
}

sp {verb-name-message*propose*learn-actionref
    (state <s> ^name dialog-event ^purpose <p>)
    (<p> ^type verb-name-message ^parameters <param>)
    (<param> ^verb-prep <prep> ^verb-name <name> ^objb <p2> ^obja <p1>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name learn-action + ^verb-name <name> + ^verb-prep <prep> +
           ^obja <p1> + ^objb <p2> + ^category svs +)
}

sp {verb-name-message*propose*learn-action
    (state <s> ^name dialog-event ^purpose <p>)
    (<p> ^type verb-name-message ^parameters <param>)
    (<param> ^verb-prep <prep> ^verb-name <name> ^b <p2> ^a <p1>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name learn-action + ^verb-name <name> + ^verb-prep <prep> +
           ^a <p1> + ^b <p2> + ^category svs +)
}

sp {action-name-message*propose*learn-action*multiplayer
    (state <s> ^name dialog-event ^purpose <p>)
    (<p> ^type action-name-message ^parameters <param>)
    (<param> ^multiplayer <name>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name learn-action + ^multiplayer <name> + ^category svs +)
}

sp {action-name-message*propose*learn-action
    (state <s> ^name dialog-event ^purpose <p>)
    (<p> ^type action-name-message ^parameters <param>)
    (<param> ^action-name <name>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name learn-action + ^action-name <name> + ^category svs +)
}

sp {parameter-condition-message-relation*propose*learn-condition*3arg
    (state <s> ^name dialog-event ^purpose <p>)
    (<p> ^type parameter-condition-message-relation ^parameters <param>)
    (<param> ^objc <objc> ^objb <objb> ^obja <obja> ^negative <val>
          ^prep <prep>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name learn-condition + ^prep <prep> + ^negative <val> +
           ^obja <obja> + ^objb <objb> + ^objc <objc> +)
}

sp {parameter-condition-message-relation*propose*learn-condition
    (state <s> ^name dialog-event ^purpose <p>)
    (<p> ^type parameter-condition-message-relation ^parameters <param>)
    (<param> -^objc <o*1> ^objb <objb> ^obja <obja> ^negative <val>
          ^prep <prep>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name learn-condition + ^category svs + ^prep <prep> +
           ^negative <val> + ^obja <obja> + ^objb <objb> +)
}

sp {parameter-condition-message*propose*learn-condition
    (state <s> ^name dialog-event ^purpose <p>)
    (<p> ^type parameter-condition-message ^parameters <param>)
    (<param> ^parameter <type> ^attribute <cond>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name learn-condition + ^prep none + ^negative false +
           ^attribute <cond> + ^obja <obja> +)
    (<obja> ^word object + ^specifier DEF + ^word <type> +)
}

sp {action-parameter-message*propose*learn-parameter
    (state <s> ^name dialog-event ^purpose <p>)
    (<p> ^type action-parameter-message ^parameters <p*1>)
    (<p*1> ^parameter <obj>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name learn-parameter + ^parameter <obj> +)
}

sp {state-demo-message*propose*learn-goal-demonstration
    (state <s> ^name dialog-event ^purpose <p>)
    (<p> ^type state-demo-message ^parameters <p*1>)
    (<p*1> ^state-name <type>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name learn-goal-demonstration + ^type <type> +)
}

sp {goal-feature-modify*propose*learn-parameter
    (state <s> ^name dialog-event ^purpose <p>)
    (<p> ^type goal-feature-modify ^parameters <pa>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name goal-feature-tracking + ^parameter <pa> +)
}

sp {action-event*propose*start-turn
    (state <s> ^name dialog-event ^purpose <p>)
    (<p> ^type game-turn)
    -->
    (<s> ^operator <o> +)
    (<o> ^name start-turn + ^category svs +)
}

sp {dialog-event*propose*game-start
    (state <s> ^name dialog-event ^purpose <p>)
    (<p> ^type game-start ^parameters <p*1>)
    (<p*1> ^game-name <name>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name game-start + ^category svs + ^game-name <name> +)
}

sp {dialog-event*propose*query-relation
    (state <s> ^name dialog-event ^purpose <p>)
    (<p> ^type describe-relation ^parameters <p*2> ^parameters <p*1>)
    (<p*2> ^indexable <obj2>)
    (<obj2> ^type preposition ^result <prep>)
    (<p*1> ^indexable <obj>)
    (<obj> ^type object ^result <obja>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name query-relation + ^descriptions <d> + ^message <m> +)
    (<m> ^fields <f> + ^type query-relation +)
    (<f> ^objects <object> +)
    (<object> ^obj <obja> + ^type <prep> +)
}

sp {dialog-event*elaborate*purpose
    (state <s> ^name dialog-event ^superstate <s*1>)
    (<s*1> ^purpose <p>)
    -->
    (<s> ^purpose <p> +)
}

sp {dialog-event*propose*describe-object-location
    (state <s> ^name dialog-event ^purpose <p>)
    (<p> ^type location-question ^parameters <p*1>)
    (<p*1> ^object <obj>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name describe-object-location + ^object <obj> +)
}

sp {dialog-event*apply*report-interaction*report
    (state <s> ^name dialog-event ^operator <o*1> ^top-state <t*1> ^io <i*2>)
    (<o*1> ^name report-interaction)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <seg>)
    (<seg> ^context <context> ^info <context> ^purpose <p>)
    (<p> ^satisfaction <sat> ^type <type>)
    (<i*2> ^output-link <out>)
    -->
    (<out> ^report-interaction <ri> +)
    (<ri> ^type <type> + ^context <context> + ^satisfaction <sat> +)
}

sp {dialog-event*apply*report-interaction*mark*performed
    (state <s> ^name dialog-event ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name report-interaction)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^performed <p*1> +)
    (<p*1> ^dialog-event <de> +)
    (<de> ^type report-interaction + ^originator agent +)
}

sp {dialog-event*propose*report-interaction
    (state <s> ^name dialog-event ^purpose <p*1>)
    (<p*1> ^type report-interaction)
    -->
    (<s> ^operator <o> +)
    (<o> ^name report-interaction +)
}

sp {describe-object*prefer*attend-to-scene-change*over*lookup-labels
    (state <s> ^name describe-object ^operator <o2> + ^operator <o1> +)
    (<o2> ^name lookup-labels)
    (<o1> ^name attend-to-scene-change)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {lookup-label*apply*complete-lookup-label*annotate*object
    (state <s> ^name lookup-label ^operator <o*1> ^sense <sense>
          ^top-state <t*1>)
    (<o*1> ^name complete-lookup-label)
    (<sense> ^label <label> ^word <w*2> ^property <p*1>)
    (<w*2> ^word <word>)
    (<t*1> ^world <w*1>)
    (<w*1> ^objects <o*2>)
    (<p*1> ^handle <prop-handle>)
    (<o*2> ^object <o*3>)
    (<o*3> ^property <prop>)
    (<prop> ^handle <prop-handle> ^value <val>)
    (<val> -^word <word> ^label <label>)
    -->
    (<val> ^word <word> +)
}

sp {lookup-label*apply*complete-lookup-label
    (state <s> ^name lookup-label ^operator <o*1> ^sense <sense>
          ^superstate <ss>)
    (<o*1> ^name complete-lookup-label)
    -->
    (<ss> ^lookup-label-result <sense> +)
}

sp {lookup-label*propose*complete-lookup-label
    (state <s> ^name lookup-label ^sense <sense>)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete-lookup-label +)
}

sp {lookup-label*propose*smem-retrieve*property
    (state <s> ^name lookup-label ^sense <s*1>)
    (<s*1> ^property <prop>)
    -->
    (<s> ^retrieve-lti <prop> +)
}

sp {lookup-label*propose*smem-retrieve*word
    (state <s> ^name lookup-label ^sense <s*1>)
    (<s*1> ^word <word>)
    -->
    (<s> ^retrieve-lti <word> +)
}

sp {lookup-label*apply*smem-query*copy-result*success
    (state <s> ^name lookup-label ^operator <o*1>
          ^smem-query-result { <> failure <res> })
    (<o*1> ^name smem-query)
    -->
    (<s> ^sense <res> + ^smem-query-result <res> -)
}

sp {lookup-label*apply*smem-query*copy-result*failure
    (state <s> ^smem-query-result failure ^name lookup-label ^operator <o*1>
          ^superstate <ss>)
    (<o*1> ^name smem-query)
    -->
    (<ss> ^lookup-label-result failure +)
}

sp {lookup-label*propose*smem-query*label
    (state <s> ^name lookup-label -^sense <s*1> ^label <label>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name smem-query + ^category smem + ^query <q> + ^return-all false +)
    (<q> ^wme-type sense + ^label <label> +)
}

sp {lookup-label*copy*parameters
    (state <s> ^name lookup-label ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^{ << label >> <param> } <val>)
    -->
    (<s> ^<param> <val> +)
}

sp {describe-object*apply*complete-describe-object*return*failure
    (state <s> ^name describe-object ^operator <o*1> ^superstate <s*1>)
   -{ (<s> ^desc-object <d*1>)
      (<d*1> ^linguistic-desc <desc>)}
    (<o*1> ^name complete-describe-object)
    (<s*1> ^operator <ss-op>)
    -->
    (<ss-op> ^description none +)
}

sp {describe-object*apply*complete-describe-object*description
    (state <s> ^name describe-object ^operator <o*1> ^desc-object <d*1>
          ^superstate <s*1>)
    (<o*1> ^name complete-describe-object)
    (<d*1> ^linguistic-desc <desc>)
    (<s*1> ^operator <ss-op>)
    -->
    (<ss-op> ^description <desc> +)
}

sp {describe-object*propose*complete-describe-object
    (state <s> ^name describe-object)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete-describe-object + ^category object-processing +)
}

sp {describe-object*apply*lookup-label*failure
    (state <s> ^lookup-label-result failure ^name describe-object
          ^operator <o>)
    (<o> ^name lookup-label ^label <label>)
    -->
    (<s> ^ignore-label <label> +)
}

sp {describe-object*apply*lookup-smem*label
    (state <s> ^name describe-object ^operator <o*1>
          ^lookup-label-result <res> ^desc-object <d*1>)
    (<o*1> ^name lookup-label)
    (<res> ^label <label> ^word <w*1> ^property <p*1>)
    (<w*1> ^word <word>)
    (<p*1> ^name <prop-name>)
    (<d*1> ^property <prop>)
    (<prop> ^name <prop-name> ^value <val>)
    (<val> ^label <label>)
    -->
    (<val> ^word <word> +)
    (<s> ^lookup-label-result <res> -)
}

sp {describe-object*propose*lookup-label
    (state <s> ^name describe-object ^desc-object <d*1> -^ignore-label <label>)
    (<d*1> ^property <prop>)
    (<prop> -^word <word> ^label <label>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name lookup-label + ^category smem + ^label <label> +)
}

sp {describe-object*elaborate*object
    (state <s> ^name describe-object ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^object <obj>)
    -->
    (<s> ^desc-object <obj> +)
}

sp {dialog-event*apply*describe-object*store
    (state <s> ^name dialog-event ^operator <o> ^top-state <t*1>)
    (<o> ^name describe-object ^object <o*1>)
    (<t*1> ^smem <s*1>)
    (<s*1> ^command <cmd>)
    (<o*1> ^smem-rep <obj>)
    -->
    (<cmd> ^store <obj> +)
}

sp {dialog-event*apply*describe-object*no-object
    (state <s> ^name dialog-event ^operator <o> ^io <i*1>)
    (<o> ^description none ^name describe-object)
    (<i*1> ^output-link <out>)
    -->
    (<out> ^send-message <msg> +)
    (<msg> ^type no-object + ^fields <f> +)
}

sp {dialog-event*apply*describe-object*describe
    (state <s> ^name dialog-event ^operator <o> ^io <i*1>)
    (<o> ^name describe-object ^description { <> none <desc> })
    (<i*1> ^output-link <out>)
    -->
    (<out> ^send-message <msg> +)
    (<msg> ^type describe-object + ^fields <f*1> +)
    (<f*1> ^object <desc> +)
}

sp {dialog-event*apply*describe-object*mark*performed
    (state <s> ^name dialog-event ^operator <o> ^top-state <t*1>)
    (<o> ^name describe-object ^description <desc>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^performed <p*1> +)
    (<p*1> ^dialog-event <de> +)
    (<de> ^type describe + ^originator agent +)
}

sp {dialog-event*propose*describe-object
    (state <s> ^name dialog-event ^purpose <p>)
    (<p> ^type describe-object ^parameters <p*1>)
    (<p*1> ^indexable <obj>)
    (<obj> ^type object ^result <wm-obj>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name describe-object + ^object <wm-obj> +)
}

sp {satisfy-purpose*propose*dialog-event*instructor
    (state <s> ^name satisfy-purpose ^purpose <p*1>)
    (<p*1> ^satisfaction <s*1>)
    (<s*1> ^dialog-event <de>)
    (<de> ^originator instructor)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name wait-for-response +)
}

sp {satisfy-purpose*propose*action-event
    (state <s> ^name satsify-purpose ^purpose <p*1>)
    (<p*1> ^satisfaction <s*1>)
    (<s*1> ^action-event <a*1>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name action-event +)
}

sp {satisfy-purpose*propose*learning-event
    (state <s> ^name satisfy-purpose ^purpose <p*1>)
    (<p*1> ^satisfaction <s*1>)
    (<s*1> ^learning-event <l*1>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name learning-event +)
}

sp {satisfy-purpose*propose*dialog-event*from*agent
    (state <s> ^name satisfy-purpose ^purpose <p*1>)
    (<p*1> ^satisfaction <s*1>)
    (<s*1> ^dialog-event <de>)
    (<de> ^originator agent)
    -->
    (<s> ^operator <o> +)
    (<o> ^name dialog-event +)
}

sp {satisfy-purpose*elaborate*purpose
    (state <s> ^name satisfy-purpose ^top-state <t*1>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <s*2>)
    (<s*2> ^purpose <purp>)
    -->
    (<s> ^purpose <purp> +)
}

sp {interaction*apply*performed-event*action-event*train-on-location*send-message
    (state <s> ^name interaction ^operator <o> ^top-state <t*2>
          ^top-state <t*1>)
    (<o> ^name performed-event ^event <e*1>)
    (<e*1> ^action-event <e>)
    (<t*2> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <seg>)
    (<seg> ^context <c*1> ^purpose <p*1>)
    (<c*1> ^type get-location-info)
    (<p*1> ^type action)
    -->
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type ok +)
}

sp {interaction*apply*performed-event*learn-predicate-info*send*message
    (state <s> ^name interaction ^operator <o> ^top-state <t*2>
          ^top-state <t*1>)
    (<o> ^name performed-event ^event <e*1>)
    (<e*1> ^learning-event <l*1>)
    (<l*1> ^type predicate)
    (<t*2> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <s*2>)
    (<s*2> ^purpose <p*1>)
    (<p*1> ^type learn-predicate-info)
    -->
    (<changes> ^outgoing-message <o*1> +)
    (<o*1> ^type report-successful-training +)
}

sp {interaction*apply*performed-event*teach-relation*send*message
    (state <s> ^name interaction ^operator <o> ^top-state <t*2>
          ^top-state <t*1>)
    (<o> ^name performed-event ^event <e*1>)
    (<e*1> ^learning-event <l*1>)
    (<l*1> ^type relation)
    (<t*2> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <s*2>)
    (<s*2> ^purpose <p*1>)
    (<p*1> ^type teach-relation)
    -->
    (<changes> ^outgoing-message <o*1> +)
    (<o*1> ^type report-successful-training +)
}

sp {interaction*apply*performed-event*train-on-object*send*message
    (state <s> ^name interaction ^operator <o> ^top-state <t*2>
          ^top-state <t*1>)
    (<o> ^name performed-event ^event <e*1>)
    (<e*1> ^learning-event <l*1>)
    (<l*1> ^type object)
    (<t*2> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <s*2>)
    (<s*2> ^purpose <p*1>)
    (<p*1> ^type train-on-object)
    -->
    (<changes> ^outgoing-message <o*1> +)
    (<o*1> ^type report-successful-training +)
}

sp {interaction*apply*performed-event*satisfied*purpose*pop
    (state <s> ^name interaction ^operator <o> ^top-state <t*1>)
    (<o> ^name performed-event ^event <event>)
    (<t*1> ^interaction <i>)
    (<i> ^stack <s*1> ^changes <changes>)
    (<s*1> ^segment <s*2>)
    (<s*2> ^purpose <p*1>)
    (<p*1> ^satisfaction <sat>)
    (<event> ^<event-cat> <perf-event>)
    (<sat> ^<event-cat> <sat-event>)
   -{ (<sat-event> ^{ <> info <attr> } <val>)
      (<perf-event> -^<attr> <val>)}
    (<perf-event> ^type <event-type>)
    (<sat-event> ^type <event-type>)
    -->
    (<changes> ^terminate-segment true +)
}

sp {interaction*apply*performed-event*remove*performed
    (state <s> ^name interaction ^operator <o> ^top-state <t*1>)
    (<o> ^name performed-event ^event <event>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    (<status> ^performed <event>)
    -->
    (<status> ^performed <event> -)
}

sp {send-message*apply*create-learned-teacher-name-message
    (state <s> ^name send-message ^operator <o*1> ^message <m*1>)
    (<o*1> ^name create-learned-teacher-name-message)
    (<m*1> ^fields <f>)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type learned-teacher-name + ^originator agent + ^fields <f> +)
}

sp {send-message*propose*create-learned-teacher-name-message
    (state <s> ^name send-message -^created-message <c*1> ^message <m*1>)
    (<m*1> ^type learned-teacher-name)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-learned-teacher-name-message +)
}

sp {send-message*apply*create-simple-message
    (state <s> ^name send-message ^operator <o>)
    (<o> ^name create-simple-message ^message-type <type>)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type <type> + ^originator agent + ^fields <f> +)
}

sp {send-message*propose*create-simple-message
    (state <s> ^name send-message -^created-message <c*1> ^message <msg>)
    (<msg> ^type simple-message ^message-type <type>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-simple-message + ^message-type <type> +)
}

sp {send-message*apply*create-describe-final-goal-state
    (state <s> ^name send-message ^operator <o*1> ^message <m*1>)
    (<o*1> ^name create-describe-final-goal-state)
    (<m*1> ^fields <f>)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type describe-final-goal-state + ^originator agent + ^fields <f> +)
}

sp {send-message*propose*create-describe-final-goal-state
    (state <s> ^name send-message -^created-message <c*1> ^message <m*1>)
    (<m*1> ^type describe-final-goal-state)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-describe-final-goal-state +)
}

sp {send-message*apply*create-describe-goal-state
    (state <s> ^name send-message ^operator <o*1> ^message <m*1>)
    (<o*1> ^name create-describe-goal-state)
    (<m*1> ^fields <f>)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type describe-goal-state + ^originator agent + ^fields <f> +)
}

sp {send-message*propose*create-describe-goal-state
    (state <s> ^name send-message -^created-message <c*1> ^message <m*1>)
    (<m*1> ^type describe-goal-state)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-describe-goal-state +)
}

sp {send-message*apply*create-reset-state
    (state <s> ^name send-message ^operator <o*1> ^message <m*1>)
    (<o*1> ^name create-reset-state)
    (<m*1> ^fields <f>)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type reset-state + ^originator agent + ^fields <f> +)
}

sp {send-message*propose*create-reset-state
    (state <s> ^name send-message -^created-message <c*1> ^message <m*1>)
    (<m*1> ^type reset-state)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-reset-state +)
}

sp {send-message*apply*create-unknown-defined-word
    (state <s> ^name send-message ^operator <o*1> ^message <m*1>)
    (<o*1> ^name create-unknown-defined-word)
    (<m*1> ^fields <f>)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type unknown-defined-word + ^originator agent + ^fields <f> +)
}

sp {send-message*propose*create-unknown-defined-word
    (state <s> ^name send-message -^created-message <c*1> ^message <m*1>)
    (<m*1> ^type unknown-defined-word)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-unknown-defined-word +)
}

sp {send-message*apply*create-learned-unknown-word
    (state <s> ^name send-message ^operator <o*1> ^message <m*1>)
    (<o*1> ^name create-learned-unknown-word)
    (<m*1> ^fields <f>)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type learned-unknown-word + ^originator agent + ^fields <f> +)
}

sp {send-message*propose*create-learned-unknown-word
    (state <s> ^name send-message -^created-message <c*1> ^message <m*1>)
    (<m*1> ^type learned-unknown-word)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-learned-unknown-word +)
}

sp {send-message*apply*create-unknown-word
    (state <s> ^name send-message ^operator <o*1> ^message <m*1>)
    (<o*1> ^name create-unknown-word)
    (<m*1> ^fields <f>)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type unknown-word + ^originator agent + ^fields <f> +)
}

sp {send-message*propose*create-unknown-word
    (state <s> ^name send-message -^created-message <c*1> ^message <m*1>)
    (<m*1> ^type unknown-word)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-unknown-word +)
}

sp {send-message*apply*create-learned-game-message
    (state <s> ^name send-message ^operator <o*1> ^message <m*1>)
    (<o*1> ^name create-learned-game-message)
    (<m*1> ^fields <f>)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type learned-game + ^originator agent + ^fields <f> +)
}

sp {send-message*propose*create-learned-game
    (state <s> ^name send-message -^created-message <c*1> ^message <m*1>)
    (<m*1> ^type learned-game)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-learned-game-message +)
}

sp {send-message*apply*create-already-know-message
    (state <s> ^name send-message ^operator <o*1> ^message <m*1>)
    (<o*1> ^name create-already-know-message)
    (<m*1> ^fields <f>)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type already-know-concept + ^originator agent + ^fields <f> +)
}

sp {send-message*propose*create-already-know-message
    (state <s> ^name send-message -^created-message <c*1> ^message <m*1>)
    (<m*1> ^type already-know)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-already-know-message +)
}

sp {send-message*apply*create-transfer-message
    (state <s> ^name send-message ^operator <o*1> ^message <m*1>)
    (<o*1> ^name create-transfer-message)
    (<m*1> ^fields <f>)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type transfer-concept + ^originator agent + ^fields <f> +)
}

sp {send-message*propose*create-transfer-message
    (state <s> ^name send-message -^created-message <c*1> ^message <m*1>)
    (<m*1> ^type transfer-concept)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-transfer-message +)
}

sp {send-message*apply*create-put-down-item-request*loc
    (state <s> ^name send-message ^operator <o> ^message <m*1>)
    (<o> ^name create-put-down-item-request ^item <item>)
    (<m*1> ^location <loc>)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type put-down-item-request + ^originator agent + ^fields <f> +)
    (<f> ^item <item> + ^location <loc> +)
}

sp {send-message*apply*create-put-down-item-request*no*loc
    (state <s> ^name send-message ^operator <o>)
   -{ (<s> ^message <m*1>)
      (<m*1> ^location <l*1>)}
    (<o> ^name create-put-down-item-request ^item <item>)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type put-down-item-request + ^originator agent + ^fields <f*1> +)
    (<f*1> ^item <item> +)
}

sp {send-message*propose*create-put-down-item-request
    (state <s> ^name send-message -^created-message <c*1> ^message <m*1>
          ^message <m*2>)
    (<m*1> ^type put-down-item-request)
    (<m*2> ^item <item>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-put-down-item-request + ^item <item> +)
}

sp {send-message*apply*create-start-leading-request
    (state <s> ^name send-message ^operator <o>)
    (<o> ^name create-start-leading-request ^person <name>)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type start-leading-request + ^originator agent + ^fields <f*1> +)
    (<f*1> ^person <name> +)
}

sp {send-message*propose*create-start-leading-request
    (state <s> ^name send-message -^created-message <c*1> ^message <m*1>
          ^message <m*2>)
    (<m*1> ^type start-leading-request)
    (<m*2> ^person <name>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-start-leading-request + ^person <name> +)
}

sp {send-message*apply*create-multiple-arguments
    (state <s> ^name send-message ^operator <o>)
    (<o> ^name create-multiple-arguments ^argument-info <arg>)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type multiple-arguments + ^originator agent + ^fields <f*1> +)
    (<f*1> ^argument-info <arg> +)
}

sp {send-message*propose*create-multiple-arguments
    (state <s> ^name send-message -^created-message <c*1> ^message <m*1>
          ^message <m*2>)
    (<m*1> ^type multiple-arguments)
    (<m*2> ^argument-info <arg>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-multiple-arguments + ^argument-info <arg> +)
}

sp {send-message*apply*create-cant-find-object
    (state <s> ^name send-message ^operator <o>)
    (<o> ^name create-cant-find-object ^object <obj>)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type cant-find-object + ^originator agent + ^fields <f*1> +)
    (<f*1> ^object <obj> +)
}

sp {send-message*propose*create-cant-find-object
    (state <s> ^name send-message -^created-message <c*1> ^message <m*1>
          ^message <m*2>)
    (<m*1> ^type cant-find-object)
    (<m*2> ^object <obj>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-cant-find-object + ^object <obj> +)
}

sp {send-message*apply*create-execution-failure
    (state <s> ^name send-message ^operator <o>)
    (<o> ^name create-execution-failure ^failure-info <info>
          ^failure-type <type>)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type execution-failure + ^originator agent + ^fields <f> +)
    (<f> ^failure-type <type> + ^failure-info <info> +)
}

sp {send-message*propose*create-execution-failure
    (state <s> ^name send-message -^created-message <c*1> ^message <m*1>
          ^message <m*3> ^message <m*2>)
    (<m*1> ^type execution-failure)
    (<m*3> ^failure-info <info>)
    (<m*2> ^failure-type <type>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-execution-failure + ^failure-info <info> +
           ^failure-type <type> +)
}

sp {send-message*apply*create-say-sentence
    (state <s> ^name send-message ^operator <o>)
    (<o> ^name create-say-sentence ^sentence <sent>)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type say-sentence + ^originator agent + ^fields <f*1> +)
    (<f*1> ^sentence <sent> +)
}

sp {send-message*propose*create-say-sentence
    (state <s> ^name send-message -^created-message <c*1> ^message <m*1>
          ^message <m*2>)
    (<m*1> ^type say-sentence)
    (<m*2> ^sentence <sent>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-say-sentence + ^sentence <sent> +)
}

sp {send-message*apply*create-ask-about-item
    (state <s> ^name send-message ^operator <o>)
    (<o> ^name create-ask-about-item ^item <item>)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type ask-about-item + ^originator agent + ^fields <f*1> +)
    (<f*1> ^item <item> +)
}

sp {send-message*propose*create-ask-about-item
    (state <s> ^name send-message -^created-message <c*1> ^message <m*1>
          ^message <m*2>)
    (<m*1> ^type ask-about-item)
    (<m*2> ^item <item>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-ask-about-item + ^item <item> +)
}

sp {send-message*apply*create-give-item-request
    (state <s> ^name send-message ^operator <o>)
    (<o> ^name create-give-item-request ^person <person> ^item <item>)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type give-item-request + ^originator agent + ^fields <f> +)
    (<f> ^item <item> + ^person <person> +)
}

sp {send-message*propose*create-give-item-request
    (state <s> ^name send-message -^created-message <c*1> ^message <m*1>
          ^message <m*3> ^message <m*2>)
    (<m*1> ^type give-item-request)
    (<m*3> ^person <person>)
    (<m*2> ^item <item>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-give-item-request + ^item <item> + ^person <person> +)
}

sp {send-message*apply*create-get-item-request
    (state <s> ^name send-message ^operator <o>)
    (<o> ^name create-get-item-request ^item <item>)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type get-item-request + ^originator agent + ^fields <f*1> +)
    (<f*1> ^item <item> +)
}

sp {send-message*propose*create-get-item-request
    (state <s> ^name send-message -^created-message <c*1> ^message <m*1>
          ^message <m*2>)
    (<m*1> ^type get-item-request)
    (<m*2> ^item <item>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-get-item-request + ^item <item> +)
}

sp {send-message*apply*create-get-location-info*no*name
    (state <s> ^name send-message ^operator <o*1>)
   -{ (<s> ^message <m*1>)
      (<m*1> ^location-name <l*1>)}
    (<o*1> ^name create-get-location-info)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type get-location-info + ^originator agent + ^fields <f> +)
}

sp {send-message*apply*create-get-location-info*with*name
    (state <s> ^name send-message ^operator <o*1> ^message <m*1>)
    (<o*1> ^name create-get-location-info)
    (<m*1> ^location-name <name>)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type get-location-info + ^originator agent + ^fields <f*1> +)
    (<f*1> ^location-name <name> +)
}

sp {send-message*propose*create-get-location-info
    (state <s> ^name send-message -^created-message <c*1> ^message <m*1>)
    (<m*1> ^type get-location-info)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-get-location-info +)
}

sp {send-message*apply*create-object-description
    (state <s> ^name send-message ^operator <o>)
    (<o> ^name create-object-description ^description <desc>)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type object-description + ^originator agent + ^fields <f*1> +)
    (<f*1> ^object <desc> +)
}

sp {send-message*propose*create-object-description
    (state <s> ^name send-message -^created-message <c*1> ^message <m*1>
          ^object-description <desc>)
    (<m*1> ^type object-description)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-object-description + ^description <desc> +)
}

sp {send-message*object-description*propose*generate-object-description
    (state <s> ^name send-message -^object-description <o*1> ^message <msg>)
    (<msg> ^type object-description ^object <obj>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name generate-object-description + ^object <obj> +)
}

sp {generate-object-description*apply*complete-generate-object-description
    (state <s> ^name generate-object-description ^operator <o*1>
          ^description <desc> ^superstate <ss>)
    (<o*1> ^name complete-generate-object-description)
    -->
    (<ss> ^object-description <desc> +)
}

sp {generate-object-description*propose*complete-generate-object-description
    (state <s> ^name generate-object-description -^waiting-retrievals true)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete-generate-object-description +)
}

sp {generate-object-description*apply*retrieve-predicate-word*retrieve*word*failure
    (state <s> ^name generate-object-description ^operator <o> ^smem <s*2>
          ^smem <s*1>)
    (<o> ^name retrieve-predicate-word ^lookup-predicate <lp>)
    (<lp> ^word-query <q>)
    (<s*2> ^command <cmd>)
    (<cmd> ^query <q>)
    (<s*1> ^result <r*1>)
    (<r*1> ^failure <q>)
    -->
    (<cmd> ^query <q> -)
    (<lp> ^word-lti lookup-failure +)
}

sp {generate-object-description*apply*retrieve-predicate-word*retrieve*word*success
    (state <s> ^name generate-object-description ^operator <o>
          ^description <desc> ^smem <s*3> ^smem <s*2> ^smem <s*1>)
    (<o> ^name retrieve-predicate-word ^lookup-predicate <lp>)
    (<lp> ^word-query <q> ^category <cat>)
    (<s*3> ^command <cmd>)
    (<cmd> ^query <q>)
    (<s*1> ^result <r*1>)
    (<r*1> ^success <q>)
    (<s*2> ^result <r*2>)
    (<r*2> ^retrieved <lti>)
    (<lti> ^spelling <word>)
    -->
    (<cmd> ^query <q> -)
    (<lp> ^word-lti <lti> +)
    (<desc> ^<cat> <word> +)
}

sp {generate-object-description*apply*retrieve-predicate-word*create*word*query
    (state <s> ^name generate-object-description ^operator <o> ^smem <s*1>)
    (<o> ^name retrieve-predicate-word ^lookup-predicate <lp>)
    (<lp> ^predicate-lti <lti>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^query <q> +)
    (<q> ^id <lti> +)
    (<lp> ^word-query <q> +)
}

sp {generate-object-description*apply*retrieve-predicate-word*retrieve*predicate*failure
    (state <s> ^name generate-object-description ^operator <o> ^smem <s*2>
          ^smem <s*1>)
    (<o> ^name retrieve-predicate-word ^lookup-predicate <lp>)
    (<lp> ^predicate-query <q>)
    (<s*2> ^command <cmd>)
    (<cmd> ^query <q>)
    (<s*1> ^result <r*1>)
    (<r*1> ^failure <q>)
    -->
    (<cmd> ^query <q> -)
    (<lp> ^word-lti lookup-failure +)
}

sp {generate-object-description*apply*retrieve-predicate-word*retrieve*predicate*success
    (state <s> ^name generate-object-description ^operator <o> ^smem <s*3>
          ^smem <s*2> ^smem <s*1>)
    (<o> ^name retrieve-predicate-word ^lookup-predicate <lp>)
    (<lp> ^predicate-query <q>)
    (<s*3> ^command <cmd>)
    (<cmd> ^query <q>)
    (<s*1> ^result <r*1>)
    (<r*1> ^success <q>)
    (<s*2> ^result <r*2>)
    (<r*2> ^retrieved <lti>)
    -->
    (<cmd> ^query <q> -)
    (<lp> ^predicate-lti <lti> +)
}

sp {generate-object-description*apply*retrieve-predicate-word*create*query
    (state <s> ^name generate-object-description ^operator <o> ^smem <s*1>)
    (<o> ^name retrieve-predicate-word ^lookup-predicate <lp>)
    (<lp> ^predicate <pred>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^query <q> +)
    (<q> ^name <pred> +)
    (<lp> ^predicate-query <q> +)
}

sp {generate-object-description*propose*retrieve-predicate-word
    (state <s> ^name generate-object-description ^lookup-predicate <lp>)
    (<lp> -^word-lti <w*1> ^predicate <pred>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name retrieve-predicate-word + ^lookup-predicate <lp> +)
}

sp {generate-object-description*elaborate*waiting-retrievals
    (state <s> ^name generate-object-description ^lookup-predicate <lp>)
    (<lp> -^word-lti <w*1>)
    -->
    (<s> ^waiting-retrievals true +)
}

sp {generate-object-description*elaborate*lookup-predicate
    (state <s> ^name generate-object-description ^object-to-describe <o*1>)
    (<o*1> ^predicates <preds>)
    (<preds> ^{ << color shape size name >> <pred-cat> } <pred>)
    -->
    (<s> ^lookup-predicate <lp> +)
    (<lp> ^predicate <pred> + ^category <pred-cat> +)
}

sp {generate-object-description*elaborate*description
    (state <s> ^name generate-object-description)
    -->
    (<s> ^description <desc> +)
}

sp {generate-object-description*elaborate*object-to-descibe*superoperator
    (state <s> ^name generate-object-description ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^object <obj>)
    -->
    (<s> ^object-to-describe <obj> +)
}

sp {send-message*apply*create-generic-message
    (state <s> ^name send-message ^operator <o> ^message <m*1>)
    (<o> ^name create-generic-message)
    (<m*1> ^fields <f>)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type generic + ^originator agent + ^fields <f> +)
}

sp {send-message*propose*create-generic-message
    (state <s> ^name send-message -^created-message <c*1> ^message <msg>)
    (<msg> ^type generic)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-generic-message +)
}

sp {send-message*apply*create-unable-to-interpret-message
    (state <s> ^name send-message ^operator <o*1>)
    (<o*1> ^name create-unable-to-interpret-message)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type unable-to-interpret-message + ^originator agent +
           ^fields <f> +)
}

sp {send-message*propose*create-unable-to-interpret-message
    (state <s> ^name send-message -^created-message <c*1> ^message <m*1>)
    (<m*1> ^type unable-to-interpret-message)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-unable-to-interpret-message +)
}

sp {send-message*apply*create-get-predicate-info*no*name
    (state <s> ^name send-message ^operator <o*1>)
   -{ (<s> ^message <m*1>)
      (<m*1> ^predicate-name <p*1>)}
    (<o*1> ^name create-get-predicate-info)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type get-predicate-info + ^originator agent + ^fields <f> +)
}

sp {send-message*apply*create-get-predicate-info*with*name
    (state <s> ^name send-message ^operator <o*1> ^message <m*1>)
    (<o*1> ^name create-get-predicate-info)
    (<m*1> ^predicate-name <name>)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type get-predicate-info + ^originator agent + ^fields <f*1> +)
    (<f*1> ^predicate-name <name> +)
}

sp {send-message*propose*create-get-predicate-info
    (state <s> ^name send-message -^created-message <c*1> ^message <m*1>)
    (<m*1> ^type get-predicate-info)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-get-predicate-info +)
}

sp {send-message*apply*create-unable-to-satisfy
    (state <s> ^name send-message ^operator <o*1>)
    (<o*1> ^name create-unable-to-satisfy)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type unable-to-satisfy + ^originator agent + ^fields <f> +)
}

sp {send-message*propose*create-unable-to-satisfy
    (state <s> ^name send-message -^created-message <c*1> ^message <m*1>)
    (<m*1> ^type unable-to-satisfy)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-unable-to-satisfy +)
}

sp {send-message*apply*create-report-successful-training
    (state <s> ^name send-message ^operator <o*1>)
    (<o*1> ^name create-report-successful-training)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type report-successful-training + ^originator agent +
           ^fields <f> +)
}

sp {send-message*propose*create-report-successful-training
    (state <s> ^name send-message -^created-message <c*1> ^message <m*1>)
    (<m*1> ^type report-successful-training)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-report-successful-training +)
}

sp {send-message*apply*complete-send-message*expected*message*terminate
    (state <s> ^name interpret-message ^operator <o*1> ^created-message <c*2>
          ^current-purpose <c*1> ^top-state <t*1>)
    (<o*1> ^name complete-send-message)
    (<c*1> ^satisfaction <s*1>)
    (<s*1> ^dialog-event <de>)
    (<de> ^originator agent ^type <type>)
    (<c*2> ^type <type>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <c>)
    -->
    (<c> ^terminate-segment true +)
}

sp {send-message*apply*complete-send-message*send*message
    (state <s> ^name send-message ^top-state <t*1> ^operator <o*1>
          ^created-message <msg> ^agent-params <a*1> ^io <i*1>)
    (<t*1> ^world-usage external)
    (<o*1> ^name complete-send-message)
    (<a*1> ^debug-interaction <flag>)
    (<i*1> ^output-link <out>)
    -->
    (<out> ^send-message <msg> +)
    (write (ifeq <flag> true (concat |Outgoing Message: | (crlf) (cmd print <msg> |-d| 2)) ||))
}

sp {send-message*apply*complete-send-message*delete*message
    (state <s> ^name send-message ^operator <o*1> ^message <msg>
          ^top-state <t*1>)
    (<o*1> ^name complete-send-message)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <c>)
    (<c> ^outgoing-message <msg>)
    -->
    (<c> ^outgoing-message <msg> -)
}

sp {send-message*propose*complete-send-message
    (state <s> ^name send-message)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete-send-message +)
}

sp {send-message*elaborate*message
    (state <s> ^name send-message ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^message <msg>)
    -->
    (<s> ^message <msg> +)
}

sp {interpret-failure*apply*interpret-retrospective-learning-failure*send*message
    (state <s> ^name interpret-failure ^operator <o*1>)
    (<o*1> ^name interpret-retrospective-learning-failure)
    -->
    (<s> ^outgoing-message <msg> +)
    (<msg> ^type simple-message +
           ^message-type retrospective-learning-failure +)
}

sp {interpret-failure*apply*interpret-retrospective-learning-failure*terminate-segment
    (state <s> ^name interpret-failure ^operator <o*1>)
    (<o*1> ^name interpret-retrospective-learning-failure)
    -->
    (<s> ^terminate-segment true +)
}

sp {interpret-failure*apply*interpret-retrospective-learning-failure*mark*handled
    (state <s> ^name interpret-failure ^operator <o*1> ^failure <f>)
    (<o*1> ^name interpret-retrospective-learning-failure)
    -->
    (<s> ^handled <f> +)
}

sp {interpret-failure*propose*interpret-retrospective-learning-failure
    (state <s> ^name interpret-failure -^handled <f> ^failure <f*1>)
    (<f*1> ^type retrospective-learning-failure)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-retrospective-learning-failure +)
}

sp {interpret-failure*apply*interpret-missing-argument*pop*action
    (state <s> ^name interpret-failure ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name interpret-missing-argument)
    (<t*1> ^action-stack <stack>)
    (<stack> ^top <top> ^changes <chgs>)
    -->
    (<chgs> ^pop <top> +)
}

sp {interpret-failure*apply*interpret-missing-argument*create*message
    (state <s> ^name interpret-failure ^operator <o*1>)
    (<o*1> ^name interpret-missing-argument)
    -->
    (<s> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type missing-argument +)
}

sp {interpret-failure*apply*interpret-missing-argument*mark*handled
    (state <s> ^name interpret-failure ^operator <o*1> ^failure <f>)
    (<o*1> ^name interpret-missing-argument)
    -->
    (<s> ^handled <f> +)
}

sp {interpret-failure*propose*interpret-missing-argument
    (state <s> ^name interpret-failure -^handled <f> ^failure <f*1>)
    (<f*1> ^type missing-argument)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-missing-argument +)
}

sp {interpret-failure*apply*interpret-cant-find-object*create*message
    (state <s> ^name interpret-failure ^operator <o>)
    (<o> ^name interpret-cant-find-object ^object <obj>)
    -->
    (<s> ^outgoing-message <msg> +)
    (<msg> ^type cant-find-object + ^object <obj> +)
}

sp {interpret-failure*apply*interpret-cant-find-object*create*new-segment
    (state <s> ^name interpret-failure ^operator <o>)
    (<o> ^name interpret-cant-find-object ^object <obj>)
    -->
    (<s> ^new-segment-info <info> +)
    (<info> ^purpose <p> + ^originator agent +)
    (<p> ^type get-find-help + ^satisfaction <s*1> +)
    (<s*1> ^dialog-event <de> +)
    (<de> ^type ANY + ^originator instructor +)
}

sp {interpret-failure*apply*interpret-cant-find-object*mark*handled
    (state <s> ^name interpret-failure ^operator <o*1> ^failure <failure>)
    (<o*1> ^name interpret-cant-find-object)
    -->
    (<s> ^handled <failure> +)
}

sp {interpret-failure*propose*interpret-cant-find-object
    (state <s> ^name interpret-failure ^failure <failure> -^handled <failure>)
    (<failure> ^type cant-find-object ^object <obj>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-cant-find-object + ^object <obj> +)
}

sp {interpret-failure*apply*interpret-execution-failure*terminate*segment
    (state <s> ^name interpret-failure ^failure <f*1> ^operator <o*1>
          ^top-state <t*1>)
    (<f*1> ^bottom-action true)
    (<o*1> ^name interpret-execution-failure)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <c>)
    -->
    (<c> ^terminate-segment true +)
}

sp {interpret-failure*apply*interpret-execution-failure*create*message
    (state <s> ^name interpret-failure ^operator <o>)
    (<o> ^name interpret-execution-failure ^failure-info <info>
          ^failure-type <type>)
    -->
    (<s> ^outgoing-message <msg> +)
    (<msg> ^type execution-failure + ^failure-type <type> +
           ^failure-info <info> +)
}

sp {interpret-failure*apply*interpret-execution-failure*mark*handled
    (state <s> ^name interpret-failure ^failure <f> ^operator <o*1>)
    (<f> ^type execution-failure)
    (<o*1> ^name interpret-execution-failure)
    -->
    (<s> ^handled <f> +)
}

sp {interpret-failure*propose*interpret-execution-failure
    (state <s> ^name interpret-failure ^failure <f> -^handled <f>)
    (<f> ^type execution-failure ^failure-info <info> ^failure-type <type>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-execution-failure + ^failure-type <type> +
           ^failure-info <info> +)
}

sp {interpret-failure*apply*interpret-no-action-selection-knowledge*create*new*segment
    (state <s> ^name interpret-failure ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name interpret-no-action-selection-knowledge)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<s> ^new-segment-info <info> +)
    (<info> ^purpose <p> + ^originator agent +)
    (<p> ^type get-next-subaction + ^satisfaction <s*1> +)
    (<s*1> ^dialog-event <de> +)
    (<de> ^type command + ^type object-description + ^originator instructor +)
}

sp {interpret-failure*apply*interpret-no-action-selection-knowledge*create*message
    (state <s> ^name interpret-failure ^operator <o*1>)
    (<o*1> ^name interpret-no-action-selection-knowledge)
    -->
    (<s> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type get-next-subaction +)
}

sp {interpret-failure*apply*interpret-no-action-selection-knowledge*mark*handled
    (state <s> ^name interpret-failure ^operator <o*1> ^failure <failure>)
    (<o*1> ^name interpret-no-action-selection-knowledge)
    -->
    (<s> ^handled <failure> +)
}

sp {interpret-failure*propose*interpret-no-action-selection-knowledge
    (state <s> ^name interpret-failure -^handled <failure> ^failure <f*1>)
    (<f*1> ^type no-action-selection-knowledge)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-no-action-selection-knowledge +)
}

sp {interpret-failure*apply*interpret-no-action-operator-for-goal*terminate*segment
    (state <s> ^name interpret-failure ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name interpret-no-action-operator-for-goal)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <c>)
    -->
    (<c> ^terminate-segment true +)
}

sp {interpret-failure*apply*interpret-no-action-operator-for-goal*create*message
    (state <s> ^name interpret-failure ^operator <o*1>)
    (<o*1> ^name interpret-no-action-operator-for-goal)
    -->
    (<s> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type no-action-operator-for-goal +)
}

sp {interpret-failure*apply*interpret-no-action-operator-for-goal*mark*handled
    (state <s> ^name interpret-failure ^operator <o*1> ^failure <failure>)
    (<o*1> ^name interpret-no-action-operator-for-goal)
    -->
    (<s> ^handled <failure> +)
}

sp {interpret-failure*propose*interpret-no-action-operator-for-goal
    (state <s> ^name interpret-failure -^handled <failure> ^failure <f*1>)
    (<f*1> ^type no-action-operator-for-goal)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-no-action-operator-for-goal +)
}

sp {interpret-failure*apply*interpret-unknown-goal*send*message
    (state <s> ^name interpret-failure ^operator <o*1>)
    (<o*1> ^name interpret-unknown-goal)
    -->
    (<s> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type get-goal-info +)
}

sp {interpret-failure*apply*interpret-unknown-goal*add*purpose
    (state <s> ^name interpret-failure ^operator <o>)
    (<o> ^name interpret-unknown-goal ^action <action>)
    -->
    (<s> ^new-segment-info <info> +)
    (<info> ^purpose <p> + ^originator agent +)
    (<p> ^type get-goal-info + ^parameters <p*1> + ^satisfaction <s*1> +)
    (<p*1> ^action <action> +)
    (<s*1> ^dialog-event <de> +)
    (<de> ^type goal-description + ^originator instructor +)
}

sp {interpret-failure*apply*interpret-unknown-goal*mark*handled
    (state <s> ^name interpret-failure ^operator <o*1> ^failure <f>)
    (<o*1> ^name interpret-unknown-goal)
    -->
    (<s> ^handled <f> +)
}

sp {interpret-failure*propose*interpret-unknown-goal
    (state <s> ^name interpret-failure ^failure <f> -^handled <f>)
    (<f> ^type unknown-goal ^action <action>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-unknown-goal + ^action <action> +)
}

sp {interpret-failure*apply*interpret-unknown-location*send*message
    (state <s> ^name interpret-failure ^operator <o*1> ^failure <f*1>)
    (<o*1> ^name interpret-unknown-location)
    (<f*1> ^location <l*1>)
    (<l*1> ^english-description <name>)
    -->
    (<s> ^outgoing-message <msg> +)
    (<msg> ^type get-location-info + ^location-name <name> +)
}

sp {interpret-failure*apply*interpret-unknown-location*add*purpose
    (state <s> ^name interpret-failure ^operator <o*1>)
    (<o*1> ^name interpret-unknown-location)
    -->
    (<s> ^new-segment-info <info> +)
    (<info> ^purpose <p> + ^originator agent +)
    (<p> ^type get-location-info + ^satisfaction <s*1> +)
    (<s*1> ^dialog-event <de> +)
    (<de> ^type location-description + ^originator instructor +)
}

sp {interpret-failure*propose*interpret-unknown-location
    (state <s> ^name interpret-failure -^new-segment-info <n*1> ^failure <f*1>)
    (<f*1> ^type unknown-location)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-unknown-location +)
}

sp {interpret-failure*apply*interpret-learn-location-failure*terminate-segment
    (state <s> ^name interpret-failure ^operator <o*1>)
    (<o*1> ^name interpret-learn-location-failure)
    -->
    (<s> ^terminate-segment true +)
}

sp {interpret-failure*apply*interpret-learn-location-failure*send*message
    (state <s> ^name interpret-failure ^operator <o*1>)
    (<o*1> ^name interpret-learn-location-failure)
    -->
    (<s> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type learn-location-failure +)
}

sp {interpret-failure*propose*interpret-learn-location-failure
    (state <s> ^name interpret-failure -^outgoing-message <o*1> ^failure <f*1>)
    (<f*1> ^type learn-location-failure)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-learn-location-failure +)
}

sp {interpret-failure*apply*interpret-multiple-arguments*create*new-segment-info
    (state <s> ^name interpret-failure ^operator <o> ^failure <f>)
    (<o> ^name interpret-multiple-arguments ^argument-info <info>)
    (<f> ^arg-name <arg-name> ^action-operator <aop>)
    -->
    (<s> ^new-segment-info <info> +)
    (<info> ^purpose <p> + ^originator agent +)
    (<p> ^type clarify-argument + ^parameters <params> + ^satisfaction <s*1> +)
    (<s*1> ^dialog-event <de> +)
    (<de> ^type object-definition + ^originator instructor +)
    (<params> ^argument-info <info> + ^action-operator <aop> +
           ^arg-name <arg-name> +)
}

sp {interpret-failure*apply*interpret-multiple-arguments*create*message
    (state <s> ^name interpret-failure ^operator <o>)
    (<o> ^name interpret-multiple-arguments ^argument-info <info>)
    -->
    (<s> ^outgoing-message <msg> +)
    (<msg> ^type multiple-arguments + ^argument-info <info> +)
}

sp {interpret-failure*apply*interpret-multiple-arguments*mark*handled
    (state <s> ^name interpret-failure ^operator <o*1> ^failure <f>)
    (<o*1> ^name interpret-multiple-arguments)
    -->
    (<s> ^handled <f> +)
}

sp {interpret-failure*propose*interpret-multiple-arguments
    (state <s> ^name interpret-failure ^failure <f> -^handled <f>)
    (<f> ^type multiple-arguments ^argument-info <arg-info>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-multiple-arguments + ^argument-info <arg-info> +)
}

sp {interpret-failure*apply*interpret-no-proposed-action*pop*action
    (state <s> ^name interpret-failure ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name interpret-no-proposed-action)
    (<t*1> ^action-stack <stack>)
    (<stack> ^top <top> ^changes <chgs>)
    -->
    (<chgs> ^pop <top> +)
}

sp {interpret-failure*apply*interpret-no-proposed-action*create*message
    (state <s> ^name interpret-failure ^operator <o*1>)
    (<o*1> ^name interpret-no-proposed-action)
    -->
    (<s> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type no-proposed-action +)
}

sp {interpret-failure*apply*interpret-no-proposed-action*mark*handled
    (state <s> ^name interpret-failure ^operator <o*1> ^failure <f>)
    (<o*1> ^name interpret-no-proposed-action)
    -->
    (<s> ^handled <f> +)
}

sp {interpret-failure*propose*interpret-no-proposed-action
    (state <s> ^name interpret-failure -^handled <f> ^failure <f*1>)
    (<f*1> ^type no-proposed-action)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-no-proposed-action +)
}

sp {interpret-failure*apply*interpret-missing-object*create*message
    (state <s> ^name interpret-failure ^operator <o>)
    (<o> ^name interpret-missing-object ^missing-object <obj>)
    -->
    (<s> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type missing-object +)
}

sp {interpret-failure*apply*interpret-missing-object*create*new-segment
    (state <s> ^name interpret-failure ^operator <o>)
    (<o> ^name interpret-missing-object ^missing-object <obj>)
    -->
    (<s> ^new-segment-info <info> +)
    (<info> ^purpose <p> + ^originator agent +)
    (<p> ^type find-missing-object + ^missing-object <obj> +
           ^satisfaction <s*1> +)
    (<s*1> ^dialog-event <de> +)
    (<de> ^type object-definition + ^originator instructor +)
}

sp {interpret-failure*apply*interpret-missing-object*mark*handled
    (state <s> ^name interpret-failure ^operator <o*1> ^failure <failure>)
    (<o*1> ^name interpret-missing-object)
    -->
    (<s> ^handled <failure> +)
}

sp {interpret-failure*propose*interpret-missing-object
    (state <s> ^name interpret-failure ^failure <failure> -^handled <failure>)
    (<failure> ^type missing-object ^missing-object <obj>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-missing-object + ^missing-object <obj> +)
}

sp {interpret-failure*apply*interpret-index-object-failure*mark*remove-message
    (state <s> ^name interpret-failure ^operator <o*1>)
    (<o*1> ^name interpret-index-object-failure)
    -->
    (<s> ^remove-message true +)
}

sp {interpret-status*apply*interpret-index-object-failure*create*message
    (state <s> ^operator <o*1> ^failure <f*1>)
    (<o*1> ^name interpret-index-object-failure)
    (<f*1> ^target-object <obj>)
    -->
    (<s> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type index-object-failure +)
}

sp {interpret-status*propose*interpret-index-object-failure
    (state <s> ^name interpret-failure -^outgoing-message <o*1> ^failure <f*1>)
    (<f*1> ^type { << index-object-failure >> <t*1> })
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-index-object-failure +)
}

sp {interpret-failure*apply*interpret-failed-to-interpret-message*send*message
    (state <s> ^name interpret-failure ^operator <o*1>)
    (<o*1> ^name interpret-failed-to-interpret-message)
    -->
    (<s> ^outgoing-message <msg> +)
    (<msg> ^type unable-to-interpret-message +)
}

sp {interpret-failure*apply*interpret-failed-to-interpret-message*terminate-segment
    (state <s> ^name interpret-failure ^operator <o*1>)
    (<o*1> ^name interpret-failed-to-interpret-message)
    -->
    (<s> ^terminate-segment true +)
}

sp {interpret-failure*propose*interpret-failed-to-interpret-message
    (state <s> ^name interpret-failure -^terminate-segment <t*1>
          ^failure <f*1>)
    (<f*1> ^type failed-to-interpret-message)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-failed-to-interpret-message +)
}

sp {interpret-failure*apply*interpret-unknown-predicate*send*message*word
    (state <s> ^name interpret-failure ^operator <o*1> ^failure <f*1>)
    (<o*1> ^name interpret-unknown-predicate)
    (<f*1> ^word <name>)
    -->
    (<s> ^outgoing-message <msg> +)
    (<msg> ^type get-predicate-info + ^predicate-name <name> +)
}

sp {interpret-failure*apply*interpret-unknown-predicate*send*message
    (state <s> ^name interpret-failure ^operator <o*1> ^failure <f*1>)
   -{ (<s> ^failure <f*2>)
      (<f*2> ^word <w*1>)}
    (<o*1> ^name interpret-unknown-predicate)
    (<f*1> ^predicate <p*1>)
    (<p*1> ^handle <handle>)
    -->
    (<s> ^outgoing-message <msg> +)
    (<msg> ^type get-predicate-info + ^predicate-name <handle> +)
}

sp {interpret-failure*apply*interpret-unknown-predicate*add*purpose
    (state <s> ^name interpret-failure ^operator <o*1>)
    (<o*1> ^name interpret-unknown-predicate)
    -->
    (<s> ^new-segment-info <info> +)
    (<info> ^purpose <p> + ^originator agent +)
    (<p> ^type get-predicate-info + ^satisfaction <s*1> +)
    (<s*1> ^dialog-event <de> +)
    (<de> ^type adjective-definition + ^originator instructor +)
}

sp {interpret-failure*propose*interpret-unknown-predicate
    (state <s> ^name interpret-failure -^new-segment-info <n*1> ^failure <f*1>)
    (<f*1> ^type { << unknown-predicate unknown-word >> <t*1> })
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-unknown-predicate +)
}

sp {interpret-failure*apply*interpret-bad-smem-structure*send*message
    (state <s> ^name interpret-failure ^operator <o*1>)
    (<o*1> ^name interpret-bad-smem-structure)
    -->
    (<s> ^outgoing-message <msg> +)
    (<msg> ^type unable-to-satisfy +)
}

sp {interpret-failure*apply*interpret-bad-smem-structure*terminate-segment
    (state <s> ^name interpret-failure ^operator <o*1>)
    (<o*1> ^name interpret-bad-smem-structure)
    -->
    (<s> ^terminate-segment true +)
}

sp {interpret-failure*propose*interpret-bad-smem-structure
    (state <s> ^name interpret-failure -^terminate-segment <t*1>
          ^failure <f*1>)
    (<f*1> ^type bad-smem-structure)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-bad-smem-structure +)
}

sp {interpret-failure*apply*interpret-unknown-task*send*message
    (state <s> ^name interpret-failure ^operator <o*1>)
    (<o*1> ^name interpret-unknown-task)
    -->
    (<s> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type get-next-task +)
}

sp {interpret-failure*apply*interpret-unknown-task*add*purpose
    (state <s> ^name interpret-failure ^operator <o*1>)
    (<o*1> ^name interpret-unknown-task)
    -->
    (<s> ^new-segment-info <info> +)
    (<info> ^purpose <p> + ^originator agent +)
    (<p> ^type get-next-task + ^satisfaction <s*1> +)
    (<s*1> ^dialog-event <de> +)
    (<de> ^type command + ^originator instructor +)
}

sp {interpret-failure*apply*interpret-unknown-task*mark*handled
    (state <s> ^name interpret-failure ^operator <o*1> ^failure <f>)
    (<o*1> ^name interpret-unknown-task)
    -->
    (<s> ^handled <f> +)
}

sp {interpret-failure*propose*interpret-unknown-task
    (state <s> ^name interpret-failure ^failure <f> -^handled <f>)
    (<f> ^type unknown-task)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-unknown-task +)
}

sp {interpret-failure*apply*complete-interpret-failure*pop-action
    (state <s> ^pop-action true ^name interpret-failure ^operator <o*1>
          ^top-state <t*1>)
    (<o*1> ^name complete-interpret-failure)
    (<t*1> ^action-stack <stack>)
    (<stack> ^top <action> ^changes <changes>)
    -->
    (<changes> ^pop <action> +)
}

sp {interpret-failure*apply*complete-interpret-failure*remove-message
    (state <s> ^remove-message true ^name interpret-failure ^operator <o*1>
          ^top-state <t*1>)
    (<o*1> ^name complete-interpret-failure)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    (<status> ^new-message <msg>)
    -->
    (<status> ^new-message <msg> -)
}

sp {interpret-failure*apply*complete-interpret-failure*terminate-segment
    (state <s> ^terminate-segment true ^name interpret-failure ^operator <o*1>
          ^top-state <t*1>)
    (<o*1> ^name complete-interpret-failure)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <c>)
    -->
    (<c> ^terminate-segment true +)
}

sp {interpret-failure*apply*complete-interpret-failure*copy*outgoing-message
    (state <s> ^name interpret-failure ^operator <o*1> ^outgoing-message <msg>
          ^top-state <t*1>)
    (<o*1> ^name complete-interpret-failure)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <c>)
    -->
    (<c> ^outgoing-message <msg> +)
}

sp {interpret-failure*apply*complete-interpret-failure*copy*new-segment-info
    (state <s> ^name interpret-failure ^operator <o*1>
          ^new-segment-info <info> ^top-state <t*1>)
    (<o*1> ^name complete-interpret-failure)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <c>)
    -->
    (<c> ^new-segment-info <info> +)
}

sp {interpret-failure*apply*complete-interpret-failure*clear*status
    (state <s> ^name interpret-failure ^operator <o*1> ^top-state <t*1>
          ^failure <failure>)
    (<o*1> ^name complete-interpret-failure)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    (<status> ^failure <failure>)
    -->
    (<status> ^failure <failure> -)
}

sp {interpret-failure*propose*complete-interpret-failure
    (state <s> ^name interpret-failure)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete-interpret-failure +)
}

sp {interpret-failure*elaborate*failure
    (state <s> ^name interpret-failure ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^failure <failure>)
    -->
    (<s> ^failure <failure> +)
}

sp {interpret-message*apply*interpret-unknown-word*store-smem-word*adjacent
    (state <s> ^name interpret-message ^operator <o> ^top-state <t*1>
          ^smem <s*1>)
    (<o> ^word adjacent ^name interpret-unknown-word ^message <msg>
          ^word <word>)
    (<t*1> ^dialog-context <dc>)
    (<s*1> ^command <sc>)
    -->
    (<sc> ^store <w1> + ^store <spell> + ^store <next> + ^store <next-to1> +)
    (<w1> ^handle <word> +)
    (<spell> ^spelling <word> + ^structure-type P + ^converts-to PP +
           ^relation <w1> +)
    (<next> ^prior-word <word> + ^current-word to + ^spelling adjacent-to +
           ^structure-type P + ^relation <w1> + ^assigners <next-to1> +
           ^converts-to PP +)
    (<next-to1> ^structure-type DP + ^relative-position after +
           ^syntactic-structure head + ^required true +)
}

sp {interpret-message*apply*interpret-unknown-word*store-smem-word*x-of
    (state <s> ^name interpret-message ^operator <o> ^smem <s*1>)
    (<o> ^name interpret-unknown-word ^message <msg>
          ^word { << passenger husband >> <w*1> } ^word <word>)
    (<s*1> ^command <sc>)
    -->
    (<sc> ^store <w1> + ^store <spell> + ^store <p3> +)
    (<w1> ^handle <word> + ^property <p3> +)
    (<spell> ^spelling <word> + ^structure-type N +
           ^syntactic-referent-type ADJ + ^number singular + ^referent <w1> +)
    (<p3> ^handle property + ^type conceptual + ^item-type property +)
}

sp {interpret-message*apply*interpret-unknown-word*store-smem-word*x-than
    (state <s> ^name interpret-message ^operator <o> ^smem <s*1>)
    (<o> ^name interpret-unknown-word ^message <msg>
          ^word { << smaller larger >> <w*1> } ^word <word>)
    (<s*1> ^command <sc>)
    -->
    (<sc> ^store <w1> + ^store <spell> + ^store <next> + ^store <next-to1> +)
    (<w1> ^handle <word> +)
    (<spell> ^spelling <word> + ^structure-type C-ADJ + ^converts-to C-ADJ-P +
           ^relation <w1> +)
    (<next> ^prior-word <word> + ^current-word than + ^spelling larger-than +
           ^structure-type C-ADJ + ^relation <w1> + ^assigners <next-to1> +
           ^converts-to C-ADJ-P +)
    (<next-to1> ^structure-type DP + ^relative-position after +
           ^syntactic-structure head + ^required true +)
}

sp {interpret-message*apply*interpret-unknown-word*store-smem-word
    (state <s> ^name interpret-message ^operator <o> ^smem <s*1>)
    (<o> -^word adjacent -^word passenger -^word smaller -^word larger
          -^word husband ^name interpret-unknown-word ^message <msg>
          ^word <word>)
    (<s*1> ^command <sc>)
    -->
    (<sc> ^store <w1> + ^store <spell> + ^store <p3> +)
    (<w1> ^handle <word> + ^property <p3> +)
    (<spell> ^spelling <word> + ^structure-type ADJ + ^referent <w1> +)
    (<p3> ^handle property + ^type visual + ^item-type property +)
}

sp {interpret-message*apply*interpret-unknown-word*create*segment
    (state <s> ^name interpret-message ^operator <o> ^top-state <t*2>
          ^top-state <t*1>)
    (<o> ^name interpret-unknown-word ^message <msg> ^word <word>)
    (<t*2> ^interaction <i*1>)
    (<i*1> ^changes <c>)
    (<t*1> ^dialog-context <dc>)
    -->
    (<c> ^new-segment-info <info> +)
    (<info> ^purpose <p> + ^originator agent +)
    (<p> ^type process-unknown-word + ^parameters <p*1> +
           ^satisfaction <sat> +)
    (<p*1> ^word <word> +)
    (<sat> ^dialog-event <de> +)
    (<de> ^type process-unknown-word + ^originator instructor +)
    (<dc> ^learning-predicate <lp> +)
    (<lp> ^name <word> +)
    (<s> ^mark-interpreted <msg> + ^outgoing-message <out-msg> +)
    (<out-msg> ^type unknown-word + ^fields <f*1> +)
    (<f*1> ^word <word> +)
}

sp {interpret-message*apply*interpret-unknown-word*remove-new-unknown
    (state <s> ^name interpret-message ^operator <o> ^top-state <t*1>)
    (<o> ^name interpret-unknown-word ^message <msg> ^word <word>)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^new-unknown <word>)
    -->
    (<dc> ^new-unknown <word> -)
}

sp {interpret-message*prefer*interpret-unknown-word*adjacent
    (state <s> ^name interpret-message ^operator <o> + ^operator <o2> +)
    (<o> -^word adjacent ^name interpret-unknown-word)
    (<o2> ^word adjacent ^name interpret-unknown-word)
    -->
    (<s> ^operator <o> > <o2>)
}

sp {interpret-message*prefer*interpret-unknown-word*alphabetic*ordering
    (state <s> ^name interpret-message ^operator <o> + ^operator <o2> +)
    (<o> -^word adjacent ^name interpret-unknown-word ^word { < <w> <word> })
    (<o2> ^name interpret-unknown-word ^word <w>)
    -->
    (<s> ^operator <o> > <o2>)
}

sp {interpret-message*propose*interpret-unknown-word
    (state <s> ^name interpret-message ^instructor-message <msg>)
    (<msg> ^type unknown-word ^word <word>)
    -->
    (<s> ^operator <o> + ^operator <o> > ^operator <o> =)
    (<o> ^name interpret-unknown-word + ^word <word> + ^message <msg> +)
}

sp {interpret-message*propose*interpret-game-state-change
    (state <s> ^name interpret-message ^instructor-message <msg>)
    (<msg> -^interpreted true ^action <a*1> ^arg1 <a*2>)
    (<a*1> ^handle load)
    (<a*2> ^word-structure <w*1>)
    (<w*1> ^spelling <type>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-game-state-change + ^type <type> +)
}

sp {dialog-event*apply*game-state-change-respond*second-tower4
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type second-tower4)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +
           ^predicate <larger-than1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color green1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color green1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^color blue1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^size tiny1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^size small1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^size medium1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^size large1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +)
    (<in0> ^1 <o4> + ^2 <o2> +)
    (<in1> ^1 <o5> + ^2 <o6> +)
    (<in2> ^1 <o6> + ^2 <o7> +)
    (<in3> ^1 <o7> + ^2 <o1> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in4> +
           ^instance <in5> + ^instance <in6> + ^instance <in7> +)
    (<in4> ^1 <o2> + ^2 <o4> +)
    (<in5> ^1 <o6> + ^2 <o5> +)
    (<in6> ^1 <o7> + ^2 <o6> +)
    (<in7> ^1 <o1> + ^2 <o7> +)
    (<larger-than1> ^item-type predicate + ^handle larger-than1 +
           ^instance <in8> + ^instance <in9> + ^instance <in10> +
           ^instance <in11> + ^instance <in12> + ^instance <in13> +
           ^instance <in14> + ^instance <in15> + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> + ^instance <in25> +)
    (<in8> ^1 <o1> + ^2 <o4> +)
    (<in9> ^1 <o2> + ^2 <o4> +)
    (<in10> ^1 <o3> + ^2 <o4> +)
    (<in11> ^1 <o1> + ^2 <o5> +)
    (<in12> ^1 <o2> + ^2 <o5> +)
    (<in13> ^1 <o3> + ^2 <o5> +)
    (<in14> ^1 <o1> + ^2 <o6> +)
    (<in15> ^1 <o2> + ^2 <o6> +)
    (<in16> ^1 <o3> + ^2 <o6> +)
    (<in17> ^1 <o1> + ^2 <o7> +)
    (<in18> ^1 <o2> + ^2 <o7> +)
    (<in19> ^1 <o3> + ^2 <o7> +)
    (<in20> ^1 <o7> + ^2 <o6> +)
    (<in21> ^1 <o7> + ^2 <o5> +)
    (<in22> ^1 <o7> + ^2 <o4> +)
    (<in23> ^1 <o6> + ^2 <o5> +)
    (<in24> ^1 <o6> + ^2 <o4> +)
    (<in25> ^1 <o5> + ^2 <o4> +)
}

sp {dialog-event*apply*game-state-change-respond*init-maze
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-maze)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <near1> +
           ^predicate <diagonal-with1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^color blue1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block + ^color blue1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category block + ^color black1 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category block + ^color black1 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category block + ^color black1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +)
    (<in0> ^1 <o13> + ^2 <o1> +)
    (<in1> ^1 <o14> + ^2 <o5> +)
    (<in2> ^1 <o15> + ^2 <o8> +)
    (<in3> ^1 <o16> + ^2 <o11> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in4> +
           ^instance <in5> + ^instance <in6> + ^instance <in7> +)
    (<in4> ^1 <o1> + ^2 <o13> +)
    (<in5> ^1 <o5> + ^2 <o14> +)
    (<in6> ^1 <o8> + ^2 <o15> +)
    (<in7> ^1 <o11> + ^2 <o16> +)
    (<near1> ^item-type predicate + ^handle near1 + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +
           ^instance <in12> + ^instance <in13> + ^instance <in14> +
           ^instance <in15> + ^instance <in16> + ^instance <in17> +
           ^instance <in18> + ^instance <in19> + ^instance <in20> +
           ^instance <in21> + ^instance <in22> + ^instance <in23> +
           ^instance <in24> + ^instance <in25> + ^instance <in26> +
           ^instance <in27> + ^instance <in28> + ^instance <in29> +
           ^instance <in30> + ^instance <in31> + ^instance <in32> +
           ^instance <in33> + ^instance <in34> + ^instance <in35> +
           ^instance <in36> + ^instance <in37> + ^instance <in38> +
           ^instance <in39> + ^instance <in40> + ^instance <in41> +
           ^instance <in42> + ^instance <in43> + ^instance <in44> +
           ^instance <in45> + ^instance <in46> + ^instance <in47> +
           ^instance <in48> + ^instance <in49> + ^instance <in50> +
           ^instance <in51> + ^instance <in52> + ^instance <in53> +
           ^instance <in54> + ^instance <in55> + ^instance <in56> +
           ^instance <in57> + ^instance <in58> + ^instance <in59> +
           ^instance <in60> + ^instance <in61> + ^instance <in62> +
           ^instance <in63> + ^instance <in64> + ^instance <in65> +)
    (<in8> ^1 <o1> + ^2 <o2> +)
    (<in9> ^1 <o1> + ^2 <o4> +)
    (<in10> ^1 <o1> + ^2 <o5> +)
    (<in11> ^1 <o2> + ^2 <o1> +)
    (<in12> ^1 <o2> + ^2 <o3> +)
    (<in13> ^1 <o2> + ^2 <o4> +)
    (<in14> ^1 <o2> + ^2 <o5> +)
    (<in15> ^1 <o2> + ^2 <o6> +)
    (<in16> ^1 <o3> + ^2 <o2> +)
    (<in17> ^1 <o3> + ^2 <o5> +)
    (<in18> ^1 <o3> + ^2 <o6> +)
    (<in19> ^1 <o4> + ^2 <o1> +)
    (<in20> ^1 <o4> + ^2 <o2> +)
    (<in21> ^1 <o4> + ^2 <o5> +)
    (<in22> ^1 <o4> + ^2 <o7> +)
    (<in23> ^1 <o4> + ^2 <o8> +)
    (<in24> ^1 <o5> + ^2 <o1> +)
    (<in25> ^1 <o5> + ^2 <o2> +)
    (<in26> ^1 <o5> + ^2 <o3> +)
    (<in27> ^1 <o5> + ^2 <o4> +)
    (<in28> ^1 <o5> + ^2 <o6> +)
    (<in29> ^1 <o5> + ^2 <o7> +)
    (<in30> ^1 <o5> + ^2 <o8> +)
    (<in31> ^1 <o5> + ^2 <o9> +)
    (<in32> ^1 <o6> + ^2 <o2> +)
    (<in33> ^1 <o6> + ^2 <o3> +)
    (<in34> ^1 <o6> + ^2 <o5> +)
    (<in35> ^1 <o6> + ^2 <o8> +)
    (<in36> ^1 <o6> + ^2 <o9> +)
    (<in37> ^1 <o7> + ^2 <o4> +)
    (<in38> ^1 <o7> + ^2 <o5> +)
    (<in39> ^1 <o7> + ^2 <o8> +)
    (<in40> ^1 <o8> + ^2 <o7> +)
    (<in41> ^1 <o8> + ^2 <o4> +)
    (<in42> ^1 <o8> + ^2 <o5> +)
    (<in43> ^1 <o8> + ^2 <o6> +)
    (<in44> ^1 <o8> + ^2 <o9> +)
    (<in45> ^1 <o9> + ^2 <o8> +)
    (<in46> ^1 <o9> + ^2 <o5> +)
    (<in47> ^1 <o9> + ^2 <o6> +)
    (<in48> ^1 <o3> + ^2 <o10> +)
    (<in49> ^1 <o3> + ^2 <o11> +)
    (<in50> ^1 <o6> + ^2 <o10> +)
    (<in51> ^1 <o6> + ^2 <o11> +)
    (<in52> ^1 <o6> + ^2 <o12> +)
    (<in53> ^1 <o9> + ^2 <o11> +)
    (<in54> ^1 <o9> + ^2 <o12> +)
    (<in55> ^1 <o10> + ^2 <o3> +)
    (<in56> ^1 <o10> + ^2 <o6> +)
    (<in57> ^1 <o10> + ^2 <o11> +)
    (<in58> ^1 <o11> + ^2 <o10> +)
    (<in59> ^1 <o11> + ^2 <o3> +)
    (<in60> ^1 <o11> + ^2 <o6> +)
    (<in61> ^1 <o11> + ^2 <o9> +)
    (<in62> ^1 <o11> + ^2 <o12> +)
    (<in63> ^1 <o12> + ^2 <o11> +)
    (<in64> ^1 <o12> + ^2 <o6> +)
    (<in65> ^1 <o12> + ^2 <o9> +)
    (<diagonal-with1> ^item-type predicate + ^handle diagonal-with1 +
           ^instance <in66> + ^instance <in67> + ^instance <in68> +
           ^instance <in69> + ^instance <in70> + ^instance <in71> +
           ^instance <in72> + ^instance <in73> + ^instance <in74> +
           ^instance <in75> + ^instance <in76> + ^instance <in77> +
           ^instance <in78> + ^instance <in79> + ^instance <in80> +
           ^instance <in81> + ^instance <in82> + ^instance <in83> +
           ^instance <in84> + ^instance <in85> + ^instance <in86> +
           ^instance <in87> + ^instance <in88> + ^instance <in89> +)
    (<in66> ^1 <o1> + ^2 <o5> +)
    (<in67> ^1 <o2> + ^2 <o4> +)
    (<in68> ^1 <o2> + ^2 <o6> +)
    (<in69> ^1 <o3> + ^2 <o5> +)
    (<in70> ^1 <o4> + ^2 <o2> +)
    (<in71> ^1 <o4> + ^2 <o8> +)
    (<in72> ^1 <o5> + ^2 <o1> +)
    (<in73> ^1 <o5> + ^2 <o3> +)
    (<in74> ^1 <o5> + ^2 <o7> +)
    (<in75> ^1 <o5> + ^2 <o9> +)
    (<in76> ^1 <o6> + ^2 <o2> +)
    (<in77> ^1 <o6> + ^2 <o8> +)
    (<in78> ^1 <o7> + ^2 <o5> +)
    (<in79> ^1 <o8> + ^2 <o4> +)
    (<in80> ^1 <o8> + ^2 <o6> +)
    (<in81> ^1 <o9> + ^2 <o5> +)
    (<in82> ^1 <o3> + ^2 <o11> +)
    (<in83> ^1 <o11> + ^2 <o3> +)
    (<in84> ^1 <o6> + ^2 <o10> +)
    (<in85> ^1 <o10> + ^2 <o6> +)
    (<in86> ^1 <o9> + ^2 <o11> +)
    (<in87> ^1 <o11> + ^2 <o9> +)
    (<in88> ^1 <o12> + ^2 <o6> +)
    (<in89> ^1 <o6> + ^2 <o12> +)
}

sp {dialog-event*apply*game-state-change-respond*final-5puzzle
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-5puzzle)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <near1> +
           ^predicate <diagonal-with1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color red1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color orange1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^color yellow1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^color green1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^color blue1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^color red1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block + ^color orange1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category block + ^color yellow1 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block + ^color green1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block + ^color blue1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> +)
    (<in0> ^1 <o7> + ^2 <o1> +)
    (<in1> ^1 <o8> + ^2 <o2> +)
    (<in2> ^1 <o9> + ^2 <o4> +)
    (<in3> ^1 <o10> + ^2 <o5> +)
    (<in4> ^1 <o11> + ^2 <o6> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in5> +
           ^instance <in6> + ^instance <in7> + ^instance <in8> +
           ^instance <in9> +)
    (<in5> ^1 <o1> + ^2 <o7> +)
    (<in6> ^1 <o2> + ^2 <o8> +)
    (<in7> ^1 <o4> + ^2 <o9> +)
    (<in8> ^1 <o5> + ^2 <o10> +)
    (<in9> ^1 <o6> + ^2 <o11> +)
    (<near1> ^item-type predicate + ^handle near1 + ^instance <in10> +
           ^instance <in11> + ^instance <in12> + ^instance <in13> +
           ^instance <in14> + ^instance <in15> + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> + ^instance <in25> +
           ^instance <in26> + ^instance <in27> + ^instance <in28> +
           ^instance <in29> + ^instance <in30> + ^instance <in31> +)
    (<in10> ^1 <o1> + ^2 <o2> +)
    (<in11> ^1 <o1> + ^2 <o4> +)
    (<in12> ^1 <o1> + ^2 <o5> +)
    (<in13> ^1 <o2> + ^2 <o1> +)
    (<in14> ^1 <o2> + ^2 <o3> +)
    (<in15> ^1 <o2> + ^2 <o4> +)
    (<in16> ^1 <o2> + ^2 <o5> +)
    (<in17> ^1 <o2> + ^2 <o6> +)
    (<in18> ^1 <o3> + ^2 <o2> +)
    (<in19> ^1 <o3> + ^2 <o5> +)
    (<in20> ^1 <o3> + ^2 <o6> +)
    (<in21> ^1 <o4> + ^2 <o1> +)
    (<in22> ^1 <o4> + ^2 <o2> +)
    (<in23> ^1 <o4> + ^2 <o5> +)
    (<in24> ^1 <o5> + ^2 <o1> +)
    (<in25> ^1 <o5> + ^2 <o2> +)
    (<in26> ^1 <o5> + ^2 <o3> +)
    (<in27> ^1 <o5> + ^2 <o4> +)
    (<in28> ^1 <o5> + ^2 <o6> +)
    (<in29> ^1 <o6> + ^2 <o2> +)
    (<in30> ^1 <o6> + ^2 <o3> +)
    (<in31> ^1 <o6> + ^2 <o5> +)
    (<diagonal-with1> ^item-type predicate + ^handle diagonal-with1 +
           ^instance <in32> + ^instance <in33> + ^instance <in34> +
           ^instance <in35> + ^instance <in36> + ^instance <in37> +
           ^instance <in38> + ^instance <in39> +)
    (<in32> ^1 <o1> + ^2 <o5> +)
    (<in33> ^1 <o2> + ^2 <o4> +)
    (<in34> ^1 <o2> + ^2 <o6> +)
    (<in35> ^1 <o3> + ^2 <o5> +)
    (<in36> ^1 <o4> + ^2 <o2> +)
    (<in37> ^1 <o5> + ^2 <o1> +)
    (<in38> ^1 <o5> + ^2 <o3> +)
    (<in39> ^1 <o6> + ^2 <o2> +)
}

sp {dialog-event*apply*game-state-change-respond*fail-tictactoe
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type fail-tictactoe)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <linear> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block + ^color red1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block + ^color red1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category block + ^color red1 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block + ^color blue1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category block + ^color blue1 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category block + ^color blue1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> +)
    (<in0> ^1 <o13> + ^2 <o1> +)
    (<in1> ^1 <o14> + ^2 <o2> +)
    (<in2> ^1 <o15> + ^2 <o3> +)
    (<in3> ^1 <o10> + ^2 <o11> +)
    (<in4> ^1 <o11> + ^2 <o12> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in5> +
           ^instance <in6> + ^instance <in7> + ^instance <in8> +
           ^instance <in9> +)
    (<in5> ^1 <o1> + ^2 <o13> +)
    (<in6> ^1 <o2> + ^2 <o14> +)
    (<in7> ^1 <o3> + ^2 <o15> +)
    (<in8> ^1 <o11> + ^2 <o10> +)
    (<in9> ^1 <o12> + ^2 <o11> +)
    (<linear> ^item-type predicate + ^handle linear + ^instance <in10> +
           ^instance <in11> + ^instance <in12> + ^instance <in13> +
           ^instance <in14> + ^instance <in15> + ^instance <in16> +
           ^instance <in17> +)
    (<in10> ^1 <set10> +)
    (<set10> ^object <o1> + ^object <o2> + ^object <o3> +)
    (<in11> ^1 <set11> +)
    (<set11> ^object <o1> + ^object <o5> + ^object <o9> +)
    (<in12> ^1 <set12> +)
    (<set12> ^object <o1> + ^object <o4> + ^object <o7> +)
    (<in13> ^1 <set13> +)
    (<set13> ^object <o4> + ^object <o5> + ^object <o6> +)
    (<in14> ^1 <set14> +)
    (<set14> ^object <o7> + ^object <o8> + ^object <o9> +)
    (<in15> ^1 <set15> +)
    (<set15> ^object <o2> + ^object <o5> + ^object <o8> +)
    (<in16> ^1 <set16> +)
    (<set16> ^object <o3> + ^object <o6> + ^object <o9> +)
    (<in17> ^1 <set17> +)
    (<set17> ^object <o3> + ^object <o5> + ^object <o7> +)
}

sp {dialog-event*apply*game-state-change-respond*final-sudoku4
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-sudoku4)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^x 1 + ^y 1 + ^value 3 +
           ^sub-grid 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^x 2 + ^y 1 + ^value 1 +
           ^sub-grid 1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^x 3 + ^y 1 + ^value 2 +
           ^sub-grid 2 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^x 4 + ^y 1 + ^value 4 +
           ^sub-grid 2 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^x 1 + ^y 2 + ^value 4 +
           ^sub-grid 1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^x 2 + ^y 2 + ^value 2 +
           ^sub-grid 1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^x 3 + ^y 2 + ^value 1 +
           ^sub-grid 2 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^x 4 + ^y 2 + ^value 3 +
           ^sub-grid 2 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^x 1 + ^y 3 + ^value 1 +
           ^sub-grid 3 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^x 2 + ^y 3 + ^value 3 +
           ^sub-grid 3 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location + ^x 3 + ^y 3 + ^value 4 +
           ^sub-grid 4 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location + ^x 4 + ^y 3 + ^value 2 +
           ^sub-grid 4 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category location + ^x 1 + ^y 4 + ^value 2 +
           ^sub-grid 3 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category location + ^x 2 + ^y 4 + ^value 4 +
           ^sub-grid 3 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category location + ^x 3 + ^y 4 + ^value 3 +
           ^sub-grid 4 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category location + ^x 4 + ^y 4 + ^value 1 +
           ^sub-grid 4 +)
}

sp {dialog-event*apply*game-state-change-respond*init-connect-3
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-connect-3)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o21> + ^object <o22> +
           ^object <o23> + ^object <o24> + ^object <o25> + ^object <o26> +
           ^object <o27> + ^object <o28> + ^object <o29> + ^object <o30> +
           ^object <o31> + ^object <o10> + ^object <o11> + ^object <o12> +
           ^object <o13> + ^object <o14> + ^object <o15> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <above1> +
           ^predicate <linear> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location +)
    (<o21> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location +)
    (<o22> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location +)
    (<o23> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location +)
    (<o24> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category location +)
    (<o25> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category location +)
    (<o26> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category location +)
    (<o27> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category location +)
    (<o28> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category location +)
    (<o29> ^item-type object + ^handle object-17 + ^predicates <pr17> +)
    (<pr17> ^visible true + ^category location +)
    (<o30> ^item-type object + ^handle object-18 + ^predicates <pr18> +)
    (<pr18> ^visible true + ^category location +)
    (<o31> ^item-type object + ^handle object-19 + ^predicates <pr19> +)
    (<pr19> ^visible true + ^category location +)
    (<o10> ^item-type object + ^handle object-20 + ^predicates <pr20> +)
    (<pr20> ^visible true + ^category block + ^color red1 +)
    (<o11> ^item-type object + ^handle object-21 + ^predicates <pr21> +)
    (<pr21> ^visible true + ^category block + ^color red1 +)
    (<o12> ^item-type object + ^handle object-22 + ^predicates <pr22> +)
    (<pr22> ^visible true + ^category block + ^color red1 +)
    (<o13> ^item-type object + ^handle object-23 + ^predicates <pr23> +)
    (<pr23> ^visible true + ^category block + ^color blue1 +)
    (<o14> ^item-type object + ^handle object-24 + ^predicates <pr24> +)
    (<pr24> ^visible true + ^category block + ^color blue1 +)
    (<o15> ^item-type object + ^handle object-25 + ^predicates <pr25> +)
    (<pr25> ^visible true + ^category block + ^color blue1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +)
    (<in0> ^1 <o10> + ^2 <o11> +)
    (<in1> ^1 <o11> + ^2 <o12> +)
    (<in2> ^1 <o13> + ^2 <o14> +)
    (<in3> ^1 <o14> + ^2 <o15> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in4> +
           ^instance <in5> + ^instance <in6> + ^instance <in7> +)
    (<in4> ^1 <o11> + ^2 <o10> +)
    (<in5> ^1 <o12> + ^2 <o11> +)
    (<in6> ^1 <o14> + ^2 <o13> +)
    (<in7> ^1 <o15> + ^2 <o14> +)
    (<above1> ^item-type predicate + ^handle above1 + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +
           ^instance <in12> + ^instance <in13> + ^instance <in14> +
           ^instance <in15> + ^instance <in16> + ^instance <in17> +
           ^instance <in18> + ^instance <in19> + ^instance <in20> +
           ^instance <in21> + ^instance <in22> +)
    (<in8> ^1 <o7> + ^2 <o27> +)
    (<in9> ^1 <o4> + ^2 <o7> +)
    (<in10> ^1 <o1> + ^2 <o4> +)
    (<in11> ^1 <o8> + ^2 <o28> +)
    (<in12> ^1 <o5> + ^2 <o8> +)
    (<in13> ^1 <o2> + ^2 <o5> +)
    (<in14> ^1 <o3> + ^2 <o6> +)
    (<in15> ^1 <o6> + ^2 <o9> +)
    (<in16> ^1 <o9> + ^2 <o29> +)
    (<in17> ^1 <o21> + ^2 <o23> +)
    (<in18> ^1 <o23> + ^2 <o25> +)
    (<in19> ^1 <o25> + ^2 <o30> +)
    (<in20> ^1 <o22> + ^2 <o24> +)
    (<in21> ^1 <o24> + ^2 <o26> +)
    (<in22> ^1 <o26> + ^2 <o31> +)
    (<linear> ^item-type predicate + ^handle linear + ^instance <in23> +
           ^instance <in24> + ^instance <in25> + ^instance <in26> +
           ^instance <in27> + ^instance <in28> + ^instance <in29> +
           ^instance <in30> + ^instance <in31> + ^instance <in32> +
           ^instance <in33> + ^instance <in34> + ^instance <in35> +
           ^instance <in36> + ^instance <in37> + ^instance <in38> +
           ^instance <in39> + ^instance <in40> + ^instance <in41> +
           ^instance <in42> + ^instance <in43> + ^instance <in44> +
           ^instance <in45> + ^instance <in46> + ^instance <in47> +
           ^instance <in48> + ^instance <in49> + ^instance <in50> +
           ^instance <in51> + ^instance <in52> + ^instance <in53> +
           ^instance <in54> + ^instance <in55> + ^instance <in56> +
           ^instance <in57> +)
    (<in23> ^1 <set23> +)
    (<set23> ^object <o1> + ^object <o2> + ^object <o3> +)
    (<in24> ^1 <set24> +)
    (<set24> ^object <o1> + ^object <o5> + ^object <o9> +)
    (<in25> ^1 <set25> +)
    (<set25> ^object <o1> + ^object <o4> + ^object <o7> +)
    (<in26> ^1 <set26> +)
    (<set26> ^object <o4> + ^object <o5> + ^object <o6> +)
    (<in27> ^1 <set27> +)
    (<set27> ^object <o7> + ^object <o8> + ^object <o9> +)
    (<in28> ^1 <set28> +)
    (<set28> ^object <o2> + ^object <o5> + ^object <o8> +)
    (<in29> ^1 <set29> +)
    (<set29> ^object <o3> + ^object <o6> + ^object <o9> +)
    (<in30> ^1 <set30> +)
    (<set30> ^object <o3> + ^object <o5> + ^object <o7> +)
    (<in31> ^1 <set31> +)
    (<set31> ^object <o3> + ^object <o21> + ^object <o22> +)
    (<in32> ^1 <set32> +)
    (<set32> ^object <o6> + ^object <o23> + ^object <o24> +)
    (<in33> ^1 <set33> +)
    (<set33> ^object <o9> + ^object <o25> + ^object <o26> +)
    (<in34> ^1 <set34> +)
    (<set34> ^object <o29> + ^object <o30> + ^object <o31> +)
    (<in35> ^1 <set35> +)
    (<set35> ^object <o27> + ^object <o28> + ^object <o29> +)
    (<in36> ^1 <set36> +)
    (<set36> ^object <o2> + ^object <o3> + ^object <o21> +)
    (<in37> ^1 <set37> +)
    (<set37> ^object <o5> + ^object <o6> + ^object <o23> +)
    (<in38> ^1 <set38> +)
    (<set38> ^object <o8> + ^object <o9> + ^object <o25> +)
    (<in39> ^1 <set39> +)
    (<set39> ^object <o28> + ^object <o29> + ^object <o30> +)
    (<in40> ^1 <set40> +)
    (<set40> ^object <o21> + ^object <o23> + ^object <o25> +)
    (<in41> ^1 <set41> +)
    (<set41> ^object <o22> + ^object <o24> + ^object <o26> +)
    (<in42> ^1 <set42> +)
    (<set42> ^object <o4> + ^object <o7> + ^object <o27> +)
    (<in43> ^1 <set43> +)
    (<set43> ^object <o5> + ^object <o8> + ^object <o28> +)
    (<in44> ^1 <set44> +)
    (<set44> ^object <o6> + ^object <o9> + ^object <o29> +)
    (<in45> ^1 <set45> +)
    (<set45> ^object <o23> + ^object <o25> + ^object <o30> +)
    (<in46> ^1 <set46> +)
    (<set46> ^object <o24> + ^object <o26> + ^object <o31> +)
    (<in47> ^1 <set47> +)
    (<set47> ^object <o4> + ^object <o8> + ^object <o29> +)
    (<in48> ^1 <set48> +)
    (<set48> ^object <o5> + ^object <o9> + ^object <o30> +)
    (<in49> ^1 <set49> +)
    (<set49> ^object <o6> + ^object <o25> + ^object <o31> +)
    (<in50> ^1 <set50> +)
    (<set50> ^object <o2> + ^object <o6> + ^object <o25> +)
    (<in51> ^1 <set51> +)
    (<set51> ^object <o3> + ^object <o23> + ^object <o25> +)
    (<in52> ^1 <set52> +)
    (<set52> ^object <o24> + ^object <o25> + ^object <o29> +)
    (<in53> ^1 <set53> +)
    (<set53> ^object <o23> + ^object <o9> + ^object <o28> +)
    (<in54> ^1 <set54> +)
    (<set54> ^object <o6> + ^object <o8> + ^object <o27> +)
    (<in55> ^1 <set55> +)
    (<set55> ^object <o22> + ^object <o23> + ^object <o9> +)
    (<in56> ^1 <set56> +)
    (<set56> ^object <o21> + ^object <o6> + ^object <o8> +)
    (<in57> ^1 <set57> +)
    (<set57> ^object <o3> + ^object <o5> + ^object <o7> +)
}

sp {dialog-event*apply*game-state-change-respond*init-husbands
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-husbands)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^shape bank1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^shape bank1 +
           ^name destination1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category block + ^shape woman1 +
           ^last-name smith1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^shape woman1 +
           ^last-name bale1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^shape woman1 +
           ^last-name rogers1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^shape man1 + ^last-name smith1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^shape man1 + ^last-name bale1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block + ^shape man1 +
           ^last-name rogers1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category block + ^shape boat1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +)
    (<in0> ^1 <o3> + ^2 <o1> +)
    (<in1> ^1 <o4> + ^2 <o1> +)
    (<in2> ^1 <o5> + ^2 <o1> +)
    (<in3> ^1 <o6> + ^2 <o1> +)
    (<in4> ^1 <o7> + ^2 <o1> +)
    (<in5> ^1 <o8> + ^2 <o1> +)
    (<in6> ^1 <o9> + ^2 <o1> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in7> +
           ^instance <in8> + ^instance <in9> + ^instance <in10> +
           ^instance <in11> + ^instance <in12> + ^instance <in13> +)
    (<in7> ^1 <o1> + ^2 <o3> +)
    (<in8> ^1 <o1> + ^2 <o4> +)
    (<in9> ^1 <o1> + ^2 <o5> +)
    (<in10> ^1 <o1> + ^2 <o6> +)
    (<in11> ^1 <o1> + ^2 <o7> +)
    (<in12> ^1 <o1> + ^2 <o8> +)
    (<in13> ^1 <o1> + ^2 <o9> +)
}

sp {dialog-event*apply*game-state-change-respond*second-fox
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type second-fox)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^shape bank1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^shape bank1 +
           ^name destination1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category block + ^color red1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^color yellow1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^color green1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^shape boat1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +)
    (<in0> ^1 <o4> + ^2 <o6> +)
    (<in1> ^1 <o5> + ^2 <o1> +)
    (<in2> ^1 <o6> + ^2 <o1> +)
    (<in3> ^1 <o3> + ^2 <o1> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in4> +
           ^instance <in5> + ^instance <in6> + ^instance <in7> +)
    (<in4> ^1 <o6> + ^2 <o4> +)
    (<in5> ^1 <o1> + ^2 <o5> +)
    (<in6> ^1 <o1> + ^2 <o6> +)
    (<in7> ^1 <o1> + ^2 <o3> +)
}

sp {dialog-event*apply*game-state-change-respond*fail-mac
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type fail-mac)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^shape bank1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^shape bank1 +
           ^name destination1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category block + ^shape missionary1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^shape missionary1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^shape missionary1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^shape cannibal1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^shape cannibal1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block + ^shape cannibal1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category block + ^shape boat1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +)
    (<in0> ^1 <o3> + ^2 <o2> +)
    (<in1> ^1 <o4> + ^2 <o2> +)
    (<in2> ^1 <o5> + ^2 <o1> +)
    (<in3> ^1 <o6> + ^2 <o9> +)
    (<in4> ^1 <o7> + ^2 <o1> +)
    (<in5> ^1 <o8> + ^2 <o1> +)
    (<in6> ^1 <o9> + ^2 <o1> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in7> +
           ^instance <in8> + ^instance <in9> + ^instance <in10> +
           ^instance <in11> + ^instance <in12> + ^instance <in13> +)
    (<in7> ^1 <o2> + ^2 <o3> +)
    (<in8> ^1 <o2> + ^2 <o4> +)
    (<in9> ^1 <o1> + ^2 <o5> +)
    (<in10> ^1 <o9> + ^2 <o6> +)
    (<in11> ^1 <o1> + ^2 <o7> +)
    (<in12> ^1 <o1> + ^2 <o8> +)
    (<in13> ^1 <o1> + ^2 <o9> +)
}

sp {dialog-event*apply*game-state-change-respond*init-tower3
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-tower3)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color green1 +
           ^volume 4.000000 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color green1 +
           ^volume 4.000000 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^color blue1 +
           ^volume 4.000000 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^size small1 + ^volume 1.000000 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^size medium1 +
           ^volume 2.000000 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^size large1 + ^volume 3.000000 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> +)
    (<in0> ^1 <o4> + ^2 <o5> +)
    (<in1> ^1 <o5> + ^2 <o6> +)
    (<in2> ^1 <o6> + ^2 <o1> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in3> +
           ^instance <in4> + ^instance <in5> +)
    (<in3> ^1 <o5> + ^2 <o4> +)
    (<in4> ^1 <o6> + ^2 <o5> +)
    (<in5> ^1 <o1> + ^2 <o6> +)
}

sp {dialog-event*apply*game-state-change-respond*final-3mens
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-3mens)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <near1> +
           ^predicate <diagonal-with1> + ^predicate <linear> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block + ^color red1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block + ^color red1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category block + ^color red1 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block + ^color blue1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category block + ^color blue1 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category block + ^color blue1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> +)
    (<in0> ^1 <o10> + ^2 <o1> +)
    (<in1> ^1 <o11> + ^2 <o2> +)
    (<in2> ^1 <o12> + ^2 <o3> +)
    (<in3> ^1 <o13> + ^2 <o14> +)
    (<in4> ^1 <o14> + ^2 <o15> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in5> +
           ^instance <in6> + ^instance <in7> + ^instance <in8> +
           ^instance <in9> +)
    (<in5> ^1 <o1> + ^2 <o10> +)
    (<in6> ^1 <o2> + ^2 <o11> +)
    (<in7> ^1 <o3> + ^2 <o12> +)
    (<in8> ^1 <o14> + ^2 <o13> +)
    (<in9> ^1 <o15> + ^2 <o14> +)
    (<near1> ^item-type predicate + ^handle near1 + ^instance <in10> +
           ^instance <in11> + ^instance <in12> + ^instance <in13> +
           ^instance <in14> + ^instance <in15> + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> + ^instance <in25> +
           ^instance <in26> + ^instance <in27> + ^instance <in28> +
           ^instance <in29> + ^instance <in30> + ^instance <in31> +
           ^instance <in32> + ^instance <in33> + ^instance <in34> +
           ^instance <in35> + ^instance <in36> + ^instance <in37> +
           ^instance <in38> + ^instance <in39> + ^instance <in40> +
           ^instance <in41> + ^instance <in42> + ^instance <in43> +
           ^instance <in44> + ^instance <in45> + ^instance <in46> +
           ^instance <in47> + ^instance <in48> + ^instance <in49> +)
    (<in10> ^1 <o1> + ^2 <o2> +)
    (<in11> ^1 <o1> + ^2 <o4> +)
    (<in12> ^1 <o1> + ^2 <o5> +)
    (<in13> ^1 <o2> + ^2 <o1> +)
    (<in14> ^1 <o2> + ^2 <o3> +)
    (<in15> ^1 <o2> + ^2 <o4> +)
    (<in16> ^1 <o2> + ^2 <o5> +)
    (<in17> ^1 <o2> + ^2 <o6> +)
    (<in18> ^1 <o3> + ^2 <o2> +)
    (<in19> ^1 <o3> + ^2 <o5> +)
    (<in20> ^1 <o3> + ^2 <o6> +)
    (<in21> ^1 <o4> + ^2 <o1> +)
    (<in22> ^1 <o4> + ^2 <o2> +)
    (<in23> ^1 <o4> + ^2 <o5> +)
    (<in24> ^1 <o4> + ^2 <o7> +)
    (<in25> ^1 <o4> + ^2 <o8> +)
    (<in26> ^1 <o5> + ^2 <o1> +)
    (<in27> ^1 <o5> + ^2 <o2> +)
    (<in28> ^1 <o5> + ^2 <o3> +)
    (<in29> ^1 <o5> + ^2 <o4> +)
    (<in30> ^1 <o5> + ^2 <o6> +)
    (<in31> ^1 <o5> + ^2 <o7> +)
    (<in32> ^1 <o5> + ^2 <o8> +)
    (<in33> ^1 <o5> + ^2 <o9> +)
    (<in34> ^1 <o6> + ^2 <o2> +)
    (<in35> ^1 <o6> + ^2 <o3> +)
    (<in36> ^1 <o6> + ^2 <o5> +)
    (<in37> ^1 <o6> + ^2 <o8> +)
    (<in38> ^1 <o6> + ^2 <o9> +)
    (<in39> ^1 <o7> + ^2 <o4> +)
    (<in40> ^1 <o7> + ^2 <o5> +)
    (<in41> ^1 <o7> + ^2 <o8> +)
    (<in42> ^1 <o8> + ^2 <o7> +)
    (<in43> ^1 <o8> + ^2 <o4> +)
    (<in44> ^1 <o8> + ^2 <o5> +)
    (<in45> ^1 <o8> + ^2 <o6> +)
    (<in46> ^1 <o8> + ^2 <o9> +)
    (<in47> ^1 <o9> + ^2 <o8> +)
    (<in48> ^1 <o9> + ^2 <o5> +)
    (<in49> ^1 <o9> + ^2 <o6> +)
    (<diagonal-with1> ^item-type predicate + ^handle diagonal-with1 +
           ^instance <in50> + ^instance <in51> + ^instance <in52> +
           ^instance <in53> + ^instance <in54> + ^instance <in55> +
           ^instance <in56> + ^instance <in57> + ^instance <in58> +
           ^instance <in59> + ^instance <in60> + ^instance <in61> +
           ^instance <in62> + ^instance <in63> + ^instance <in64> +
           ^instance <in65> +)
    (<in50> ^1 <o1> + ^2 <o5> +)
    (<in51> ^1 <o2> + ^2 <o4> +)
    (<in52> ^1 <o2> + ^2 <o6> +)
    (<in53> ^1 <o3> + ^2 <o5> +)
    (<in54> ^1 <o4> + ^2 <o2> +)
    (<in55> ^1 <o4> + ^2 <o8> +)
    (<in56> ^1 <o5> + ^2 <o1> +)
    (<in57> ^1 <o5> + ^2 <o3> +)
    (<in58> ^1 <o5> + ^2 <o7> +)
    (<in59> ^1 <o5> + ^2 <o9> +)
    (<in60> ^1 <o6> + ^2 <o2> +)
    (<in61> ^1 <o6> + ^2 <o8> +)
    (<in62> ^1 <o7> + ^2 <o5> +)
    (<in63> ^1 <o8> + ^2 <o4> +)
    (<in64> ^1 <o8> + ^2 <o6> +)
    (<in65> ^1 <o9> + ^2 <o5> +)
    (<linear> ^item-type predicate + ^handle linear + ^instance <in66> +
           ^instance <in67> + ^instance <in68> + ^instance <in69> +
           ^instance <in70> + ^instance <in71> + ^instance <in72> +
           ^instance <in73> +)
    (<in66> ^1 <set66> +)
    (<set66> ^object <o1> + ^object <o2> + ^object <o3> +)
    (<in67> ^1 <set67> +)
    (<set67> ^object <o1> + ^object <o5> + ^object <o9> +)
    (<in68> ^1 <set68> +)
    (<set68> ^object <o1> + ^object <o4> + ^object <o7> +)
    (<in69> ^1 <set69> +)
    (<set69> ^object <o4> + ^object <o5> + ^object <o6> +)
    (<in70> ^1 <set70> +)
    (<set70> ^object <o7> + ^object <o8> + ^object <o9> +)
    (<in71> ^1 <set71> +)
    (<set71> ^object <o2> + ^object <o5> + ^object <o8> +)
    (<in72> ^1 <set72> +)
    (<set72> ^object <o3> + ^object <o6> + ^object <o9> +)
    (<in73> ^1 <set73> +)
    (<set73> ^object <o3> + ^object <o5> + ^object <o7> +)
}

sp {dialog-event*apply*game-state-change-respond*init-mini-sudoku
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-mini-sudoku)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^row 1 + ^column 1 +
           ^section 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^row 2 + ^column 1 +
           ^value 1 + ^section 1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^row 3 + ^column 1 +
           ^value 2 + ^section 2 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^row 4 + ^column 1 +
           ^section 2 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^row 1 + ^column 2 +
           ^value 4 + ^section 1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^row 2 + ^column 2 +
           ^section 1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^row 3 + ^column 2 +
           ^section 2 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^row 4 + ^column 2 +
           ^section 2 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^row 1 + ^column 3 +
           ^section 3 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^row 2 + ^column 3 +
           ^section 3 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location + ^row 3 + ^column 3 +
           ^section 4 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location + ^row 4 + ^column 3 +
           ^value 2 + ^section 4 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category location + ^row 1 + ^column 4 +
           ^section 3 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category location + ^row 2 + ^column 4 +
           ^value 4 + ^section 3 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category location + ^row 3 + ^column 4 +
           ^value 3 + ^section 4 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category location + ^row 4 + ^column 4 +
           ^section 4 +)
}

sp {dialog-event*apply*game-state-change-respond*init-tower4
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-tower4)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +
           ^predicate <larger-than1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color green1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color green1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^color blue1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^size tiny1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^size small1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^size medium1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^size large1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +)
    (<in0> ^1 <o4> + ^2 <o5> +)
    (<in1> ^1 <o5> + ^2 <o6> +)
    (<in2> ^1 <o6> + ^2 <o7> +)
    (<in3> ^1 <o7> + ^2 <o1> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in4> +
           ^instance <in5> + ^instance <in6> + ^instance <in7> +)
    (<in4> ^1 <o5> + ^2 <o4> +)
    (<in5> ^1 <o6> + ^2 <o5> +)
    (<in6> ^1 <o7> + ^2 <o6> +)
    (<in7> ^1 <o1> + ^2 <o7> +)
    (<larger-than1> ^item-type predicate + ^handle larger-than1 +
           ^instance <in8> + ^instance <in9> + ^instance <in10> +
           ^instance <in11> + ^instance <in12> + ^instance <in13> +
           ^instance <in14> + ^instance <in15> + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> + ^instance <in25> +)
    (<in8> ^1 <o1> + ^2 <o4> +)
    (<in9> ^1 <o2> + ^2 <o4> +)
    (<in10> ^1 <o3> + ^2 <o4> +)
    (<in11> ^1 <o1> + ^2 <o5> +)
    (<in12> ^1 <o2> + ^2 <o5> +)
    (<in13> ^1 <o3> + ^2 <o5> +)
    (<in14> ^1 <o1> + ^2 <o6> +)
    (<in15> ^1 <o2> + ^2 <o6> +)
    (<in16> ^1 <o3> + ^2 <o6> +)
    (<in17> ^1 <o1> + ^2 <o7> +)
    (<in18> ^1 <o2> + ^2 <o7> +)
    (<in19> ^1 <o3> + ^2 <o7> +)
    (<in20> ^1 <o7> + ^2 <o6> +)
    (<in21> ^1 <o7> + ^2 <o5> +)
    (<in22> ^1 <o7> + ^2 <o4> +)
    (<in23> ^1 <o6> + ^2 <o5> +)
    (<in24> ^1 <o6> + ^2 <o4> +)
    (<in25> ^1 <o5> + ^2 <o4> +)
}

sp {dialog-event*apply*game-state-change-respond*final-breakthrough
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-breakthrough)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> + ^object <o17> + ^object <o18> + ^object <o19> +
           ^object <o20> + ^object <o21> + ^object <o22> + ^object <o23> +
           ^object <o24> + ^object <o25> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <above1> +
           ^predicate <under1> + ^predicate <diagonal-with1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color blue1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color blue1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^color blue1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^color blue1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category location + ^color red1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category location + ^color red1 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category location + ^color red1 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category location + ^color red1 +)
    (<o17> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category block + ^color red1 +)
    (<o18> ^item-type object + ^handle object-17 + ^predicates <pr17> +)
    (<pr17> ^visible true + ^category block + ^color red1 +)
    (<o19> ^item-type object + ^handle object-18 + ^predicates <pr18> +)
    (<pr18> ^visible true + ^category block + ^color red1 +)
    (<o20> ^item-type object + ^handle object-19 + ^predicates <pr19> +)
    (<pr19> ^visible true + ^category block + ^color red1 +)
    (<o21> ^item-type object + ^handle object-20 + ^predicates <pr20> +)
    (<pr20> ^visible true + ^category block + ^color blue1 +)
    (<o22> ^item-type object + ^handle object-21 + ^predicates <pr21> +)
    (<pr21> ^visible true + ^category block + ^color blue1 +)
    (<o23> ^item-type object + ^handle object-22 + ^predicates <pr22> +)
    (<pr22> ^visible true + ^category block + ^color blue1 +)
    (<o24> ^item-type object + ^handle object-23 + ^predicates <pr23> +)
    (<pr23> ^visible true + ^category block + ^color blue1 +)
    (<o25> ^item-type object + ^handle object-24 + ^predicates <pr24> +)
    (<pr24> ^visible true + ^category location + ^name garbage +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +
           ^instance <in7> +)
    (<in0> ^1 <o17> + ^2 <o13> +)
    (<in1> ^1 <o18> + ^2 <o2> +)
    (<in2> ^1 <o19> + ^2 <o3> +)
    (<in3> ^1 <o20> + ^2 <o10> +)
    (<in4> ^1 <o21> + ^2 <o25> +)
    (<in5> ^1 <o22> + ^2 <o14> +)
    (<in6> ^1 <o23> + ^2 <o15> +)
    (<in7> ^1 <o24> + ^2 <o16> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +
           ^instance <in12> + ^instance <in13> + ^instance <in14> +
           ^instance <in15> +)
    (<in8> ^1 <o13> + ^2 <o17> +)
    (<in9> ^1 <o2> + ^2 <o18> +)
    (<in10> ^1 <o3> + ^2 <o19> +)
    (<in11> ^1 <o10> + ^2 <o20> +)
    (<in12> ^1 <o25> + ^2 <o21> +)
    (<in13> ^1 <o14> + ^2 <o22> +)
    (<in14> ^1 <o15> + ^2 <o23> +)
    (<in15> ^1 <o16> + ^2 <o24> +)
    (<above1> ^item-type predicate + ^handle above1 + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> + ^instance <in25> +
           ^instance <in26> + ^instance <in27> + ^instance <in28> +
           ^instance <in29> + ^instance <in30> + ^instance <in31> +
           ^instance <in32> + ^instance <in33> + ^instance <in34> +
           ^instance <in35> + ^instance <in36> + ^instance <in37> +
           ^instance <in38> + ^instance <in39> + ^instance <in40> +
           ^instance <in41> + ^instance <in42> + ^instance <in43> +
           ^instance <in44> + ^instance <in45> +)
    (<in16> ^1 <o13> + ^2 <o7> +)
    (<in17> ^1 <o14> + ^2 <o7> +)
    (<in18> ^1 <o13> + ^2 <o8> +)
    (<in19> ^1 <o14> + ^2 <o8> +)
    (<in20> ^1 <o15> + ^2 <o8> +)
    (<in21> ^1 <o14> + ^2 <o9> +)
    (<in22> ^1 <o15> + ^2 <o9> +)
    (<in23> ^1 <o16> + ^2 <o9> +)
    (<in24> ^1 <o15> + ^2 <o12> +)
    (<in25> ^1 <o16> + ^2 <o12> +)
    (<in26> ^1 <o7> + ^2 <o4> +)
    (<in27> ^1 <o8> + ^2 <o4> +)
    (<in28> ^1 <o7> + ^2 <o5> +)
    (<in29> ^1 <o8> + ^2 <o5> +)
    (<in30> ^1 <o9> + ^2 <o5> +)
    (<in31> ^1 <o8> + ^2 <o6> +)
    (<in32> ^1 <o9> + ^2 <o6> +)
    (<in33> ^1 <o12> + ^2 <o6> +)
    (<in34> ^1 <o9> + ^2 <o11> +)
    (<in35> ^1 <o12> + ^2 <o11> +)
    (<in36> ^1 <o4> + ^2 <o1> +)
    (<in37> ^1 <o5> + ^2 <o1> +)
    (<in38> ^1 <o4> + ^2 <o2> +)
    (<in39> ^1 <o5> + ^2 <o2> +)
    (<in40> ^1 <o6> + ^2 <o2> +)
    (<in41> ^1 <o5> + ^2 <o3> +)
    (<in42> ^1 <o6> + ^2 <o3> +)
    (<in43> ^1 <o11> + ^2 <o3> +)
    (<in44> ^1 <o6> + ^2 <o10> +)
    (<in45> ^1 <o11> + ^2 <o10> +)
    (<under1> ^item-type predicate + ^handle under1 + ^instance <in46> +
           ^instance <in47> + ^instance <in48> + ^instance <in49> +
           ^instance <in50> + ^instance <in51> + ^instance <in52> +
           ^instance <in53> + ^instance <in54> + ^instance <in55> +
           ^instance <in56> + ^instance <in57> + ^instance <in58> +
           ^instance <in59> + ^instance <in60> + ^instance <in61> +
           ^instance <in62> + ^instance <in63> + ^instance <in64> +
           ^instance <in65> + ^instance <in66> + ^instance <in67> +
           ^instance <in68> + ^instance <in69> + ^instance <in70> +
           ^instance <in71> + ^instance <in72> + ^instance <in73> +
           ^instance <in74> + ^instance <in75> +)
    (<in46> ^1 <o7> + ^2 <o13> +)
    (<in47> ^1 <o7> + ^2 <o14> +)
    (<in48> ^1 <o8> + ^2 <o13> +)
    (<in49> ^1 <o8> + ^2 <o14> +)
    (<in50> ^1 <o8> + ^2 <o15> +)
    (<in51> ^1 <o9> + ^2 <o14> +)
    (<in52> ^1 <o9> + ^2 <o15> +)
    (<in53> ^1 <o9> + ^2 <o16> +)
    (<in54> ^1 <o12> + ^2 <o15> +)
    (<in55> ^1 <o12> + ^2 <o16> +)
    (<in56> ^1 <o4> + ^2 <o7> +)
    (<in57> ^1 <o4> + ^2 <o8> +)
    (<in58> ^1 <o5> + ^2 <o7> +)
    (<in59> ^1 <o5> + ^2 <o8> +)
    (<in60> ^1 <o5> + ^2 <o9> +)
    (<in61> ^1 <o6> + ^2 <o8> +)
    (<in62> ^1 <o6> + ^2 <o9> +)
    (<in63> ^1 <o6> + ^2 <o12> +)
    (<in64> ^1 <o11> + ^2 <o9> +)
    (<in65> ^1 <o11> + ^2 <o12> +)
    (<in66> ^1 <o1> + ^2 <o4> +)
    (<in67> ^1 <o1> + ^2 <o5> +)
    (<in68> ^1 <o2> + ^2 <o4> +)
    (<in69> ^1 <o2> + ^2 <o5> +)
    (<in70> ^1 <o2> + ^2 <o6> +)
    (<in71> ^1 <o3> + ^2 <o5> +)
    (<in72> ^1 <o3> + ^2 <o6> +)
    (<in73> ^1 <o3> + ^2 <o11> +)
    (<in74> ^1 <o10> + ^2 <o6> +)
    (<in75> ^1 <o10> + ^2 <o11> +)
    (<diagonal-with1> ^item-type predicate + ^handle diagonal-with1 +
           ^instance <in76> + ^instance <in77> + ^instance <in78> +
           ^instance <in79> + ^instance <in80> + ^instance <in81> +
           ^instance <in82> + ^instance <in83> + ^instance <in84> +
           ^instance <in85> + ^instance <in86> + ^instance <in87> +
           ^instance <in88> + ^instance <in89> + ^instance <in90> +
           ^instance <in91> + ^instance <in92> + ^instance <in93> +
           ^instance <in94> + ^instance <in95> + ^instance <in96> +
           ^instance <in97> + ^instance <in98> + ^instance <in99> +
           ^instance <in100> + ^instance <in101> + ^instance <in102> +
           ^instance <in103> + ^instance <in104> + ^instance <in105> +
           ^instance <in106> + ^instance <in107> + ^instance <in108> +
           ^instance <in109> + ^instance <in110> + ^instance <in111> +)
    (<in76> ^1 <o1> + ^2 <o5> +)
    (<in77> ^1 <o2> + ^2 <o4> +)
    (<in78> ^1 <o2> + ^2 <o6> +)
    (<in79> ^1 <o3> + ^2 <o5> +)
    (<in80> ^1 <o4> + ^2 <o2> +)
    (<in81> ^1 <o4> + ^2 <o8> +)
    (<in82> ^1 <o5> + ^2 <o1> +)
    (<in83> ^1 <o5> + ^2 <o3> +)
    (<in84> ^1 <o5> + ^2 <o7> +)
    (<in85> ^1 <o5> + ^2 <o9> +)
    (<in86> ^1 <o6> + ^2 <o2> +)
    (<in87> ^1 <o6> + ^2 <o8> +)
    (<in88> ^1 <o7> + ^2 <o5> +)
    (<in89> ^1 <o8> + ^2 <o4> +)
    (<in90> ^1 <o8> + ^2 <o6> +)
    (<in91> ^1 <o9> + ^2 <o5> +)
    (<in92> ^1 <o3> + ^2 <o11> +)
    (<in93> ^1 <o11> + ^2 <o3> +)
    (<in94> ^1 <o6> + ^2 <o10> +)
    (<in95> ^1 <o10> + ^2 <o6> +)
    (<in96> ^1 <o9> + ^2 <o11> +)
    (<in97> ^1 <o11> + ^2 <o9> +)
    (<in98> ^1 <o12> + ^2 <o6> +)
    (<in99> ^1 <o6> + ^2 <o12> +)
    (<in100> ^1 <o16> + ^2 <o9> +)
    (<in101> ^1 <o9> + ^2 <o16> +)
    (<in102> ^1 <o12> + ^2 <o15> +)
    (<in103> ^1 <o15> + ^2 <o12> +)
    (<in104> ^1 <o14> + ^2 <o9> +)
    (<in105> ^1 <o9> + ^2 <o14> +)
    (<in106> ^1 <o8> + ^2 <o15> +)
    (<in107> ^1 <o15> + ^2 <o8> +)
    (<in108> ^1 <o14> + ^2 <o7> +)
    (<in109> ^1 <o7> + ^2 <o14> +)
    (<in110> ^1 <o13> + ^2 <o8> +)
    (<in111> ^1 <o8> + ^2 <o13> +)
}

sp {dialog-event*apply*game-state-change-respond*init-familycross
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-familycross)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^shape bank1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^shape bank1 +
           ^name destination1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category block + ^shape adult1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^shape adult1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^shape child1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^shape child1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^shape boat1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> +)
    (<in0> ^1 <o3> + ^2 <o1> +)
    (<in1> ^1 <o4> + ^2 <o1> +)
    (<in2> ^1 <o5> + ^2 <o1> +)
    (<in3> ^1 <o6> + ^2 <o1> +)
    (<in4> ^1 <o7> + ^2 <o1> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in5> +
           ^instance <in6> + ^instance <in7> + ^instance <in8> +
           ^instance <in9> +)
    (<in5> ^1 <o1> + ^2 <o3> +)
    (<in6> ^1 <o1> + ^2 <o4> +)
    (<in7> ^1 <o1> + ^2 <o5> +)
    (<in8> ^1 <o1> + ^2 <o6> +)
    (<in9> ^1 <o1> + ^2 <o7> +)
}

sp {dialog-event*apply*game-state-change-respond*final-i8puzzle
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-i8puzzle)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> + ^object <o17> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <near1> +
           ^predicate <diagonal-with1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^value 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^value 2 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^value 3 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^value 4 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^value 5 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^value 6 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^value 7 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^value 8 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block + ^value 1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block + ^value 2 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category block + ^value 3 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block + ^value 4 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category block + ^value 5 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category block + ^value 6 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category block + ^value 7 +)
    (<o17> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category block + ^value 8 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +
           ^instance <in7> +)
    (<in0> ^1 <o10> + ^2 <o1> +)
    (<in1> ^1 <o11> + ^2 <o2> +)
    (<in2> ^1 <o12> + ^2 <o4> +)
    (<in3> ^1 <o13> + ^2 <o5> +)
    (<in4> ^1 <o14> + ^2 <o6> +)
    (<in5> ^1 <o15> + ^2 <o7> +)
    (<in6> ^1 <o16> + ^2 <o8> +)
    (<in7> ^1 <o17> + ^2 <o9> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +
           ^instance <in12> + ^instance <in13> + ^instance <in14> +
           ^instance <in15> +)
    (<in8> ^1 <o1> + ^2 <o10> +)
    (<in9> ^1 <o2> + ^2 <o11> +)
    (<in10> ^1 <o4> + ^2 <o12> +)
    (<in11> ^1 <o5> + ^2 <o13> +)
    (<in12> ^1 <o6> + ^2 <o14> +)
    (<in13> ^1 <o7> + ^2 <o15> +)
    (<in14> ^1 <o8> + ^2 <o16> +)
    (<in15> ^1 <o9> + ^2 <o17> +)
    (<near1> ^item-type predicate + ^handle near1 + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> + ^instance <in25> +
           ^instance <in26> + ^instance <in27> + ^instance <in28> +
           ^instance <in29> + ^instance <in30> + ^instance <in31> +
           ^instance <in32> + ^instance <in33> + ^instance <in34> +
           ^instance <in35> + ^instance <in36> + ^instance <in37> +
           ^instance <in38> + ^instance <in39> + ^instance <in40> +
           ^instance <in41> + ^instance <in42> + ^instance <in43> +
           ^instance <in44> + ^instance <in45> + ^instance <in46> +
           ^instance <in47> + ^instance <in48> + ^instance <in49> +
           ^instance <in50> + ^instance <in51> + ^instance <in52> +
           ^instance <in53> + ^instance <in54> + ^instance <in55> +)
    (<in16> ^1 <o1> + ^2 <o2> +)
    (<in17> ^1 <o1> + ^2 <o4> +)
    (<in18> ^1 <o1> + ^2 <o5> +)
    (<in19> ^1 <o2> + ^2 <o1> +)
    (<in20> ^1 <o2> + ^2 <o3> +)
    (<in21> ^1 <o2> + ^2 <o4> +)
    (<in22> ^1 <o2> + ^2 <o5> +)
    (<in23> ^1 <o2> + ^2 <o6> +)
    (<in24> ^1 <o3> + ^2 <o2> +)
    (<in25> ^1 <o3> + ^2 <o5> +)
    (<in26> ^1 <o3> + ^2 <o6> +)
    (<in27> ^1 <o4> + ^2 <o1> +)
    (<in28> ^1 <o4> + ^2 <o2> +)
    (<in29> ^1 <o4> + ^2 <o5> +)
    (<in30> ^1 <o4> + ^2 <o7> +)
    (<in31> ^1 <o4> + ^2 <o8> +)
    (<in32> ^1 <o5> + ^2 <o1> +)
    (<in33> ^1 <o5> + ^2 <o2> +)
    (<in34> ^1 <o5> + ^2 <o3> +)
    (<in35> ^1 <o5> + ^2 <o4> +)
    (<in36> ^1 <o5> + ^2 <o6> +)
    (<in37> ^1 <o5> + ^2 <o7> +)
    (<in38> ^1 <o5> + ^2 <o8> +)
    (<in39> ^1 <o5> + ^2 <o9> +)
    (<in40> ^1 <o6> + ^2 <o2> +)
    (<in41> ^1 <o6> + ^2 <o3> +)
    (<in42> ^1 <o6> + ^2 <o5> +)
    (<in43> ^1 <o6> + ^2 <o8> +)
    (<in44> ^1 <o6> + ^2 <o9> +)
    (<in45> ^1 <o7> + ^2 <o4> +)
    (<in46> ^1 <o7> + ^2 <o5> +)
    (<in47> ^1 <o7> + ^2 <o8> +)
    (<in48> ^1 <o8> + ^2 <o7> +)
    (<in49> ^1 <o8> + ^2 <o4> +)
    (<in50> ^1 <o8> + ^2 <o5> +)
    (<in51> ^1 <o8> + ^2 <o6> +)
    (<in52> ^1 <o8> + ^2 <o9> +)
    (<in53> ^1 <o9> + ^2 <o8> +)
    (<in54> ^1 <o9> + ^2 <o5> +)
    (<in55> ^1 <o9> + ^2 <o6> +)
    (<diagonal-with1> ^item-type predicate + ^handle diagonal-with1 +
           ^instance <in56> + ^instance <in57> + ^instance <in58> +
           ^instance <in59> + ^instance <in60> + ^instance <in61> +
           ^instance <in62> + ^instance <in63> + ^instance <in64> +
           ^instance <in65> + ^instance <in66> + ^instance <in67> +
           ^instance <in68> + ^instance <in69> + ^instance <in70> +
           ^instance <in71> +)
    (<in56> ^1 <o1> + ^2 <o5> +)
    (<in57> ^1 <o2> + ^2 <o4> +)
    (<in58> ^1 <o2> + ^2 <o6> +)
    (<in59> ^1 <o3> + ^2 <o5> +)
    (<in60> ^1 <o4> + ^2 <o2> +)
    (<in61> ^1 <o4> + ^2 <o8> +)
    (<in62> ^1 <o5> + ^2 <o1> +)
    (<in63> ^1 <o5> + ^2 <o3> +)
    (<in64> ^1 <o5> + ^2 <o7> +)
    (<in65> ^1 <o5> + ^2 <o9> +)
    (<in66> ^1 <o6> + ^2 <o2> +)
    (<in67> ^1 <o6> + ^2 <o8> +)
    (<in68> ^1 <o7> + ^2 <o5> +)
    (<in69> ^1 <o8> + ^2 <o4> +)
    (<in70> ^1 <o8> + ^2 <o6> +)
    (<in71> ^1 <o9> + ^2 <o5> +)
}

sp {dialog-event*apply*game-state-change-respond*init-8puzzle
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-8puzzle)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> + ^object <o17> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <near1> +
           ^predicate <diagonal-with1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color red1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color orange1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^color yellow1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^color green1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^color blue1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^color purple1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^color gray1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^color brown1 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block + ^color red1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block + ^color orange1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category block + ^color yellow1 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block + ^color green1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category block + ^color blue1 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category block + ^color purple1 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category block + ^color gray1 +)
    (<o17> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category block + ^color brown1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +
           ^instance <in7> +)
    (<in0> ^1 <o10> + ^2 <o2> +)
    (<in1> ^1 <o11> + ^2 <o3> +)
    (<in2> ^1 <o12> + ^2 <o1> +)
    (<in3> ^1 <o13> + ^2 <o5> +)
    (<in4> ^1 <o14> + ^2 <o6> +)
    (<in5> ^1 <o15> + ^2 <o7> +)
    (<in6> ^1 <o16> + ^2 <o8> +)
    (<in7> ^1 <o17> + ^2 <o9> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +
           ^instance <in12> + ^instance <in13> + ^instance <in14> +
           ^instance <in15> +)
    (<in8> ^1 <o2> + ^2 <o10> +)
    (<in9> ^1 <o3> + ^2 <o11> +)
    (<in10> ^1 <o1> + ^2 <o12> +)
    (<in11> ^1 <o5> + ^2 <o13> +)
    (<in12> ^1 <o6> + ^2 <o14> +)
    (<in13> ^1 <o7> + ^2 <o15> +)
    (<in14> ^1 <o8> + ^2 <o16> +)
    (<in15> ^1 <o9> + ^2 <o17> +)
    (<near1> ^item-type predicate + ^handle near1 + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> + ^instance <in25> +
           ^instance <in26> + ^instance <in27> + ^instance <in28> +
           ^instance <in29> + ^instance <in30> + ^instance <in31> +
           ^instance <in32> + ^instance <in33> + ^instance <in34> +
           ^instance <in35> + ^instance <in36> + ^instance <in37> +
           ^instance <in38> + ^instance <in39> + ^instance <in40> +
           ^instance <in41> + ^instance <in42> + ^instance <in43> +
           ^instance <in44> + ^instance <in45> + ^instance <in46> +
           ^instance <in47> + ^instance <in48> + ^instance <in49> +
           ^instance <in50> + ^instance <in51> + ^instance <in52> +
           ^instance <in53> + ^instance <in54> + ^instance <in55> +)
    (<in16> ^1 <o1> + ^2 <o2> +)
    (<in17> ^1 <o1> + ^2 <o4> +)
    (<in18> ^1 <o1> + ^2 <o5> +)
    (<in19> ^1 <o2> + ^2 <o1> +)
    (<in20> ^1 <o2> + ^2 <o3> +)
    (<in21> ^1 <o2> + ^2 <o4> +)
    (<in22> ^1 <o2> + ^2 <o5> +)
    (<in23> ^1 <o2> + ^2 <o6> +)
    (<in24> ^1 <o3> + ^2 <o2> +)
    (<in25> ^1 <o3> + ^2 <o5> +)
    (<in26> ^1 <o3> + ^2 <o6> +)
    (<in27> ^1 <o4> + ^2 <o1> +)
    (<in28> ^1 <o4> + ^2 <o2> +)
    (<in29> ^1 <o4> + ^2 <o5> +)
    (<in30> ^1 <o4> + ^2 <o7> +)
    (<in31> ^1 <o4> + ^2 <o8> +)
    (<in32> ^1 <o5> + ^2 <o1> +)
    (<in33> ^1 <o5> + ^2 <o2> +)
    (<in34> ^1 <o5> + ^2 <o3> +)
    (<in35> ^1 <o5> + ^2 <o4> +)
    (<in36> ^1 <o5> + ^2 <o6> +)
    (<in37> ^1 <o5> + ^2 <o7> +)
    (<in38> ^1 <o5> + ^2 <o8> +)
    (<in39> ^1 <o5> + ^2 <o9> +)
    (<in40> ^1 <o6> + ^2 <o2> +)
    (<in41> ^1 <o6> + ^2 <o3> +)
    (<in42> ^1 <o6> + ^2 <o5> +)
    (<in43> ^1 <o6> + ^2 <o8> +)
    (<in44> ^1 <o6> + ^2 <o9> +)
    (<in45> ^1 <o7> + ^2 <o4> +)
    (<in46> ^1 <o7> + ^2 <o5> +)
    (<in47> ^1 <o7> + ^2 <o8> +)
    (<in48> ^1 <o8> + ^2 <o7> +)
    (<in49> ^1 <o8> + ^2 <o4> +)
    (<in50> ^1 <o8> + ^2 <o5> +)
    (<in51> ^1 <o8> + ^2 <o6> +)
    (<in52> ^1 <o8> + ^2 <o9> +)
    (<in53> ^1 <o9> + ^2 <o8> +)
    (<in54> ^1 <o9> + ^2 <o5> +)
    (<in55> ^1 <o9> + ^2 <o6> +)
    (<diagonal-with1> ^item-type predicate + ^handle diagonal-with1 +
           ^instance <in56> + ^instance <in57> + ^instance <in58> +
           ^instance <in59> + ^instance <in60> + ^instance <in61> +
           ^instance <in62> + ^instance <in63> + ^instance <in64> +
           ^instance <in65> + ^instance <in66> + ^instance <in67> +
           ^instance <in68> + ^instance <in69> + ^instance <in70> +
           ^instance <in71> +)
    (<in56> ^1 <o1> + ^2 <o5> +)
    (<in57> ^1 <o2> + ^2 <o4> +)
    (<in58> ^1 <o2> + ^2 <o6> +)
    (<in59> ^1 <o3> + ^2 <o5> +)
    (<in60> ^1 <o4> + ^2 <o2> +)
    (<in61> ^1 <o4> + ^2 <o8> +)
    (<in62> ^1 <o5> + ^2 <o1> +)
    (<in63> ^1 <o5> + ^2 <o3> +)
    (<in64> ^1 <o5> + ^2 <o7> +)
    (<in65> ^1 <o5> + ^2 <o9> +)
    (<in66> ^1 <o6> + ^2 <o2> +)
    (<in67> ^1 <o6> + ^2 <o8> +)
    (<in68> ^1 <o7> + ^2 <o5> +)
    (<in69> ^1 <o8> + ^2 <o4> +)
    (<in70> ^1 <o8> + ^2 <o6> +)
    (<in71> ^1 <o9> + ^2 <o5> +)
}

sp {dialog-event*apply*game-state-change-respond*init-breakthrough
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-breakthrough)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> + ^object <o17> + ^object <o18> + ^object <o19> +
           ^object <o20> + ^object <o21> + ^object <o22> + ^object <o23> +
           ^object <o24> + ^object <o25> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <above1> +
           ^predicate <under1> + ^predicate <diagonal-with1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color blue1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color blue1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^color blue1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^color blue1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category location + ^color red1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category location + ^color red1 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category location + ^color red1 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category location + ^color red1 +)
    (<o17> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category block + ^color red1 +)
    (<o18> ^item-type object + ^handle object-17 + ^predicates <pr17> +)
    (<pr17> ^visible true + ^category block + ^color red1 +)
    (<o19> ^item-type object + ^handle object-18 + ^predicates <pr18> +)
    (<pr18> ^visible true + ^category block + ^color red1 +)
    (<o20> ^item-type object + ^handle object-19 + ^predicates <pr19> +)
    (<pr19> ^visible true + ^category block + ^color red1 +)
    (<o21> ^item-type object + ^handle object-20 + ^predicates <pr20> +)
    (<pr20> ^visible true + ^category block + ^color blue1 +)
    (<o22> ^item-type object + ^handle object-21 + ^predicates <pr21> +)
    (<pr21> ^visible true + ^category block + ^color blue1 +)
    (<o23> ^item-type object + ^handle object-22 + ^predicates <pr22> +)
    (<pr22> ^visible true + ^category block + ^color blue1 +)
    (<o24> ^item-type object + ^handle object-23 + ^predicates <pr23> +)
    (<pr23> ^visible true + ^category block + ^color blue1 +)
    (<o25> ^item-type object + ^handle object-24 + ^predicates <pr24> +)
    (<pr24> ^visible true + ^category location + ^name garbage +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +
           ^instance <in7> +)
    (<in0> ^1 <o17> + ^2 <o1> +)
    (<in1> ^1 <o18> + ^2 <o2> +)
    (<in2> ^1 <o19> + ^2 <o3> +)
    (<in3> ^1 <o20> + ^2 <o10> +)
    (<in4> ^1 <o21> + ^2 <o13> +)
    (<in5> ^1 <o22> + ^2 <o14> +)
    (<in6> ^1 <o23> + ^2 <o15> +)
    (<in7> ^1 <o24> + ^2 <o16> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +
           ^instance <in12> + ^instance <in13> + ^instance <in14> +
           ^instance <in15> +)
    (<in8> ^1 <o1> + ^2 <o17> +)
    (<in9> ^1 <o2> + ^2 <o18> +)
    (<in10> ^1 <o3> + ^2 <o19> +)
    (<in11> ^1 <o10> + ^2 <o20> +)
    (<in12> ^1 <o13> + ^2 <o21> +)
    (<in13> ^1 <o14> + ^2 <o22> +)
    (<in14> ^1 <o15> + ^2 <o23> +)
    (<in15> ^1 <o16> + ^2 <o24> +)
    (<above1> ^item-type predicate + ^handle above1 + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> + ^instance <in25> +
           ^instance <in26> + ^instance <in27> + ^instance <in28> +
           ^instance <in29> + ^instance <in30> + ^instance <in31> +
           ^instance <in32> + ^instance <in33> + ^instance <in34> +
           ^instance <in35> + ^instance <in36> + ^instance <in37> +
           ^instance <in38> + ^instance <in39> + ^instance <in40> +
           ^instance <in41> + ^instance <in42> + ^instance <in43> +
           ^instance <in44> + ^instance <in45> +)
    (<in16> ^1 <o13> + ^2 <o7> +)
    (<in17> ^1 <o14> + ^2 <o7> +)
    (<in18> ^1 <o13> + ^2 <o8> +)
    (<in19> ^1 <o14> + ^2 <o8> +)
    (<in20> ^1 <o15> + ^2 <o8> +)
    (<in21> ^1 <o14> + ^2 <o9> +)
    (<in22> ^1 <o15> + ^2 <o9> +)
    (<in23> ^1 <o16> + ^2 <o9> +)
    (<in24> ^1 <o15> + ^2 <o12> +)
    (<in25> ^1 <o16> + ^2 <o12> +)
    (<in26> ^1 <o7> + ^2 <o4> +)
    (<in27> ^1 <o8> + ^2 <o4> +)
    (<in28> ^1 <o7> + ^2 <o5> +)
    (<in29> ^1 <o8> + ^2 <o5> +)
    (<in30> ^1 <o9> + ^2 <o5> +)
    (<in31> ^1 <o8> + ^2 <o6> +)
    (<in32> ^1 <o9> + ^2 <o6> +)
    (<in33> ^1 <o12> + ^2 <o6> +)
    (<in34> ^1 <o9> + ^2 <o11> +)
    (<in35> ^1 <o12> + ^2 <o11> +)
    (<in36> ^1 <o4> + ^2 <o1> +)
    (<in37> ^1 <o5> + ^2 <o1> +)
    (<in38> ^1 <o4> + ^2 <o2> +)
    (<in39> ^1 <o5> + ^2 <o2> +)
    (<in40> ^1 <o6> + ^2 <o2> +)
    (<in41> ^1 <o5> + ^2 <o3> +)
    (<in42> ^1 <o6> + ^2 <o3> +)
    (<in43> ^1 <o11> + ^2 <o3> +)
    (<in44> ^1 <o6> + ^2 <o10> +)
    (<in45> ^1 <o11> + ^2 <o10> +)
    (<under1> ^item-type predicate + ^handle under1 + ^instance <in46> +
           ^instance <in47> + ^instance <in48> + ^instance <in49> +
           ^instance <in50> + ^instance <in51> + ^instance <in52> +
           ^instance <in53> + ^instance <in54> + ^instance <in55> +
           ^instance <in56> + ^instance <in57> + ^instance <in58> +
           ^instance <in59> + ^instance <in60> + ^instance <in61> +
           ^instance <in62> + ^instance <in63> + ^instance <in64> +
           ^instance <in65> + ^instance <in66> + ^instance <in67> +
           ^instance <in68> + ^instance <in69> + ^instance <in70> +
           ^instance <in71> + ^instance <in72> + ^instance <in73> +
           ^instance <in74> + ^instance <in75> +)
    (<in46> ^1 <o7> + ^2 <o13> +)
    (<in47> ^1 <o7> + ^2 <o14> +)
    (<in48> ^1 <o8> + ^2 <o13> +)
    (<in49> ^1 <o8> + ^2 <o14> +)
    (<in50> ^1 <o8> + ^2 <o15> +)
    (<in51> ^1 <o9> + ^2 <o14> +)
    (<in52> ^1 <o9> + ^2 <o15> +)
    (<in53> ^1 <o9> + ^2 <o16> +)
    (<in54> ^1 <o12> + ^2 <o15> +)
    (<in55> ^1 <o12> + ^2 <o16> +)
    (<in56> ^1 <o4> + ^2 <o7> +)
    (<in57> ^1 <o4> + ^2 <o8> +)
    (<in58> ^1 <o5> + ^2 <o7> +)
    (<in59> ^1 <o5> + ^2 <o8> +)
    (<in60> ^1 <o5> + ^2 <o9> +)
    (<in61> ^1 <o6> + ^2 <o8> +)
    (<in62> ^1 <o6> + ^2 <o9> +)
    (<in63> ^1 <o6> + ^2 <o12> +)
    (<in64> ^1 <o11> + ^2 <o9> +)
    (<in65> ^1 <o11> + ^2 <o12> +)
    (<in66> ^1 <o1> + ^2 <o4> +)
    (<in67> ^1 <o1> + ^2 <o5> +)
    (<in68> ^1 <o2> + ^2 <o4> +)
    (<in69> ^1 <o2> + ^2 <o5> +)
    (<in70> ^1 <o2> + ^2 <o6> +)
    (<in71> ^1 <o3> + ^2 <o5> +)
    (<in72> ^1 <o3> + ^2 <o6> +)
    (<in73> ^1 <o3> + ^2 <o11> +)
    (<in74> ^1 <o10> + ^2 <o6> +)
    (<in75> ^1 <o10> + ^2 <o11> +)
    (<diagonal-with1> ^item-type predicate + ^handle diagonal-with1 +
           ^instance <in76> + ^instance <in77> + ^instance <in78> +
           ^instance <in79> + ^instance <in80> + ^instance <in81> +
           ^instance <in82> + ^instance <in83> + ^instance <in84> +
           ^instance <in85> + ^instance <in86> + ^instance <in87> +
           ^instance <in88> + ^instance <in89> + ^instance <in90> +
           ^instance <in91> + ^instance <in92> + ^instance <in93> +
           ^instance <in94> + ^instance <in95> + ^instance <in96> +
           ^instance <in97> + ^instance <in98> + ^instance <in99> +
           ^instance <in100> + ^instance <in101> + ^instance <in102> +
           ^instance <in103> + ^instance <in104> + ^instance <in105> +
           ^instance <in106> + ^instance <in107> + ^instance <in108> +
           ^instance <in109> + ^instance <in110> + ^instance <in111> +)
    (<in76> ^1 <o1> + ^2 <o5> +)
    (<in77> ^1 <o2> + ^2 <o4> +)
    (<in78> ^1 <o2> + ^2 <o6> +)
    (<in79> ^1 <o3> + ^2 <o5> +)
    (<in80> ^1 <o4> + ^2 <o2> +)
    (<in81> ^1 <o4> + ^2 <o8> +)
    (<in82> ^1 <o5> + ^2 <o1> +)
    (<in83> ^1 <o5> + ^2 <o3> +)
    (<in84> ^1 <o5> + ^2 <o7> +)
    (<in85> ^1 <o5> + ^2 <o9> +)
    (<in86> ^1 <o6> + ^2 <o2> +)
    (<in87> ^1 <o6> + ^2 <o8> +)
    (<in88> ^1 <o7> + ^2 <o5> +)
    (<in89> ^1 <o8> + ^2 <o4> +)
    (<in90> ^1 <o8> + ^2 <o6> +)
    (<in91> ^1 <o9> + ^2 <o5> +)
    (<in92> ^1 <o3> + ^2 <o11> +)
    (<in93> ^1 <o11> + ^2 <o3> +)
    (<in94> ^1 <o6> + ^2 <o10> +)
    (<in95> ^1 <o10> + ^2 <o6> +)
    (<in96> ^1 <o9> + ^2 <o11> +)
    (<in97> ^1 <o11> + ^2 <o9> +)
    (<in98> ^1 <o12> + ^2 <o6> +)
    (<in99> ^1 <o6> + ^2 <o12> +)
    (<in100> ^1 <o16> + ^2 <o9> +)
    (<in101> ^1 <o9> + ^2 <o16> +)
    (<in102> ^1 <o12> + ^2 <o15> +)
    (<in103> ^1 <o15> + ^2 <o12> +)
    (<in104> ^1 <o14> + ^2 <o9> +)
    (<in105> ^1 <o9> + ^2 <o14> +)
    (<in106> ^1 <o8> + ^2 <o15> +)
    (<in107> ^1 <o15> + ^2 <o8> +)
    (<in108> ^1 <o14> + ^2 <o7> +)
    (<in109> ^1 <o7> + ^2 <o14> +)
    (<in110> ^1 <o13> + ^2 <o8> +)
    (<in111> ^1 <o8> + ^2 <o13> +)
}

sp {dialog-event*apply*game-state-change-respond*init-peg2
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-peg2)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> + ^object <o17> + ^object <o18> + ^object <o19> +
           ^object <o20> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^x 2 + ^y 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^x 3 + ^y 1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^x 4 + ^y 1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^x 2 + ^y 2 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^x 3 + ^y 2 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^x 2 + ^y 3 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^x 2 + ^y 0 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^x 3 + ^y 0 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^x 4 + ^y 0 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^x 5 + ^y 0 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category block +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category block +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category block +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category block +)
    (<o17> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category block +)
    (<o18> ^item-type object + ^handle object-17 + ^predicates <pr17> +)
    (<pr17> ^visible true + ^category block +)
    (<o19> ^item-type object + ^handle object-18 + ^predicates <pr18> +)
    (<pr18> ^visible true + ^category block +)
    (<o20> ^item-type object + ^handle object-19 + ^predicates <pr19> +)
    (<pr19> ^visible true + ^category object + ^name garbage +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +
           ^instance <in7> + ^instance <in8> +)
    (<in0> ^1 <o11> + ^2 <o1> +)
    (<in1> ^1 <o12> + ^2 <o2> +)
    (<in2> ^1 <o13> + ^2 <o3> +)
    (<in3> ^1 <o14> + ^2 <o4> +)
    (<in4> ^1 <o15> + ^2 <o6> +)
    (<in5> ^1 <o16> + ^2 <o7> +)
    (<in6> ^1 <o17> + ^2 <o8> +)
    (<in7> ^1 <o18> + ^2 <o9> +)
    (<in8> ^1 <o19> + ^2 <o10> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in9> +
           ^instance <in10> + ^instance <in11> + ^instance <in12> +
           ^instance <in13> + ^instance <in14> + ^instance <in15> +
           ^instance <in16> + ^instance <in17> +)
    (<in9> ^1 <o1> + ^2 <o11> +)
    (<in10> ^1 <o2> + ^2 <o12> +)
    (<in11> ^1 <o3> + ^2 <o13> +)
    (<in12> ^1 <o4> + ^2 <o14> +)
    (<in13> ^1 <o6> + ^2 <o15> +)
    (<in14> ^1 <o7> + ^2 <o16> +)
    (<in15> ^1 <o8> + ^2 <o17> +)
    (<in16> ^1 <o9> + ^2 <o18> +)
    (<in17> ^1 <o10> + ^2 <o19> +)
}

sp {dialog-event*apply*game-state-change-respond*init-8puzzle6alt
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-8puzzle6alt)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> + ^object <o17> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <near1> +
           ^predicate <diagonal-with1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color red1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color orange1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^color yellow1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^color green1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^color blue1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^color purple1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^color gray1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^color brown1 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block + ^color red1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block + ^color orange1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category block + ^color yellow1 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block + ^color green1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category block + ^color blue1 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category block + ^color purple1 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category block + ^color gray1 +)
    (<o17> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category block + ^color brown1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +
           ^instance <in7> +)
    (<in0> ^1 <o10> + ^2 <o5> +)
    (<in1> ^1 <o11> + ^2 <o3> +)
    (<in2> ^1 <o12> + ^2 <o1> +)
    (<in3> ^1 <o13> + ^2 <o4> +)
    (<in4> ^1 <o14> + ^2 <o6> +)
    (<in5> ^1 <o15> + ^2 <o7> +)
    (<in6> ^1 <o16> + ^2 <o8> +)
    (<in7> ^1 <o17> + ^2 <o9> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +
           ^instance <in12> + ^instance <in13> + ^instance <in14> +
           ^instance <in15> +)
    (<in8> ^1 <o5> + ^2 <o10> +)
    (<in9> ^1 <o3> + ^2 <o11> +)
    (<in10> ^1 <o1> + ^2 <o12> +)
    (<in11> ^1 <o4> + ^2 <o13> +)
    (<in12> ^1 <o6> + ^2 <o14> +)
    (<in13> ^1 <o7> + ^2 <o15> +)
    (<in14> ^1 <o8> + ^2 <o16> +)
    (<in15> ^1 <o9> + ^2 <o17> +)
    (<near1> ^item-type predicate + ^handle near1 + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> + ^instance <in25> +
           ^instance <in26> + ^instance <in27> + ^instance <in28> +
           ^instance <in29> + ^instance <in30> + ^instance <in31> +
           ^instance <in32> + ^instance <in33> + ^instance <in34> +
           ^instance <in35> + ^instance <in36> + ^instance <in37> +
           ^instance <in38> + ^instance <in39> + ^instance <in40> +
           ^instance <in41> + ^instance <in42> + ^instance <in43> +
           ^instance <in44> + ^instance <in45> + ^instance <in46> +
           ^instance <in47> + ^instance <in48> + ^instance <in49> +
           ^instance <in50> + ^instance <in51> + ^instance <in52> +
           ^instance <in53> + ^instance <in54> + ^instance <in55> +)
    (<in16> ^1 <o1> + ^2 <o2> +)
    (<in17> ^1 <o1> + ^2 <o4> +)
    (<in18> ^1 <o1> + ^2 <o5> +)
    (<in19> ^1 <o2> + ^2 <o1> +)
    (<in20> ^1 <o2> + ^2 <o3> +)
    (<in21> ^1 <o2> + ^2 <o4> +)
    (<in22> ^1 <o2> + ^2 <o5> +)
    (<in23> ^1 <o2> + ^2 <o6> +)
    (<in24> ^1 <o3> + ^2 <o2> +)
    (<in25> ^1 <o3> + ^2 <o5> +)
    (<in26> ^1 <o3> + ^2 <o6> +)
    (<in27> ^1 <o4> + ^2 <o1> +)
    (<in28> ^1 <o4> + ^2 <o2> +)
    (<in29> ^1 <o4> + ^2 <o5> +)
    (<in30> ^1 <o4> + ^2 <o7> +)
    (<in31> ^1 <o4> + ^2 <o8> +)
    (<in32> ^1 <o5> + ^2 <o1> +)
    (<in33> ^1 <o5> + ^2 <o2> +)
    (<in34> ^1 <o5> + ^2 <o3> +)
    (<in35> ^1 <o5> + ^2 <o4> +)
    (<in36> ^1 <o5> + ^2 <o6> +)
    (<in37> ^1 <o5> + ^2 <o7> +)
    (<in38> ^1 <o5> + ^2 <o8> +)
    (<in39> ^1 <o5> + ^2 <o9> +)
    (<in40> ^1 <o6> + ^2 <o2> +)
    (<in41> ^1 <o6> + ^2 <o3> +)
    (<in42> ^1 <o6> + ^2 <o5> +)
    (<in43> ^1 <o6> + ^2 <o8> +)
    (<in44> ^1 <o6> + ^2 <o9> +)
    (<in45> ^1 <o7> + ^2 <o4> +)
    (<in46> ^1 <o7> + ^2 <o5> +)
    (<in47> ^1 <o7> + ^2 <o8> +)
    (<in48> ^1 <o8> + ^2 <o7> +)
    (<in49> ^1 <o8> + ^2 <o4> +)
    (<in50> ^1 <o8> + ^2 <o5> +)
    (<in51> ^1 <o8> + ^2 <o6> +)
    (<in52> ^1 <o8> + ^2 <o9> +)
    (<in53> ^1 <o9> + ^2 <o8> +)
    (<in54> ^1 <o9> + ^2 <o5> +)
    (<in55> ^1 <o9> + ^2 <o6> +)
    (<diagonal-with1> ^item-type predicate + ^handle diagonal-with1 +
           ^instance <in56> + ^instance <in57> + ^instance <in58> +
           ^instance <in59> + ^instance <in60> + ^instance <in61> +
           ^instance <in62> + ^instance <in63> + ^instance <in64> +
           ^instance <in65> + ^instance <in66> + ^instance <in67> +
           ^instance <in68> + ^instance <in69> + ^instance <in70> +
           ^instance <in71> +)
    (<in56> ^1 <o1> + ^2 <o5> +)
    (<in57> ^1 <o2> + ^2 <o4> +)
    (<in58> ^1 <o2> + ^2 <o6> +)
    (<in59> ^1 <o3> + ^2 <o5> +)
    (<in60> ^1 <o4> + ^2 <o2> +)
    (<in61> ^1 <o4> + ^2 <o8> +)
    (<in62> ^1 <o5> + ^2 <o1> +)
    (<in63> ^1 <o5> + ^2 <o3> +)
    (<in64> ^1 <o5> + ^2 <o7> +)
    (<in65> ^1 <o5> + ^2 <o9> +)
    (<in66> ^1 <o6> + ^2 <o2> +)
    (<in67> ^1 <o6> + ^2 <o8> +)
    (<in68> ^1 <o7> + ^2 <o5> +)
    (<in69> ^1 <o8> + ^2 <o4> +)
    (<in70> ^1 <o8> + ^2 <o6> +)
    (<in71> ^1 <o9> + ^2 <o5> +)
}

sp {dialog-event*apply*game-state-change-respond*final-stacked-frogs
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-stacked-frogs)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^x 1 + ^y 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^x 2 + ^y 1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^x 3 + ^y 1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^x 4 + ^y 1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +)
    (<in0> ^1 <o5> + ^2 <o1> +)
    (<in1> ^1 <o6> + ^2 <o1> +)
    (<in2> ^1 <o7> + ^2 <o1> +)
    (<in3> ^1 <o8> + ^2 <o1> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in4> +
           ^instance <in5> + ^instance <in6> + ^instance <in7> +)
    (<in4> ^1 <o1> + ^2 <o5> +)
    (<in5> ^1 <o1> + ^2 <o6> +)
    (<in6> ^1 <o1> + ^2 <o7> +)
    (<in7> ^1 <o1> + ^2 <o8> +)
}

sp {dialog-event*apply*game-state-change-respond*final-i15puzzle
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-i15puzzle)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> + ^object <o17> + ^object <o18> + ^object <o19> +
           ^object <o20> + ^object <o21> + ^object <o22> + ^object <o23> +
           ^object <o24> + ^object <o25> + ^object <o26> + ^object <o27> +
           ^object <o28> + ^object <o29> + ^object <o30> + ^object <o31> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <near1> +
           ^predicate <diagonal-with1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^value 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^value 2 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^value 3 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^value 4 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^value 5 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^value 6 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^value 7 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^value 8 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^value 9 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^value 10 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location + ^value 11 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location + ^value 12 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category location + ^value 13 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category location + ^value 14 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category location + ^value 15 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category location + ^value 16 +)
    (<o17> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category block + ^value 1 +)
    (<o18> ^item-type object + ^handle object-17 + ^predicates <pr17> +)
    (<pr17> ^visible true + ^category block + ^value 2 +)
    (<o19> ^item-type object + ^handle object-18 + ^predicates <pr18> +)
    (<pr18> ^visible true + ^category block + ^value 3 +)
    (<o20> ^item-type object + ^handle object-19 + ^predicates <pr19> +)
    (<pr19> ^visible true + ^category block + ^value 4 +)
    (<o21> ^item-type object + ^handle object-20 + ^predicates <pr20> +)
    (<pr20> ^visible true + ^category block + ^value 5 +)
    (<o22> ^item-type object + ^handle object-21 + ^predicates <pr21> +)
    (<pr21> ^visible true + ^category block + ^value 6 +)
    (<o23> ^item-type object + ^handle object-22 + ^predicates <pr22> +)
    (<pr22> ^visible true + ^category block + ^value 7 +)
    (<o24> ^item-type object + ^handle object-23 + ^predicates <pr23> +)
    (<pr23> ^visible true + ^category block + ^value 8 +)
    (<o25> ^item-type object + ^handle object-24 + ^predicates <pr24> +)
    (<pr24> ^visible true + ^category block + ^value 9 +)
    (<o26> ^item-type object + ^handle object-25 + ^predicates <pr25> +)
    (<pr25> ^visible true + ^category block + ^value 16 +)
    (<o27> ^item-type object + ^handle object-26 + ^predicates <pr26> +)
    (<pr26> ^visible true + ^category block + ^value 11 +)
    (<o28> ^item-type object + ^handle object-27 + ^predicates <pr27> +)
    (<pr27> ^visible true + ^category block + ^value 12 +)
    (<o29> ^item-type object + ^handle object-28 + ^predicates <pr28> +)
    (<pr28> ^visible true + ^category block + ^value 13 +)
    (<o30> ^item-type object + ^handle object-29 + ^predicates <pr29> +)
    (<pr29> ^visible true + ^category block + ^value 14 +)
    (<o31> ^item-type object + ^handle object-30 + ^predicates <pr30> +)
    (<pr30> ^visible true + ^category block + ^value 15 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +
           ^instance <in7> + ^instance <in8> + ^instance <in9> +
           ^instance <in10> + ^instance <in11> + ^instance <in12> +
           ^instance <in13> + ^instance <in14> +)
    (<in0> ^1 <o17> + ^2 <o1> +)
    (<in1> ^1 <o18> + ^2 <o2> +)
    (<in2> ^1 <o19> + ^2 <o3> +)
    (<in3> ^1 <o20> + ^2 <o4> +)
    (<in4> ^1 <o21> + ^2 <o5> +)
    (<in5> ^1 <o22> + ^2 <o6> +)
    (<in6> ^1 <o23> + ^2 <o7> +)
    (<in7> ^1 <o24> + ^2 <o8> +)
    (<in8> ^1 <o25> + ^2 <o9> +)
    (<in9> ^1 <o26> + ^2 <o16> +)
    (<in10> ^1 <o27> + ^2 <o11> +)
    (<in11> ^1 <o28> + ^2 <o12> +)
    (<in12> ^1 <o29> + ^2 <o13> +)
    (<in13> ^1 <o30> + ^2 <o14> +)
    (<in14> ^1 <o31> + ^2 <o15> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in15> +
           ^instance <in16> + ^instance <in17> + ^instance <in18> +
           ^instance <in19> + ^instance <in20> + ^instance <in21> +
           ^instance <in22> + ^instance <in23> + ^instance <in24> +
           ^instance <in25> + ^instance <in26> + ^instance <in27> +
           ^instance <in28> + ^instance <in29> +)
    (<in15> ^1 <o1> + ^2 <o17> +)
    (<in16> ^1 <o2> + ^2 <o18> +)
    (<in17> ^1 <o3> + ^2 <o19> +)
    (<in18> ^1 <o4> + ^2 <o20> +)
    (<in19> ^1 <o5> + ^2 <o21> +)
    (<in20> ^1 <o6> + ^2 <o22> +)
    (<in21> ^1 <o7> + ^2 <o23> +)
    (<in22> ^1 <o8> + ^2 <o24> +)
    (<in23> ^1 <o9> + ^2 <o25> +)
    (<in24> ^1 <o16> + ^2 <o26> +)
    (<in25> ^1 <o11> + ^2 <o27> +)
    (<in26> ^1 <o12> + ^2 <o28> +)
    (<in27> ^1 <o13> + ^2 <o29> +)
    (<in28> ^1 <o14> + ^2 <o30> +)
    (<in29> ^1 <o15> + ^2 <o31> +)
    (<near1> ^item-type predicate + ^handle near1 + ^instance <in30> +
           ^instance <in31> + ^instance <in32> + ^instance <in33> +
           ^instance <in34> + ^instance <in35> + ^instance <in36> +
           ^instance <in37> + ^instance <in38> + ^instance <in39> +
           ^instance <in40> + ^instance <in41> + ^instance <in42> +
           ^instance <in43> + ^instance <in44> + ^instance <in45> +
           ^instance <in46> + ^instance <in47> + ^instance <in48> +
           ^instance <in49> + ^instance <in50> + ^instance <in51> +
           ^instance <in52> + ^instance <in53> + ^instance <in54> +
           ^instance <in55> + ^instance <in56> + ^instance <in57> +
           ^instance <in58> + ^instance <in59> + ^instance <in60> +
           ^instance <in61> + ^instance <in62> + ^instance <in63> +
           ^instance <in64> + ^instance <in65> + ^instance <in66> +
           ^instance <in67> + ^instance <in68> + ^instance <in69> +
           ^instance <in70> + ^instance <in71> + ^instance <in72> +
           ^instance <in73> + ^instance <in74> + ^instance <in75> +
           ^instance <in76> + ^instance <in77> + ^instance <in78> +
           ^instance <in79> + ^instance <in80> + ^instance <in81> +
           ^instance <in82> + ^instance <in83> + ^instance <in84> +
           ^instance <in85> + ^instance <in86> + ^instance <in87> +
           ^instance <in88> + ^instance <in89> + ^instance <in90> +
           ^instance <in91> + ^instance <in92> + ^instance <in93> +
           ^instance <in94> + ^instance <in95> + ^instance <in96> +
           ^instance <in97> + ^instance <in98> + ^instance <in99> +
           ^instance <in100> + ^instance <in101> + ^instance <in102> +
           ^instance <in103> + ^instance <in104> + ^instance <in105> +
           ^instance <in106> + ^instance <in107> + ^instance <in108> +
           ^instance <in109> + ^instance <in110> + ^instance <in111> +
           ^instance <in112> + ^instance <in113> +)
    (<in30> ^1 <o1> + ^2 <o2> +)
    (<in31> ^1 <o1> + ^2 <o4> +)
    (<in32> ^1 <o1> + ^2 <o5> +)
    (<in33> ^1 <o2> + ^2 <o1> +)
    (<in34> ^1 <o2> + ^2 <o3> +)
    (<in35> ^1 <o2> + ^2 <o4> +)
    (<in36> ^1 <o2> + ^2 <o5> +)
    (<in37> ^1 <o2> + ^2 <o6> +)
    (<in38> ^1 <o3> + ^2 <o2> +)
    (<in39> ^1 <o3> + ^2 <o5> +)
    (<in40> ^1 <o3> + ^2 <o6> +)
    (<in41> ^1 <o4> + ^2 <o1> +)
    (<in42> ^1 <o4> + ^2 <o2> +)
    (<in43> ^1 <o4> + ^2 <o5> +)
    (<in44> ^1 <o4> + ^2 <o7> +)
    (<in45> ^1 <o4> + ^2 <o8> +)
    (<in46> ^1 <o5> + ^2 <o1> +)
    (<in47> ^1 <o5> + ^2 <o2> +)
    (<in48> ^1 <o5> + ^2 <o3> +)
    (<in49> ^1 <o5> + ^2 <o4> +)
    (<in50> ^1 <o5> + ^2 <o6> +)
    (<in51> ^1 <o5> + ^2 <o7> +)
    (<in52> ^1 <o5> + ^2 <o8> +)
    (<in53> ^1 <o5> + ^2 <o9> +)
    (<in54> ^1 <o6> + ^2 <o2> +)
    (<in55> ^1 <o6> + ^2 <o3> +)
    (<in56> ^1 <o6> + ^2 <o5> +)
    (<in57> ^1 <o6> + ^2 <o8> +)
    (<in58> ^1 <o6> + ^2 <o9> +)
    (<in59> ^1 <o7> + ^2 <o4> +)
    (<in60> ^1 <o7> + ^2 <o5> +)
    (<in61> ^1 <o7> + ^2 <o8> +)
    (<in62> ^1 <o8> + ^2 <o7> +)
    (<in63> ^1 <o8> + ^2 <o4> +)
    (<in64> ^1 <o8> + ^2 <o5> +)
    (<in65> ^1 <o8> + ^2 <o6> +)
    (<in66> ^1 <o8> + ^2 <o9> +)
    (<in67> ^1 <o9> + ^2 <o8> +)
    (<in68> ^1 <o9> + ^2 <o5> +)
    (<in69> ^1 <o9> + ^2 <o6> +)
    (<in70> ^1 <o3> + ^2 <o10> +)
    (<in71> ^1 <o3> + ^2 <o11> +)
    (<in72> ^1 <o6> + ^2 <o10> +)
    (<in73> ^1 <o6> + ^2 <o11> +)
    (<in74> ^1 <o6> + ^2 <o12> +)
    (<in75> ^1 <o9> + ^2 <o11> +)
    (<in76> ^1 <o9> + ^2 <o12> +)
    (<in77> ^1 <o9> + ^2 <o16> +)
    (<in78> ^1 <o9> + ^2 <o15> +)
    (<in79> ^1 <o9> + ^2 <o14> +)
    (<in80> ^1 <o8> + ^2 <o13> +)
    (<in81> ^1 <o8> + ^2 <o14> +)
    (<in82> ^1 <o8> + ^2 <o15> +)
    (<in83> ^1 <o7> + ^2 <o13> +)
    (<in84> ^1 <o7> + ^2 <o14> +)
    (<in85> ^1 <o10> + ^2 <o3> +)
    (<in86> ^1 <o10> + ^2 <o6> +)
    (<in87> ^1 <o10> + ^2 <o11> +)
    (<in88> ^1 <o11> + ^2 <o10> +)
    (<in89> ^1 <o11> + ^2 <o3> +)
    (<in90> ^1 <o11> + ^2 <o6> +)
    (<in91> ^1 <o11> + ^2 <o9> +)
    (<in92> ^1 <o11> + ^2 <o12> +)
    (<in93> ^1 <o12> + ^2 <o11> +)
    (<in94> ^1 <o12> + ^2 <o6> +)
    (<in95> ^1 <o12> + ^2 <o9> +)
    (<in96> ^1 <o12> + ^2 <o15> +)
    (<in97> ^1 <o12> + ^2 <o16> +)
    (<in98> ^1 <o16> + ^2 <o12> +)
    (<in99> ^1 <o16> + ^2 <o9> +)
    (<in100> ^1 <o16> + ^2 <o15> +)
    (<in101> ^1 <o15> + ^2 <o16> +)
    (<in102> ^1 <o15> + ^2 <o12> +)
    (<in103> ^1 <o15> + ^2 <o9> +)
    (<in104> ^1 <o15> + ^2 <o8> +)
    (<in105> ^1 <o15> + ^2 <o14> +)
    (<in106> ^1 <o14> + ^2 <o15> +)
    (<in107> ^1 <o14> + ^2 <o9> +)
    (<in108> ^1 <o14> + ^2 <o8> +)
    (<in109> ^1 <o14> + ^2 <o7> +)
    (<in110> ^1 <o14> + ^2 <o13> +)
    (<in111> ^1 <o13> + ^2 <o7> +)
    (<in112> ^1 <o13> + ^2 <o8> +)
    (<in113> ^1 <o13> + ^2 <o14> +)
    (<diagonal-with1> ^item-type predicate + ^handle diagonal-with1 +
           ^instance <in114> + ^instance <in115> + ^instance <in116> +
           ^instance <in117> + ^instance <in118> + ^instance <in119> +
           ^instance <in120> + ^instance <in121> + ^instance <in122> +
           ^instance <in123> + ^instance <in124> + ^instance <in125> +
           ^instance <in126> + ^instance <in127> + ^instance <in128> +
           ^instance <in129> + ^instance <in130> + ^instance <in131> +
           ^instance <in132> + ^instance <in133> + ^instance <in134> +
           ^instance <in135> + ^instance <in136> + ^instance <in137> +
           ^instance <in138> + ^instance <in139> + ^instance <in140> +
           ^instance <in141> + ^instance <in142> + ^instance <in143> +
           ^instance <in144> + ^instance <in145> + ^instance <in146> +
           ^instance <in147> + ^instance <in148> + ^instance <in149> +)
    (<in114> ^1 <o1> + ^2 <o5> +)
    (<in115> ^1 <o2> + ^2 <o4> +)
    (<in116> ^1 <o2> + ^2 <o6> +)
    (<in117> ^1 <o3> + ^2 <o5> +)
    (<in118> ^1 <o4> + ^2 <o2> +)
    (<in119> ^1 <o4> + ^2 <o8> +)
    (<in120> ^1 <o5> + ^2 <o1> +)
    (<in121> ^1 <o5> + ^2 <o3> +)
    (<in122> ^1 <o5> + ^2 <o7> +)
    (<in123> ^1 <o5> + ^2 <o9> +)
    (<in124> ^1 <o6> + ^2 <o2> +)
    (<in125> ^1 <o6> + ^2 <o8> +)
    (<in126> ^1 <o7> + ^2 <o5> +)
    (<in127> ^1 <o8> + ^2 <o4> +)
    (<in128> ^1 <o8> + ^2 <o6> +)
    (<in129> ^1 <o9> + ^2 <o5> +)
    (<in130> ^1 <o3> + ^2 <o11> +)
    (<in131> ^1 <o11> + ^2 <o3> +)
    (<in132> ^1 <o6> + ^2 <o10> +)
    (<in133> ^1 <o10> + ^2 <o6> +)
    (<in134> ^1 <o9> + ^2 <o11> +)
    (<in135> ^1 <o11> + ^2 <o9> +)
    (<in136> ^1 <o12> + ^2 <o6> +)
    (<in137> ^1 <o6> + ^2 <o12> +)
    (<in138> ^1 <o16> + ^2 <o9> +)
    (<in139> ^1 <o9> + ^2 <o16> +)
    (<in140> ^1 <o12> + ^2 <o15> +)
    (<in141> ^1 <o15> + ^2 <o12> +)
    (<in142> ^1 <o14> + ^2 <o9> +)
    (<in143> ^1 <o9> + ^2 <o14> +)
    (<in144> ^1 <o8> + ^2 <o15> +)
    (<in145> ^1 <o15> + ^2 <o8> +)
    (<in146> ^1 <o14> + ^2 <o7> +)
    (<in147> ^1 <o7> + ^2 <o14> +)
    (<in148> ^1 <o13> + ^2 <o8> +)
    (<in149> ^1 <o8> + ^2 <o13> +)
}

sp {dialog-event*apply*game-state-change-respond*init-mac
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-mac)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^shape bank1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^shape bank1 +
           ^name destination1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category block + ^shape missionary1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^shape missionary1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^shape missionary1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^shape cannibal1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^shape cannibal1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block + ^shape cannibal1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category block + ^shape boat1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +)
    (<in0> ^1 <o3> + ^2 <o1> +)
    (<in1> ^1 <o4> + ^2 <o1> +)
    (<in2> ^1 <o5> + ^2 <o1> +)
    (<in3> ^1 <o6> + ^2 <o1> +)
    (<in4> ^1 <o7> + ^2 <o1> +)
    (<in5> ^1 <o8> + ^2 <o1> +)
    (<in6> ^1 <o9> + ^2 <o1> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in7> +
           ^instance <in8> + ^instance <in9> + ^instance <in10> +
           ^instance <in11> + ^instance <in12> + ^instance <in13> +)
    (<in7> ^1 <o1> + ^2 <o3> +)
    (<in8> ^1 <o1> + ^2 <o4> +)
    (<in9> ^1 <o1> + ^2 <o5> +)
    (<in10> ^1 <o1> + ^2 <o6> +)
    (<in11> ^1 <o1> + ^2 <o7> +)
    (<in12> ^1 <o1> + ^2 <o8> +)
    (<in13> ^1 <o1> + ^2 <o9> +)
}

sp {dialog-event*apply*game-state-change-respond*fail-jigsawdoku
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type fail-jigsawdoku)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^row 1 + ^column 1 +
           ^section 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^row 2 + ^column 1 +
           ^value 1 + ^section 1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^row 3 + ^column 1 +
           ^value 2 + ^section 1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^row 4 + ^column 1 +
           ^section 1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^row 1 + ^column 2 +
           ^value 4 + ^section 2 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^row 2 + ^column 2 +
           ^value 4 + ^section 2 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^row 3 + ^column 2 +
           ^section 3 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^row 4 + ^column 2 +
           ^section 3 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^row 1 + ^column 3 +
           ^section 2 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^row 2 + ^column 3 +
           ^section 2 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location + ^row 3 + ^column 3 +
           ^section 3 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location + ^row 4 + ^column 3 +
           ^value 2 + ^section 3 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category location + ^row 1 + ^column 4 +
           ^section 4 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category location + ^row 2 + ^column 4 +
           ^value 4 + ^section 4 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category location + ^row 3 + ^column 4 +
           ^value 3 + ^section 4 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category location + ^row 4 + ^column 4 +
           ^section 4 +)
}

sp {dialog-event*apply*game-state-change-respond*init-i5puzzle
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-i5puzzle)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <near1> +
           ^predicate <diagonal-with1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^value 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^value 2 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^value 3 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^value 4 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^value 5 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^value 1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block + ^value 2 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category block + ^value 3 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block + ^value 4 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block + ^value 5 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> +)
    (<in0> ^1 <o7> + ^2 <o2> +)
    (<in1> ^1 <o8> + ^2 <o3> +)
    (<in2> ^1 <o9> + ^2 <o1> +)
    (<in3> ^1 <o10> + ^2 <o5> +)
    (<in4> ^1 <o11> + ^2 <o6> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in5> +
           ^instance <in6> + ^instance <in7> + ^instance <in8> +
           ^instance <in9> +)
    (<in5> ^1 <o2> + ^2 <o7> +)
    (<in6> ^1 <o3> + ^2 <o8> +)
    (<in7> ^1 <o1> + ^2 <o9> +)
    (<in8> ^1 <o5> + ^2 <o10> +)
    (<in9> ^1 <o6> + ^2 <o11> +)
    (<near1> ^item-type predicate + ^handle near1 + ^instance <in10> +
           ^instance <in11> + ^instance <in12> + ^instance <in13> +
           ^instance <in14> + ^instance <in15> + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> + ^instance <in25> +
           ^instance <in26> + ^instance <in27> + ^instance <in28> +
           ^instance <in29> + ^instance <in30> + ^instance <in31> +)
    (<in10> ^1 <o1> + ^2 <o2> +)
    (<in11> ^1 <o1> + ^2 <o4> +)
    (<in12> ^1 <o1> + ^2 <o5> +)
    (<in13> ^1 <o2> + ^2 <o1> +)
    (<in14> ^1 <o2> + ^2 <o3> +)
    (<in15> ^1 <o2> + ^2 <o4> +)
    (<in16> ^1 <o2> + ^2 <o5> +)
    (<in17> ^1 <o2> + ^2 <o6> +)
    (<in18> ^1 <o3> + ^2 <o2> +)
    (<in19> ^1 <o3> + ^2 <o5> +)
    (<in20> ^1 <o3> + ^2 <o6> +)
    (<in21> ^1 <o4> + ^2 <o1> +)
    (<in22> ^1 <o4> + ^2 <o2> +)
    (<in23> ^1 <o4> + ^2 <o5> +)
    (<in24> ^1 <o5> + ^2 <o1> +)
    (<in25> ^1 <o5> + ^2 <o2> +)
    (<in26> ^1 <o5> + ^2 <o3> +)
    (<in27> ^1 <o5> + ^2 <o4> +)
    (<in28> ^1 <o5> + ^2 <o6> +)
    (<in29> ^1 <o6> + ^2 <o2> +)
    (<in30> ^1 <o6> + ^2 <o3> +)
    (<in31> ^1 <o6> + ^2 <o5> +)
    (<diagonal-with1> ^item-type predicate + ^handle diagonal-with1 +
           ^instance <in32> + ^instance <in33> + ^instance <in34> +
           ^instance <in35> + ^instance <in36> + ^instance <in37> +
           ^instance <in38> + ^instance <in39> +)
    (<in32> ^1 <o1> + ^2 <o5> +)
    (<in33> ^1 <o2> + ^2 <o4> +)
    (<in34> ^1 <o2> + ^2 <o6> +)
    (<in35> ^1 <o3> + ^2 <o5> +)
    (<in36> ^1 <o4> + ^2 <o2> +)
    (<in37> ^1 <o5> + ^2 <o1> +)
    (<in38> ^1 <o5> + ^2 <o3> +)
    (<in39> ^1 <o6> + ^2 <o2> +)
}

sp {dialog-event*apply*game-state-change-respond*final-8puzzle
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-8puzzle)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> + ^object <o17> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <near1> +
           ^predicate <diagonal-with1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color red1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color orange1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^color yellow1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^color green1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^color blue1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^color purple1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^color gray1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^color brown1 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block + ^color red1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block + ^color orange1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category block + ^color yellow1 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block + ^color green1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category block + ^color blue1 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category block + ^color purple1 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category block + ^color gray1 +)
    (<o17> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category block + ^color brown1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +
           ^instance <in7> +)
    (<in0> ^1 <o10> + ^2 <o1> +)
    (<in1> ^1 <o11> + ^2 <o2> +)
    (<in2> ^1 <o12> + ^2 <o4> +)
    (<in3> ^1 <o13> + ^2 <o5> +)
    (<in4> ^1 <o14> + ^2 <o6> +)
    (<in5> ^1 <o15> + ^2 <o7> +)
    (<in6> ^1 <o16> + ^2 <o8> +)
    (<in7> ^1 <o17> + ^2 <o9> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +
           ^instance <in12> + ^instance <in13> + ^instance <in14> +
           ^instance <in15> +)
    (<in8> ^1 <o1> + ^2 <o10> +)
    (<in9> ^1 <o2> + ^2 <o11> +)
    (<in10> ^1 <o4> + ^2 <o12> +)
    (<in11> ^1 <o5> + ^2 <o13> +)
    (<in12> ^1 <o6> + ^2 <o14> +)
    (<in13> ^1 <o7> + ^2 <o15> +)
    (<in14> ^1 <o8> + ^2 <o16> +)
    (<in15> ^1 <o9> + ^2 <o17> +)
    (<near1> ^item-type predicate + ^handle near1 + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> + ^instance <in25> +
           ^instance <in26> + ^instance <in27> + ^instance <in28> +
           ^instance <in29> + ^instance <in30> + ^instance <in31> +
           ^instance <in32> + ^instance <in33> + ^instance <in34> +
           ^instance <in35> + ^instance <in36> + ^instance <in37> +
           ^instance <in38> + ^instance <in39> + ^instance <in40> +
           ^instance <in41> + ^instance <in42> + ^instance <in43> +
           ^instance <in44> + ^instance <in45> + ^instance <in46> +
           ^instance <in47> + ^instance <in48> + ^instance <in49> +
           ^instance <in50> + ^instance <in51> + ^instance <in52> +
           ^instance <in53> + ^instance <in54> + ^instance <in55> +)
    (<in16> ^1 <o1> + ^2 <o2> +)
    (<in17> ^1 <o1> + ^2 <o4> +)
    (<in18> ^1 <o1> + ^2 <o5> +)
    (<in19> ^1 <o2> + ^2 <o1> +)
    (<in20> ^1 <o2> + ^2 <o3> +)
    (<in21> ^1 <o2> + ^2 <o4> +)
    (<in22> ^1 <o2> + ^2 <o5> +)
    (<in23> ^1 <o2> + ^2 <o6> +)
    (<in24> ^1 <o3> + ^2 <o2> +)
    (<in25> ^1 <o3> + ^2 <o5> +)
    (<in26> ^1 <o3> + ^2 <o6> +)
    (<in27> ^1 <o4> + ^2 <o1> +)
    (<in28> ^1 <o4> + ^2 <o2> +)
    (<in29> ^1 <o4> + ^2 <o5> +)
    (<in30> ^1 <o4> + ^2 <o7> +)
    (<in31> ^1 <o4> + ^2 <o8> +)
    (<in32> ^1 <o5> + ^2 <o1> +)
    (<in33> ^1 <o5> + ^2 <o2> +)
    (<in34> ^1 <o5> + ^2 <o3> +)
    (<in35> ^1 <o5> + ^2 <o4> +)
    (<in36> ^1 <o5> + ^2 <o6> +)
    (<in37> ^1 <o5> + ^2 <o7> +)
    (<in38> ^1 <o5> + ^2 <o8> +)
    (<in39> ^1 <o5> + ^2 <o9> +)
    (<in40> ^1 <o6> + ^2 <o2> +)
    (<in41> ^1 <o6> + ^2 <o3> +)
    (<in42> ^1 <o6> + ^2 <o5> +)
    (<in43> ^1 <o6> + ^2 <o8> +)
    (<in44> ^1 <o6> + ^2 <o9> +)
    (<in45> ^1 <o7> + ^2 <o4> +)
    (<in46> ^1 <o7> + ^2 <o5> +)
    (<in47> ^1 <o7> + ^2 <o8> +)
    (<in48> ^1 <o8> + ^2 <o7> +)
    (<in49> ^1 <o8> + ^2 <o4> +)
    (<in50> ^1 <o8> + ^2 <o5> +)
    (<in51> ^1 <o8> + ^2 <o6> +)
    (<in52> ^1 <o8> + ^2 <o9> +)
    (<in53> ^1 <o9> + ^2 <o8> +)
    (<in54> ^1 <o9> + ^2 <o5> +)
    (<in55> ^1 <o9> + ^2 <o6> +)
    (<diagonal-with1> ^item-type predicate + ^handle diagonal-with1 +
           ^instance <in56> + ^instance <in57> + ^instance <in58> +
           ^instance <in59> + ^instance <in60> + ^instance <in61> +
           ^instance <in62> + ^instance <in63> + ^instance <in64> +
           ^instance <in65> + ^instance <in66> + ^instance <in67> +
           ^instance <in68> + ^instance <in69> + ^instance <in70> +
           ^instance <in71> +)
    (<in56> ^1 <o1> + ^2 <o5> +)
    (<in57> ^1 <o2> + ^2 <o4> +)
    (<in58> ^1 <o2> + ^2 <o6> +)
    (<in59> ^1 <o3> + ^2 <o5> +)
    (<in60> ^1 <o4> + ^2 <o2> +)
    (<in61> ^1 <o4> + ^2 <o8> +)
    (<in62> ^1 <o5> + ^2 <o1> +)
    (<in63> ^1 <o5> + ^2 <o3> +)
    (<in64> ^1 <o5> + ^2 <o7> +)
    (<in65> ^1 <o5> + ^2 <o9> +)
    (<in66> ^1 <o6> + ^2 <o2> +)
    (<in67> ^1 <o6> + ^2 <o8> +)
    (<in68> ^1 <o7> + ^2 <o5> +)
    (<in69> ^1 <o8> + ^2 <o4> +)
    (<in70> ^1 <o8> + ^2 <o6> +)
    (<in71> ^1 <o9> + ^2 <o5> +)
}

sp {dialog-event*apply*game-state-change-respond*final-jigsawdoku
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-jigsawdoku)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^row 1 + ^column 1 +
           ^value 3 + ^section 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^row 2 + ^column 1 +
           ^value 1 + ^section 1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^row 3 + ^column 1 +
           ^value 2 + ^section 1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^row 4 + ^column 1 +
           ^value 4 + ^section 1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^row 1 + ^column 2 +
           ^value 4 + ^section 2 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^row 2 + ^column 2 +
           ^value 2 + ^section 2 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^row 3 + ^column 2 +
           ^value 1 + ^section 3 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^row 4 + ^column 2 +
           ^value 3 + ^section 3 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^row 1 + ^column 3 +
           ^value 1 + ^section 2 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^row 2 + ^column 3 +
           ^value 3 + ^section 2 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location + ^row 3 + ^column 3 +
           ^value 4 + ^section 3 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location + ^row 4 + ^column 3 +
           ^value 2 + ^section 3 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category location + ^row 1 + ^column 4 +
           ^value 2 + ^section 4 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category location + ^row 2 + ^column 4 +
           ^value 4 + ^section 4 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category location + ^row 3 + ^column 4 +
           ^value 3 + ^section 4 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category location + ^row 4 + ^column 4 +
           ^value 1 + ^section 4 +)
}

sp {dialog-event*apply*game-state-change-respond*final-lzstacked-frogs
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-lzstacked-frogs)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^x 1 + ^y 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^x 2 + ^y 1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^x 3 + ^y 1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^x 4 + ^y 1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^color red1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +)
    (<in0> ^1 <o5> + ^2 <o1> +)
    (<in1> ^1 <o6> + ^2 <o1> +)
    (<in2> ^1 <o7> + ^2 <o1> +)
    (<in3> ^1 <o8> + ^2 <o1> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in4> +
           ^instance <in5> + ^instance <in6> + ^instance <in7> +)
    (<in4> ^1 <o1> + ^2 <o5> +)
    (<in5> ^1 <o1> + ^2 <o6> +)
    (<in6> ^1 <o1> + ^2 <o7> +)
    (<in7> ^1 <o1> + ^2 <o8> +)
}

sp {dialog-event*apply*game-state-change-respond*final-president
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-president)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category object + ^shape card + ^suit spades +
           ^value 5 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category object + ^shape card + ^suit hearts +
           ^value 1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category object + ^shape card + ^suit diamonds +
           ^value 9 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category object + ^shape card + ^suit club +
           ^value 10 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category object + ^shape card + ^suit ace +
           ^value 9 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category object + ^shape card + ^suit ace +
           ^value 10 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category object + ^name deck +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category object + ^shape hand + ^name player +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category object + ^name dealer +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> +)
    (<in0> ^1 <o1> + ^2 <o9> +)
    (<in1> ^1 <o2> + ^2 <o9> +)
    (<in2> ^1 <o3> + ^2 <o9> +)
    (<in3> ^1 <o4> + ^2 <o9> +)
    (<in4> ^1 <o5> + ^2 <o7> +)
    (<in5> ^1 <o6> + ^2 <o9> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in6> +
           ^instance <in7> + ^instance <in8> + ^instance <in9> +
           ^instance <in10> + ^instance <in11> +)
    (<in6> ^1 <o9> + ^2 <o1> +)
    (<in7> ^1 <o9> + ^2 <o2> +)
    (<in8> ^1 <o9> + ^2 <o3> +)
    (<in9> ^1 <o9> + ^2 <o4> +)
    (<in10> ^1 <o7> + ^2 <o5> +)
    (<in11> ^1 <o9> + ^2 <o6> +)
}

sp {dialog-event*apply*game-state-change-respond*final-husbands
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-husbands)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^shape bank1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^shape bank1 +
           ^name destination1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category block + ^shape woman1 +
           ^last-name smith1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^shape woman1 +
           ^last-name bale1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^shape woman1 +
           ^last-name rogers1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^shape man1 + ^last-name smith1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^shape man1 + ^last-name bale1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block + ^shape man1 +
           ^last-name rogers1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category block + ^shape boat1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +)
    (<in0> ^1 <o3> + ^2 <o2> +)
    (<in1> ^1 <o4> + ^2 <o2> +)
    (<in2> ^1 <o5> + ^2 <o2> +)
    (<in3> ^1 <o6> + ^2 <o2> +)
    (<in4> ^1 <o7> + ^2 <o2> +)
    (<in5> ^1 <o8> + ^2 <o2> +)
    (<in6> ^1 <o9> + ^2 <o2> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in7> +
           ^instance <in8> + ^instance <in9> + ^instance <in10> +
           ^instance <in11> + ^instance <in12> + ^instance <in13> +)
    (<in7> ^1 <o2> + ^2 <o3> +)
    (<in8> ^1 <o2> + ^2 <o4> +)
    (<in9> ^1 <o2> + ^2 <o5> +)
    (<in10> ^1 <o2> + ^2 <o6> +)
    (<in11> ^1 <o2> + ^2 <o7> +)
    (<in12> ^1 <o2> + ^2 <o8> +)
    (<in13> ^1 <o2> + ^2 <o9> +)
}

sp {dialog-event*apply*game-state-change-respond*final-risk
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-risk)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <near1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^color red1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block + ^color red1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category block + ^color red1 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block + ^color red1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block + ^color red1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category block + ^color red1 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block + ^color red1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category block + ^color red1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +
           ^instance <in7> +)
    (<in0> ^1 <o7> + ^2 <o1> +)
    (<in1> ^1 <o8> + ^2 <o1> +)
    (<in2> ^1 <o9> + ^2 <o2> +)
    (<in3> ^1 <o10> + ^2 <o6> +)
    (<in4> ^1 <o11> + ^2 <o3> +)
    (<in5> ^1 <o12> + ^2 <o3> +)
    (<in6> ^1 <o13> + ^2 <o4> +)
    (<in7> ^1 <o14> + ^2 <o5> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +
           ^instance <in12> + ^instance <in13> + ^instance <in14> +
           ^instance <in15> +)
    (<in8> ^1 <o1> + ^2 <o7> +)
    (<in9> ^1 <o1> + ^2 <o8> +)
    (<in10> ^1 <o2> + ^2 <o9> +)
    (<in11> ^1 <o6> + ^2 <o10> +)
    (<in12> ^1 <o3> + ^2 <o11> +)
    (<in13> ^1 <o3> + ^2 <o12> +)
    (<in14> ^1 <o4> + ^2 <o13> +)
    (<in15> ^1 <o5> + ^2 <o14> +)
    (<near1> ^item-type predicate + ^handle near1 + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> + ^instance <in25> +
           ^instance <in26> + ^instance <in27> + ^instance <in28> +
           ^instance <in29> + ^instance <in30> + ^instance <in31> +
           ^instance <in32> + ^instance <in33> + ^instance <in34> +
           ^instance <in35> + ^instance <in36> + ^instance <in37> +)
    (<in16> ^1 <o1> + ^2 <o2> +)
    (<in17> ^1 <o1> + ^2 <o4> +)
    (<in18> ^1 <o1> + ^2 <o5> +)
    (<in19> ^1 <o2> + ^2 <o1> +)
    (<in20> ^1 <o2> + ^2 <o3> +)
    (<in21> ^1 <o2> + ^2 <o4> +)
    (<in22> ^1 <o2> + ^2 <o5> +)
    (<in23> ^1 <o2> + ^2 <o6> +)
    (<in24> ^1 <o3> + ^2 <o2> +)
    (<in25> ^1 <o3> + ^2 <o5> +)
    (<in26> ^1 <o3> + ^2 <o6> +)
    (<in27> ^1 <o4> + ^2 <o1> +)
    (<in28> ^1 <o4> + ^2 <o2> +)
    (<in29> ^1 <o4> + ^2 <o5> +)
    (<in30> ^1 <o5> + ^2 <o1> +)
    (<in31> ^1 <o5> + ^2 <o2> +)
    (<in32> ^1 <o5> + ^2 <o3> +)
    (<in33> ^1 <o5> + ^2 <o4> +)
    (<in34> ^1 <o5> + ^2 <o6> +)
    (<in35> ^1 <o6> + ^2 <o2> +)
    (<in36> ^1 <o6> + ^2 <o3> +)
    (<in37> ^1 <o6> + ^2 <o5> +)
}

sp {dialog-event*apply*game-state-change-respond*init-logi5a
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-logi5a)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^row 1 + ^column 1 +
           ^value c + ^color red1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^row 2 + ^column 1 +
           ^value a + ^color red1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^row 3 + ^column 1 +
           ^value b + ^color red1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^row 4 + ^column 1 +
           ^value d + ^color red1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^row 1 + ^column 2 +
           ^value d + ^color yellow1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^row 2 + ^column 2 +
           ^color yellow1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^row 3 + ^column 2 +
           ^value a + ^color green1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^row 4 + ^column 2 +
           ^value c + ^color green1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^row 1 + ^column 3 +
           ^value a + ^color yellow1 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^row 2 + ^column 3 +
           ^color yellow1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location + ^row 3 + ^column 3 +
           ^value d + ^color green1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location + ^row 4 + ^column 3 +
           ^value green1 + ^color 4 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category location + ^row 1 + ^column 4 +
           ^color blue1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category location + ^row 2 + ^column 4 +
           ^color blue1 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category location + ^row 3 + ^column 4 +
           ^value c + ^color blue1 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category location + ^row 4 + ^column 4 +
           ^value a + ^color blue1 +)
}

sp {dialog-event*apply*game-state-change-respond*init-15puzzle
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-15puzzle)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> + ^object <o17> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <near1> +
           ^predicate <diagonal-with1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color red1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color orange1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^color yellow1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^color green1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^color blue1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^color purple1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^color gray1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^color brown1 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block + ^color red1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block + ^color orange1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category block + ^color yellow1 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block + ^color green1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category block + ^color blue1 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category block + ^color purple1 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category block + ^color gray1 +)
    (<o17> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category block + ^color brown1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +
           ^instance <in7> +)
    (<in0> ^1 <o10> + ^2 <o2> +)
    (<in1> ^1 <o11> + ^2 <o3> +)
    (<in2> ^1 <o12> + ^2 <o1> +)
    (<in3> ^1 <o13> + ^2 <o5> +)
    (<in4> ^1 <o14> + ^2 <o6> +)
    (<in5> ^1 <o15> + ^2 <o7> +)
    (<in6> ^1 <o16> + ^2 <o8> +)
    (<in7> ^1 <o17> + ^2 <o9> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +
           ^instance <in12> + ^instance <in13> + ^instance <in14> +
           ^instance <in15> +)
    (<in8> ^1 <o2> + ^2 <o10> +)
    (<in9> ^1 <o3> + ^2 <o11> +)
    (<in10> ^1 <o1> + ^2 <o12> +)
    (<in11> ^1 <o5> + ^2 <o13> +)
    (<in12> ^1 <o6> + ^2 <o14> +)
    (<in13> ^1 <o7> + ^2 <o15> +)
    (<in14> ^1 <o8> + ^2 <o16> +)
    (<in15> ^1 <o9> + ^2 <o17> +)
    (<near1> ^item-type predicate + ^handle near1 + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> + ^instance <in25> +
           ^instance <in26> + ^instance <in27> + ^instance <in28> +
           ^instance <in29> + ^instance <in30> + ^instance <in31> +
           ^instance <in32> + ^instance <in33> + ^instance <in34> +
           ^instance <in35> + ^instance <in36> + ^instance <in37> +
           ^instance <in38> + ^instance <in39> + ^instance <in40> +
           ^instance <in41> + ^instance <in42> + ^instance <in43> +
           ^instance <in44> + ^instance <in45> + ^instance <in46> +
           ^instance <in47> + ^instance <in48> + ^instance <in49> +
           ^instance <in50> + ^instance <in51> + ^instance <in52> +
           ^instance <in53> + ^instance <in54> + ^instance <in55> +)
    (<in16> ^1 <o1> + ^2 <o2> +)
    (<in17> ^1 <o1> + ^2 <o4> +)
    (<in18> ^1 <o1> + ^2 <o5> +)
    (<in19> ^1 <o2> + ^2 <o1> +)
    (<in20> ^1 <o2> + ^2 <o3> +)
    (<in21> ^1 <o2> + ^2 <o4> +)
    (<in22> ^1 <o2> + ^2 <o5> +)
    (<in23> ^1 <o2> + ^2 <o6> +)
    (<in24> ^1 <o3> + ^2 <o2> +)
    (<in25> ^1 <o3> + ^2 <o5> +)
    (<in26> ^1 <o3> + ^2 <o6> +)
    (<in27> ^1 <o4> + ^2 <o1> +)
    (<in28> ^1 <o4> + ^2 <o2> +)
    (<in29> ^1 <o4> + ^2 <o5> +)
    (<in30> ^1 <o4> + ^2 <o7> +)
    (<in31> ^1 <o4> + ^2 <o8> +)
    (<in32> ^1 <o5> + ^2 <o1> +)
    (<in33> ^1 <o5> + ^2 <o2> +)
    (<in34> ^1 <o5> + ^2 <o3> +)
    (<in35> ^1 <o5> + ^2 <o4> +)
    (<in36> ^1 <o5> + ^2 <o6> +)
    (<in37> ^1 <o5> + ^2 <o7> +)
    (<in38> ^1 <o5> + ^2 <o8> +)
    (<in39> ^1 <o5> + ^2 <o9> +)
    (<in40> ^1 <o6> + ^2 <o2> +)
    (<in41> ^1 <o6> + ^2 <o3> +)
    (<in42> ^1 <o6> + ^2 <o5> +)
    (<in43> ^1 <o6> + ^2 <o8> +)
    (<in44> ^1 <o6> + ^2 <o9> +)
    (<in45> ^1 <o7> + ^2 <o4> +)
    (<in46> ^1 <o7> + ^2 <o5> +)
    (<in47> ^1 <o7> + ^2 <o8> +)
    (<in48> ^1 <o8> + ^2 <o7> +)
    (<in49> ^1 <o8> + ^2 <o4> +)
    (<in50> ^1 <o8> + ^2 <o5> +)
    (<in51> ^1 <o8> + ^2 <o6> +)
    (<in52> ^1 <o8> + ^2 <o9> +)
    (<in53> ^1 <o9> + ^2 <o8> +)
    (<in54> ^1 <o9> + ^2 <o5> +)
    (<in55> ^1 <o9> + ^2 <o6> +)
    (<diagonal-with1> ^item-type predicate + ^handle diagonal-with1 +
           ^instance <in56> + ^instance <in57> + ^instance <in58> +
           ^instance <in59> + ^instance <in60> + ^instance <in61> +
           ^instance <in62> + ^instance <in63> + ^instance <in64> +
           ^instance <in65> + ^instance <in66> + ^instance <in67> +
           ^instance <in68> + ^instance <in69> + ^instance <in70> +
           ^instance <in71> +)
    (<in56> ^1 <o1> + ^2 <o5> +)
    (<in57> ^1 <o2> + ^2 <o4> +)
    (<in58> ^1 <o2> + ^2 <o6> +)
    (<in59> ^1 <o3> + ^2 <o5> +)
    (<in60> ^1 <o4> + ^2 <o2> +)
    (<in61> ^1 <o4> + ^2 <o8> +)
    (<in62> ^1 <o5> + ^2 <o1> +)
    (<in63> ^1 <o5> + ^2 <o3> +)
    (<in64> ^1 <o5> + ^2 <o7> +)
    (<in65> ^1 <o5> + ^2 <o9> +)
    (<in66> ^1 <o6> + ^2 <o2> +)
    (<in67> ^1 <o6> + ^2 <o8> +)
    (<in68> ^1 <o7> + ^2 <o5> +)
    (<in69> ^1 <o8> + ^2 <o4> +)
    (<in70> ^1 <o8> + ^2 <o6> +)
    (<in71> ^1 <o9> + ^2 <o5> +)
}

sp {dialog-event*apply*game-state-change-respond*fail-crazy8
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type fail-crazy8)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category object + ^shape card + ^suit spades +
           ^value 5 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category object + ^shape card + ^suit hearts +
           ^value 1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category object + ^shape card + ^suit diamonds +
           ^value 9 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category object + ^shape card + ^suit club +
           ^value 10 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category object + ^shape card + ^suit ace +
           ^value 9 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category object + ^shape card + ^suit ace +
           ^value 10 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category object + ^name deck +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category object + ^shape hand + ^name player +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category object + ^name dealer +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> +)
    (<in0> ^1 <o1> + ^2 <o8> +)
    (<in1> ^1 <o2> + ^2 <o8> +)
    (<in2> ^1 <o3> + ^2 <o8> +)
    (<in3> ^1 <o4> + ^2 <o8> +)
    (<in4> ^1 <o5> + ^2 <o7> +)
    (<in5> ^1 <o6> + ^2 <o8> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in6> +
           ^instance <in7> + ^instance <in8> + ^instance <in9> +
           ^instance <in10> + ^instance <in11> +)
    (<in6> ^1 <o8> + ^2 <o1> +)
    (<in7> ^1 <o8> + ^2 <o2> +)
    (<in8> ^1 <o8> + ^2 <o3> +)
    (<in9> ^1 <o8> + ^2 <o4> +)
    (<in10> ^1 <o7> + ^2 <o5> +)
    (<in11> ^1 <o8> + ^2 <o6> +)
}

sp {dialog-event*apply*game-state-change-respond*init-sokoban
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-sokoban)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o17> + ^object <o18> + ^object <o19> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <near1> +
           ^predicate <diagonal-with1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^x 1 + ^y 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^x 2 + ^y 1 + ^color green1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^x 3 + ^y 1 + ^color red1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^x 1 + ^y 2 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^x 2 + ^y 2 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^x 3 + ^y 2 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^x 1 + ^y 3 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^x 2 + ^y 3 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^x 3 + ^y 3 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^x 1 + ^y 4 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location + ^x 2 + ^y 4 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location + ^x 3 + ^y 4 +)
    (<o17> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block + ^color blue1 +)
    (<o18> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category block + ^color red1 +)
    (<o19> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category block + ^color green1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> +)
    (<in0> ^1 <o17> + ^2 <o1> +)
    (<in1> ^1 <o18> + ^2 <o2> +)
    (<in2> ^1 <o19> + ^2 <o8> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in3> +
           ^instance <in4> + ^instance <in5> +)
    (<in3> ^1 <o1> + ^2 <o17> +)
    (<in4> ^1 <o2> + ^2 <o18> +)
    (<in5> ^1 <o8> + ^2 <o19> +)
    (<near1> ^item-type predicate + ^handle near1 + ^instance <in6> +
           ^instance <in7> + ^instance <in8> + ^instance <in9> +
           ^instance <in10> + ^instance <in11> + ^instance <in12> +
           ^instance <in13> + ^instance <in14> + ^instance <in15> +
           ^instance <in16> + ^instance <in17> + ^instance <in18> +
           ^instance <in19> + ^instance <in20> + ^instance <in21> +
           ^instance <in22> + ^instance <in23> + ^instance <in24> +
           ^instance <in25> + ^instance <in26> + ^instance <in27> +
           ^instance <in28> + ^instance <in29> + ^instance <in30> +
           ^instance <in31> + ^instance <in32> + ^instance <in33> +
           ^instance <in34> + ^instance <in35> + ^instance <in36> +
           ^instance <in37> + ^instance <in38> + ^instance <in39> +
           ^instance <in40> + ^instance <in41> + ^instance <in42> +
           ^instance <in43> + ^instance <in44> + ^instance <in45> +
           ^instance <in46> + ^instance <in47> + ^instance <in48> +
           ^instance <in49> + ^instance <in50> + ^instance <in51> +
           ^instance <in52> + ^instance <in53> + ^instance <in54> +
           ^instance <in55> + ^instance <in56> + ^instance <in57> +
           ^instance <in58> + ^instance <in59> + ^instance <in60> +
           ^instance <in61> + ^instance <in62> + ^instance <in63> +)
    (<in6> ^1 <o1> + ^2 <o2> +)
    (<in7> ^1 <o1> + ^2 <o4> +)
    (<in8> ^1 <o1> + ^2 <o5> +)
    (<in9> ^1 <o2> + ^2 <o1> +)
    (<in10> ^1 <o2> + ^2 <o3> +)
    (<in11> ^1 <o2> + ^2 <o4> +)
    (<in12> ^1 <o2> + ^2 <o5> +)
    (<in13> ^1 <o2> + ^2 <o6> +)
    (<in14> ^1 <o3> + ^2 <o2> +)
    (<in15> ^1 <o3> + ^2 <o5> +)
    (<in16> ^1 <o3> + ^2 <o6> +)
    (<in17> ^1 <o4> + ^2 <o1> +)
    (<in18> ^1 <o4> + ^2 <o2> +)
    (<in19> ^1 <o4> + ^2 <o5> +)
    (<in20> ^1 <o4> + ^2 <o7> +)
    (<in21> ^1 <o4> + ^2 <o8> +)
    (<in22> ^1 <o5> + ^2 <o1> +)
    (<in23> ^1 <o5> + ^2 <o2> +)
    (<in24> ^1 <o5> + ^2 <o3> +)
    (<in25> ^1 <o5> + ^2 <o4> +)
    (<in26> ^1 <o5> + ^2 <o6> +)
    (<in27> ^1 <o5> + ^2 <o7> +)
    (<in28> ^1 <o5> + ^2 <o8> +)
    (<in29> ^1 <o5> + ^2 <o9> +)
    (<in30> ^1 <o6> + ^2 <o2> +)
    (<in31> ^1 <o6> + ^2 <o3> +)
    (<in32> ^1 <o6> + ^2 <o5> +)
    (<in33> ^1 <o6> + ^2 <o8> +)
    (<in34> ^1 <o6> + ^2 <o9> +)
    (<in35> ^1 <o7> + ^2 <o4> +)
    (<in36> ^1 <o7> + ^2 <o5> +)
    (<in37> ^1 <o7> + ^2 <o8> +)
    (<in38> ^1 <o8> + ^2 <o7> +)
    (<in39> ^1 <o8> + ^2 <o4> +)
    (<in40> ^1 <o8> + ^2 <o5> +)
    (<in41> ^1 <o8> + ^2 <o6> +)
    (<in42> ^1 <o8> + ^2 <o9> +)
    (<in43> ^1 <o9> + ^2 <o8> +)
    (<in44> ^1 <o9> + ^2 <o5> +)
    (<in45> ^1 <o9> + ^2 <o6> +)
    (<in46> ^1 <o9> + ^2 <o11> +)
    (<in47> ^1 <o9> + ^2 <o12> +)
    (<in48> ^1 <o8> + ^2 <o19> +)
    (<in49> ^1 <o8> + ^2 <o11> +)
    (<in50> ^1 <o8> + ^2 <o12> +)
    (<in51> ^1 <o7> + ^2 <o10> +)
    (<in52> ^1 <o7> + ^2 <o11> +)
    (<in53> ^1 <o10> + ^2 <o7> +)
    (<in54> ^1 <o10> + ^2 <o8> +)
    (<in55> ^1 <o10> + ^2 <o11> +)
    (<in56> ^1 <o11> + ^2 <o10> +)
    (<in57> ^1 <o11> + ^2 <o7> +)
    (<in58> ^1 <o11> + ^2 <o8> +)
    (<in59> ^1 <o11> + ^2 <o9> +)
    (<in60> ^1 <o11> + ^2 <o12> +)
    (<in61> ^1 <o12> + ^2 <o11> +)
    (<in62> ^1 <o12> + ^2 <o8> +)
    (<in63> ^1 <o12> + ^2 <o9> +)
    (<diagonal-with1> ^item-type predicate + ^handle diagonal-with1 +
           ^instance <in64> + ^instance <in65> + ^instance <in66> +
           ^instance <in67> + ^instance <in68> + ^instance <in69> +
           ^instance <in70> + ^instance <in71> + ^instance <in72> +
           ^instance <in73> + ^instance <in74> + ^instance <in75> +
           ^instance <in76> + ^instance <in77> + ^instance <in78> +
           ^instance <in79> + ^instance <in80> + ^instance <in81> +
           ^instance <in82> + ^instance <in83> + ^instance <in84> +
           ^instance <in85> + ^instance <in86> + ^instance <in87> +)
    (<in64> ^1 <o1> + ^2 <o5> +)
    (<in65> ^1 <o2> + ^2 <o4> +)
    (<in66> ^1 <o2> + ^2 <o6> +)
    (<in67> ^1 <o3> + ^2 <o5> +)
    (<in68> ^1 <o4> + ^2 <o2> +)
    (<in69> ^1 <o4> + ^2 <o8> +)
    (<in70> ^1 <o5> + ^2 <o1> +)
    (<in71> ^1 <o5> + ^2 <o3> +)
    (<in72> ^1 <o5> + ^2 <o7> +)
    (<in73> ^1 <o5> + ^2 <o9> +)
    (<in74> ^1 <o6> + ^2 <o2> +)
    (<in75> ^1 <o6> + ^2 <o8> +)
    (<in76> ^1 <o7> + ^2 <o5> +)
    (<in77> ^1 <o8> + ^2 <o4> +)
    (<in78> ^1 <o8> + ^2 <o6> +)
    (<in79> ^1 <o9> + ^2 <o5> +)
    (<in80> ^1 <o9> + ^2 <o11> +)
    (<in81> ^1 <o11> + ^2 <o9> +)
    (<in82> ^1 <o12> + ^2 <o8> +)
    (<in83> ^1 <o8> + ^2 <o12> +)
    (<in84> ^1 <o10> + ^2 <o8> +)
    (<in85> ^1 <o8> + ^2 <o10> +)
    (<in86> ^1 <o11> + ^2 <o7> +)
    (<in87> ^1 <o7> + ^2 <o11> +)
}

sp {dialog-event*apply*game-state-change-respond*final-tower3fon
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-tower3fon)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +
           ^predicate <larger-than1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color green1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color green1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^color blue1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^size small1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^size medium1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^size large1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> +)
    (<in0> ^1 <o5> + ^2 <o6> +)
    (<in1> ^1 <o6> + ^2 <o3> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in2> +
           ^instance <in3> +)
    (<in2> ^1 <o6> + ^2 <o5> +)
    (<in3> ^1 <o3> + ^2 <o6> +)
    (<larger-than1> ^item-type predicate + ^handle larger-than1 +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +
           ^instance <in7> + ^instance <in8> + ^instance <in9> +
           ^instance <in10> + ^instance <in11> + ^instance <in12> +
           ^instance <in13> + ^instance <in14> + ^instance <in15> +)
    (<in4> ^1 <o1> + ^2 <o4> +)
    (<in5> ^1 <o2> + ^2 <o4> +)
    (<in6> ^1 <o3> + ^2 <o4> +)
    (<in7> ^1 <o1> + ^2 <o5> +)
    (<in8> ^1 <o2> + ^2 <o5> +)
    (<in9> ^1 <o3> + ^2 <o5> +)
    (<in10> ^1 <o1> + ^2 <o6> +)
    (<in11> ^1 <o2> + ^2 <o6> +)
    (<in12> ^1 <o3> + ^2 <o6> +)
    (<in13> ^1 <o6> + ^2 <o5> +)
    (<in14> ^1 <o6> + ^2 <o4> +)
    (<in15> ^1 <o5> + ^2 <o4> +)
}

sp {dialog-event*apply*game-state-change-respond*final-i5puzzle
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-i5puzzle)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <near1> +
           ^predicate <diagonal-with1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^value 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^value 2 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^value 3 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^value 4 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^value 5 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^value 1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block + ^value 2 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category block + ^value 3 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block + ^value 4 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block + ^value 5 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> +)
    (<in0> ^1 <o7> + ^2 <o1> +)
    (<in1> ^1 <o8> + ^2 <o2> +)
    (<in2> ^1 <o9> + ^2 <o4> +)
    (<in3> ^1 <o10> + ^2 <o5> +)
    (<in4> ^1 <o11> + ^2 <o6> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in5> +
           ^instance <in6> + ^instance <in7> + ^instance <in8> +
           ^instance <in9> +)
    (<in5> ^1 <o1> + ^2 <o7> +)
    (<in6> ^1 <o2> + ^2 <o8> +)
    (<in7> ^1 <o4> + ^2 <o9> +)
    (<in8> ^1 <o5> + ^2 <o10> +)
    (<in9> ^1 <o6> + ^2 <o11> +)
    (<near1> ^item-type predicate + ^handle near1 + ^instance <in10> +
           ^instance <in11> + ^instance <in12> + ^instance <in13> +
           ^instance <in14> + ^instance <in15> + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> + ^instance <in25> +
           ^instance <in26> + ^instance <in27> + ^instance <in28> +
           ^instance <in29> + ^instance <in30> + ^instance <in31> +)
    (<in10> ^1 <o1> + ^2 <o2> +)
    (<in11> ^1 <o1> + ^2 <o4> +)
    (<in12> ^1 <o1> + ^2 <o5> +)
    (<in13> ^1 <o2> + ^2 <o1> +)
    (<in14> ^1 <o2> + ^2 <o3> +)
    (<in15> ^1 <o2> + ^2 <o4> +)
    (<in16> ^1 <o2> + ^2 <o5> +)
    (<in17> ^1 <o2> + ^2 <o6> +)
    (<in18> ^1 <o3> + ^2 <o2> +)
    (<in19> ^1 <o3> + ^2 <o5> +)
    (<in20> ^1 <o3> + ^2 <o6> +)
    (<in21> ^1 <o4> + ^2 <o1> +)
    (<in22> ^1 <o4> + ^2 <o2> +)
    (<in23> ^1 <o4> + ^2 <o5> +)
    (<in24> ^1 <o5> + ^2 <o1> +)
    (<in25> ^1 <o5> + ^2 <o2> +)
    (<in26> ^1 <o5> + ^2 <o3> +)
    (<in27> ^1 <o5> + ^2 <o4> +)
    (<in28> ^1 <o5> + ^2 <o6> +)
    (<in29> ^1 <o6> + ^2 <o2> +)
    (<in30> ^1 <o6> + ^2 <o3> +)
    (<in31> ^1 <o6> + ^2 <o5> +)
    (<diagonal-with1> ^item-type predicate + ^handle diagonal-with1 +
           ^instance <in32> + ^instance <in33> + ^instance <in34> +
           ^instance <in35> + ^instance <in36> + ^instance <in37> +
           ^instance <in38> + ^instance <in39> +)
    (<in32> ^1 <o1> + ^2 <o5> +)
    (<in33> ^1 <o2> + ^2 <o4> +)
    (<in34> ^1 <o2> + ^2 <o6> +)
    (<in35> ^1 <o3> + ^2 <o5> +)
    (<in36> ^1 <o4> + ^2 <o2> +)
    (<in37> ^1 <o5> + ^2 <o1> +)
    (<in38> ^1 <o5> + ^2 <o3> +)
    (<in39> ^1 <o6> + ^2 <o2> +)
}

sp {dialog-event*apply*game-state-change-respond*fail-fox2
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type fail-fox2)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^shape bank1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^shape bank1 +
           ^name destination1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category block + ^color red1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^color yellow1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^color green1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^shape boat1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +)
    (<in0> ^1 <o4> + ^2 <o1> +)
    (<in1> ^1 <o5> + ^2 <o1> +)
    (<in2> ^1 <o6> + ^2 <o2> +)
    (<in3> ^1 <o3> + ^2 <o2> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in4> +
           ^instance <in5> + ^instance <in6> + ^instance <in7> +)
    (<in4> ^1 <o1> + ^2 <o4> +)
    (<in5> ^1 <o1> + ^2 <o5> +)
    (<in6> ^1 <o2> + ^2 <o6> +)
    (<in7> ^1 <o2> + ^2 <o3> +)
}

sp {dialog-event*apply*game-state-change-respond*init-othello
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-othello)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> + ^object <o17> + ^object <o18> + ^object <o19> +
           ^object <o20> + ^object <o21> + ^object <o22> + ^object <o23> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^x 1 + ^y 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^x 2 + ^y 1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^x 3 + ^y 1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^x 4 + ^y 1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^x 1 + ^y 2 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^x 2 + ^y 2 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^x 3 + ^y 2 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^x 4 + ^y 2 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^x 1 + ^y 3 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^x 2 + ^y 3 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location + ^x 3 + ^y 3 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location + ^x 4 + ^y 3 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category location + ^x 1 + ^y 4 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category location + ^x 2 + ^y 4 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category location + ^x 3 + ^y 4 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category location + ^x 4 + ^y 4 +)
    (<o17> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category block + ^color red1 +)
    (<o18> ^item-type object + ^handle object-17 + ^predicates <pr17> +)
    (<pr17> ^visible true + ^category block + ^color red1 +)
    (<o19> ^item-type object + ^handle object-18 + ^predicates <pr18> +)
    (<pr18> ^visible true + ^category block + ^color red1 +)
    (<o20> ^item-type object + ^handle object-19 + ^predicates <pr19> +)
    (<pr19> ^visible true + ^category block + ^color blue1 +)
    (<o21> ^item-type object + ^handle object-20 + ^predicates <pr20> +)
    (<pr20> ^visible true + ^category block + ^color blue1 +)
    (<o22> ^item-type object + ^handle object-21 + ^predicates <pr21> +)
    (<pr21> ^visible true + ^category block + ^color blue1 +)
    (<o23> ^item-type object + ^handle object-22 + ^predicates <pr22> +)
    (<pr22> ^visible true + ^category block + ^color red1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> +)
    (<in0> ^1 <o17> + ^2 <o10> +)
    (<in1> ^1 <o18> + ^2 <o8> +)
    (<in2> ^1 <o19> + ^2 <o3> +)
    (<in3> ^1 <o20> + ^2 <o6> +)
    (<in4> ^1 <o21> + ^2 <o7> +)
    (<in5> ^1 <o22> + ^2 <o11> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in6> +
           ^instance <in7> + ^instance <in8> + ^instance <in9> +
           ^instance <in10> + ^instance <in11> +)
    (<in6> ^1 <o10> + ^2 <o17> +)
    (<in7> ^1 <o8> + ^2 <o18> +)
    (<in8> ^1 <o3> + ^2 <o19> +)
    (<in9> ^1 <o6> + ^2 <o20> +)
    (<in10> ^1 <o7> + ^2 <o21> +)
    (<in11> ^1 <o11> + ^2 <o22> +)
}

sp {dialog-event*apply*game-state-change-respond*final-crazy8
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-crazy8)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category object + ^shape card + ^suit spades +
           ^value 5 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category object + ^shape card + ^suit hearts +
           ^value 1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category object + ^shape card + ^suit diamonds +
           ^value 9 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category object + ^shape card + ^suit club +
           ^value 10 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category object + ^shape card + ^suit ace +
           ^value 9 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category object + ^shape card + ^suit ace +
           ^value 10 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category object + ^name deck +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category object + ^shape hand + ^name player +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category object + ^name dealer +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> +)
    (<in0> ^1 <o1> + ^2 <o9> +)
    (<in1> ^1 <o2> + ^2 <o9> +)
    (<in2> ^1 <o3> + ^2 <o9> +)
    (<in3> ^1 <o4> + ^2 <o9> +)
    (<in4> ^1 <o5> + ^2 <o7> +)
    (<in5> ^1 <o6> + ^2 <o9> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in6> +
           ^instance <in7> + ^instance <in8> + ^instance <in9> +
           ^instance <in10> + ^instance <in11> +)
    (<in6> ^1 <o9> + ^2 <o1> +)
    (<in7> ^1 <o9> + ^2 <o2> +)
    (<in8> ^1 <o9> + ^2 <o3> +)
    (<in9> ^1 <o9> + ^2 <o4> +)
    (<in10> ^1 <o7> + ^2 <o5> +)
    (<in11> ^1 <o9> + ^2 <o6> +)
}

sp {dialog-event*apply*game-state-change-respond*init-lzstacked-frogs2
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-lzstacked-frogs2)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^x 1 + ^y 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^x 2 + ^y 1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^x 3 + ^y 1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^x 4 + ^y 1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^x 5 + ^y 1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^x 6 + ^y 1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^color red1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category block +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category block +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> +)
    (<in0> ^1 <o7> + ^2 <o1> +)
    (<in1> ^1 <o8> + ^2 <o2> +)
    (<in2> ^1 <o9> + ^2 <o3> +)
    (<in3> ^1 <o10> + ^2 <o4> +)
    (<in4> ^1 <o11> + ^2 <o5> +)
    (<in5> ^1 <o12> + ^2 <o6> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in6> +
           ^instance <in7> + ^instance <in8> + ^instance <in9> +
           ^instance <in10> + ^instance <in11> +)
    (<in6> ^1 <o1> + ^2 <o7> +)
    (<in7> ^1 <o2> + ^2 <o8> +)
    (<in8> ^1 <o3> + ^2 <o9> +)
    (<in9> ^1 <o4> + ^2 <o10> +)
    (<in10> ^1 <o5> + ^2 <o11> +)
    (<in11> ^1 <o6> + ^2 <o12> +)
}

sp {dialog-event*apply*game-state-change-respond*final-logi5
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-logi5)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^row 1 + ^column 1 +
           ^value 3 + ^color red1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^row 2 + ^column 1 +
           ^value 1 + ^color red1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^row 3 + ^column 1 +
           ^value 2 + ^color red1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^row 4 + ^column 1 +
           ^value 4 + ^color red1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^row 1 + ^column 2 +
           ^value 4 + ^color yellow1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^row 2 + ^column 2 +
           ^value 2 + ^color yellow1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^row 3 + ^column 2 +
           ^value 1 + ^color green1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^row 4 + ^column 2 +
           ^value 3 + ^color green1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^row 1 + ^column 3 +
           ^value 1 + ^color yellow1 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^row 2 + ^column 3 +
           ^value 3 + ^color yellow1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location + ^row 3 + ^column 3 +
           ^value 4 + ^color green1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location + ^row 4 + ^column 3 +
           ^value 2 + ^color green1 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category location + ^row 1 + ^column 4 +
           ^value 2 + ^color blue1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category location + ^row 2 + ^column 4 +
           ^value 4 + ^color blue1 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category location + ^row 3 + ^column 4 +
           ^value 3 + ^color blue1 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category location + ^row 4 + ^column 4 +
           ^value 1 + ^color blue1 +)
}

sp {dialog-event*apply*game-state-change-respond*init-jigsawdoku
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-jigsawdoku)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^row 1 + ^column 1 +
           ^value 3 + ^section 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^row 2 + ^column 1 +
           ^value 1 + ^section 1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^row 3 + ^column 1 +
           ^value 2 + ^section 1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^row 4 + ^column 1 +
           ^value 4 + ^section 1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^row 1 + ^column 2 +
           ^value 4 + ^section 2 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^row 2 + ^column 2 +
           ^section 2 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^row 3 + ^column 2 +
           ^value 1 + ^section 3 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^row 4 + ^column 2 +
           ^value 3 + ^section 3 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^row 1 + ^column 3 +
           ^value 1 + ^section 2 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^row 2 + ^column 3 +
           ^section 2 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location + ^row 3 + ^column 3 +
           ^value 4 + ^section 3 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location + ^row 4 + ^column 3 +
           ^value 2 + ^section 3 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category location + ^row 1 + ^column 4 +
           ^section 4 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category location + ^row 2 + ^column 4 +
           ^section 4 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category location + ^row 3 + ^column 4 +
           ^value 3 + ^section 4 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category location + ^row 4 + ^column 4 +
           ^value 1 + ^section 4 +)
}

sp {dialog-event*apply*game-state-change-respond*init-5puzzle
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-5puzzle)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <near1> +
           ^predicate <diagonal-with1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color red1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color orange1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^color yellow1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^color green1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^color blue1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^color red1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block + ^color orange1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category block + ^color yellow1 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block + ^color green1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block + ^color blue1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> +)
    (<in0> ^1 <o7> + ^2 <o2> +)
    (<in1> ^1 <o8> + ^2 <o3> +)
    (<in2> ^1 <o9> + ^2 <o1> +)
    (<in3> ^1 <o10> + ^2 <o5> +)
    (<in4> ^1 <o11> + ^2 <o6> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in5> +
           ^instance <in6> + ^instance <in7> + ^instance <in8> +
           ^instance <in9> +)
    (<in5> ^1 <o2> + ^2 <o7> +)
    (<in6> ^1 <o3> + ^2 <o8> +)
    (<in7> ^1 <o1> + ^2 <o9> +)
    (<in8> ^1 <o5> + ^2 <o10> +)
    (<in9> ^1 <o6> + ^2 <o11> +)
    (<near1> ^item-type predicate + ^handle near1 + ^instance <in10> +
           ^instance <in11> + ^instance <in12> + ^instance <in13> +
           ^instance <in14> + ^instance <in15> + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> + ^instance <in25> +
           ^instance <in26> + ^instance <in27> + ^instance <in28> +
           ^instance <in29> + ^instance <in30> + ^instance <in31> +)
    (<in10> ^1 <o1> + ^2 <o2> +)
    (<in11> ^1 <o1> + ^2 <o4> +)
    (<in12> ^1 <o1> + ^2 <o5> +)
    (<in13> ^1 <o2> + ^2 <o1> +)
    (<in14> ^1 <o2> + ^2 <o3> +)
    (<in15> ^1 <o2> + ^2 <o4> +)
    (<in16> ^1 <o2> + ^2 <o5> +)
    (<in17> ^1 <o2> + ^2 <o6> +)
    (<in18> ^1 <o3> + ^2 <o2> +)
    (<in19> ^1 <o3> + ^2 <o5> +)
    (<in20> ^1 <o3> + ^2 <o6> +)
    (<in21> ^1 <o4> + ^2 <o1> +)
    (<in22> ^1 <o4> + ^2 <o2> +)
    (<in23> ^1 <o4> + ^2 <o5> +)
    (<in24> ^1 <o5> + ^2 <o1> +)
    (<in25> ^1 <o5> + ^2 <o2> +)
    (<in26> ^1 <o5> + ^2 <o3> +)
    (<in27> ^1 <o5> + ^2 <o4> +)
    (<in28> ^1 <o5> + ^2 <o6> +)
    (<in29> ^1 <o6> + ^2 <o2> +)
    (<in30> ^1 <o6> + ^2 <o3> +)
    (<in31> ^1 <o6> + ^2 <o5> +)
    (<diagonal-with1> ^item-type predicate + ^handle diagonal-with1 +
           ^instance <in32> + ^instance <in33> + ^instance <in34> +
           ^instance <in35> + ^instance <in36> + ^instance <in37> +
           ^instance <in38> + ^instance <in39> +)
    (<in32> ^1 <o1> + ^2 <o5> +)
    (<in33> ^1 <o2> + ^2 <o4> +)
    (<in34> ^1 <o2> + ^2 <o6> +)
    (<in35> ^1 <o3> + ^2 <o5> +)
    (<in36> ^1 <o4> + ^2 <o2> +)
    (<in37> ^1 <o5> + ^2 <o1> +)
    (<in38> ^1 <o5> + ^2 <o3> +)
    (<in39> ^1 <o6> + ^2 <o2> +)
}

sp {dialog-event*apply*game-state-change-respond*init-mac2
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-mac2)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^shape bank1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^shape bank1 +
           ^name destination1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category block + ^shape missionary1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^shape missionary1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^shape cannibal1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^shape cannibal1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^shape boat1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> +)
    (<in0> ^1 <o3> + ^2 <o1> +)
    (<in1> ^1 <o4> + ^2 <o1> +)
    (<in2> ^1 <o5> + ^2 <o1> +)
    (<in3> ^1 <o6> + ^2 <o1> +)
    (<in4> ^1 <o7> + ^2 <o1> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in5> +
           ^instance <in6> + ^instance <in7> + ^instance <in8> +
           ^instance <in9> +)
    (<in5> ^1 <o1> + ^2 <o3> +)
    (<in6> ^1 <o1> + ^2 <o4> +)
    (<in7> ^1 <o1> + ^2 <o5> +)
    (<in8> ^1 <o1> + ^2 <o6> +)
    (<in9> ^1 <o1> + ^2 <o7> +)
}

sp {dialog-event*apply*game-state-change-respond*fail-husbands
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type fail-husbands)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^shape bank1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^shape bank1 +
           ^name destination1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category block + ^shape woman1 +
           ^last-name smith1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^shape woman1 +
           ^last-name bale1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^shape woman1 +
           ^last-name rogers1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^shape man1 + ^last-name smith1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^shape man1 + ^last-name bale1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block + ^shape man1 +
           ^last-name rogers1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category block + ^shape boat1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +)
    (<in0> ^1 <o3> + ^2 <o1> +)
    (<in1> ^1 <o4> + ^2 <o1> +)
    (<in2> ^1 <o5> + ^2 <o1> +)
    (<in3> ^1 <o6> + ^2 <o1> +)
    (<in4> ^1 <o7> + ^2 <o2> +)
    (<in5> ^1 <o8> + ^2 <o1> +)
    (<in6> ^1 <o9> + ^2 <o1> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in7> +
           ^instance <in8> + ^instance <in9> + ^instance <in10> +
           ^instance <in11> + ^instance <in12> + ^instance <in13> +)
    (<in7> ^1 <o1> + ^2 <o3> +)
    (<in8> ^1 <o1> + ^2 <o4> +)
    (<in9> ^1 <o1> + ^2 <o5> +)
    (<in10> ^1 <o1> + ^2 <o6> +)
    (<in11> ^1 <o2> + ^2 <o7> +)
    (<in12> ^1 <o1> + ^2 <o8> +)
    (<in13> ^1 <o1> + ^2 <o9> +)
}

sp {dialog-event*apply*game-state-change-respond*final-tower3fs
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-tower3fs)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +
           ^predicate <larger-than1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color green1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color green1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^color blue1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^size medium1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^size large1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> +)
    (<in0> ^1 <o4> + ^2 <o5> +)
    (<in1> ^1 <o5> + ^2 <o6> +)
    (<in2> ^1 <o6> + ^2 <o3> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in3> +
           ^instance <in4> + ^instance <in5> +)
    (<in3> ^1 <o5> + ^2 <o4> +)
    (<in4> ^1 <o6> + ^2 <o5> +)
    (<in5> ^1 <o3> + ^2 <o6> +)
    (<larger-than1> ^item-type predicate + ^handle larger-than1 +
           ^instance <in6> + ^instance <in7> + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +
           ^instance <in12> + ^instance <in13> + ^instance <in14> +
           ^instance <in15> + ^instance <in16> + ^instance <in17> +)
    (<in6> ^1 <o1> + ^2 <o4> +)
    (<in7> ^1 <o2> + ^2 <o4> +)
    (<in8> ^1 <o3> + ^2 <o4> +)
    (<in9> ^1 <o1> + ^2 <o5> +)
    (<in10> ^1 <o2> + ^2 <o5> +)
    (<in11> ^1 <o3> + ^2 <o5> +)
    (<in12> ^1 <o1> + ^2 <o6> +)
    (<in13> ^1 <o2> + ^2 <o6> +)
    (<in14> ^1 <o3> + ^2 <o6> +)
    (<in15> ^1 <o6> + ^2 <o5> +)
    (<in16> ^1 <o6> + ^2 <o4> +)
    (<in17> ^1 <o5> + ^2 <o4> +)
}

sp {dialog-event*apply*game-state-change-respond*init-logi5
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-logi5)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^row 1 + ^column 1 +
           ^value 3 + ^color red1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^row 2 + ^column 1 +
           ^value 1 + ^color red1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^row 3 + ^column 1 +
           ^value 2 + ^color red1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^row 4 + ^column 1 +
           ^value 4 + ^color red1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^row 1 + ^column 2 +
           ^value 4 + ^color yellow1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^row 2 + ^column 2 +
           ^color yellow1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^row 3 + ^column 2 +
           ^value 1 + ^color green1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^row 4 + ^column 2 +
           ^value 3 + ^color green1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^row 1 + ^column 3 +
           ^value 1 + ^color yellow1 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^row 2 + ^column 3 +
           ^color yellow1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location + ^row 3 + ^column 3 +
           ^value 4 + ^color green1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location + ^row 4 + ^column 3 +
           ^value green1 + ^color 4 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category location + ^row 1 + ^column 4 +
           ^color blue1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category location + ^row 2 + ^column 4 +
           ^color blue1 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category location + ^row 3 + ^column 4 +
           ^value 3 + ^color blue1 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category location + ^row 4 + ^column 4 +
           ^value 1 + ^color blue1 +)
}

sp {dialog-event*apply*game-state-change-respond*init-tower5
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-tower5)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +
           ^predicate <larger-than1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color green1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color green1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^color blue1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^size tiny1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^size small1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^size medium1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^size large1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block + ^size giant1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> +)
    (<in0> ^1 <o4> + ^2 <o5> +)
    (<in1> ^1 <o5> + ^2 <o6> +)
    (<in2> ^1 <o6> + ^2 <o7> +)
    (<in3> ^1 <o7> + ^2 <o8> +)
    (<in4> ^1 <o8> + ^2 <o1> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in5> +
           ^instance <in6> + ^instance <in7> + ^instance <in8> +
           ^instance <in9> +)
    (<in5> ^1 <o5> + ^2 <o4> +)
    (<in6> ^1 <o6> + ^2 <o5> +)
    (<in7> ^1 <o7> + ^2 <o6> +)
    (<in8> ^1 <o8> + ^2 <o7> +)
    (<in9> ^1 <o1> + ^2 <o8> +)
    (<larger-than1> ^item-type predicate + ^handle larger-than1 +
           ^instance <in10> + ^instance <in11> + ^instance <in12> +
           ^instance <in13> + ^instance <in14> + ^instance <in15> +
           ^instance <in16> + ^instance <in17> + ^instance <in18> +
           ^instance <in19> + ^instance <in20> + ^instance <in21> +
           ^instance <in22> + ^instance <in23> + ^instance <in24> +
           ^instance <in25> + ^instance <in26> + ^instance <in27> +
           ^instance <in28> + ^instance <in29> + ^instance <in30> +
           ^instance <in31> + ^instance <in32> + ^instance <in33> +
           ^instance <in34> +)
    (<in10> ^1 <o1> + ^2 <o4> +)
    (<in11> ^1 <o2> + ^2 <o4> +)
    (<in12> ^1 <o3> + ^2 <o4> +)
    (<in13> ^1 <o1> + ^2 <o5> +)
    (<in14> ^1 <o2> + ^2 <o5> +)
    (<in15> ^1 <o3> + ^2 <o5> +)
    (<in16> ^1 <o1> + ^2 <o6> +)
    (<in17> ^1 <o2> + ^2 <o6> +)
    (<in18> ^1 <o3> + ^2 <o6> +)
    (<in19> ^1 <o1> + ^2 <o7> +)
    (<in20> ^1 <o2> + ^2 <o7> +)
    (<in21> ^1 <o3> + ^2 <o7> +)
    (<in22> ^1 <o1> + ^2 <o8> +)
    (<in23> ^1 <o2> + ^2 <o8> +)
    (<in24> ^1 <o3> + ^2 <o8> +)
    (<in25> ^1 <o8> + ^2 <o7> +)
    (<in26> ^1 <o8> + ^2 <o6> +)
    (<in27> ^1 <o8> + ^2 <o5> +)
    (<in28> ^1 <o8> + ^2 <o4> +)
    (<in29> ^1 <o7> + ^2 <o6> +)
    (<in30> ^1 <o7> + ^2 <o5> +)
    (<in31> ^1 <o7> + ^2 <o4> +)
    (<in32> ^1 <o6> + ^2 <o5> +)
    (<in33> ^1 <o6> + ^2 <o4> +)
    (<in34> ^1 <o5> + ^2 <o4> +)
}

sp {dialog-event*apply*game-state-change-respond*final-blocksworld2
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-blocksworld2)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^color blue1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^color purple1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^color yellow1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> +)
    (<in0> ^1 <o6> + ^2 <o4> +)
    (<in1> ^1 <o4> + ^2 <o5> +)
    (<in2> ^1 <o5> + ^2 <o1> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in3> +
           ^instance <in4> + ^instance <in5> +)
    (<in3> ^1 <o4> + ^2 <o6> +)
    (<in4> ^1 <o5> + ^2 <o4> +)
    (<in5> ^1 <o1> + ^2 <o5> +)
}

sp {dialog-event*apply*game-state-change-respond*fail-tower5
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type fail-tower5)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +
           ^predicate <larger-than1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color green1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color green1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^color blue1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^size tiny1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^size small1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^size medium1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^size large1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block + ^size giant1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> +)
    (<in0> ^1 <o4> + ^2 <o6> +)
    (<in1> ^1 <o5> + ^2 <o4> +)
    (<in2> ^1 <o6> + ^2 <o7> +)
    (<in3> ^1 <o7> + ^2 <o8> +)
    (<in4> ^1 <o8> + ^2 <o1> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in5> +
           ^instance <in6> + ^instance <in7> + ^instance <in8> +
           ^instance <in9> +)
    (<in5> ^1 <o6> + ^2 <o4> +)
    (<in6> ^1 <o4> + ^2 <o5> +)
    (<in7> ^1 <o7> + ^2 <o6> +)
    (<in8> ^1 <o8> + ^2 <o7> +)
    (<in9> ^1 <o1> + ^2 <o8> +)
    (<larger-than1> ^item-type predicate + ^handle larger-than1 +
           ^instance <in10> + ^instance <in11> + ^instance <in12> +
           ^instance <in13> + ^instance <in14> + ^instance <in15> +
           ^instance <in16> + ^instance <in17> + ^instance <in18> +
           ^instance <in19> + ^instance <in20> + ^instance <in21> +
           ^instance <in22> + ^instance <in23> + ^instance <in24> +
           ^instance <in25> + ^instance <in26> + ^instance <in27> +
           ^instance <in28> + ^instance <in29> + ^instance <in30> +
           ^instance <in31> + ^instance <in32> + ^instance <in33> +
           ^instance <in34> +)
    (<in10> ^1 <o1> + ^2 <o4> +)
    (<in11> ^1 <o2> + ^2 <o4> +)
    (<in12> ^1 <o3> + ^2 <o4> +)
    (<in13> ^1 <o1> + ^2 <o5> +)
    (<in14> ^1 <o2> + ^2 <o5> +)
    (<in15> ^1 <o3> + ^2 <o5> +)
    (<in16> ^1 <o1> + ^2 <o6> +)
    (<in17> ^1 <o2> + ^2 <o6> +)
    (<in18> ^1 <o3> + ^2 <o6> +)
    (<in19> ^1 <o1> + ^2 <o7> +)
    (<in20> ^1 <o2> + ^2 <o7> +)
    (<in21> ^1 <o3> + ^2 <o7> +)
    (<in22> ^1 <o1> + ^2 <o8> +)
    (<in23> ^1 <o2> + ^2 <o8> +)
    (<in24> ^1 <o3> + ^2 <o8> +)
    (<in25> ^1 <o8> + ^2 <o7> +)
    (<in26> ^1 <o8> + ^2 <o6> +)
    (<in27> ^1 <o8> + ^2 <o5> +)
    (<in28> ^1 <o8> + ^2 <o4> +)
    (<in29> ^1 <o7> + ^2 <o6> +)
    (<in30> ^1 <o7> + ^2 <o5> +)
    (<in31> ^1 <o7> + ^2 <o4> +)
    (<in32> ^1 <o6> + ^2 <o5> +)
    (<in33> ^1 <o6> + ^2 <o4> +)
    (<in34> ^1 <o5> + ^2 <o4> +)
}

sp {dialog-event*apply*game-state-change-respond*init-blocksworld2
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-blocksworld2)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^color blue1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^color purple1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^color yellow1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> +)
    (<in0> ^1 <o4> + ^2 <o5> +)
    (<in1> ^1 <o5> + ^2 <o6> +)
    (<in2> ^1 <o6> + ^2 <o1> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in3> +
           ^instance <in4> + ^instance <in5> +)
    (<in3> ^1 <o5> + ^2 <o4> +)
    (<in4> ^1 <o6> + ^2 <o5> +)
    (<in5> ^1 <o1> + ^2 <o6> +)
}

sp {dialog-event*apply*game-state-change-respond*init-president
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-president)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category object + ^shape card + ^suit spades +
           ^value 5 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category object + ^shape card + ^suit hearts +
           ^value 2 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category object + ^shape card + ^suit diamonds +
           ^value 9 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category object + ^shape card + ^suit club +
           ^value 10 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category object + ^shape card + ^suit ace +
           ^value 9 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category object + ^shape card + ^suit ace +
           ^value 10 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category object + ^name deck +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category object + ^shape hand + ^name player +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category object + ^name dealer +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> +)
    (<in0> ^1 <o1> + ^2 <o8> +)
    (<in1> ^1 <o2> + ^2 <o8> +)
    (<in2> ^1 <o3> + ^2 <o8> +)
    (<in3> ^1 <o4> + ^2 <o8> +)
    (<in4> ^1 <o5> + ^2 <o7> +)
    (<in5> ^1 <o6> + ^2 <o9> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in6> +
           ^instance <in7> + ^instance <in8> + ^instance <in9> +
           ^instance <in10> + ^instance <in11> +)
    (<in6> ^1 <o8> + ^2 <o1> +)
    (<in7> ^1 <o8> + ^2 <o2> +)
    (<in8> ^1 <o8> + ^2 <o3> +)
    (<in9> ^1 <o8> + ^2 <o4> +)
    (<in10> ^1 <o7> + ^2 <o5> +)
    (<in11> ^1 <o9> + ^2 <o6> +)
}

sp {dialog-event*apply*game-state-change-respond*final-tower4
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-tower4)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +
           ^predicate <larger-than1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color green1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color green1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^color blue1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^size tiny1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^size small1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^size medium1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^size large1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +)
    (<in0> ^1 <o4> + ^2 <o5> +)
    (<in1> ^1 <o5> + ^2 <o6> +)
    (<in2> ^1 <o6> + ^2 <o7> +)
    (<in3> ^1 <o7> + ^2 <o3> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in4> +
           ^instance <in5> + ^instance <in6> + ^instance <in7> +)
    (<in4> ^1 <o5> + ^2 <o4> +)
    (<in5> ^1 <o6> + ^2 <o5> +)
    (<in6> ^1 <o7> + ^2 <o6> +)
    (<in7> ^1 <o3> + ^2 <o7> +)
    (<larger-than1> ^item-type predicate + ^handle larger-than1 +
           ^instance <in8> + ^instance <in9> + ^instance <in10> +
           ^instance <in11> + ^instance <in12> + ^instance <in13> +
           ^instance <in14> + ^instance <in15> + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> + ^instance <in25> +)
    (<in8> ^1 <o1> + ^2 <o4> +)
    (<in9> ^1 <o2> + ^2 <o4> +)
    (<in10> ^1 <o3> + ^2 <o4> +)
    (<in11> ^1 <o1> + ^2 <o5> +)
    (<in12> ^1 <o2> + ^2 <o5> +)
    (<in13> ^1 <o3> + ^2 <o5> +)
    (<in14> ^1 <o1> + ^2 <o6> +)
    (<in15> ^1 <o2> + ^2 <o6> +)
    (<in16> ^1 <o3> + ^2 <o6> +)
    (<in17> ^1 <o1> + ^2 <o7> +)
    (<in18> ^1 <o2> + ^2 <o7> +)
    (<in19> ^1 <o3> + ^2 <o7> +)
    (<in20> ^1 <o7> + ^2 <o6> +)
    (<in21> ^1 <o7> + ^2 <o5> +)
    (<in22> ^1 <o7> + ^2 <o4> +)
    (<in23> ^1 <o6> + ^2 <o5> +)
    (<in24> ^1 <o6> + ^2 <o4> +)
    (<in25> ^1 <o5> + ^2 <o4> +)
}

sp {dialog-event*apply*game-state-change-respond*init-3mens
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-3mens)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <near1> +
           ^predicate <diagonal-with1> + ^predicate <linear> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block + ^color red1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block + ^color red1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category block + ^color red1 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block + ^color blue1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category block + ^color blue1 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category block + ^color blue1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +)
    (<in0> ^1 <o10> + ^2 <o11> +)
    (<in1> ^1 <o11> + ^2 <o12> +)
    (<in2> ^1 <o13> + ^2 <o14> +)
    (<in3> ^1 <o14> + ^2 <o15> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in4> +
           ^instance <in5> + ^instance <in6> + ^instance <in7> +)
    (<in4> ^1 <o11> + ^2 <o10> +)
    (<in5> ^1 <o12> + ^2 <o11> +)
    (<in6> ^1 <o14> + ^2 <o13> +)
    (<in7> ^1 <o15> + ^2 <o14> +)
    (<near1> ^item-type predicate + ^handle near1 + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +
           ^instance <in12> + ^instance <in13> + ^instance <in14> +
           ^instance <in15> + ^instance <in16> + ^instance <in17> +
           ^instance <in18> + ^instance <in19> + ^instance <in20> +
           ^instance <in21> + ^instance <in22> + ^instance <in23> +
           ^instance <in24> + ^instance <in25> + ^instance <in26> +
           ^instance <in27> + ^instance <in28> + ^instance <in29> +
           ^instance <in30> + ^instance <in31> + ^instance <in32> +
           ^instance <in33> + ^instance <in34> + ^instance <in35> +
           ^instance <in36> + ^instance <in37> + ^instance <in38> +
           ^instance <in39> + ^instance <in40> + ^instance <in41> +
           ^instance <in42> + ^instance <in43> + ^instance <in44> +
           ^instance <in45> + ^instance <in46> + ^instance <in47> +)
    (<in8> ^1 <o1> + ^2 <o2> +)
    (<in9> ^1 <o1> + ^2 <o4> +)
    (<in10> ^1 <o1> + ^2 <o5> +)
    (<in11> ^1 <o2> + ^2 <o1> +)
    (<in12> ^1 <o2> + ^2 <o3> +)
    (<in13> ^1 <o2> + ^2 <o4> +)
    (<in14> ^1 <o2> + ^2 <o5> +)
    (<in15> ^1 <o2> + ^2 <o6> +)
    (<in16> ^1 <o3> + ^2 <o2> +)
    (<in17> ^1 <o3> + ^2 <o5> +)
    (<in18> ^1 <o3> + ^2 <o6> +)
    (<in19> ^1 <o4> + ^2 <o1> +)
    (<in20> ^1 <o4> + ^2 <o2> +)
    (<in21> ^1 <o4> + ^2 <o5> +)
    (<in22> ^1 <o4> + ^2 <o7> +)
    (<in23> ^1 <o4> + ^2 <o8> +)
    (<in24> ^1 <o5> + ^2 <o1> +)
    (<in25> ^1 <o5> + ^2 <o2> +)
    (<in26> ^1 <o5> + ^2 <o3> +)
    (<in27> ^1 <o5> + ^2 <o4> +)
    (<in28> ^1 <o5> + ^2 <o6> +)
    (<in29> ^1 <o5> + ^2 <o7> +)
    (<in30> ^1 <o5> + ^2 <o8> +)
    (<in31> ^1 <o5> + ^2 <o9> +)
    (<in32> ^1 <o6> + ^2 <o2> +)
    (<in33> ^1 <o6> + ^2 <o3> +)
    (<in34> ^1 <o6> + ^2 <o5> +)
    (<in35> ^1 <o6> + ^2 <o8> +)
    (<in36> ^1 <o6> + ^2 <o9> +)
    (<in37> ^1 <o7> + ^2 <o4> +)
    (<in38> ^1 <o7> + ^2 <o5> +)
    (<in39> ^1 <o7> + ^2 <o8> +)
    (<in40> ^1 <o8> + ^2 <o7> +)
    (<in41> ^1 <o8> + ^2 <o4> +)
    (<in42> ^1 <o8> + ^2 <o5> +)
    (<in43> ^1 <o8> + ^2 <o6> +)
    (<in44> ^1 <o8> + ^2 <o9> +)
    (<in45> ^1 <o9> + ^2 <o8> +)
    (<in46> ^1 <o9> + ^2 <o5> +)
    (<in47> ^1 <o9> + ^2 <o6> +)
    (<diagonal-with1> ^item-type predicate + ^handle diagonal-with1 +
           ^instance <in48> + ^instance <in49> + ^instance <in50> +
           ^instance <in51> + ^instance <in52> + ^instance <in53> +
           ^instance <in54> + ^instance <in55> + ^instance <in56> +
           ^instance <in57> + ^instance <in58> + ^instance <in59> +
           ^instance <in60> + ^instance <in61> + ^instance <in62> +
           ^instance <in63> +)
    (<in48> ^1 <o1> + ^2 <o5> +)
    (<in49> ^1 <o2> + ^2 <o4> +)
    (<in50> ^1 <o2> + ^2 <o6> +)
    (<in51> ^1 <o3> + ^2 <o5> +)
    (<in52> ^1 <o4> + ^2 <o2> +)
    (<in53> ^1 <o4> + ^2 <o8> +)
    (<in54> ^1 <o5> + ^2 <o1> +)
    (<in55> ^1 <o5> + ^2 <o3> +)
    (<in56> ^1 <o5> + ^2 <o7> +)
    (<in57> ^1 <o5> + ^2 <o9> +)
    (<in58> ^1 <o6> + ^2 <o2> +)
    (<in59> ^1 <o6> + ^2 <o8> +)
    (<in60> ^1 <o7> + ^2 <o5> +)
    (<in61> ^1 <o8> + ^2 <o4> +)
    (<in62> ^1 <o8> + ^2 <o6> +)
    (<in63> ^1 <o9> + ^2 <o5> +)
    (<linear> ^item-type predicate + ^handle linear + ^instance <in64> +
           ^instance <in65> + ^instance <in66> + ^instance <in67> +
           ^instance <in68> + ^instance <in69> + ^instance <in70> +
           ^instance <in71> +)
    (<in64> ^1 <set64> +)
    (<set64> ^object <o1> + ^object <o2> + ^object <o3> +)
    (<in65> ^1 <set65> +)
    (<set65> ^object <o1> + ^object <o5> + ^object <o9> +)
    (<in66> ^1 <set66> +)
    (<set66> ^object <o1> + ^object <o4> + ^object <o7> +)
    (<in67> ^1 <set67> +)
    (<set67> ^object <o4> + ^object <o5> + ^object <o6> +)
    (<in68> ^1 <set68> +)
    (<set68> ^object <o7> + ^object <o8> + ^object <o9> +)
    (<in69> ^1 <set69> +)
    (<set69> ^object <o2> + ^object <o5> + ^object <o8> +)
    (<in70> ^1 <set70> +)
    (<set70> ^object <o3> + ^object <o6> + ^object <o9> +)
    (<in71> ^1 <set71> +)
    (<set71> ^object <o3> + ^object <o5> + ^object <o7> +)
}

sp {dialog-event*apply*game-state-change-respond*final-tower3fonon
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-tower3fonon)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color green1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color green1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^color blue1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^size small1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^size medium1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^size large1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> +)
    (<in0> ^1 <o4> + ^2 <o1> +)
    (<in1> ^1 <o5> + ^2 <o2> +)
    (<in2> ^1 <o6> + ^2 <o3> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in3> +
           ^instance <in4> + ^instance <in5> +)
    (<in3> ^1 <o1> + ^2 <o4> +)
    (<in4> ^1 <o2> + ^2 <o5> +)
    (<in5> ^1 <o3> + ^2 <o6> +)
}

sp {dialog-event*apply*game-state-change-respond*final-mac
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-mac)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^shape bank1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^shape bank1 +
           ^name destination1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category block + ^shape missionary1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^shape missionary1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^shape missionary1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^shape cannibal1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^shape cannibal1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block + ^shape cannibal1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category block + ^shape boat1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +)
    (<in0> ^1 <o3> + ^2 <o2> +)
    (<in1> ^1 <o4> + ^2 <o2> +)
    (<in2> ^1 <o5> + ^2 <o2> +)
    (<in3> ^1 <o6> + ^2 <o2> +)
    (<in4> ^1 <o7> + ^2 <o2> +)
    (<in5> ^1 <o8> + ^2 <o2> +)
    (<in6> ^1 <o9> + ^2 <o2> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in7> +
           ^instance <in8> + ^instance <in9> + ^instance <in10> +
           ^instance <in11> + ^instance <in12> + ^instance <in13> +)
    (<in7> ^1 <o2> + ^2 <o3> +)
    (<in8> ^1 <o2> + ^2 <o4> +)
    (<in9> ^1 <o2> + ^2 <o5> +)
    (<in10> ^1 <o2> + ^2 <o6> +)
    (<in11> ^1 <o2> + ^2 <o7> +)
    (<in12> ^1 <o2> + ^2 <o8> +)
    (<in13> ^1 <o2> + ^2 <o9> +)
}

sp {dialog-event*apply*game-state-change-respond*init-peg
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-peg)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> + ^object <o17> + ^object <o18> + ^object <o19> +
           ^object <o20> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^x 1 + ^y 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^x 2 + ^y 1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^x 3 + ^y 1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^x 4 + ^y 1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^x 1 + ^y 2 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^x 2 + ^y 2 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^x 3 + ^y 2 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^x 1 + ^y 3 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^x 2 + ^y 3 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^x 1 + ^y 4 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category block +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category block +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category block +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category block +)
    (<o17> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category block +)
    (<o18> ^item-type object + ^handle object-17 + ^predicates <pr17> +)
    (<pr17> ^visible true + ^category block +)
    (<o19> ^item-type object + ^handle object-18 + ^predicates <pr18> +)
    (<pr18> ^visible true + ^category block +)
    (<o20> ^item-type object + ^handle object-19 + ^predicates <pr19> +)
    (<pr19> ^visible true + ^category object + ^name garbage +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +
           ^instance <in7> + ^instance <in8> +)
    (<in0> ^1 <o11> + ^2 <o1> +)
    (<in1> ^1 <o12> + ^2 <o2> +)
    (<in2> ^1 <o13> + ^2 <o3> +)
    (<in3> ^1 <o14> + ^2 <o4> +)
    (<in4> ^1 <o15> + ^2 <o5> +)
    (<in5> ^1 <o16> + ^2 <o6> +)
    (<in6> ^1 <o17> + ^2 <o7> +)
    (<in7> ^1 <o18> + ^2 <o9> +)
    (<in8> ^1 <o19> + ^2 <o10> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in9> +
           ^instance <in10> + ^instance <in11> + ^instance <in12> +
           ^instance <in13> + ^instance <in14> + ^instance <in15> +
           ^instance <in16> + ^instance <in17> +)
    (<in9> ^1 <o1> + ^2 <o11> +)
    (<in10> ^1 <o2> + ^2 <o12> +)
    (<in11> ^1 <o3> + ^2 <o13> +)
    (<in12> ^1 <o4> + ^2 <o14> +)
    (<in13> ^1 <o5> + ^2 <o15> +)
    (<in14> ^1 <o6> + ^2 <o16> +)
    (<in15> ^1 <o7> + ^2 <o17> +)
    (<in16> ^1 <o9> + ^2 <o18> +)
    (<in17> ^1 <o10> + ^2 <o19> +)
}

sp {dialog-event*apply*game-state-change-respond*final-fox
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-fox)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^shape bank1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^shape bank1 +
           ^name destination1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category block + ^color red1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^color yellow1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^color green1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^shape boat1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +)
    (<in0> ^1 <o4> + ^2 <o2> +)
    (<in1> ^1 <o5> + ^2 <o2> +)
    (<in2> ^1 <o6> + ^2 <o2> +)
    (<in3> ^1 <o3> + ^2 <o2> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in4> +
           ^instance <in5> + ^instance <in6> + ^instance <in7> +)
    (<in4> ^1 <o2> + ^2 <o4> +)
    (<in5> ^1 <o2> + ^2 <o5> +)
    (<in6> ^1 <o2> + ^2 <o6> +)
    (<in7> ^1 <o2> + ^2 <o3> +)
}

sp {dialog-event*apply*game-state-change-respond*fail-othello
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type fail-othello)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> + ^object <o17> + ^object <o18> + ^object <o19> +
           ^object <o20> + ^object <o21> + ^object <o22> + ^object <o23> +
           ^object <o24> + ^object <o25> + ^object <o26> + ^object <o27> +
           ^object <o28> + ^object <o29> + ^object <o30> + ^object <o31> +
           ^object <o32> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^x 1 + ^y 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^x 2 + ^y 1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^x 3 + ^y 1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^x 4 + ^y 1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^x 1 + ^y 2 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^x 2 + ^y 2 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^x 3 + ^y 2 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^x 4 + ^y 2 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^x 1 + ^y 3 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^x 2 + ^y 3 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location + ^x 3 + ^y 3 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location + ^x 4 + ^y 3 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category location + ^x 1 + ^y 4 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category location + ^x 2 + ^y 4 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category location + ^x 3 + ^y 4 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category location + ^x 4 + ^y 4 +)
    (<o17> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category block + ^color red1 +)
    (<o18> ^item-type object + ^handle object-17 + ^predicates <pr17> +)
    (<pr17> ^visible true + ^category block + ^color red1 +)
    (<o19> ^item-type object + ^handle object-18 + ^predicates <pr18> +)
    (<pr18> ^visible true + ^category block + ^color red1 +)
    (<o20> ^item-type object + ^handle object-19 + ^predicates <pr19> +)
    (<pr19> ^visible true + ^category block + ^color blue1 +)
    (<o21> ^item-type object + ^handle object-20 + ^predicates <pr20> +)
    (<pr20> ^visible true + ^category block + ^color blue1 +)
    (<o22> ^item-type object + ^handle object-21 + ^predicates <pr21> +)
    (<pr21> ^visible true + ^category block + ^color blue1 +)
    (<o23> ^item-type object + ^handle object-22 + ^predicates <pr22> +)
    (<pr22> ^visible true + ^category block + ^color blue1 +)
    (<o24> ^item-type object + ^handle object-23 + ^predicates <pr23> +)
    (<pr23> ^visible true + ^category block + ^color blue1 +)
    (<o25> ^item-type object + ^handle object-24 + ^predicates <pr24> +)
    (<pr24> ^visible true + ^category block + ^color red1 +)
    (<o26> ^item-type object + ^handle object-25 + ^predicates <pr25> +)
    (<pr25> ^visible true + ^category block + ^color blue1 +)
    (<o27> ^item-type object + ^handle object-26 + ^predicates <pr26> +)
    (<pr26> ^visible true + ^category block + ^color red1 +)
    (<o28> ^item-type object + ^handle object-27 + ^predicates <pr27> +)
    (<pr27> ^visible true + ^category block + ^color blue1 +)
    (<o29> ^item-type object + ^handle object-28 + ^predicates <pr28> +)
    (<pr28> ^visible true + ^category block + ^color red1 +)
    (<o30> ^item-type object + ^handle object-29 + ^predicates <pr29> +)
    (<pr29> ^visible true + ^category block + ^color blue1 +)
    (<o31> ^item-type object + ^handle object-30 + ^predicates <pr30> +)
    (<pr30> ^visible true + ^category block + ^color blue1 +)
    (<o32> ^item-type object + ^handle object-31 + ^predicates <pr31> +)
    (<pr31> ^visible true + ^category block + ^color blue1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +
           ^instance <in7> + ^instance <in8> + ^instance <in9> +
           ^instance <in10> + ^instance <in11> + ^instance <in12> +
           ^instance <in13> + ^instance <in14> + ^instance <in15> +)
    (<in0> ^1 <o17> + ^2 <o1> +)
    (<in1> ^1 <o18> + ^2 <o2> +)
    (<in2> ^1 <o19> + ^2 <o3> +)
    (<in3> ^1 <o20> + ^2 <o4> +)
    (<in4> ^1 <o21> + ^2 <o5> +)
    (<in5> ^1 <o22> + ^2 <o6> +)
    (<in6> ^1 <o23> + ^2 <o7> +)
    (<in7> ^1 <o24> + ^2 <o8> +)
    (<in8> ^1 <o25> + ^2 <o9> +)
    (<in9> ^1 <o26> + ^2 <o10> +)
    (<in10> ^1 <o27> + ^2 <o11> +)
    (<in11> ^1 <o28> + ^2 <o12> +)
    (<in12> ^1 <o29> + ^2 <o13> +)
    (<in13> ^1 <o30> + ^2 <o14> +)
    (<in14> ^1 <o31> + ^2 <o15> +)
    (<in15> ^1 <o32> + ^2 <o16> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> + ^instance <in25> +
           ^instance <in26> + ^instance <in27> + ^instance <in28> +
           ^instance <in29> + ^instance <in30> + ^instance <in31> +)
    (<in16> ^1 <o1> + ^2 <o17> +)
    (<in17> ^1 <o2> + ^2 <o18> +)
    (<in18> ^1 <o3> + ^2 <o19> +)
    (<in19> ^1 <o4> + ^2 <o20> +)
    (<in20> ^1 <o5> + ^2 <o21> +)
    (<in21> ^1 <o6> + ^2 <o22> +)
    (<in22> ^1 <o7> + ^2 <o23> +)
    (<in23> ^1 <o8> + ^2 <o24> +)
    (<in24> ^1 <o9> + ^2 <o25> +)
    (<in25> ^1 <o10> + ^2 <o26> +)
    (<in26> ^1 <o11> + ^2 <o27> +)
    (<in27> ^1 <o12> + ^2 <o28> +)
    (<in28> ^1 <o13> + ^2 <o29> +)
    (<in29> ^1 <o14> + ^2 <o30> +)
    (<in30> ^1 <o15> + ^2 <o31> +)
    (<in31> ^1 <o16> + ^2 <o32> +)
}

sp {dialog-event*apply*game-state-change-respond*init-lzstacked-frogs
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-lzstacked-frogs)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^x 1 + ^y 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^x 2 + ^y 1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^x 3 + ^y 1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^x 4 + ^y 1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^color red1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +)
    (<in0> ^1 <o5> + ^2 <o1> +)
    (<in1> ^1 <o6> + ^2 <o2> +)
    (<in2> ^1 <o7> + ^2 <o3> +)
    (<in3> ^1 <o8> + ^2 <o4> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in4> +
           ^instance <in5> + ^instance <in6> + ^instance <in7> +)
    (<in4> ^1 <o1> + ^2 <o5> +)
    (<in5> ^1 <o2> + ^2 <o6> +)
    (<in6> ^1 <o3> + ^2 <o7> +)
    (<in7> ^1 <o4> + ^2 <o8> +)
}

sp {dialog-event*apply*game-state-change-respond*final-pushmaze
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-pushmaze)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> + ^object <o17> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <near1> +
           ^predicate <diagonal-with1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^x 1 + ^y 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^x 2 + ^y 1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^x 3 + ^y 1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^x 1 + ^y 2 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^x 2 + ^y 2 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^x 3 + ^y 2 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^x 1 + ^y 3 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^x 2 + ^y 3 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^x 3 + ^y 3 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^x 1 + ^y 4 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location + ^x 2 + ^y 4 + ^color blue1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location + ^x 3 + ^y 4 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block + ^color blue1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category block + ^color black1 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category block + ^color black1 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category block + ^color black1 +)
    (<o17> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category block + ^color black1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> +)
    (<in0> ^1 <o13> + ^2 <o11> +)
    (<in1> ^1 <o14> + ^2 <o10> +)
    (<in2> ^1 <o15> + ^2 <o5> +)
    (<in3> ^1 <o16> + ^2 <o6> +)
    (<in4> ^1 <o17> + ^2 <o9> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in5> +
           ^instance <in6> + ^instance <in7> + ^instance <in8> +
           ^instance <in9> +)
    (<in5> ^1 <o11> + ^2 <o13> +)
    (<in6> ^1 <o10> + ^2 <o14> +)
    (<in7> ^1 <o5> + ^2 <o15> +)
    (<in8> ^1 <o6> + ^2 <o16> +)
    (<in9> ^1 <o9> + ^2 <o17> +)
    (<near1> ^item-type predicate + ^handle near1 + ^instance <in10> +
           ^instance <in11> + ^instance <in12> + ^instance <in13> +
           ^instance <in14> + ^instance <in15> + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> + ^instance <in25> +
           ^instance <in26> + ^instance <in27> + ^instance <in28> +
           ^instance <in29> + ^instance <in30> + ^instance <in31> +
           ^instance <in32> + ^instance <in33> + ^instance <in34> +
           ^instance <in35> + ^instance <in36> + ^instance <in37> +
           ^instance <in38> + ^instance <in39> + ^instance <in40> +
           ^instance <in41> + ^instance <in42> + ^instance <in43> +
           ^instance <in44> + ^instance <in45> + ^instance <in46> +
           ^instance <in47> + ^instance <in48> + ^instance <in49> +
           ^instance <in50> + ^instance <in51> + ^instance <in52> +
           ^instance <in53> + ^instance <in54> + ^instance <in55> +
           ^instance <in56> + ^instance <in57> + ^instance <in58> +
           ^instance <in59> + ^instance <in60> + ^instance <in61> +
           ^instance <in62> + ^instance <in63> + ^instance <in64> +
           ^instance <in65> + ^instance <in66> + ^instance <in67> +)
    (<in10> ^1 <o1> + ^2 <o2> +)
    (<in11> ^1 <o1> + ^2 <o4> +)
    (<in12> ^1 <o1> + ^2 <o5> +)
    (<in13> ^1 <o2> + ^2 <o1> +)
    (<in14> ^1 <o2> + ^2 <o3> +)
    (<in15> ^1 <o2> + ^2 <o4> +)
    (<in16> ^1 <o2> + ^2 <o5> +)
    (<in17> ^1 <o2> + ^2 <o6> +)
    (<in18> ^1 <o3> + ^2 <o2> +)
    (<in19> ^1 <o3> + ^2 <o5> +)
    (<in20> ^1 <o3> + ^2 <o6> +)
    (<in21> ^1 <o4> + ^2 <o1> +)
    (<in22> ^1 <o4> + ^2 <o2> +)
    (<in23> ^1 <o4> + ^2 <o5> +)
    (<in24> ^1 <o4> + ^2 <o7> +)
    (<in25> ^1 <o4> + ^2 <o8> +)
    (<in26> ^1 <o5> + ^2 <o1> +)
    (<in27> ^1 <o5> + ^2 <o2> +)
    (<in28> ^1 <o5> + ^2 <o3> +)
    (<in29> ^1 <o5> + ^2 <o4> +)
    (<in30> ^1 <o5> + ^2 <o6> +)
    (<in31> ^1 <o5> + ^2 <o7> +)
    (<in32> ^1 <o5> + ^2 <o8> +)
    (<in33> ^1 <o5> + ^2 <o9> +)
    (<in34> ^1 <o6> + ^2 <o2> +)
    (<in35> ^1 <o6> + ^2 <o3> +)
    (<in36> ^1 <o6> + ^2 <o5> +)
    (<in37> ^1 <o6> + ^2 <o8> +)
    (<in38> ^1 <o6> + ^2 <o9> +)
    (<in39> ^1 <o7> + ^2 <o4> +)
    (<in40> ^1 <o7> + ^2 <o5> +)
    (<in41> ^1 <o7> + ^2 <o8> +)
    (<in42> ^1 <o8> + ^2 <o7> +)
    (<in43> ^1 <o8> + ^2 <o4> +)
    (<in44> ^1 <o8> + ^2 <o5> +)
    (<in45> ^1 <o8> + ^2 <o6> +)
    (<in46> ^1 <o8> + ^2 <o9> +)
    (<in47> ^1 <o9> + ^2 <o8> +)
    (<in48> ^1 <o9> + ^2 <o5> +)
    (<in49> ^1 <o9> + ^2 <o6> +)
    (<in50> ^1 <o9> + ^2 <o11> +)
    (<in51> ^1 <o9> + ^2 <o12> +)
    (<in52> ^1 <o8> + ^2 <o19> +)
    (<in53> ^1 <o8> + ^2 <o11> +)
    (<in54> ^1 <o8> + ^2 <o12> +)
    (<in55> ^1 <o7> + ^2 <o10> +)
    (<in56> ^1 <o7> + ^2 <o11> +)
    (<in57> ^1 <o10> + ^2 <o7> +)
    (<in58> ^1 <o10> + ^2 <o8> +)
    (<in59> ^1 <o10> + ^2 <o11> +)
    (<in60> ^1 <o11> + ^2 <o10> +)
    (<in61> ^1 <o11> + ^2 <o7> +)
    (<in62> ^1 <o11> + ^2 <o8> +)
    (<in63> ^1 <o11> + ^2 <o9> +)
    (<in64> ^1 <o11> + ^2 <o12> +)
    (<in65> ^1 <o12> + ^2 <o11> +)
    (<in66> ^1 <o12> + ^2 <o8> +)
    (<in67> ^1 <o12> + ^2 <o9> +)
    (<diagonal-with1> ^item-type predicate + ^handle diagonal-with1 +
           ^instance <in68> + ^instance <in69> + ^instance <in70> +
           ^instance <in71> + ^instance <in72> + ^instance <in73> +
           ^instance <in74> + ^instance <in75> + ^instance <in76> +
           ^instance <in77> + ^instance <in78> + ^instance <in79> +
           ^instance <in80> + ^instance <in81> + ^instance <in82> +
           ^instance <in83> + ^instance <in84> + ^instance <in85> +
           ^instance <in86> + ^instance <in87> + ^instance <in88> +
           ^instance <in89> + ^instance <in90> + ^instance <in91> +)
    (<in68> ^1 <o1> + ^2 <o5> +)
    (<in69> ^1 <o2> + ^2 <o4> +)
    (<in70> ^1 <o2> + ^2 <o6> +)
    (<in71> ^1 <o3> + ^2 <o5> +)
    (<in72> ^1 <o4> + ^2 <o2> +)
    (<in73> ^1 <o4> + ^2 <o8> +)
    (<in74> ^1 <o5> + ^2 <o1> +)
    (<in75> ^1 <o5> + ^2 <o3> +)
    (<in76> ^1 <o5> + ^2 <o7> +)
    (<in77> ^1 <o5> + ^2 <o9> +)
    (<in78> ^1 <o6> + ^2 <o2> +)
    (<in79> ^1 <o6> + ^2 <o8> +)
    (<in80> ^1 <o7> + ^2 <o5> +)
    (<in81> ^1 <o8> + ^2 <o4> +)
    (<in82> ^1 <o8> + ^2 <o6> +)
    (<in83> ^1 <o9> + ^2 <o5> +)
    (<in84> ^1 <o9> + ^2 <o11> +)
    (<in85> ^1 <o11> + ^2 <o9> +)
    (<in86> ^1 <o12> + ^2 <o8> +)
    (<in87> ^1 <o8> + ^2 <o12> +)
    (<in88> ^1 <o10> + ^2 <o8> +)
    (<in89> ^1 <o8> + ^2 <o10> +)
    (<in90> ^1 <o11> + ^2 <o7> +)
    (<in91> ^1 <o7> + ^2 <o11> +)
}

sp {dialog-event*apply*game-state-change-respond*final-mini-sudoku
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-mini-sudoku)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^row 1 + ^column 1 +
           ^value 3 + ^section 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^row 2 + ^column 1 +
           ^value 1 + ^section 1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^row 3 + ^column 1 +
           ^value 2 + ^section 2 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^row 4 + ^column 1 +
           ^value 4 + ^section 2 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^row 1 + ^column 2 +
           ^value 4 + ^section 1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^row 2 + ^column 2 +
           ^value 2 + ^section 1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^row 3 + ^column 2 +
           ^value 1 + ^section 2 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^row 4 + ^column 2 +
           ^value 3 + ^section 2 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^row 1 + ^column 3 +
           ^value 1 + ^section 3 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^row 2 + ^column 3 +
           ^value 3 + ^section 3 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location + ^row 3 + ^column 3 +
           ^value 4 + ^section 4 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location + ^row 4 + ^column 3 +
           ^value 2 + ^section 4 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category location + ^row 1 + ^column 4 +
           ^value 2 + ^section 3 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category location + ^row 2 + ^column 4 +
           ^value 4 + ^section 3 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category location + ^row 3 + ^column 4 +
           ^value 3 + ^section 4 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category location + ^row 4 + ^column 4 +
           ^value 1 + ^section 4 +)
}

sp {dialog-event*apply*game-state-change-respond*fail-breakthrough
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type fail-breakthrough)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> + ^object <o17> + ^object <o18> + ^object <o19> +
           ^object <o20> + ^object <o21> + ^object <o22> + ^object <o23> +
           ^object <o24> + ^object <o25> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <above1> +
           ^predicate <under1> + ^predicate <diagonal-with1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color blue1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color blue1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^color blue1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^color blue1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category location + ^color red1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category location + ^color red1 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category location + ^color red1 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category location + ^color red1 +)
    (<o17> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category block + ^color red1 +)
    (<o18> ^item-type object + ^handle object-17 + ^predicates <pr17> +)
    (<pr17> ^visible true + ^category block + ^color red1 +)
    (<o19> ^item-type object + ^handle object-18 + ^predicates <pr18> +)
    (<pr18> ^visible true + ^category block + ^color red1 +)
    (<o20> ^item-type object + ^handle object-19 + ^predicates <pr19> +)
    (<pr19> ^visible true + ^category block + ^color red1 +)
    (<o21> ^item-type object + ^handle object-20 + ^predicates <pr20> +)
    (<pr20> ^visible true + ^category block + ^color blue1 +)
    (<o22> ^item-type object + ^handle object-21 + ^predicates <pr21> +)
    (<pr21> ^visible true + ^category block + ^color blue1 +)
    (<o23> ^item-type object + ^handle object-22 + ^predicates <pr22> +)
    (<pr22> ^visible true + ^category block + ^color blue1 +)
    (<o24> ^item-type object + ^handle object-23 + ^predicates <pr23> +)
    (<pr23> ^visible true + ^category block + ^color blue1 +)
    (<o25> ^item-type object + ^handle object-24 + ^predicates <pr24> +)
    (<pr24> ^visible true + ^category location + ^name garbage +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +
           ^instance <in7> +)
    (<in0> ^1 <o17> + ^2 <o25> +)
    (<in1> ^1 <o18> + ^2 <o2> +)
    (<in2> ^1 <o19> + ^2 <o3> +)
    (<in3> ^1 <o20> + ^2 <o10> +)
    (<in4> ^1 <o21> + ^2 <o1> +)
    (<in5> ^1 <o22> + ^2 <o14> +)
    (<in6> ^1 <o23> + ^2 <o15> +)
    (<in7> ^1 <o24> + ^2 <o16> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +
           ^instance <in12> + ^instance <in13> + ^instance <in14> +
           ^instance <in15> +)
    (<in8> ^1 <o25> + ^2 <o17> +)
    (<in9> ^1 <o2> + ^2 <o18> +)
    (<in10> ^1 <o3> + ^2 <o19> +)
    (<in11> ^1 <o10> + ^2 <o20> +)
    (<in12> ^1 <o1> + ^2 <o21> +)
    (<in13> ^1 <o14> + ^2 <o22> +)
    (<in14> ^1 <o15> + ^2 <o23> +)
    (<in15> ^1 <o16> + ^2 <o24> +)
    (<above1> ^item-type predicate + ^handle above1 + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> + ^instance <in25> +
           ^instance <in26> + ^instance <in27> + ^instance <in28> +
           ^instance <in29> + ^instance <in30> + ^instance <in31> +
           ^instance <in32> + ^instance <in33> + ^instance <in34> +
           ^instance <in35> + ^instance <in36> + ^instance <in37> +
           ^instance <in38> + ^instance <in39> + ^instance <in40> +
           ^instance <in41> + ^instance <in42> + ^instance <in43> +
           ^instance <in44> + ^instance <in45> +)
    (<in16> ^1 <o13> + ^2 <o7> +)
    (<in17> ^1 <o14> + ^2 <o7> +)
    (<in18> ^1 <o13> + ^2 <o8> +)
    (<in19> ^1 <o14> + ^2 <o8> +)
    (<in20> ^1 <o15> + ^2 <o8> +)
    (<in21> ^1 <o14> + ^2 <o9> +)
    (<in22> ^1 <o15> + ^2 <o9> +)
    (<in23> ^1 <o16> + ^2 <o9> +)
    (<in24> ^1 <o15> + ^2 <o12> +)
    (<in25> ^1 <o16> + ^2 <o12> +)
    (<in26> ^1 <o7> + ^2 <o4> +)
    (<in27> ^1 <o8> + ^2 <o4> +)
    (<in28> ^1 <o7> + ^2 <o5> +)
    (<in29> ^1 <o8> + ^2 <o5> +)
    (<in30> ^1 <o9> + ^2 <o5> +)
    (<in31> ^1 <o8> + ^2 <o6> +)
    (<in32> ^1 <o9> + ^2 <o6> +)
    (<in33> ^1 <o12> + ^2 <o6> +)
    (<in34> ^1 <o9> + ^2 <o11> +)
    (<in35> ^1 <o12> + ^2 <o11> +)
    (<in36> ^1 <o4> + ^2 <o1> +)
    (<in37> ^1 <o5> + ^2 <o1> +)
    (<in38> ^1 <o4> + ^2 <o2> +)
    (<in39> ^1 <o5> + ^2 <o2> +)
    (<in40> ^1 <o6> + ^2 <o2> +)
    (<in41> ^1 <o5> + ^2 <o3> +)
    (<in42> ^1 <o6> + ^2 <o3> +)
    (<in43> ^1 <o11> + ^2 <o3> +)
    (<in44> ^1 <o6> + ^2 <o10> +)
    (<in45> ^1 <o11> + ^2 <o10> +)
    (<under1> ^item-type predicate + ^handle under1 + ^instance <in46> +
           ^instance <in47> + ^instance <in48> + ^instance <in49> +
           ^instance <in50> + ^instance <in51> + ^instance <in52> +
           ^instance <in53> + ^instance <in54> + ^instance <in55> +
           ^instance <in56> + ^instance <in57> + ^instance <in58> +
           ^instance <in59> + ^instance <in60> + ^instance <in61> +
           ^instance <in62> + ^instance <in63> + ^instance <in64> +
           ^instance <in65> + ^instance <in66> + ^instance <in67> +
           ^instance <in68> + ^instance <in69> + ^instance <in70> +
           ^instance <in71> + ^instance <in72> + ^instance <in73> +
           ^instance <in74> + ^instance <in75> +)
    (<in46> ^1 <o7> + ^2 <o13> +)
    (<in47> ^1 <o7> + ^2 <o14> +)
    (<in48> ^1 <o8> + ^2 <o13> +)
    (<in49> ^1 <o8> + ^2 <o14> +)
    (<in50> ^1 <o8> + ^2 <o15> +)
    (<in51> ^1 <o9> + ^2 <o14> +)
    (<in52> ^1 <o9> + ^2 <o15> +)
    (<in53> ^1 <o9> + ^2 <o16> +)
    (<in54> ^1 <o12> + ^2 <o15> +)
    (<in55> ^1 <o12> + ^2 <o16> +)
    (<in56> ^1 <o4> + ^2 <o7> +)
    (<in57> ^1 <o4> + ^2 <o8> +)
    (<in58> ^1 <o5> + ^2 <o7> +)
    (<in59> ^1 <o5> + ^2 <o8> +)
    (<in60> ^1 <o5> + ^2 <o9> +)
    (<in61> ^1 <o6> + ^2 <o8> +)
    (<in62> ^1 <o6> + ^2 <o9> +)
    (<in63> ^1 <o6> + ^2 <o12> +)
    (<in64> ^1 <o11> + ^2 <o9> +)
    (<in65> ^1 <o11> + ^2 <o12> +)
    (<in66> ^1 <o1> + ^2 <o4> +)
    (<in67> ^1 <o1> + ^2 <o5> +)
    (<in68> ^1 <o2> + ^2 <o4> +)
    (<in69> ^1 <o2> + ^2 <o5> +)
    (<in70> ^1 <o2> + ^2 <o6> +)
    (<in71> ^1 <o3> + ^2 <o5> +)
    (<in72> ^1 <o3> + ^2 <o6> +)
    (<in73> ^1 <o3> + ^2 <o11> +)
    (<in74> ^1 <o10> + ^2 <o6> +)
    (<in75> ^1 <o10> + ^2 <o11> +)
    (<diagonal-with1> ^item-type predicate + ^handle diagonal-with1 +
           ^instance <in76> + ^instance <in77> + ^instance <in78> +
           ^instance <in79> + ^instance <in80> + ^instance <in81> +
           ^instance <in82> + ^instance <in83> + ^instance <in84> +
           ^instance <in85> + ^instance <in86> + ^instance <in87> +
           ^instance <in88> + ^instance <in89> + ^instance <in90> +
           ^instance <in91> + ^instance <in92> + ^instance <in93> +
           ^instance <in94> + ^instance <in95> + ^instance <in96> +
           ^instance <in97> + ^instance <in98> + ^instance <in99> +
           ^instance <in100> + ^instance <in101> + ^instance <in102> +
           ^instance <in103> + ^instance <in104> + ^instance <in105> +
           ^instance <in106> + ^instance <in107> + ^instance <in108> +
           ^instance <in109> + ^instance <in110> + ^instance <in111> +)
    (<in76> ^1 <o1> + ^2 <o5> +)
    (<in77> ^1 <o2> + ^2 <o4> +)
    (<in78> ^1 <o2> + ^2 <o6> +)
    (<in79> ^1 <o3> + ^2 <o5> +)
    (<in80> ^1 <o4> + ^2 <o2> +)
    (<in81> ^1 <o4> + ^2 <o8> +)
    (<in82> ^1 <o5> + ^2 <o1> +)
    (<in83> ^1 <o5> + ^2 <o3> +)
    (<in84> ^1 <o5> + ^2 <o7> +)
    (<in85> ^1 <o5> + ^2 <o9> +)
    (<in86> ^1 <o6> + ^2 <o2> +)
    (<in87> ^1 <o6> + ^2 <o8> +)
    (<in88> ^1 <o7> + ^2 <o5> +)
    (<in89> ^1 <o8> + ^2 <o4> +)
    (<in90> ^1 <o8> + ^2 <o6> +)
    (<in91> ^1 <o9> + ^2 <o5> +)
    (<in92> ^1 <o3> + ^2 <o11> +)
    (<in93> ^1 <o11> + ^2 <o3> +)
    (<in94> ^1 <o6> + ^2 <o10> +)
    (<in95> ^1 <o10> + ^2 <o6> +)
    (<in96> ^1 <o9> + ^2 <o11> +)
    (<in97> ^1 <o11> + ^2 <o9> +)
    (<in98> ^1 <o12> + ^2 <o6> +)
    (<in99> ^1 <o6> + ^2 <o12> +)
    (<in100> ^1 <o16> + ^2 <o9> +)
    (<in101> ^1 <o9> + ^2 <o16> +)
    (<in102> ^1 <o12> + ^2 <o15> +)
    (<in103> ^1 <o15> + ^2 <o12> +)
    (<in104> ^1 <o14> + ^2 <o9> +)
    (<in105> ^1 <o9> + ^2 <o14> +)
    (<in106> ^1 <o8> + ^2 <o15> +)
    (<in107> ^1 <o15> + ^2 <o8> +)
    (<in108> ^1 <o14> + ^2 <o7> +)
    (<in109> ^1 <o7> + ^2 <o14> +)
    (<in110> ^1 <o13> + ^2 <o8> +)
    (<in111> ^1 <o8> + ^2 <o13> +)
}

sp {dialog-event*apply*game-state-change-respond*init-i15puzzle
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-i15puzzle)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> + ^object <o17> + ^object <o18> + ^object <o19> +
           ^object <o20> + ^object <o21> + ^object <o22> + ^object <o23> +
           ^object <o24> + ^object <o25> + ^object <o26> + ^object <o27> +
           ^object <o28> + ^object <o29> + ^object <o30> + ^object <o31> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <near1> +
           ^predicate <diagonal-with1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^value 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^value 2 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^value 3 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^value 4 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^value 5 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^value 6 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^value 7 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^value 8 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^value 9 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^value 10 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location + ^value 11 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location + ^value 12 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category location + ^value 13 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category location + ^value 14 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category location + ^value 15 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category location + ^value 16 +)
    (<o17> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category block + ^value 1 +)
    (<o18> ^item-type object + ^handle object-17 + ^predicates <pr17> +)
    (<pr17> ^visible true + ^category block + ^value 2 +)
    (<o19> ^item-type object + ^handle object-18 + ^predicates <pr18> +)
    (<pr18> ^visible true + ^category block + ^value 3 +)
    (<o20> ^item-type object + ^handle object-19 + ^predicates <pr19> +)
    (<pr19> ^visible true + ^category block + ^value 4 +)
    (<o21> ^item-type object + ^handle object-20 + ^predicates <pr20> +)
    (<pr20> ^visible true + ^category block + ^value 5 +)
    (<o22> ^item-type object + ^handle object-21 + ^predicates <pr21> +)
    (<pr21> ^visible true + ^category block + ^value 6 +)
    (<o23> ^item-type object + ^handle object-22 + ^predicates <pr22> +)
    (<pr22> ^visible true + ^category block + ^value 7 +)
    (<o24> ^item-type object + ^handle object-23 + ^predicates <pr23> +)
    (<pr23> ^visible true + ^category block + ^value 8 +)
    (<o25> ^item-type object + ^handle object-24 + ^predicates <pr24> +)
    (<pr24> ^visible true + ^category block + ^value 9 +)
    (<o26> ^item-type object + ^handle object-25 + ^predicates <pr25> +)
    (<pr25> ^visible true + ^category block + ^value 16 +)
    (<o27> ^item-type object + ^handle object-26 + ^predicates <pr26> +)
    (<pr26> ^visible true + ^category block + ^value 11 +)
    (<o28> ^item-type object + ^handle object-27 + ^predicates <pr27> +)
    (<pr27> ^visible true + ^category block + ^value 12 +)
    (<o29> ^item-type object + ^handle object-28 + ^predicates <pr28> +)
    (<pr28> ^visible true + ^category block + ^value 13 +)
    (<o30> ^item-type object + ^handle object-29 + ^predicates <pr29> +)
    (<pr29> ^visible true + ^category block + ^value 14 +)
    (<o31> ^item-type object + ^handle object-30 + ^predicates <pr30> +)
    (<pr30> ^visible true + ^category block + ^value 15 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +
           ^instance <in7> + ^instance <in8> + ^instance <in9> +
           ^instance <in10> + ^instance <in11> + ^instance <in12> +
           ^instance <in13> + ^instance <in14> +)
    (<in0> ^1 <o17> + ^2 <o1> +)
    (<in1> ^1 <o18> + ^2 <o2> +)
    (<in2> ^1 <o19> + ^2 <o10> +)
    (<in3> ^1 <o20> + ^2 <o4> +)
    (<in4> ^1 <o21> + ^2 <o5> +)
    (<in5> ^1 <o22> + ^2 <o6> +)
    (<in6> ^1 <o23> + ^2 <o7> +)
    (<in7> ^1 <o24> + ^2 <o8> +)
    (<in8> ^1 <o25> + ^2 <o9> +)
    (<in9> ^1 <o26> + ^2 <o16> +)
    (<in10> ^1 <o27> + ^2 <o11> +)
    (<in11> ^1 <o28> + ^2 <o12> +)
    (<in12> ^1 <o29> + ^2 <o13> +)
    (<in13> ^1 <o30> + ^2 <o14> +)
    (<in14> ^1 <o31> + ^2 <o15> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in15> +
           ^instance <in16> + ^instance <in17> + ^instance <in18> +
           ^instance <in19> + ^instance <in20> + ^instance <in21> +
           ^instance <in22> + ^instance <in23> + ^instance <in24> +
           ^instance <in25> + ^instance <in26> + ^instance <in27> +
           ^instance <in28> + ^instance <in29> +)
    (<in15> ^1 <o1> + ^2 <o17> +)
    (<in16> ^1 <o2> + ^2 <o18> +)
    (<in17> ^1 <o10> + ^2 <o19> +)
    (<in18> ^1 <o4> + ^2 <o20> +)
    (<in19> ^1 <o5> + ^2 <o21> +)
    (<in20> ^1 <o6> + ^2 <o22> +)
    (<in21> ^1 <o7> + ^2 <o23> +)
    (<in22> ^1 <o8> + ^2 <o24> +)
    (<in23> ^1 <o9> + ^2 <o25> +)
    (<in24> ^1 <o16> + ^2 <o26> +)
    (<in25> ^1 <o11> + ^2 <o27> +)
    (<in26> ^1 <o12> + ^2 <o28> +)
    (<in27> ^1 <o13> + ^2 <o29> +)
    (<in28> ^1 <o14> + ^2 <o30> +)
    (<in29> ^1 <o15> + ^2 <o31> +)
    (<near1> ^item-type predicate + ^handle near1 + ^instance <in30> +
           ^instance <in31> + ^instance <in32> + ^instance <in33> +
           ^instance <in34> + ^instance <in35> + ^instance <in36> +
           ^instance <in37> + ^instance <in38> + ^instance <in39> +
           ^instance <in40> + ^instance <in41> + ^instance <in42> +
           ^instance <in43> + ^instance <in44> + ^instance <in45> +
           ^instance <in46> + ^instance <in47> + ^instance <in48> +
           ^instance <in49> + ^instance <in50> + ^instance <in51> +
           ^instance <in52> + ^instance <in53> + ^instance <in54> +
           ^instance <in55> + ^instance <in56> + ^instance <in57> +
           ^instance <in58> + ^instance <in59> + ^instance <in60> +
           ^instance <in61> + ^instance <in62> + ^instance <in63> +
           ^instance <in64> + ^instance <in65> + ^instance <in66> +
           ^instance <in67> + ^instance <in68> + ^instance <in69> +
           ^instance <in70> + ^instance <in71> + ^instance <in72> +
           ^instance <in73> + ^instance <in74> + ^instance <in75> +
           ^instance <in76> + ^instance <in77> + ^instance <in78> +
           ^instance <in79> + ^instance <in80> + ^instance <in81> +
           ^instance <in82> + ^instance <in83> + ^instance <in84> +
           ^instance <in85> + ^instance <in86> + ^instance <in87> +
           ^instance <in88> + ^instance <in89> + ^instance <in90> +
           ^instance <in91> + ^instance <in92> + ^instance <in93> +
           ^instance <in94> + ^instance <in95> + ^instance <in96> +
           ^instance <in97> + ^instance <in98> + ^instance <in99> +
           ^instance <in100> + ^instance <in101> + ^instance <in102> +
           ^instance <in103> + ^instance <in104> + ^instance <in105> +
           ^instance <in106> + ^instance <in107> + ^instance <in108> +
           ^instance <in109> + ^instance <in110> + ^instance <in111> +
           ^instance <in112> + ^instance <in113> +)
    (<in30> ^1 <o1> + ^2 <o2> +)
    (<in31> ^1 <o1> + ^2 <o4> +)
    (<in32> ^1 <o1> + ^2 <o5> +)
    (<in33> ^1 <o2> + ^2 <o1> +)
    (<in34> ^1 <o2> + ^2 <o3> +)
    (<in35> ^1 <o2> + ^2 <o4> +)
    (<in36> ^1 <o2> + ^2 <o5> +)
    (<in37> ^1 <o2> + ^2 <o6> +)
    (<in38> ^1 <o3> + ^2 <o2> +)
    (<in39> ^1 <o3> + ^2 <o5> +)
    (<in40> ^1 <o3> + ^2 <o6> +)
    (<in41> ^1 <o4> + ^2 <o1> +)
    (<in42> ^1 <o4> + ^2 <o2> +)
    (<in43> ^1 <o4> + ^2 <o5> +)
    (<in44> ^1 <o4> + ^2 <o7> +)
    (<in45> ^1 <o4> + ^2 <o8> +)
    (<in46> ^1 <o5> + ^2 <o1> +)
    (<in47> ^1 <o5> + ^2 <o2> +)
    (<in48> ^1 <o5> + ^2 <o3> +)
    (<in49> ^1 <o5> + ^2 <o4> +)
    (<in50> ^1 <o5> + ^2 <o6> +)
    (<in51> ^1 <o5> + ^2 <o7> +)
    (<in52> ^1 <o5> + ^2 <o8> +)
    (<in53> ^1 <o5> + ^2 <o9> +)
    (<in54> ^1 <o6> + ^2 <o2> +)
    (<in55> ^1 <o6> + ^2 <o3> +)
    (<in56> ^1 <o6> + ^2 <o5> +)
    (<in57> ^1 <o6> + ^2 <o8> +)
    (<in58> ^1 <o6> + ^2 <o9> +)
    (<in59> ^1 <o7> + ^2 <o4> +)
    (<in60> ^1 <o7> + ^2 <o5> +)
    (<in61> ^1 <o7> + ^2 <o8> +)
    (<in62> ^1 <o8> + ^2 <o7> +)
    (<in63> ^1 <o8> + ^2 <o4> +)
    (<in64> ^1 <o8> + ^2 <o5> +)
    (<in65> ^1 <o8> + ^2 <o6> +)
    (<in66> ^1 <o8> + ^2 <o9> +)
    (<in67> ^1 <o9> + ^2 <o8> +)
    (<in68> ^1 <o9> + ^2 <o5> +)
    (<in69> ^1 <o9> + ^2 <o6> +)
    (<in70> ^1 <o3> + ^2 <o10> +)
    (<in71> ^1 <o3> + ^2 <o11> +)
    (<in72> ^1 <o6> + ^2 <o10> +)
    (<in73> ^1 <o6> + ^2 <o11> +)
    (<in74> ^1 <o6> + ^2 <o12> +)
    (<in75> ^1 <o9> + ^2 <o11> +)
    (<in76> ^1 <o9> + ^2 <o12> +)
    (<in77> ^1 <o9> + ^2 <o16> +)
    (<in78> ^1 <o9> + ^2 <o15> +)
    (<in79> ^1 <o9> + ^2 <o14> +)
    (<in80> ^1 <o8> + ^2 <o13> +)
    (<in81> ^1 <o8> + ^2 <o14> +)
    (<in82> ^1 <o8> + ^2 <o15> +)
    (<in83> ^1 <o7> + ^2 <o13> +)
    (<in84> ^1 <o7> + ^2 <o14> +)
    (<in85> ^1 <o10> + ^2 <o3> +)
    (<in86> ^1 <o10> + ^2 <o6> +)
    (<in87> ^1 <o10> + ^2 <o11> +)
    (<in88> ^1 <o11> + ^2 <o10> +)
    (<in89> ^1 <o11> + ^2 <o3> +)
    (<in90> ^1 <o11> + ^2 <o6> +)
    (<in91> ^1 <o11> + ^2 <o9> +)
    (<in92> ^1 <o11> + ^2 <o12> +)
    (<in93> ^1 <o12> + ^2 <o11> +)
    (<in94> ^1 <o12> + ^2 <o6> +)
    (<in95> ^1 <o12> + ^2 <o9> +)
    (<in96> ^1 <o12> + ^2 <o15> +)
    (<in97> ^1 <o12> + ^2 <o16> +)
    (<in98> ^1 <o16> + ^2 <o12> +)
    (<in99> ^1 <o16> + ^2 <o9> +)
    (<in100> ^1 <o16> + ^2 <o15> +)
    (<in101> ^1 <o15> + ^2 <o16> +)
    (<in102> ^1 <o15> + ^2 <o12> +)
    (<in103> ^1 <o15> + ^2 <o9> +)
    (<in104> ^1 <o15> + ^2 <o8> +)
    (<in105> ^1 <o15> + ^2 <o14> +)
    (<in106> ^1 <o14> + ^2 <o15> +)
    (<in107> ^1 <o14> + ^2 <o9> +)
    (<in108> ^1 <o14> + ^2 <o8> +)
    (<in109> ^1 <o14> + ^2 <o7> +)
    (<in110> ^1 <o14> + ^2 <o13> +)
    (<in111> ^1 <o13> + ^2 <o7> +)
    (<in112> ^1 <o13> + ^2 <o8> +)
    (<in113> ^1 <o13> + ^2 <o14> +)
    (<diagonal-with1> ^item-type predicate + ^handle diagonal-with1 +
           ^instance <in114> + ^instance <in115> + ^instance <in116> +
           ^instance <in117> + ^instance <in118> + ^instance <in119> +
           ^instance <in120> + ^instance <in121> + ^instance <in122> +
           ^instance <in123> + ^instance <in124> + ^instance <in125> +
           ^instance <in126> + ^instance <in127> + ^instance <in128> +
           ^instance <in129> + ^instance <in130> + ^instance <in131> +
           ^instance <in132> + ^instance <in133> + ^instance <in134> +
           ^instance <in135> + ^instance <in136> + ^instance <in137> +
           ^instance <in138> + ^instance <in139> + ^instance <in140> +
           ^instance <in141> + ^instance <in142> + ^instance <in143> +
           ^instance <in144> + ^instance <in145> + ^instance <in146> +
           ^instance <in147> + ^instance <in148> + ^instance <in149> +)
    (<in114> ^1 <o1> + ^2 <o5> +)
    (<in115> ^1 <o2> + ^2 <o4> +)
    (<in116> ^1 <o2> + ^2 <o6> +)
    (<in117> ^1 <o3> + ^2 <o5> +)
    (<in118> ^1 <o4> + ^2 <o2> +)
    (<in119> ^1 <o4> + ^2 <o8> +)
    (<in120> ^1 <o5> + ^2 <o1> +)
    (<in121> ^1 <o5> + ^2 <o3> +)
    (<in122> ^1 <o5> + ^2 <o7> +)
    (<in123> ^1 <o5> + ^2 <o9> +)
    (<in124> ^1 <o6> + ^2 <o2> +)
    (<in125> ^1 <o6> + ^2 <o8> +)
    (<in126> ^1 <o7> + ^2 <o5> +)
    (<in127> ^1 <o8> + ^2 <o4> +)
    (<in128> ^1 <o8> + ^2 <o6> +)
    (<in129> ^1 <o9> + ^2 <o5> +)
    (<in130> ^1 <o3> + ^2 <o11> +)
    (<in131> ^1 <o11> + ^2 <o3> +)
    (<in132> ^1 <o6> + ^2 <o10> +)
    (<in133> ^1 <o10> + ^2 <o6> +)
    (<in134> ^1 <o9> + ^2 <o11> +)
    (<in135> ^1 <o11> + ^2 <o9> +)
    (<in136> ^1 <o12> + ^2 <o6> +)
    (<in137> ^1 <o6> + ^2 <o12> +)
    (<in138> ^1 <o16> + ^2 <o9> +)
    (<in139> ^1 <o9> + ^2 <o16> +)
    (<in140> ^1 <o12> + ^2 <o15> +)
    (<in141> ^1 <o15> + ^2 <o12> +)
    (<in142> ^1 <o14> + ^2 <o9> +)
    (<in143> ^1 <o9> + ^2 <o14> +)
    (<in144> ^1 <o8> + ^2 <o15> +)
    (<in145> ^1 <o15> + ^2 <o8> +)
    (<in146> ^1 <o14> + ^2 <o7> +)
    (<in147> ^1 <o7> + ^2 <o14> +)
    (<in148> ^1 <o13> + ^2 <o8> +)
    (<in149> ^1 <o8> + ^2 <o13> +)
}

sp {dialog-event*apply*game-state-change-respond*init-stacked-frogs
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-stacked-frogs)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^x 1 + ^y 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^x 2 + ^y 1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^x 3 + ^y 1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^x 4 + ^y 1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +)
    (<in0> ^1 <o5> + ^2 <o1> +)
    (<in1> ^1 <o6> + ^2 <o2> +)
    (<in2> ^1 <o7> + ^2 <o3> +)
    (<in3> ^1 <o8> + ^2 <o4> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in4> +
           ^instance <in5> + ^instance <in6> + ^instance <in7> +)
    (<in4> ^1 <o1> + ^2 <o5> +)
    (<in5> ^1 <o2> + ^2 <o6> +)
    (<in6> ^1 <o3> + ^2 <o7> +)
    (<in7> ^1 <o4> + ^2 <o8> +)
}

sp {dialog-event*apply*game-state-change-respond*init-frog4
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-frog4)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> + ^object <o17> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <left-of1> +
           ^predicate <right-of1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color red1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color red1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^color red1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^color red1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^color blue1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^color blue1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^color blue1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^color blue1 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block + ^color blue1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block + ^color blue1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category block + ^color blue1 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block + ^color blue1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category block + ^color red1 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category block + ^color red1 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category block + ^color red1 +)
    (<o17> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category block + ^color red1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +
           ^instance <in7> +)
    (<in0> ^1 <o10> + ^2 <o1> +)
    (<in1> ^1 <o11> + ^2 <o2> +)
    (<in2> ^1 <o12> + ^2 <o3> +)
    (<in3> ^1 <o13> + ^2 <o4> +)
    (<in4> ^1 <o14> + ^2 <o6> +)
    (<in5> ^1 <o15> + ^2 <o7> +)
    (<in6> ^1 <o16> + ^2 <o8> +)
    (<in7> ^1 <o17> + ^2 <o9> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +
           ^instance <in12> + ^instance <in13> + ^instance <in14> +
           ^instance <in15> +)
    (<in8> ^1 <o1> + ^2 <o10> +)
    (<in9> ^1 <o2> + ^2 <o11> +)
    (<in10> ^1 <o3> + ^2 <o12> +)
    (<in11> ^1 <o4> + ^2 <o13> +)
    (<in12> ^1 <o6> + ^2 <o14> +)
    (<in13> ^1 <o7> + ^2 <o15> +)
    (<in14> ^1 <o8> + ^2 <o16> +)
    (<in15> ^1 <o9> + ^2 <o17> +)
    (<left-of1> ^item-type predicate + ^handle left-of1 + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> +)
    (<in16> ^1 <o1> + ^2 <o2> +)
    (<in17> ^1 <o2> + ^2 <o3> +)
    (<in18> ^1 <o3> + ^2 <o4> +)
    (<in19> ^1 <o4> + ^2 <o5> +)
    (<in20> ^1 <o5> + ^2 <o6> +)
    (<in21> ^1 <o6> + ^2 <o7> +)
    (<in22> ^1 <o7> + ^2 <o8> +)
    (<in23> ^1 <o8> + ^2 <o9> +)
    (<right-of1> ^item-type predicate + ^handle right-of1 + ^instance <in24> +
           ^instance <in25> + ^instance <in26> + ^instance <in27> +
           ^instance <in28> + ^instance <in29> + ^instance <in30> +
           ^instance <in31> +)
    (<in24> ^1 <o2> + ^2 <o1> +)
    (<in25> ^1 <o3> + ^2 <o2> +)
    (<in26> ^1 <o4> + ^2 <o3> +)
    (<in27> ^1 <o5> + ^2 <o4> +)
    (<in28> ^1 <o6> + ^2 <o5> +)
    (<in29> ^1 <o7> + ^2 <o6> +)
    (<in30> ^1 <o8> + ^2 <o7> +)
    (<in31> ^1 <o9> + ^2 <o8> +)
}

sp {dialog-event*apply*game-state-change-respond*init-stacked-frogs2
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-stacked-frogs2)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^x 1 + ^y 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^x 2 + ^y 1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^x 3 + ^y 1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^x 4 + ^y 1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^x 5 + ^y 1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^x 6 + ^y 1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category block +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category block +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> +)
    (<in0> ^1 <o7> + ^2 <o1> +)
    (<in1> ^1 <o8> + ^2 <o2> +)
    (<in2> ^1 <o9> + ^2 <o3> +)
    (<in3> ^1 <o10> + ^2 <o4> +)
    (<in4> ^1 <o11> + ^2 <o5> +)
    (<in5> ^1 <o12> + ^2 <o6> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in6> +
           ^instance <in7> + ^instance <in8> + ^instance <in9> +
           ^instance <in10> + ^instance <in11> +)
    (<in6> ^1 <o1> + ^2 <o7> +)
    (<in7> ^1 <o2> + ^2 <o8> +)
    (<in8> ^1 <o3> + ^2 <o9> +)
    (<in9> ^1 <o4> + ^2 <o10> +)
    (<in10> ^1 <o5> + ^2 <o11> +)
    (<in11> ^1 <o6> + ^2 <o12> +)
}

sp {dialog-event*apply*game-state-change-respond*final-peg
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-peg)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> + ^object <o17> + ^object <o18> + ^object <o19> +
           ^object <o20> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^x 1 + ^y 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^x 2 + ^y 1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^x 3 + ^y 1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^x 4 + ^y 1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^x 1 + ^y 2 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^x 2 + ^y 2 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^x 3 + ^y 2 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^x 1 + ^y 3 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^x 2 + ^y 3 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^x 1 + ^y 4 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category block +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category block +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category block +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category block +)
    (<o17> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category block +)
    (<o18> ^item-type object + ^handle object-17 + ^predicates <pr17> +)
    (<pr17> ^visible true + ^category block +)
    (<o19> ^item-type object + ^handle object-18 + ^predicates <pr18> +)
    (<pr18> ^visible true + ^category block +)
    (<o20> ^item-type object + ^handle object-19 + ^predicates <pr19> +)
    (<pr19> ^visible true + ^category object + ^name garbage +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +
           ^instance <in7> + ^instance <in8> +)
    (<in0> ^1 <o11> + ^2 <o1> +)
    (<in1> ^1 <o12> + ^2 <o20> +)
    (<in2> ^1 <o13> + ^2 <o20> +)
    (<in3> ^1 <o14> + ^2 <o20> +)
    (<in4> ^1 <o15> + ^2 <o20> +)
    (<in5> ^1 <o16> + ^2 <o20> +)
    (<in6> ^1 <o17> + ^2 <o20> +)
    (<in7> ^1 <o18> + ^2 <o20> +)
    (<in8> ^1 <o19> + ^2 <o20> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in9> +
           ^instance <in10> + ^instance <in11> + ^instance <in12> +
           ^instance <in13> + ^instance <in14> + ^instance <in15> +
           ^instance <in16> + ^instance <in17> +)
    (<in9> ^1 <o1> + ^2 <o11> +)
    (<in10> ^1 <o20> + ^2 <o12> +)
    (<in11> ^1 <o20> + ^2 <o13> +)
    (<in12> ^1 <o20> + ^2 <o14> +)
    (<in13> ^1 <o20> + ^2 <o15> +)
    (<in14> ^1 <o20> + ^2 <o16> +)
    (<in15> ^1 <o20> + ^2 <o17> +)
    (<in16> ^1 <o20> + ^2 <o18> +)
    (<in17> ^1 <o20> + ^2 <o19> +)
}

sp {dialog-event*apply*game-state-change-respond*final-connect-3
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-connect-3)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o21> + ^object <o22> +
           ^object <o23> + ^object <o24> + ^object <o25> + ^object <o26> +
           ^object <o27> + ^object <o28> + ^object <o29> + ^object <o30> +
           ^object <o31> + ^object <o10> + ^object <o11> + ^object <o12> +
           ^object <o13> + ^object <o14> + ^object <o15> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <above1> +
           ^predicate <linear> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location +)
    (<o21> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location +)
    (<o22> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location +)
    (<o23> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location +)
    (<o24> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category location +)
    (<o25> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category location +)
    (<o26> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category location +)
    (<o27> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category location +)
    (<o28> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category location +)
    (<o29> ^item-type object + ^handle object-17 + ^predicates <pr17> +)
    (<pr17> ^visible true + ^category location +)
    (<o30> ^item-type object + ^handle object-18 + ^predicates <pr18> +)
    (<pr18> ^visible true + ^category location +)
    (<o31> ^item-type object + ^handle object-19 + ^predicates <pr19> +)
    (<pr19> ^visible true + ^category location +)
    (<o10> ^item-type object + ^handle object-20 + ^predicates <pr20> +)
    (<pr20> ^visible true + ^category block + ^color red1 +)
    (<o11> ^item-type object + ^handle object-21 + ^predicates <pr21> +)
    (<pr21> ^visible true + ^category block + ^color red1 +)
    (<o12> ^item-type object + ^handle object-22 + ^predicates <pr22> +)
    (<pr22> ^visible true + ^category block + ^color red1 +)
    (<o13> ^item-type object + ^handle object-23 + ^predicates <pr23> +)
    (<pr23> ^visible true + ^category block + ^color red1 +)
    (<o14> ^item-type object + ^handle object-24 + ^predicates <pr24> +)
    (<pr24> ^visible true + ^category block + ^color blue1 +)
    (<o15> ^item-type object + ^handle object-25 + ^predicates <pr25> +)
    (<pr25> ^visible true + ^category block + ^color blue1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +)
    (<in0> ^1 <o10> + ^2 <o27> +)
    (<in1> ^1 <o11> + ^2 <o28> +)
    (<in2> ^1 <o12> + ^2 <o29> +)
    (<in3> ^1 <o14> + ^2 <o15> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in4> +
           ^instance <in5> + ^instance <in6> + ^instance <in7> +)
    (<in4> ^1 <o27> + ^2 <o10> +)
    (<in5> ^1 <o28> + ^2 <o11> +)
    (<in6> ^1 <o29> + ^2 <o12> +)
    (<in7> ^1 <o15> + ^2 <o14> +)
    (<above1> ^item-type predicate + ^handle above1 + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +
           ^instance <in12> + ^instance <in13> + ^instance <in14> +
           ^instance <in15> + ^instance <in16> + ^instance <in17> +
           ^instance <in18> + ^instance <in19> + ^instance <in20> +
           ^instance <in21> + ^instance <in22> +)
    (<in8> ^1 <o7> + ^2 <o27> +)
    (<in9> ^1 <o4> + ^2 <o7> +)
    (<in10> ^1 <o1> + ^2 <o4> +)
    (<in11> ^1 <o8> + ^2 <o28> +)
    (<in12> ^1 <o5> + ^2 <o8> +)
    (<in13> ^1 <o2> + ^2 <o5> +)
    (<in14> ^1 <o3> + ^2 <o6> +)
    (<in15> ^1 <o6> + ^2 <o9> +)
    (<in16> ^1 <o9> + ^2 <o29> +)
    (<in17> ^1 <o21> + ^2 <o23> +)
    (<in18> ^1 <o23> + ^2 <o25> +)
    (<in19> ^1 <o25> + ^2 <o30> +)
    (<in20> ^1 <o22> + ^2 <o24> +)
    (<in21> ^1 <o24> + ^2 <o26> +)
    (<in22> ^1 <o26> + ^2 <o31> +)
    (<linear> ^item-type predicate + ^handle linear + ^instance <in23> +
           ^instance <in24> + ^instance <in25> + ^instance <in26> +
           ^instance <in27> + ^instance <in28> + ^instance <in29> +
           ^instance <in30> + ^instance <in31> + ^instance <in32> +
           ^instance <in33> + ^instance <in34> + ^instance <in35> +
           ^instance <in36> + ^instance <in37> + ^instance <in38> +
           ^instance <in39> + ^instance <in40> + ^instance <in41> +
           ^instance <in42> + ^instance <in43> + ^instance <in44> +
           ^instance <in45> + ^instance <in46> + ^instance <in47> +
           ^instance <in48> + ^instance <in49> + ^instance <in50> +
           ^instance <in51> + ^instance <in52> + ^instance <in53> +
           ^instance <in54> + ^instance <in55> + ^instance <in56> +
           ^instance <in57> +)
    (<in23> ^1 <set23> +)
    (<set23> ^object <o1> + ^object <o2> + ^object <o3> +)
    (<in24> ^1 <set24> +)
    (<set24> ^object <o1> + ^object <o5> + ^object <o9> +)
    (<in25> ^1 <set25> +)
    (<set25> ^object <o1> + ^object <o4> + ^object <o7> +)
    (<in26> ^1 <set26> +)
    (<set26> ^object <o4> + ^object <o5> + ^object <o6> +)
    (<in27> ^1 <set27> +)
    (<set27> ^object <o7> + ^object <o8> + ^object <o9> +)
    (<in28> ^1 <set28> +)
    (<set28> ^object <o2> + ^object <o5> + ^object <o8> +)
    (<in29> ^1 <set29> +)
    (<set29> ^object <o3> + ^object <o6> + ^object <o9> +)
    (<in30> ^1 <set30> +)
    (<set30> ^object <o3> + ^object <o5> + ^object <o7> +)
    (<in31> ^1 <set31> +)
    (<set31> ^object <o3> + ^object <o21> + ^object <o22> +)
    (<in32> ^1 <set32> +)
    (<set32> ^object <o6> + ^object <o23> + ^object <o24> +)
    (<in33> ^1 <set33> +)
    (<set33> ^object <o9> + ^object <o25> + ^object <o26> +)
    (<in34> ^1 <set34> +)
    (<set34> ^object <o29> + ^object <o30> + ^object <o31> +)
    (<in35> ^1 <set35> +)
    (<set35> ^object <o27> + ^object <o28> + ^object <o29> +)
    (<in36> ^1 <set36> +)
    (<set36> ^object <o2> + ^object <o3> + ^object <o21> +)
    (<in37> ^1 <set37> +)
    (<set37> ^object <o5> + ^object <o6> + ^object <o23> +)
    (<in38> ^1 <set38> +)
    (<set38> ^object <o8> + ^object <o9> + ^object <o25> +)
    (<in39> ^1 <set39> +)
    (<set39> ^object <o28> + ^object <o29> + ^object <o30> +)
    (<in40> ^1 <set40> +)
    (<set40> ^object <o21> + ^object <o23> + ^object <o25> +)
    (<in41> ^1 <set41> +)
    (<set41> ^object <o22> + ^object <o24> + ^object <o26> +)
    (<in42> ^1 <set42> +)
    (<set42> ^object <o4> + ^object <o7> + ^object <o27> +)
    (<in43> ^1 <set43> +)
    (<set43> ^object <o5> + ^object <o8> + ^object <o28> +)
    (<in44> ^1 <set44> +)
    (<set44> ^object <o6> + ^object <o9> + ^object <o29> +)
    (<in45> ^1 <set45> +)
    (<set45> ^object <o23> + ^object <o25> + ^object <o30> +)
    (<in46> ^1 <set46> +)
    (<set46> ^object <o24> + ^object <o26> + ^object <o31> +)
    (<in47> ^1 <set47> +)
    (<set47> ^object <o4> + ^object <o8> + ^object <o29> +)
    (<in48> ^1 <set48> +)
    (<set48> ^object <o5> + ^object <o9> + ^object <o30> +)
    (<in49> ^1 <set49> +)
    (<set49> ^object <o6> + ^object <o25> + ^object <o31> +)
    (<in50> ^1 <set50> +)
    (<set50> ^object <o2> + ^object <o6> + ^object <o25> +)
    (<in51> ^1 <set51> +)
    (<set51> ^object <o3> + ^object <o23> + ^object <o25> +)
    (<in52> ^1 <set52> +)
    (<set52> ^object <o24> + ^object <o25> + ^object <o29> +)
    (<in53> ^1 <set53> +)
    (<set53> ^object <o23> + ^object <o9> + ^object <o28> +)
    (<in54> ^1 <set54> +)
    (<set54> ^object <o6> + ^object <o8> + ^object <o27> +)
    (<in55> ^1 <set55> +)
    (<set55> ^object <o22> + ^object <o23> + ^object <o9> +)
    (<in56> ^1 <set56> +)
    (<set56> ^object <o21> + ^object <o6> + ^object <o8> +)
    (<in57> ^1 <set57> +)
    (<set57> ^object <o3> + ^object <o5> + ^object <o7> +)
}

sp {dialog-event*apply*game-state-change-respond*init-tictactoe
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-tictactoe)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <linear> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block + ^color red1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block + ^color red1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category block + ^color red1 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block + ^color blue1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category block + ^color blue1 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category block + ^color blue1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +)
    (<in0> ^1 <o10> + ^2 <o11> +)
    (<in1> ^1 <o11> + ^2 <o12> +)
    (<in2> ^1 <o13> + ^2 <o14> +)
    (<in3> ^1 <o14> + ^2 <o15> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in4> +
           ^instance <in5> + ^instance <in6> + ^instance <in7> +)
    (<in4> ^1 <o11> + ^2 <o10> +)
    (<in5> ^1 <o12> + ^2 <o11> +)
    (<in6> ^1 <o14> + ^2 <o13> +)
    (<in7> ^1 <o15> + ^2 <o14> +)
    (<linear> ^item-type predicate + ^handle linear + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +
           ^instance <in12> + ^instance <in13> + ^instance <in14> +
           ^instance <in15> +)
    (<in8> ^1 <set8> +)
    (<set8> ^object <o1> + ^object <o2> + ^object <o3> +)
    (<in9> ^1 <set9> +)
    (<set9> ^object <o1> + ^object <o5> + ^object <o9> +)
    (<in10> ^1 <set10> +)
    (<set10> ^object <o1> + ^object <o4> + ^object <o7> +)
    (<in11> ^1 <set11> +)
    (<set11> ^object <o4> + ^object <o5> + ^object <o6> +)
    (<in12> ^1 <set12> +)
    (<set12> ^object <o7> + ^object <o8> + ^object <o9> +)
    (<in13> ^1 <set13> +)
    (<set13> ^object <o2> + ^object <o5> + ^object <o8> +)
    (<in14> ^1 <set14> +)
    (<set14> ^object <o3> + ^object <o6> + ^object <o9> +)
    (<in15> ^1 <set15> +)
    (<set15> ^object <o3> + ^object <o5> + ^object <o7> +)
}

sp {dialog-event*apply*game-state-change-respond*init-sudoku4
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-sudoku4)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^x 1 + ^y 1 + ^value 0 +
           ^sub-grid 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^x 2 + ^y 1 + ^value 1 +
           ^sub-grid 1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^x 3 + ^y 1 + ^value 2 +
           ^sub-grid 2 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^x 4 + ^y 1 + ^value 0 +
           ^sub-grid 2 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^x 1 + ^y 2 + ^value 4 +
           ^sub-grid 1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^x 2 + ^y 2 + ^value 0 +
           ^sub-grid 1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^x 3 + ^y 2 + ^value 0 +
           ^sub-grid 2 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^x 4 + ^y 2 + ^value 0 +
           ^sub-grid 2 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^x 1 + ^y 3 + ^value 0 +
           ^sub-grid 3 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^x 2 + ^y 3 + ^value 0 +
           ^sub-grid 3 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location + ^x 3 + ^y 3 + ^value 0 +
           ^sub-grid 4 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location + ^x 4 + ^y 3 + ^value 2 +
           ^sub-grid 4 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category location + ^x 1 + ^y 4 + ^value 0 +
           ^sub-grid 3 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category location + ^x 2 + ^y 4 + ^value 4 +
           ^sub-grid 3 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category location + ^x 3 + ^y 4 + ^value 3 +
           ^sub-grid 4 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category location + ^x 4 + ^y 4 + ^value 0 +
           ^sub-grid 4 +)
}

sp {dialog-event*apply*game-state-change-respond*final-sokoban
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-sokoban)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o17> + ^object <o18> + ^object <o19> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <near1> +
           ^predicate <diagonal-with1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^x 1 + ^y 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^x 2 + ^y 1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^x 3 + ^y 1 + ^color red1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^x 1 + ^y 2 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^x 2 + ^y 2 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^x 3 + ^y 2 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^x 1 + ^y 3 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^x 2 + ^y 3 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^x 3 + ^y 3 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^x 1 + ^y 4 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location + ^x 2 + ^y 4 + ^color green1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location + ^x 3 + ^y 4 +)
    (<o17> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block + ^color blue1 +)
    (<o18> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category block + ^color red1 +)
    (<o19> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category block + ^color green1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> +)
    (<in0> ^1 <o17> + ^2 <o8> +)
    (<in1> ^1 <o18> + ^2 <o3> +)
    (<in2> ^1 <o19> + ^2 <o11> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in3> +
           ^instance <in4> + ^instance <in5> +)
    (<in3> ^1 <o8> + ^2 <o17> +)
    (<in4> ^1 <o3> + ^2 <o18> +)
    (<in5> ^1 <o11> + ^2 <o19> +)
    (<near1> ^item-type predicate + ^handle near1 + ^instance <in6> +
           ^instance <in7> + ^instance <in8> + ^instance <in9> +
           ^instance <in10> + ^instance <in11> + ^instance <in12> +
           ^instance <in13> + ^instance <in14> + ^instance <in15> +
           ^instance <in16> + ^instance <in17> + ^instance <in18> +
           ^instance <in19> + ^instance <in20> + ^instance <in21> +
           ^instance <in22> + ^instance <in23> + ^instance <in24> +
           ^instance <in25> + ^instance <in26> + ^instance <in27> +
           ^instance <in28> + ^instance <in29> + ^instance <in30> +
           ^instance <in31> + ^instance <in32> + ^instance <in33> +
           ^instance <in34> + ^instance <in35> + ^instance <in36> +
           ^instance <in37> + ^instance <in38> + ^instance <in39> +
           ^instance <in40> + ^instance <in41> + ^instance <in42> +
           ^instance <in43> + ^instance <in44> + ^instance <in45> +
           ^instance <in46> + ^instance <in47> + ^instance <in48> +
           ^instance <in49> + ^instance <in50> + ^instance <in51> +
           ^instance <in52> + ^instance <in53> + ^instance <in54> +
           ^instance <in55> + ^instance <in56> + ^instance <in57> +
           ^instance <in58> + ^instance <in59> + ^instance <in60> +
           ^instance <in61> + ^instance <in62> + ^instance <in63> +)
    (<in6> ^1 <o1> + ^2 <o2> +)
    (<in7> ^1 <o1> + ^2 <o4> +)
    (<in8> ^1 <o1> + ^2 <o5> +)
    (<in9> ^1 <o2> + ^2 <o1> +)
    (<in10> ^1 <o2> + ^2 <o3> +)
    (<in11> ^1 <o2> + ^2 <o4> +)
    (<in12> ^1 <o2> + ^2 <o5> +)
    (<in13> ^1 <o2> + ^2 <o6> +)
    (<in14> ^1 <o3> + ^2 <o2> +)
    (<in15> ^1 <o3> + ^2 <o5> +)
    (<in16> ^1 <o3> + ^2 <o6> +)
    (<in17> ^1 <o4> + ^2 <o1> +)
    (<in18> ^1 <o4> + ^2 <o2> +)
    (<in19> ^1 <o4> + ^2 <o5> +)
    (<in20> ^1 <o4> + ^2 <o7> +)
    (<in21> ^1 <o4> + ^2 <o8> +)
    (<in22> ^1 <o5> + ^2 <o1> +)
    (<in23> ^1 <o5> + ^2 <o2> +)
    (<in24> ^1 <o5> + ^2 <o3> +)
    (<in25> ^1 <o5> + ^2 <o4> +)
    (<in26> ^1 <o5> + ^2 <o6> +)
    (<in27> ^1 <o5> + ^2 <o7> +)
    (<in28> ^1 <o5> + ^2 <o8> +)
    (<in29> ^1 <o5> + ^2 <o9> +)
    (<in30> ^1 <o6> + ^2 <o2> +)
    (<in31> ^1 <o6> + ^2 <o3> +)
    (<in32> ^1 <o6> + ^2 <o5> +)
    (<in33> ^1 <o6> + ^2 <o8> +)
    (<in34> ^1 <o6> + ^2 <o9> +)
    (<in35> ^1 <o7> + ^2 <o4> +)
    (<in36> ^1 <o7> + ^2 <o5> +)
    (<in37> ^1 <o7> + ^2 <o8> +)
    (<in38> ^1 <o8> + ^2 <o7> +)
    (<in39> ^1 <o8> + ^2 <o4> +)
    (<in40> ^1 <o8> + ^2 <o5> +)
    (<in41> ^1 <o8> + ^2 <o6> +)
    (<in42> ^1 <o8> + ^2 <o9> +)
    (<in43> ^1 <o9> + ^2 <o8> +)
    (<in44> ^1 <o9> + ^2 <o5> +)
    (<in45> ^1 <o9> + ^2 <o6> +)
    (<in46> ^1 <o9> + ^2 <o11> +)
    (<in47> ^1 <o9> + ^2 <o12> +)
    (<in48> ^1 <o8> + ^2 <o19> +)
    (<in49> ^1 <o8> + ^2 <o11> +)
    (<in50> ^1 <o8> + ^2 <o12> +)
    (<in51> ^1 <o7> + ^2 <o10> +)
    (<in52> ^1 <o7> + ^2 <o11> +)
    (<in53> ^1 <o10> + ^2 <o7> +)
    (<in54> ^1 <o10> + ^2 <o8> +)
    (<in55> ^1 <o10> + ^2 <o11> +)
    (<in56> ^1 <o11> + ^2 <o10> +)
    (<in57> ^1 <o11> + ^2 <o7> +)
    (<in58> ^1 <o11> + ^2 <o8> +)
    (<in59> ^1 <o11> + ^2 <o9> +)
    (<in60> ^1 <o11> + ^2 <o12> +)
    (<in61> ^1 <o12> + ^2 <o11> +)
    (<in62> ^1 <o12> + ^2 <o8> +)
    (<in63> ^1 <o12> + ^2 <o9> +)
    (<diagonal-with1> ^item-type predicate + ^handle diagonal-with1 +
           ^instance <in64> + ^instance <in65> + ^instance <in66> +
           ^instance <in67> + ^instance <in68> + ^instance <in69> +
           ^instance <in70> + ^instance <in71> + ^instance <in72> +
           ^instance <in73> + ^instance <in74> + ^instance <in75> +
           ^instance <in76> + ^instance <in77> + ^instance <in78> +
           ^instance <in79> + ^instance <in80> + ^instance <in81> +
           ^instance <in82> + ^instance <in83> + ^instance <in84> +
           ^instance <in85> + ^instance <in86> + ^instance <in87> +)
    (<in64> ^1 <o1> + ^2 <o5> +)
    (<in65> ^1 <o2> + ^2 <o4> +)
    (<in66> ^1 <o2> + ^2 <o6> +)
    (<in67> ^1 <o3> + ^2 <o5> +)
    (<in68> ^1 <o4> + ^2 <o2> +)
    (<in69> ^1 <o4> + ^2 <o8> +)
    (<in70> ^1 <o5> + ^2 <o1> +)
    (<in71> ^1 <o5> + ^2 <o3> +)
    (<in72> ^1 <o5> + ^2 <o7> +)
    (<in73> ^1 <o5> + ^2 <o9> +)
    (<in74> ^1 <o6> + ^2 <o2> +)
    (<in75> ^1 <o6> + ^2 <o8> +)
    (<in76> ^1 <o7> + ^2 <o5> +)
    (<in77> ^1 <o8> + ^2 <o4> +)
    (<in78> ^1 <o8> + ^2 <o6> +)
    (<in79> ^1 <o9> + ^2 <o5> +)
    (<in80> ^1 <o9> + ^2 <o11> +)
    (<in81> ^1 <o11> + ^2 <o9> +)
    (<in82> ^1 <o12> + ^2 <o8> +)
    (<in83> ^1 <o8> + ^2 <o12> +)
    (<in84> ^1 <o10> + ^2 <o8> +)
    (<in85> ^1 <o8> + ^2 <o10> +)
    (<in86> ^1 <o11> + ^2 <o7> +)
    (<in87> ^1 <o7> + ^2 <o11> +)
}

sp {dialog-event*apply*game-state-change-respond*second-frog3
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type second-frog3)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <left-of1> +
           ^predicate <right-of1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color red1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color red1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^color red1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^color blue1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^color blue1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^color blue1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block + ^color blue1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category block + ^color blue1 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block + ^color blue1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block + ^color red1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category block + ^color red1 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block + ^color red1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> +)
    (<in0> ^1 <o8> + ^2 <o1> +)
    (<in1> ^1 <o9> + ^2 <o2> +)
    (<in2> ^1 <o10> + ^2 <o5> +)
    (<in3> ^1 <o11> + ^2 <o3> +)
    (<in4> ^1 <o12> + ^2 <o6> +)
    (<in5> ^1 <o13> + ^2 <o7> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in6> +
           ^instance <in7> + ^instance <in8> + ^instance <in9> +
           ^instance <in10> + ^instance <in11> +)
    (<in6> ^1 <o1> + ^2 <o8> +)
    (<in7> ^1 <o2> + ^2 <o9> +)
    (<in8> ^1 <o5> + ^2 <o19> +)
    (<in9> ^1 <o3> + ^2 <o11> +)
    (<in10> ^1 <o6> + ^2 <o12> +)
    (<in11> ^1 <o7> + ^2 <o13> +)
    (<left-of1> ^item-type predicate + ^handle left-of1 + ^instance <in12> +
           ^instance <in13> + ^instance <in14> + ^instance <in15> +
           ^instance <in16> + ^instance <in17> +)
    (<in12> ^1 <o1> + ^2 <o2> +)
    (<in13> ^1 <o2> + ^2 <o3> +)
    (<in14> ^1 <o3> + ^2 <o4> +)
    (<in15> ^1 <o4> + ^2 <o5> +)
    (<in16> ^1 <o5> + ^2 <o6> +)
    (<in17> ^1 <o6> + ^2 <o7> +)
    (<right-of1> ^item-type predicate + ^handle right-of1 + ^instance <in18> +
           ^instance <in19> + ^instance <in20> + ^instance <in21> +
           ^instance <in22> + ^instance <in23> +)
    (<in18> ^1 <o2> + ^2 <o1> +)
    (<in19> ^1 <o3> + ^2 <o2> +)
    (<in20> ^1 <o4> + ^2 <o3> +)
    (<in21> ^1 <o5> + ^2 <o4> +)
    (<in22> ^1 <o6> + ^2 <o5> +)
    (<in23> ^1 <o7> + ^2 <o6> +)
}

sp {dialog-event*apply*game-state-change-respond*fail-connect-4
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type fail-connect-4)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o21> + ^object <o22> +
           ^object <o23> + ^object <o24> + ^object <o25> + ^object <o26> +
           ^object <o27> + ^object <o28> + ^object <o29> + ^object <o30> +
           ^object <o31> + ^object <o10> + ^object <o11> + ^object <o12> +
           ^object <o13> + ^object <o14> + ^object <o15> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <above1> +
           ^predicate <linear> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location +)
    (<o21> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location +)
    (<o22> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location +)
    (<o23> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location +)
    (<o24> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category location +)
    (<o25> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category location +)
    (<o26> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category location +)
    (<o27> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category location +)
    (<o28> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category location +)
    (<o29> ^item-type object + ^handle object-17 + ^predicates <pr17> +)
    (<pr17> ^visible true + ^category location +)
    (<o30> ^item-type object + ^handle object-18 + ^predicates <pr18> +)
    (<pr18> ^visible true + ^category location +)
    (<o31> ^item-type object + ^handle object-19 + ^predicates <pr19> +)
    (<pr19> ^visible true + ^category location +)
    (<o10> ^item-type object + ^handle object-20 + ^predicates <pr20> +)
    (<pr20> ^visible true + ^category block + ^color blue1 +)
    (<o11> ^item-type object + ^handle object-21 + ^predicates <pr21> +)
    (<pr21> ^visible true + ^category block + ^color blue1 +)
    (<o12> ^item-type object + ^handle object-22 + ^predicates <pr22> +)
    (<pr22> ^visible true + ^category block + ^color blue1 +)
    (<o13> ^item-type object + ^handle object-23 + ^predicates <pr23> +)
    (<pr23> ^visible true + ^category block + ^color blue1 +)
    (<o14> ^item-type object + ^handle object-24 + ^predicates <pr24> +)
    (<pr24> ^visible true + ^category block + ^color red1 +)
    (<o15> ^item-type object + ^handle object-25 + ^predicates <pr25> +)
    (<pr25> ^visible true + ^category block + ^color red1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> +)
    (<in0> ^1 <o10> + ^2 <o27> +)
    (<in1> ^1 <o11> + ^2 <o28> +)
    (<in2> ^1 <o12> + ^2 <o29> +)
    (<in3> ^1 <o13> + ^2 <o30> +)
    (<in4> ^1 <o14> + ^2 <o15> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in5> +
           ^instance <in6> + ^instance <in7> + ^instance <in8> +
           ^instance <in9> +)
    (<in5> ^1 <o27> + ^2 <o10> +)
    (<in6> ^1 <o28> + ^2 <o11> +)
    (<in7> ^1 <o29> + ^2 <o12> +)
    (<in8> ^1 <o30> + ^2 <o13> +)
    (<in9> ^1 <o15> + ^2 <o14> +)
    (<above1> ^item-type predicate + ^handle above1 + ^instance <in10> +
           ^instance <in11> + ^instance <in12> + ^instance <in13> +
           ^instance <in14> + ^instance <in15> + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> +)
    (<in10> ^1 <o7> + ^2 <o27> +)
    (<in11> ^1 <o4> + ^2 <o7> +)
    (<in12> ^1 <o1> + ^2 <o4> +)
    (<in13> ^1 <o8> + ^2 <o28> +)
    (<in14> ^1 <o5> + ^2 <o8> +)
    (<in15> ^1 <o2> + ^2 <o5> +)
    (<in16> ^1 <o3> + ^2 <o6> +)
    (<in17> ^1 <o6> + ^2 <o9> +)
    (<in18> ^1 <o9> + ^2 <o29> +)
    (<in19> ^1 <o21> + ^2 <o23> +)
    (<in20> ^1 <o23> + ^2 <o25> +)
    (<in21> ^1 <o25> + ^2 <o30> +)
    (<in22> ^1 <o22> + ^2 <o24> +)
    (<in23> ^1 <o24> + ^2 <o26> +)
    (<in24> ^1 <o26> + ^2 <o31> +)
    (<linear> ^item-type predicate + ^handle linear + ^instance <in25> +
           ^instance <in26> + ^instance <in27> + ^instance <in28> +
           ^instance <in29> + ^instance <in30> + ^instance <in31> +
           ^instance <in32> + ^instance <in33> + ^instance <in34> +
           ^instance <in35> + ^instance <in36> + ^instance <in37> +
           ^instance <in38> + ^instance <in39> + ^instance <in40> +
           ^instance <in41> +)
    (<in25> ^1 <set25> +)
    (<set25> ^object <o1> + ^object <o2> + ^object <o3> + ^object <o21> +)
    (<in26> ^1 <set26> +)
    (<set26> ^object <o1> + ^object <o5> + ^object <o9> + ^object <o30> +)
    (<in27> ^1 <set27> +)
    (<set27> ^object <o1> + ^object <o4> + ^object <o7> + ^object <o27> +)
    (<in28> ^1 <set28> +)
    (<set28> ^object <o4> + ^object <o5> + ^object <o6> + ^object <o23> +)
    (<in29> ^1 <set29> +)
    (<set29> ^object <o7> + ^object <o8> + ^object <o9> + ^object <o25> +)
    (<in30> ^1 <set30> +)
    (<set30> ^object <o27> + ^object <o28> + ^object <o29> + ^object <o30> +)
    (<in31> ^1 <set31> +)
    (<set31> ^object <o2> + ^object <o5> + ^object <o8> + ^object <o28> +)
    (<in32> ^1 <set32> +)
    (<set32> ^object <o3> + ^object <o6> + ^object <o9> + ^object <o29> +)
    (<in33> ^1 <set33> +)
    (<set33> ^object <o21> + ^object <o23> + ^object <o25> + ^object <o30> +)
    (<in34> ^1 <set34> +)
    (<set34> ^object <o21> + ^object <o6> + ^object <o8> + ^object <o27> +)
    (<in35> ^1 <set35> +)
    (<set35> ^object <o2> + ^object <o3> + ^object <o21> + ^object <o22> +)
    (<in36> ^1 <set36> +)
    (<set36> ^object <o5> + ^object <o6> + ^object <o23> + ^object <o24> +)
    (<in37> ^1 <set37> +)
    (<set37> ^object <o8> + ^object <o9> + ^object <o25> + ^object <o26> +)
    (<in38> ^1 <set38> +)
    (<set38> ^object <o28> + ^object <o29> + ^object <o30> + ^object <o31> +)
    (<in39> ^1 <set39> +)
    (<set39> ^object <o22> + ^object <o24> + ^object <o26> + ^object <o31> +)
    (<in40> ^1 <set40> +)
    (<set40> ^object <o2> + ^object <o6> + ^object <o25> + ^object <o31> +)
    (<in41> ^1 <set41> +)
    (<set41> ^object <o22> + ^object <o23> + ^object <o9> + ^object <o28> +)
}

sp {dialog-event*apply*game-state-change-respond*init-frog3
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-frog3)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <left-of1> +
           ^predicate <right-of1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color red1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color red1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^color red1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^color blue1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^color blue1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^color blue1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block + ^color blue1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category block + ^color blue1 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block + ^color blue1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block + ^color red1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category block + ^color red1 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block + ^color red1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> +)
    (<in0> ^1 <o8> + ^2 <o1> +)
    (<in1> ^1 <o9> + ^2 <o2> +)
    (<in2> ^1 <o10> + ^2 <o3> +)
    (<in3> ^1 <o11> + ^2 <o5> +)
    (<in4> ^1 <o12> + ^2 <o6> +)
    (<in5> ^1 <o13> + ^2 <o7> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in6> +
           ^instance <in7> + ^instance <in8> + ^instance <in9> +
           ^instance <in10> + ^instance <in11> +)
    (<in6> ^1 <o1> + ^2 <o8> +)
    (<in7> ^1 <o2> + ^2 <o9> +)
    (<in8> ^1 <o3> + ^2 <o19> +)
    (<in9> ^1 <o5> + ^2 <o11> +)
    (<in10> ^1 <o6> + ^2 <o12> +)
    (<in11> ^1 <o7> + ^2 <o13> +)
    (<left-of1> ^item-type predicate + ^handle left-of1 + ^instance <in12> +
           ^instance <in13> + ^instance <in14> + ^instance <in15> +
           ^instance <in16> + ^instance <in17> +)
    (<in12> ^1 <o1> + ^2 <o2> +)
    (<in13> ^1 <o2> + ^2 <o3> +)
    (<in14> ^1 <o3> + ^2 <o4> +)
    (<in15> ^1 <o4> + ^2 <o5> +)
    (<in16> ^1 <o5> + ^2 <o6> +)
    (<in17> ^1 <o6> + ^2 <o7> +)
    (<right-of1> ^item-type predicate + ^handle right-of1 + ^instance <in18> +
           ^instance <in19> + ^instance <in20> + ^instance <in21> +
           ^instance <in22> + ^instance <in23> +)
    (<in18> ^1 <o2> + ^2 <o1> +)
    (<in19> ^1 <o3> + ^2 <o2> +)
    (<in20> ^1 <o4> + ^2 <o3> +)
    (<in21> ^1 <o5> + ^2 <o4> +)
    (<in22> ^1 <o6> + ^2 <o5> +)
    (<in23> ^1 <o7> + ^2 <o6> +)
}

sp {dialog-event*apply*game-state-change-respond*fail-connect-3
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type fail-connect-3)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o21> + ^object <o22> +
           ^object <o23> + ^object <o24> + ^object <o25> + ^object <o26> +
           ^object <o27> + ^object <o28> + ^object <o29> + ^object <o30> +
           ^object <o31> + ^object <o10> + ^object <o11> + ^object <o12> +
           ^object <o13> + ^object <o14> + ^object <o15> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <above1> +
           ^predicate <linear> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location +)
    (<o21> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location +)
    (<o22> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location +)
    (<o23> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location +)
    (<o24> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category location +)
    (<o25> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category location +)
    (<o26> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category location +)
    (<o27> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category location +)
    (<o28> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category location +)
    (<o29> ^item-type object + ^handle object-17 + ^predicates <pr17> +)
    (<pr17> ^visible true + ^category location +)
    (<o30> ^item-type object + ^handle object-18 + ^predicates <pr18> +)
    (<pr18> ^visible true + ^category location +)
    (<o31> ^item-type object + ^handle object-19 + ^predicates <pr19> +)
    (<pr19> ^visible true + ^category location +)
    (<o10> ^item-type object + ^handle object-20 + ^predicates <pr20> +)
    (<pr20> ^visible true + ^category block + ^color blue1 +)
    (<o11> ^item-type object + ^handle object-21 + ^predicates <pr21> +)
    (<pr21> ^visible true + ^category block + ^color blue1 +)
    (<o12> ^item-type object + ^handle object-22 + ^predicates <pr22> +)
    (<pr22> ^visible true + ^category block + ^color blue1 +)
    (<o13> ^item-type object + ^handle object-23 + ^predicates <pr23> +)
    (<pr23> ^visible true + ^category block + ^color blue1 +)
    (<o14> ^item-type object + ^handle object-24 + ^predicates <pr24> +)
    (<pr24> ^visible true + ^category block + ^color red1 +)
    (<o15> ^item-type object + ^handle object-25 + ^predicates <pr25> +)
    (<pr25> ^visible true + ^category block + ^color red1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +)
    (<in0> ^1 <o10> + ^2 <o27> +)
    (<in1> ^1 <o11> + ^2 <o28> +)
    (<in2> ^1 <o12> + ^2 <o29> +)
    (<in3> ^1 <o14> + ^2 <o15> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in4> +
           ^instance <in5> + ^instance <in6> + ^instance <in7> +)
    (<in4> ^1 <o27> + ^2 <o10> +)
    (<in5> ^1 <o28> + ^2 <o11> +)
    (<in6> ^1 <o29> + ^2 <o12> +)
    (<in7> ^1 <o15> + ^2 <o14> +)
    (<above1> ^item-type predicate + ^handle above1 + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +
           ^instance <in12> + ^instance <in13> + ^instance <in14> +
           ^instance <in15> + ^instance <in16> + ^instance <in17> +
           ^instance <in18> + ^instance <in19> + ^instance <in20> +
           ^instance <in21> + ^instance <in22> +)
    (<in8> ^1 <o7> + ^2 <o27> +)
    (<in9> ^1 <o4> + ^2 <o7> +)
    (<in10> ^1 <o1> + ^2 <o4> +)
    (<in11> ^1 <o8> + ^2 <o28> +)
    (<in12> ^1 <o5> + ^2 <o8> +)
    (<in13> ^1 <o2> + ^2 <o5> +)
    (<in14> ^1 <o3> + ^2 <o6> +)
    (<in15> ^1 <o6> + ^2 <o9> +)
    (<in16> ^1 <o9> + ^2 <o29> +)
    (<in17> ^1 <o21> + ^2 <o23> +)
    (<in18> ^1 <o23> + ^2 <o25> +)
    (<in19> ^1 <o25> + ^2 <o30> +)
    (<in20> ^1 <o22> + ^2 <o24> +)
    (<in21> ^1 <o24> + ^2 <o26> +)
    (<in22> ^1 <o26> + ^2 <o31> +)
    (<linear> ^item-type predicate + ^handle linear + ^instance <in23> +
           ^instance <in24> + ^instance <in25> + ^instance <in26> +
           ^instance <in27> + ^instance <in28> + ^instance <in29> +
           ^instance <in30> + ^instance <in31> + ^instance <in32> +
           ^instance <in33> + ^instance <in34> + ^instance <in35> +
           ^instance <in36> + ^instance <in37> + ^instance <in38> +
           ^instance <in39> + ^instance <in40> + ^instance <in41> +
           ^instance <in42> + ^instance <in43> + ^instance <in44> +
           ^instance <in45> + ^instance <in46> + ^instance <in47> +
           ^instance <in48> + ^instance <in49> + ^instance <in50> +
           ^instance <in51> + ^instance <in52> + ^instance <in53> +
           ^instance <in54> + ^instance <in55> + ^instance <in56> +
           ^instance <in57> +)
    (<in23> ^1 <set23> +)
    (<set23> ^object <o1> + ^object <o2> + ^object <o3> +)
    (<in24> ^1 <set24> +)
    (<set24> ^object <o1> + ^object <o5> + ^object <o9> +)
    (<in25> ^1 <set25> +)
    (<set25> ^object <o1> + ^object <o4> + ^object <o7> +)
    (<in26> ^1 <set26> +)
    (<set26> ^object <o4> + ^object <o5> + ^object <o6> +)
    (<in27> ^1 <set27> +)
    (<set27> ^object <o7> + ^object <o8> + ^object <o9> +)
    (<in28> ^1 <set28> +)
    (<set28> ^object <o2> + ^object <o5> + ^object <o8> +)
    (<in29> ^1 <set29> +)
    (<set29> ^object <o3> + ^object <o6> + ^object <o9> +)
    (<in30> ^1 <set30> +)
    (<set30> ^object <o3> + ^object <o5> + ^object <o7> +)
    (<in31> ^1 <set31> +)
    (<set31> ^object <o3> + ^object <o21> + ^object <o22> +)
    (<in32> ^1 <set32> +)
    (<set32> ^object <o6> + ^object <o23> + ^object <o24> +)
    (<in33> ^1 <set33> +)
    (<set33> ^object <o9> + ^object <o25> + ^object <o26> +)
    (<in34> ^1 <set34> +)
    (<set34> ^object <o29> + ^object <o30> + ^object <o31> +)
    (<in35> ^1 <set35> +)
    (<set35> ^object <o27> + ^object <o28> + ^object <o29> +)
    (<in36> ^1 <set36> +)
    (<set36> ^object <o2> + ^object <o3> + ^object <o21> +)
    (<in37> ^1 <set37> +)
    (<set37> ^object <o5> + ^object <o6> + ^object <o23> +)
    (<in38> ^1 <set38> +)
    (<set38> ^object <o8> + ^object <o9> + ^object <o25> +)
    (<in39> ^1 <set39> +)
    (<set39> ^object <o28> + ^object <o29> + ^object <o30> +)
    (<in40> ^1 <set40> +)
    (<set40> ^object <o21> + ^object <o23> + ^object <o25> +)
    (<in41> ^1 <set41> +)
    (<set41> ^object <o22> + ^object <o24> + ^object <o26> +)
    (<in42> ^1 <set42> +)
    (<set42> ^object <o4> + ^object <o7> + ^object <o27> +)
    (<in43> ^1 <set43> +)
    (<set43> ^object <o5> + ^object <o8> + ^object <o28> +)
    (<in44> ^1 <set44> +)
    (<set44> ^object <o6> + ^object <o9> + ^object <o29> +)
    (<in45> ^1 <set45> +)
    (<set45> ^object <o23> + ^object <o25> + ^object <o30> +)
    (<in46> ^1 <set46> +)
    (<set46> ^object <o24> + ^object <o26> + ^object <o31> +)
    (<in47> ^1 <set47> +)
    (<set47> ^object <o4> + ^object <o8> + ^object <o29> +)
    (<in48> ^1 <set48> +)
    (<set48> ^object <o5> + ^object <o9> + ^object <o30> +)
    (<in49> ^1 <set49> +)
    (<set49> ^object <o6> + ^object <o25> + ^object <o31> +)
    (<in50> ^1 <set50> +)
    (<set50> ^object <o2> + ^object <o6> + ^object <o25> +)
    (<in51> ^1 <set51> +)
    (<set51> ^object <o3> + ^object <o23> + ^object <o25> +)
    (<in52> ^1 <set52> +)
    (<set52> ^object <o24> + ^object <o25> + ^object <o29> +)
    (<in53> ^1 <set53> +)
    (<set53> ^object <o23> + ^object <o9> + ^object <o28> +)
    (<in54> ^1 <set54> +)
    (<set54> ^object <o6> + ^object <o8> + ^object <o27> +)
    (<in55> ^1 <set55> +)
    (<set55> ^object <o22> + ^object <o23> + ^object <o9> +)
    (<in56> ^1 <set56> +)
    (<set56> ^object <o21> + ^object <o6> + ^object <o8> +)
    (<in57> ^1 <set57> +)
    (<set57> ^object <o3> + ^object <o5> + ^object <o7> +)
}

sp {dialog-event*apply*game-state-change-respond*fail-sudoku4
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type fail-sudoku4)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^x 1 + ^y 1 + ^value 0 +
           ^sub-grid 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^x 2 + ^y 1 + ^value 1 +
           ^sub-grid 1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^x 3 + ^y 1 + ^value 2 +
           ^sub-grid 2 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^x 4 + ^y 1 + ^value 0 +
           ^sub-grid 2 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^x 1 + ^y 2 + ^value 4 +
           ^sub-grid 1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^x 2 + ^y 2 + ^value 4 +
           ^sub-grid 1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^x 3 + ^y 2 + ^value 0 +
           ^sub-grid 2 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^x 4 + ^y 2 + ^value 0 +
           ^sub-grid 2 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^x 1 + ^y 3 + ^value 0 +
           ^sub-grid 3 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^x 2 + ^y 3 + ^value 0 +
           ^sub-grid 3 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location + ^x 3 + ^y 3 + ^value 0 +
           ^sub-grid 4 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location + ^x 4 + ^y 3 + ^value 2 +
           ^sub-grid 4 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category location + ^x 1 + ^y 4 + ^value 0 +
           ^sub-grid 3 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category location + ^x 2 + ^y 4 + ^value 4 +
           ^sub-grid 3 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category location + ^x 3 + ^y 4 + ^value 3 +
           ^sub-grid 4 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category location + ^x 4 + ^y 4 + ^value 0 +
           ^sub-grid 4 +)
}

sp {dialog-event*apply*game-state-change-respond*final-frog
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-frog)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <left-of1> +
           ^predicate <right-of1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color red1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color red1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^color blue1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^color blue1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^color blue1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^color blue1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block + ^color red1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category block + ^color red1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +)
    (<in0> ^1 <o6> + ^2 <o4> +)
    (<in1> ^1 <o7> + ^2 <o5> +)
    (<in2> ^1 <o8> + ^2 <o1> +)
    (<in3> ^1 <o9> + ^2 <o2> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in4> +
           ^instance <in5> + ^instance <in6> + ^instance <in7> +)
    (<in4> ^1 <o4> + ^2 <o6> +)
    (<in5> ^1 <o5> + ^2 <o7> +)
    (<in6> ^1 <o1> + ^2 <o8> +)
    (<in7> ^1 <o2> + ^2 <o9> +)
    (<left-of1> ^item-type predicate + ^handle left-of1 + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +)
    (<in8> ^1 <o1> + ^2 <o2> +)
    (<in9> ^1 <o2> + ^2 <o3> +)
    (<in10> ^1 <o3> + ^2 <o4> +)
    (<in11> ^1 <o4> + ^2 <o5> +)
    (<right-of1> ^item-type predicate + ^handle right-of1 + ^instance <in12> +
           ^instance <in13> + ^instance <in14> + ^instance <in15> +)
    (<in12> ^1 <o2> + ^2 <o1> +)
    (<in13> ^1 <o3> + ^2 <o2> +)
    (<in14> ^1 <o4> + ^2 <o3> +)
    (<in15> ^1 <o5> + ^2 <o4> +)
}

sp {dialog-event*apply*game-state-change-respond*init-connect-4
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-connect-4)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o21> + ^object <o22> +
           ^object <o23> + ^object <o24> + ^object <o25> + ^object <o26> +
           ^object <o27> + ^object <o28> + ^object <o29> + ^object <o30> +
           ^object <o31> + ^object <o10> + ^object <o11> + ^object <o12> +
           ^object <o13> + ^object <o14> + ^object <o15> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <above1> +
           ^predicate <linear> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location +)
    (<o21> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location +)
    (<o22> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location +)
    (<o23> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location +)
    (<o24> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category location +)
    (<o25> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category location +)
    (<o26> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category location +)
    (<o27> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category location +)
    (<o28> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category location +)
    (<o29> ^item-type object + ^handle object-17 + ^predicates <pr17> +)
    (<pr17> ^visible true + ^category location +)
    (<o30> ^item-type object + ^handle object-18 + ^predicates <pr18> +)
    (<pr18> ^visible true + ^category location +)
    (<o31> ^item-type object + ^handle object-19 + ^predicates <pr19> +)
    (<pr19> ^visible true + ^category location +)
    (<o10> ^item-type object + ^handle object-20 + ^predicates <pr20> +)
    (<pr20> ^visible true + ^category block + ^color red1 +)
    (<o11> ^item-type object + ^handle object-21 + ^predicates <pr21> +)
    (<pr21> ^visible true + ^category block + ^color red1 +)
    (<o12> ^item-type object + ^handle object-22 + ^predicates <pr22> +)
    (<pr22> ^visible true + ^category block + ^color red1 +)
    (<o13> ^item-type object + ^handle object-23 + ^predicates <pr23> +)
    (<pr23> ^visible true + ^category block + ^color blue1 +)
    (<o14> ^item-type object + ^handle object-24 + ^predicates <pr24> +)
    (<pr24> ^visible true + ^category block + ^color blue1 +)
    (<o15> ^item-type object + ^handle object-25 + ^predicates <pr25> +)
    (<pr25> ^visible true + ^category block + ^color blue1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +)
    (<in0> ^1 <o10> + ^2 <o11> +)
    (<in1> ^1 <o11> + ^2 <o12> +)
    (<in2> ^1 <o13> + ^2 <o14> +)
    (<in3> ^1 <o14> + ^2 <o15> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in4> +
           ^instance <in5> + ^instance <in6> + ^instance <in7> +)
    (<in4> ^1 <o11> + ^2 <o10> +)
    (<in5> ^1 <o12> + ^2 <o11> +)
    (<in6> ^1 <o14> + ^2 <o13> +)
    (<in7> ^1 <o15> + ^2 <o14> +)
    (<above1> ^item-type predicate + ^handle above1 + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +
           ^instance <in12> + ^instance <in13> + ^instance <in14> +
           ^instance <in15> + ^instance <in16> + ^instance <in17> +
           ^instance <in18> + ^instance <in19> + ^instance <in20> +
           ^instance <in21> + ^instance <in22> +)
    (<in8> ^1 <o7> + ^2 <o27> +)
    (<in9> ^1 <o4> + ^2 <o7> +)
    (<in10> ^1 <o1> + ^2 <o4> +)
    (<in11> ^1 <o8> + ^2 <o28> +)
    (<in12> ^1 <o5> + ^2 <o8> +)
    (<in13> ^1 <o2> + ^2 <o5> +)
    (<in14> ^1 <o3> + ^2 <o6> +)
    (<in15> ^1 <o6> + ^2 <o9> +)
    (<in16> ^1 <o9> + ^2 <o29> +)
    (<in17> ^1 <o21> + ^2 <o23> +)
    (<in18> ^1 <o23> + ^2 <o25> +)
    (<in19> ^1 <o25> + ^2 <o30> +)
    (<in20> ^1 <o22> + ^2 <o24> +)
    (<in21> ^1 <o24> + ^2 <o26> +)
    (<in22> ^1 <o26> + ^2 <o31> +)
    (<linear> ^item-type predicate + ^handle linear + ^instance <in23> +
           ^instance <in24> + ^instance <in25> + ^instance <in26> +
           ^instance <in27> + ^instance <in28> + ^instance <in29> +
           ^instance <in30> + ^instance <in31> + ^instance <in32> +
           ^instance <in33> + ^instance <in34> + ^instance <in35> +
           ^instance <in36> + ^instance <in37> + ^instance <in38> +
           ^instance <in39> +)
    (<in23> ^1 <set23> +)
    (<set23> ^object <o1> + ^object <o2> + ^object <o3> + ^object <o21> +)
    (<in24> ^1 <set24> +)
    (<set24> ^object <o1> + ^object <o5> + ^object <o9> + ^object <o30> +)
    (<in25> ^1 <set25> +)
    (<set25> ^object <o1> + ^object <o4> + ^object <o7> + ^object <o27> +)
    (<in26> ^1 <set26> +)
    (<set26> ^object <o4> + ^object <o5> + ^object <o6> + ^object <o23> +)
    (<in27> ^1 <set27> +)
    (<set27> ^object <o7> + ^object <o8> + ^object <o9> + ^object <o25> +)
    (<in28> ^1 <set28> +)
    (<set28> ^object <o27> + ^object <o28> + ^object <o29> + ^object <o30> +)
    (<in29> ^1 <set29> +)
    (<set29> ^object <o2> + ^object <o5> + ^object <o8> + ^object <o28> +)
    (<in30> ^1 <set30> +)
    (<set30> ^object <o3> + ^object <o6> + ^object <o9> + ^object <o29> +)
    (<in31> ^1 <set31> +)
    (<set31> ^object <o21> + ^object <o23> + ^object <o25> + ^object <o30> +)
    (<in32> ^1 <set32> +)
    (<set32> ^object <o21> + ^object <o6> + ^object <o8> + ^object <o27> +)
    (<in33> ^1 <set33> +)
    (<set33> ^object <o2> + ^object <o3> + ^object <o21> + ^object <o22> +)
    (<in34> ^1 <set34> +)
    (<set34> ^object <o5> + ^object <o6> + ^object <o23> + ^object <o24> +)
    (<in35> ^1 <set35> +)
    (<set35> ^object <o8> + ^object <o9> + ^object <o25> + ^object <o26> +)
    (<in36> ^1 <set36> +)
    (<set36> ^object <o28> + ^object <o29> + ^object <o30> + ^object <o31> +)
    (<in37> ^1 <set37> +)
    (<set37> ^object <o22> + ^object <o24> + ^object <o26> + ^object <o31> +)
    (<in38> ^1 <set38> +)
    (<set38> ^object <o2> + ^object <o6> + ^object <o25> + ^object <o31> +)
    (<in39> ^1 <set39> +)
    (<set39> ^object <o22> + ^object <o23> + ^object <o9> + ^object <o28> +)
}

sp {dialog-event*apply*game-state-change-respond*fail-president
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type fail-president)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category object + ^shape card + ^suit spades +
           ^value 5 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category object + ^shape card + ^suit hearts +
           ^value 1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category object + ^shape card + ^suit diamonds +
           ^value 9 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category object + ^shape card + ^suit club +
           ^value 10 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category object + ^shape card + ^suit ace +
           ^value 9 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category object + ^shape card + ^suit ace +
           ^value 10 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category object + ^name deck +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category object + ^shape hand + ^name player +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category object + ^name dealer +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> +)
    (<in0> ^1 <o1> + ^2 <o8> +)
    (<in1> ^1 <o2> + ^2 <o8> +)
    (<in2> ^1 <o3> + ^2 <o8> +)
    (<in3> ^1 <o4> + ^2 <o8> +)
    (<in4> ^1 <o5> + ^2 <o7> +)
    (<in5> ^1 <o6> + ^2 <o8> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in6> +
           ^instance <in7> + ^instance <in8> + ^instance <in9> +
           ^instance <in10> + ^instance <in11> +)
    (<in6> ^1 <o8> + ^2 <o1> +)
    (<in7> ^1 <o8> + ^2 <o2> +)
    (<in8> ^1 <o8> + ^2 <o3> +)
    (<in9> ^1 <o8> + ^2 <o4> +)
    (<in10> ^1 <o7> + ^2 <o5> +)
    (<in11> ^1 <o8> + ^2 <o6> +)
}

sp {dialog-event*apply*game-state-change-respond*init-husbands2
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-husbands2)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^shape bank1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^shape bank1 +
           ^name destination1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category block + ^shape woman1 +
           ^last-name smith1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^shape woman1 +
           ^last-name bale1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^shape man1 + ^last-name smith1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^shape man1 + ^last-name bale1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^shape boat1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> +)
    (<in0> ^1 <o3> + ^2 <o1> +)
    (<in1> ^1 <o4> + ^2 <o1> +)
    (<in2> ^1 <o5> + ^2 <o1> +)
    (<in3> ^1 <o6> + ^2 <o1> +)
    (<in4> ^1 <o7> + ^2 <o1> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in5> +
           ^instance <in6> + ^instance <in7> + ^instance <in8> +
           ^instance <in9> +)
    (<in5> ^1 <o1> + ^2 <o3> +)
    (<in6> ^1 <o1> + ^2 <o4> +)
    (<in7> ^1 <o1> + ^2 <o5> +)
    (<in8> ^1 <o1> + ^2 <o6> +)
    (<in9> ^1 <o1> + ^2 <o7> +)
}

sp {dialog-event*apply*game-state-change-respond*final-lzstacked-frogs2
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-lzstacked-frogs2)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^x 1 + ^y 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^x 2 + ^y 1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^x 3 + ^y 1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^x 4 + ^y 1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^x 5 + ^y 1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^x 6 + ^y 1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^color red1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category block +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category block +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> +)
    (<in0> ^1 <o7> + ^2 <o1> +)
    (<in1> ^1 <o8> + ^2 <o1> +)
    (<in2> ^1 <o9> + ^2 <o1> +)
    (<in3> ^1 <o10> + ^2 <o1> +)
    (<in4> ^1 <o11> + ^2 <o1> +)
    (<in5> ^1 <o12> + ^2 <o1> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in6> +
           ^instance <in7> + ^instance <in8> + ^instance <in9> +
           ^instance <in10> + ^instance <in11> +)
    (<in6> ^1 <o1> + ^2 <o7> +)
    (<in7> ^1 <o1> + ^2 <o8> +)
    (<in8> ^1 <o1> + ^2 <o9> +)
    (<in9> ^1 <o1> + ^2 <o10> +)
    (<in10> ^1 <o1> + ^2 <o11> +)
    (<in11> ^1 <o1> + ^2 <o12> +)
}

sp {dialog-event*apply*game-state-change-respond*final-othello
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-othello)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> + ^object <o17> + ^object <o18> + ^object <o19> +
           ^object <o20> + ^object <o21> + ^object <o22> + ^object <o23> +
           ^object <o24> + ^object <o25> + ^object <o26> + ^object <o27> +
           ^object <o28> + ^object <o29> + ^object <o30> + ^object <o31> +
           ^object <o32> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^x 1 + ^y 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^x 2 + ^y 1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^x 3 + ^y 1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^x 4 + ^y 1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^x 1 + ^y 2 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^x 2 + ^y 2 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^x 3 + ^y 2 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^x 4 + ^y 2 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^x 1 + ^y 3 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^x 2 + ^y 3 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location + ^x 3 + ^y 3 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location + ^x 4 + ^y 3 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category location + ^x 1 + ^y 4 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category location + ^x 2 + ^y 4 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category location + ^x 3 + ^y 4 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category location + ^x 4 + ^y 4 +)
    (<o17> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category block + ^color red1 +)
    (<o18> ^item-type object + ^handle object-17 + ^predicates <pr17> +)
    (<pr17> ^visible true + ^category block + ^color red1 +)
    (<o19> ^item-type object + ^handle object-18 + ^predicates <pr18> +)
    (<pr18> ^visible true + ^category block + ^color red1 +)
    (<o20> ^item-type object + ^handle object-19 + ^predicates <pr19> +)
    (<pr19> ^visible true + ^category block + ^color blue1 +)
    (<o21> ^item-type object + ^handle object-20 + ^predicates <pr20> +)
    (<pr20> ^visible true + ^category block + ^color blue1 +)
    (<o22> ^item-type object + ^handle object-21 + ^predicates <pr21> +)
    (<pr21> ^visible true + ^category block + ^color blue1 +)
    (<o23> ^item-type object + ^handle object-22 + ^predicates <pr22> +)
    (<pr22> ^visible true + ^category block + ^color red1 +)
    (<o24> ^item-type object + ^handle object-23 + ^predicates <pr23> +)
    (<pr23> ^visible true + ^category block + ^color red1 +)
    (<o25> ^item-type object + ^handle object-24 + ^predicates <pr24> +)
    (<pr24> ^visible true + ^category block + ^color red1 +)
    (<o26> ^item-type object + ^handle object-25 + ^predicates <pr25> +)
    (<pr25> ^visible true + ^category block + ^color blue1 +)
    (<o27> ^item-type object + ^handle object-26 + ^predicates <pr26> +)
    (<pr26> ^visible true + ^category block + ^color red1 +)
    (<o28> ^item-type object + ^handle object-27 + ^predicates <pr27> +)
    (<pr27> ^visible true + ^category block + ^color blue1 +)
    (<o29> ^item-type object + ^handle object-28 + ^predicates <pr28> +)
    (<pr28> ^visible true + ^category block + ^color red1 +)
    (<o30> ^item-type object + ^handle object-29 + ^predicates <pr29> +)
    (<pr29> ^visible true + ^category block + ^color blue1 +)
    (<o31> ^item-type object + ^handle object-30 + ^predicates <pr30> +)
    (<pr30> ^visible true + ^category block + ^color red1 +)
    (<o32> ^item-type object + ^handle object-31 + ^predicates <pr31> +)
    (<pr31> ^visible true + ^category block + ^color red1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +
           ^instance <in7> + ^instance <in8> + ^instance <in9> +
           ^instance <in10> + ^instance <in11> + ^instance <in12> +
           ^instance <in13> + ^instance <in14> + ^instance <in15> +)
    (<in0> ^1 <o17> + ^2 <o1> +)
    (<in1> ^1 <o18> + ^2 <o2> +)
    (<in2> ^1 <o19> + ^2 <o3> +)
    (<in3> ^1 <o20> + ^2 <o4> +)
    (<in4> ^1 <o21> + ^2 <o5> +)
    (<in5> ^1 <o22> + ^2 <o6> +)
    (<in6> ^1 <o23> + ^2 <o7> +)
    (<in7> ^1 <o24> + ^2 <o8> +)
    (<in8> ^1 <o25> + ^2 <o9> +)
    (<in9> ^1 <o26> + ^2 <o10> +)
    (<in10> ^1 <o27> + ^2 <o11> +)
    (<in11> ^1 <o28> + ^2 <o12> +)
    (<in12> ^1 <o29> + ^2 <o13> +)
    (<in13> ^1 <o30> + ^2 <o14> +)
    (<in14> ^1 <o31> + ^2 <o15> +)
    (<in15> ^1 <o32> + ^2 <o16> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> + ^instance <in25> +
           ^instance <in26> + ^instance <in27> + ^instance <in28> +
           ^instance <in29> + ^instance <in30> + ^instance <in31> +)
    (<in16> ^1 <o1> + ^2 <o17> +)
    (<in17> ^1 <o2> + ^2 <o18> +)
    (<in18> ^1 <o3> + ^2 <o19> +)
    (<in19> ^1 <o4> + ^2 <o20> +)
    (<in20> ^1 <o5> + ^2 <o21> +)
    (<in21> ^1 <o6> + ^2 <o22> +)
    (<in22> ^1 <o7> + ^2 <o23> +)
    (<in23> ^1 <o8> + ^2 <o24> +)
    (<in24> ^1 <o9> + ^2 <o25> +)
    (<in25> ^1 <o10> + ^2 <o26> +)
    (<in26> ^1 <o11> + ^2 <o27> +)
    (<in27> ^1 <o12> + ^2 <o28> +)
    (<in28> ^1 <o13> + ^2 <o29> +)
    (<in29> ^1 <o14> + ^2 <o30> +)
    (<in30> ^1 <o15> + ^2 <o31> +)
    (<in31> ^1 <o16> + ^2 <o32> +)
}

sp {dialog-event*apply*game-state-change-respond*second-frog4
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type second-frog4)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> + ^object <o17> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <left-of1> +
           ^predicate <right-of1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color red1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color red1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^color red1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^color red1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^color blue1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^color blue1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^color blue1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^color blue1 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block + ^color blue1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block + ^color blue1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category block + ^color blue1 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block + ^color blue1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category block + ^color red1 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category block + ^color red1 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category block + ^color red1 +)
    (<o17> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category block + ^color red1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +
           ^instance <in7> +)
    (<in0> ^1 <o10> + ^2 <o1> +)
    (<in1> ^1 <o11> + ^2 <o2> +)
    (<in2> ^1 <o12> + ^2 <o3> +)
    (<in3> ^1 <o13> + ^2 <o6> +)
    (<in4> ^1 <o14> + ^2 <o4> +)
    (<in5> ^1 <o15> + ^2 <o7> +)
    (<in6> ^1 <o16> + ^2 <o8> +)
    (<in7> ^1 <o17> + ^2 <o9> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +
           ^instance <in12> + ^instance <in13> + ^instance <in14> +
           ^instance <in15> +)
    (<in8> ^1 <o1> + ^2 <o10> +)
    (<in9> ^1 <o2> + ^2 <o11> +)
    (<in10> ^1 <o3> + ^2 <o12> +)
    (<in11> ^1 <o6> + ^2 <o13> +)
    (<in12> ^1 <o4> + ^2 <o14> +)
    (<in13> ^1 <o7> + ^2 <o15> +)
    (<in14> ^1 <o8> + ^2 <o16> +)
    (<in15> ^1 <o9> + ^2 <o17> +)
    (<left-of1> ^item-type predicate + ^handle left-of1 + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> +)
    (<in16> ^1 <o1> + ^2 <o2> +)
    (<in17> ^1 <o2> + ^2 <o3> +)
    (<in18> ^1 <o3> + ^2 <o4> +)
    (<in19> ^1 <o4> + ^2 <o5> +)
    (<in20> ^1 <o5> + ^2 <o6> +)
    (<in21> ^1 <o6> + ^2 <o7> +)
    (<in22> ^1 <o7> + ^2 <o8> +)
    (<in23> ^1 <o8> + ^2 <o9> +)
    (<right-of1> ^item-type predicate + ^handle right-of1 + ^instance <in24> +
           ^instance <in25> + ^instance <in26> + ^instance <in27> +
           ^instance <in28> + ^instance <in29> + ^instance <in30> +
           ^instance <in31> +)
    (<in24> ^1 <o2> + ^2 <o1> +)
    (<in25> ^1 <o3> + ^2 <o2> +)
    (<in26> ^1 <o4> + ^2 <o3> +)
    (<in27> ^1 <o5> + ^2 <o4> +)
    (<in28> ^1 <o6> + ^2 <o5> +)
    (<in29> ^1 <o7> + ^2 <o6> +)
    (<in30> ^1 <o8> + ^2 <o7> +)
    (<in31> ^1 <o9> + ^2 <o8> +)
}

sp {dialog-event*apply*game-state-change-respond*init-frog
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-frog)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <left-of1> +
           ^predicate <right-of1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color red1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color red1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^color blue1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^color blue1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^color blue1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^color blue1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block + ^color red1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category block + ^color red1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +)
    (<in0> ^1 <o6> + ^2 <o1> +)
    (<in1> ^1 <o7> + ^2 <o2> +)
    (<in2> ^1 <o8> + ^2 <o4> +)
    (<in3> ^1 <o9> + ^2 <o5> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in4> +
           ^instance <in5> + ^instance <in6> + ^instance <in7> +)
    (<in4> ^1 <o1> + ^2 <o6> +)
    (<in5> ^1 <o2> + ^2 <o7> +)
    (<in6> ^1 <o4> + ^2 <o8> +)
    (<in7> ^1 <o5> + ^2 <o9> +)
    (<left-of1> ^item-type predicate + ^handle left-of1 + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +)
    (<in8> ^1 <o1> + ^2 <o2> +)
    (<in9> ^1 <o2> + ^2 <o3> +)
    (<in10> ^1 <o3> + ^2 <o4> +)
    (<in11> ^1 <o4> + ^2 <o5> +)
    (<right-of1> ^item-type predicate + ^handle right-of1 + ^instance <in12> +
           ^instance <in13> + ^instance <in14> + ^instance <in15> +)
    (<in12> ^1 <o2> + ^2 <o1> +)
    (<in13> ^1 <o3> + ^2 <o2> +)
    (<in14> ^1 <o4> + ^2 <o3> +)
    (<in15> ^1 <o5> + ^2 <o4> +)
}

sp {dialog-event*apply*game-state-change-respond*init-mini-sudoku2
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-mini-sudoku2)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^row 1 + ^column 1 +
           ^value 3 + ^section 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^row 2 + ^column 1 +
           ^value 1 + ^section 1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^row 3 + ^column 1 +
           ^value 2 + ^section 2 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^row 4 + ^column 1 +
           ^value 4 + ^section 2 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^row 1 + ^column 2 +
           ^value 4 + ^section 1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^row 2 + ^column 2 +
           ^section 1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^row 3 + ^column 2 +
           ^value 1 + ^section 2 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^row 4 + ^column 2 +
           ^value 3 + ^section 2 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^row 1 + ^column 3 +
           ^value 1 + ^section 3 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^row 2 + ^column 3 +
           ^section 3 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location + ^row 3 + ^column 3 +
           ^value 4 + ^section 4 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location + ^row 4 + ^column 3 +
           ^value 2 + ^section 4 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category location + ^row 1 + ^column 4 +
           ^section 3 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category location + ^row 2 + ^column 4 +
           ^section 3 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category location + ^row 3 + ^column 4 +
           ^value 3 + ^section 4 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category location + ^row 4 + ^column 4 +
           ^value 1 + ^section 4 +)
}

sp {dialog-event*apply*game-state-change-respond*fail-risk
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type fail-risk)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <near1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^color blue1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block + ^color blue1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category block + ^color blue1 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block + ^color blue1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block + ^color blue1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category block + ^color blue1 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block + ^color blue1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category block + ^color blue1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +
           ^instance <in7> +)
    (<in0> ^1 <o7> + ^2 <o1> +)
    (<in1> ^1 <o8> + ^2 <o1> +)
    (<in2> ^1 <o9> + ^2 <o2> +)
    (<in3> ^1 <o10> + ^2 <o6> +)
    (<in4> ^1 <o11> + ^2 <o3> +)
    (<in5> ^1 <o12> + ^2 <o3> +)
    (<in6> ^1 <o13> + ^2 <o4> +)
    (<in7> ^1 <o14> + ^2 <o5> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +
           ^instance <in12> + ^instance <in13> + ^instance <in14> +
           ^instance <in15> +)
    (<in8> ^1 <o1> + ^2 <o7> +)
    (<in9> ^1 <o1> + ^2 <o8> +)
    (<in10> ^1 <o2> + ^2 <o9> +)
    (<in11> ^1 <o6> + ^2 <o10> +)
    (<in12> ^1 <o3> + ^2 <o11> +)
    (<in13> ^1 <o3> + ^2 <o12> +)
    (<in14> ^1 <o4> + ^2 <o13> +)
    (<in15> ^1 <o5> + ^2 <o14> +)
    (<near1> ^item-type predicate + ^handle near1 + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> + ^instance <in25> +
           ^instance <in26> + ^instance <in27> + ^instance <in28> +
           ^instance <in29> + ^instance <in30> + ^instance <in31> +
           ^instance <in32> + ^instance <in33> + ^instance <in34> +
           ^instance <in35> + ^instance <in36> + ^instance <in37> +)
    (<in16> ^1 <o1> + ^2 <o2> +)
    (<in17> ^1 <o1> + ^2 <o4> +)
    (<in18> ^1 <o1> + ^2 <o5> +)
    (<in19> ^1 <o2> + ^2 <o1> +)
    (<in20> ^1 <o2> + ^2 <o3> +)
    (<in21> ^1 <o2> + ^2 <o4> +)
    (<in22> ^1 <o2> + ^2 <o5> +)
    (<in23> ^1 <o2> + ^2 <o6> +)
    (<in24> ^1 <o3> + ^2 <o2> +)
    (<in25> ^1 <o3> + ^2 <o5> +)
    (<in26> ^1 <o3> + ^2 <o6> +)
    (<in27> ^1 <o4> + ^2 <o1> +)
    (<in28> ^1 <o4> + ^2 <o2> +)
    (<in29> ^1 <o4> + ^2 <o5> +)
    (<in30> ^1 <o5> + ^2 <o1> +)
    (<in31> ^1 <o5> + ^2 <o2> +)
    (<in32> ^1 <o5> + ^2 <o3> +)
    (<in33> ^1 <o5> + ^2 <o4> +)
    (<in34> ^1 <o5> + ^2 <o6> +)
    (<in35> ^1 <o6> + ^2 <o2> +)
    (<in36> ^1 <o6> + ^2 <o3> +)
    (<in37> ^1 <o6> + ^2 <o5> +)
}

sp {dialog-event*apply*game-state-change-respond*final-maze
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-maze)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <near1> +
           ^predicate <diagonal-with1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^color blue1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block + ^color blue1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category block + ^color black1 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category block + ^color black1 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category block + ^color black1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +)
    (<in0> ^1 <o13> + ^2 <o10> +)
    (<in1> ^1 <o14> + ^2 <o5> +)
    (<in2> ^1 <o15> + ^2 <o8> +)
    (<in3> ^1 <o16> + ^2 <o11> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in4> +
           ^instance <in5> + ^instance <in6> + ^instance <in7> +)
    (<in4> ^1 <o10> + ^2 <o13> +)
    (<in5> ^1 <o5> + ^2 <o14> +)
    (<in6> ^1 <o8> + ^2 <o15> +)
    (<in7> ^1 <o11> + ^2 <o16> +)
    (<near1> ^item-type predicate + ^handle near1 + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +
           ^instance <in12> + ^instance <in13> + ^instance <in14> +
           ^instance <in15> + ^instance <in16> + ^instance <in17> +
           ^instance <in18> + ^instance <in19> + ^instance <in20> +
           ^instance <in21> + ^instance <in22> + ^instance <in23> +
           ^instance <in24> + ^instance <in25> + ^instance <in26> +
           ^instance <in27> + ^instance <in28> + ^instance <in29> +
           ^instance <in30> + ^instance <in31> + ^instance <in32> +
           ^instance <in33> + ^instance <in34> + ^instance <in35> +
           ^instance <in36> + ^instance <in37> + ^instance <in38> +
           ^instance <in39> + ^instance <in40> + ^instance <in41> +
           ^instance <in42> + ^instance <in43> + ^instance <in44> +
           ^instance <in45> + ^instance <in46> + ^instance <in47> +
           ^instance <in48> + ^instance <in49> + ^instance <in50> +
           ^instance <in51> + ^instance <in52> + ^instance <in53> +
           ^instance <in54> + ^instance <in55> + ^instance <in56> +
           ^instance <in57> + ^instance <in58> + ^instance <in59> +
           ^instance <in60> + ^instance <in61> + ^instance <in62> +
           ^instance <in63> + ^instance <in64> + ^instance <in65> +)
    (<in8> ^1 <o1> + ^2 <o2> +)
    (<in9> ^1 <o1> + ^2 <o4> +)
    (<in10> ^1 <o1> + ^2 <o5> +)
    (<in11> ^1 <o2> + ^2 <o1> +)
    (<in12> ^1 <o2> + ^2 <o3> +)
    (<in13> ^1 <o2> + ^2 <o4> +)
    (<in14> ^1 <o2> + ^2 <o5> +)
    (<in15> ^1 <o2> + ^2 <o6> +)
    (<in16> ^1 <o3> + ^2 <o2> +)
    (<in17> ^1 <o3> + ^2 <o5> +)
    (<in18> ^1 <o3> + ^2 <o6> +)
    (<in19> ^1 <o4> + ^2 <o1> +)
    (<in20> ^1 <o4> + ^2 <o2> +)
    (<in21> ^1 <o4> + ^2 <o5> +)
    (<in22> ^1 <o4> + ^2 <o7> +)
    (<in23> ^1 <o4> + ^2 <o8> +)
    (<in24> ^1 <o5> + ^2 <o1> +)
    (<in25> ^1 <o5> + ^2 <o2> +)
    (<in26> ^1 <o5> + ^2 <o3> +)
    (<in27> ^1 <o5> + ^2 <o4> +)
    (<in28> ^1 <o5> + ^2 <o6> +)
    (<in29> ^1 <o5> + ^2 <o7> +)
    (<in30> ^1 <o5> + ^2 <o8> +)
    (<in31> ^1 <o5> + ^2 <o9> +)
    (<in32> ^1 <o6> + ^2 <o2> +)
    (<in33> ^1 <o6> + ^2 <o3> +)
    (<in34> ^1 <o6> + ^2 <o5> +)
    (<in35> ^1 <o6> + ^2 <o8> +)
    (<in36> ^1 <o6> + ^2 <o9> +)
    (<in37> ^1 <o7> + ^2 <o4> +)
    (<in38> ^1 <o7> + ^2 <o5> +)
    (<in39> ^1 <o7> + ^2 <o8> +)
    (<in40> ^1 <o8> + ^2 <o7> +)
    (<in41> ^1 <o8> + ^2 <o4> +)
    (<in42> ^1 <o8> + ^2 <o5> +)
    (<in43> ^1 <o8> + ^2 <o6> +)
    (<in44> ^1 <o8> + ^2 <o9> +)
    (<in45> ^1 <o9> + ^2 <o8> +)
    (<in46> ^1 <o9> + ^2 <o5> +)
    (<in47> ^1 <o9> + ^2 <o6> +)
    (<in48> ^1 <o3> + ^2 <o10> +)
    (<in49> ^1 <o3> + ^2 <o11> +)
    (<in50> ^1 <o6> + ^2 <o10> +)
    (<in51> ^1 <o6> + ^2 <o11> +)
    (<in52> ^1 <o6> + ^2 <o12> +)
    (<in53> ^1 <o9> + ^2 <o11> +)
    (<in54> ^1 <o9> + ^2 <o12> +)
    (<in55> ^1 <o10> + ^2 <o3> +)
    (<in56> ^1 <o10> + ^2 <o6> +)
    (<in57> ^1 <o10> + ^2 <o11> +)
    (<in58> ^1 <o11> + ^2 <o10> +)
    (<in59> ^1 <o11> + ^2 <o3> +)
    (<in60> ^1 <o11> + ^2 <o6> +)
    (<in61> ^1 <o11> + ^2 <o9> +)
    (<in62> ^1 <o11> + ^2 <o12> +)
    (<in63> ^1 <o12> + ^2 <o11> +)
    (<in64> ^1 <o12> + ^2 <o6> +)
    (<in65> ^1 <o12> + ^2 <o9> +)
    (<diagonal-with1> ^item-type predicate + ^handle diagonal-with1 +
           ^instance <in66> + ^instance <in67> + ^instance <in68> +
           ^instance <in69> + ^instance <in70> + ^instance <in71> +
           ^instance <in72> + ^instance <in73> + ^instance <in74> +
           ^instance <in75> + ^instance <in76> + ^instance <in77> +
           ^instance <in78> + ^instance <in79> + ^instance <in80> +
           ^instance <in81> + ^instance <in82> + ^instance <in83> +
           ^instance <in84> + ^instance <in85> + ^instance <in86> +
           ^instance <in87> + ^instance <in88> + ^instance <in89> +)
    (<in66> ^1 <o1> + ^2 <o5> +)
    (<in67> ^1 <o2> + ^2 <o4> +)
    (<in68> ^1 <o2> + ^2 <o6> +)
    (<in69> ^1 <o3> + ^2 <o5> +)
    (<in70> ^1 <o4> + ^2 <o2> +)
    (<in71> ^1 <o4> + ^2 <o8> +)
    (<in72> ^1 <o5> + ^2 <o1> +)
    (<in73> ^1 <o5> + ^2 <o3> +)
    (<in74> ^1 <o5> + ^2 <o7> +)
    (<in75> ^1 <o5> + ^2 <o9> +)
    (<in76> ^1 <o6> + ^2 <o2> +)
    (<in77> ^1 <o6> + ^2 <o8> +)
    (<in78> ^1 <o7> + ^2 <o5> +)
    (<in79> ^1 <o8> + ^2 <o4> +)
    (<in80> ^1 <o8> + ^2 <o6> +)
    (<in81> ^1 <o9> + ^2 <o5> +)
    (<in82> ^1 <o3> + ^2 <o11> +)
    (<in83> ^1 <o11> + ^2 <o3> +)
    (<in84> ^1 <o6> + ^2 <o10> +)
    (<in85> ^1 <o10> + ^2 <o6> +)
    (<in86> ^1 <o9> + ^2 <o11> +)
    (<in87> ^1 <o11> + ^2 <o9> +)
    (<in88> ^1 <o12> + ^2 <o6> +)
    (<in89> ^1 <o6> + ^2 <o12> +)
}

sp {dialog-event*apply*game-state-change-respond*init-mahjong
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-mahjong)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category block + ^color green1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category block + ^color red1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category block + ^color yellow1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^name garbage +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^color green1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^color red1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^color yellow1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block + ^color green1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category block + ^color green1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> +)
    (<in0> ^1 <o3> + ^2 <o2> +)
    (<in1> ^1 <o5> + ^2 <o6> +)
    (<in2> ^1 <o8> + ^2 <o9> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in3> +
           ^instance <in4> + ^instance <in5> +)
    (<in3> ^1 <o9> + ^2 <o8> +)
    (<in4> ^1 <o6> + ^2 <o5> +)
    (<in5> ^1 <o2> + ^2 <o3> +)
}

sp {dialog-event*apply*game-state-change-respond*fail-tower4
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type fail-tower4)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +
           ^predicate <larger-than1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color green1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color green1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^color blue1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^size tiny1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^size small1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^size medium1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^size large1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +)
    (<in0> ^1 <o5> + ^2 <o4> +)
    (<in1> ^1 <o4> + ^2 <o6> +)
    (<in2> ^1 <o6> + ^2 <o7> +)
    (<in3> ^1 <o7> + ^2 <o1> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in4> +
           ^instance <in5> + ^instance <in6> + ^instance <in7> +)
    (<in4> ^1 <o4> + ^2 <o5> +)
    (<in5> ^1 <o6> + ^2 <o4> +)
    (<in6> ^1 <o7> + ^2 <o6> +)
    (<in7> ^1 <o1> + ^2 <o7> +)
    (<larger-than1> ^item-type predicate + ^handle larger-than1 +
           ^instance <in8> + ^instance <in9> + ^instance <in10> +
           ^instance <in11> + ^instance <in12> + ^instance <in13> +
           ^instance <in14> + ^instance <in15> + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> + ^instance <in25> +)
    (<in8> ^1 <o1> + ^2 <o4> +)
    (<in9> ^1 <o2> + ^2 <o4> +)
    (<in10> ^1 <o3> + ^2 <o4> +)
    (<in11> ^1 <o1> + ^2 <o5> +)
    (<in12> ^1 <o2> + ^2 <o5> +)
    (<in13> ^1 <o3> + ^2 <o5> +)
    (<in14> ^1 <o1> + ^2 <o6> +)
    (<in15> ^1 <o2> + ^2 <o6> +)
    (<in16> ^1 <o3> + ^2 <o6> +)
    (<in17> ^1 <o1> + ^2 <o7> +)
    (<in18> ^1 <o2> + ^2 <o7> +)
    (<in19> ^1 <o3> + ^2 <o7> +)
    (<in20> ^1 <o7> + ^2 <o6> +)
    (<in21> ^1 <o7> + ^2 <o5> +)
    (<in22> ^1 <o7> + ^2 <o4> +)
    (<in23> ^1 <o6> + ^2 <o5> +)
    (<in24> ^1 <o6> + ^2 <o4> +)
    (<in25> ^1 <o5> + ^2 <o4> +)
}

sp {dialog-event*apply*game-state-change-respond*final-tower5
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-tower5)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +
           ^predicate <larger-than1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color green1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color green1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^color blue1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^size tiny1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^size small1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^size medium1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^size large1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block + ^size giant1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> +)
    (<in0> ^1 <o4> + ^2 <o5> +)
    (<in1> ^1 <o5> + ^2 <o6> +)
    (<in2> ^1 <o6> + ^2 <o7> +)
    (<in3> ^1 <o7> + ^2 <o8> +)
    (<in4> ^1 <o8> + ^2 <o3> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in5> +
           ^instance <in6> + ^instance <in7> + ^instance <in8> +
           ^instance <in9> +)
    (<in5> ^1 <o5> + ^2 <o4> +)
    (<in6> ^1 <o6> + ^2 <o5> +)
    (<in7> ^1 <o7> + ^2 <o6> +)
    (<in8> ^1 <o8> + ^2 <o7> +)
    (<in9> ^1 <o3> + ^2 <o8> +)
    (<larger-than1> ^item-type predicate + ^handle larger-than1 +
           ^instance <in10> + ^instance <in11> + ^instance <in12> +
           ^instance <in13> + ^instance <in14> + ^instance <in15> +
           ^instance <in16> + ^instance <in17> + ^instance <in18> +
           ^instance <in19> + ^instance <in20> + ^instance <in21> +
           ^instance <in22> + ^instance <in23> + ^instance <in24> +
           ^instance <in25> + ^instance <in26> + ^instance <in27> +
           ^instance <in28> + ^instance <in29> + ^instance <in30> +
           ^instance <in31> + ^instance <in32> + ^instance <in33> +
           ^instance <in34> +)
    (<in10> ^1 <o1> + ^2 <o4> +)
    (<in11> ^1 <o2> + ^2 <o4> +)
    (<in12> ^1 <o3> + ^2 <o4> +)
    (<in13> ^1 <o1> + ^2 <o5> +)
    (<in14> ^1 <o2> + ^2 <o5> +)
    (<in15> ^1 <o3> + ^2 <o5> +)
    (<in16> ^1 <o1> + ^2 <o6> +)
    (<in17> ^1 <o2> + ^2 <o6> +)
    (<in18> ^1 <o3> + ^2 <o6> +)
    (<in19> ^1 <o1> + ^2 <o7> +)
    (<in20> ^1 <o2> + ^2 <o7> +)
    (<in21> ^1 <o3> + ^2 <o7> +)
    (<in22> ^1 <o1> + ^2 <o8> +)
    (<in23> ^1 <o2> + ^2 <o8> +)
    (<in24> ^1 <o3> + ^2 <o8> +)
    (<in25> ^1 <o8> + ^2 <o7> +)
    (<in26> ^1 <o8> + ^2 <o6> +)
    (<in27> ^1 <o8> + ^2 <o5> +)
    (<in28> ^1 <o8> + ^2 <o4> +)
    (<in29> ^1 <o7> + ^2 <o6> +)
    (<in30> ^1 <o7> + ^2 <o5> +)
    (<in31> ^1 <o7> + ^2 <o4> +)
    (<in32> ^1 <o6> + ^2 <o5> +)
    (<in33> ^1 <o6> + ^2 <o4> +)
    (<in34> ^1 <o5> + ^2 <o4> +)
}

sp {dialog-event*apply*game-state-change-respond*third-mac
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type third-mac)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^shape bank1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^shape bank1 +
           ^name destination1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category block + ^shape missionary1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^shape missionary1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^shape missionary1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^shape cannibal1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^shape cannibal1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block + ^shape cannibal1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category block + ^shape boat1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +)
    (<in0> ^1 <o3> + ^2 <o1> +)
    (<in1> ^1 <o4> + ^2 <o1> +)
    (<in2> ^1 <o5> + ^2 <o9> +)
    (<in3> ^1 <o6> + ^2 <o9> +)
    (<in4> ^1 <o7> + ^2 <o1> +)
    (<in5> ^1 <o8> + ^2 <o1> +)
    (<in6> ^1 <o9> + ^2 <o1> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in7> +
           ^instance <in8> + ^instance <in9> + ^instance <in10> +
           ^instance <in11> + ^instance <in12> + ^instance <in13> +)
    (<in7> ^1 <o1> + ^2 <o3> +)
    (<in8> ^1 <o1> + ^2 <o4> +)
    (<in9> ^1 <o9> + ^2 <o5> +)
    (<in10> ^1 <o9> + ^2 <o6> +)
    (<in11> ^1 <o1> + ^2 <o7> +)
    (<in12> ^1 <o1> + ^2 <o8> +)
    (<in13> ^1 <o1> + ^2 <o9> +)
}

sp {dialog-event*apply*game-state-change-respond*second-tower3
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type second-tower3)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color green1 +
           ^volume 4.000000 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color green1 +
           ^volume 4.000000 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^color blue1 +
           ^volume 4.000000 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^size small1 + ^volume 1.000000 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^size medium1 +
           ^volume 2.000000 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^size large1 + ^volume 3.000000 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> +)
    (<in0> ^1 <o4> + ^2 <o2> +)
    (<in1> ^1 <o5> + ^2 <o6> +)
    (<in2> ^1 <o6> + ^2 <o3> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in3> +
           ^instance <in4> + ^instance <in5> +)
    (<in3> ^1 <o2> + ^2 <o4> +)
    (<in4> ^1 <o6> + ^2 <o5> +)
    (<in5> ^1 <o3> + ^2 <o6> +)
}

sp {dialog-event*apply*game-state-change-respond*final-tower3fons
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-tower3fons)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +
           ^predicate <larger-than1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color green1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color green1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^color blue1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^size medium1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^size large1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> +)
    (<in0> ^1 <o5> + ^2 <o6> +)
    (<in1> ^1 <o6> + ^2 <o3> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in2> +
           ^instance <in3> +)
    (<in2> ^1 <o6> + ^2 <o5> +)
    (<in3> ^1 <o3> + ^2 <o6> +)
    (<larger-than1> ^item-type predicate + ^handle larger-than1 +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +
           ^instance <in7> + ^instance <in8> + ^instance <in9> +
           ^instance <in10> + ^instance <in11> + ^instance <in12> +
           ^instance <in13> + ^instance <in14> + ^instance <in15> +)
    (<in4> ^1 <o1> + ^2 <o4> +)
    (<in5> ^1 <o2> + ^2 <o4> +)
    (<in6> ^1 <o3> + ^2 <o4> +)
    (<in7> ^1 <o1> + ^2 <o5> +)
    (<in8> ^1 <o2> + ^2 <o5> +)
    (<in9> ^1 <o3> + ^2 <o5> +)
    (<in10> ^1 <o1> + ^2 <o6> +)
    (<in11> ^1 <o2> + ^2 <o6> +)
    (<in12> ^1 <o3> + ^2 <o6> +)
    (<in13> ^1 <o6> + ^2 <o5> +)
    (<in14> ^1 <o6> + ^2 <o4> +)
    (<in15> ^1 <o5> + ^2 <o4> +)
}

sp {dialog-event*apply*game-state-change-respond*second-frog
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type second-frog)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <left-of1> +
           ^predicate <right-of1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color red1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color red1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^color blue1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^color blue1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^color blue1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^color blue1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block + ^color red1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category block + ^color red1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +)
    (<in0> ^1 <o6> + ^2 <o1> +)
    (<in1> ^1 <o7> + ^2 <o4> +)
    (<in2> ^1 <o8> + ^2 <o2> +)
    (<in3> ^1 <o9> + ^2 <o5> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in4> +
           ^instance <in5> + ^instance <in6> + ^instance <in7> +)
    (<in4> ^1 <o1> + ^2 <o6> +)
    (<in5> ^1 <o4> + ^2 <o7> +)
    (<in6> ^1 <o2> + ^2 <o8> +)
    (<in7> ^1 <o5> + ^2 <o9> +)
    (<left-of1> ^item-type predicate + ^handle left-of1 + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +)
    (<in8> ^1 <o1> + ^2 <o2> +)
    (<in9> ^1 <o2> + ^2 <o3> +)
    (<in10> ^1 <o3> + ^2 <o4> +)
    (<in11> ^1 <o4> + ^2 <o5> +)
    (<right-of1> ^item-type predicate + ^handle right-of1 + ^instance <in12> +
           ^instance <in13> + ^instance <in14> + ^instance <in15> +)
    (<in12> ^1 <o2> + ^2 <o1> +)
    (<in13> ^1 <o3> + ^2 <o2> +)
    (<in14> ^1 <o4> + ^2 <o3> +)
    (<in15> ^1 <o5> + ^2 <o4> +)
}

sp {dialog-event*apply*game-state-change-respond*fail-mini-sudoku
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type fail-mini-sudoku)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^row 1 + ^column 1 +
           ^section 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^row 2 + ^column 1 +
           ^value 1 + ^section 1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^row 3 + ^column 1 +
           ^value 2 + ^section 2 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^row 4 + ^column 1 +
           ^section 2 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^row 1 + ^column 2 +
           ^value 4 + ^section 1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^row 2 + ^column 2 +
           ^value 4 + ^section 1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^row 3 + ^column 2 +
           ^section 2 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^row 4 + ^column 2 +
           ^section 2 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^row 1 + ^column 3 +
           ^section 3 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^row 2 + ^column 3 +
           ^section 3 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location + ^row 3 + ^column 3 +
           ^section 4 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location + ^row 4 + ^column 3 +
           ^value 2 + ^section 4 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category location + ^row 1 + ^column 4 +
           ^section 3 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category location + ^row 2 + ^column 4 +
           ^value 4 + ^section 3 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category location + ^row 3 + ^column 4 +
           ^value 3 + ^section 4 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category location + ^row 4 + ^column 4 +
           ^section 4 +)
}

sp {dialog-event*apply*game-state-change-respond*final-tictactoe
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-tictactoe)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <linear> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block + ^color red1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block + ^color red1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category block + ^color red1 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block + ^color blue1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category block + ^color blue1 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category block + ^color blue1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> +)
    (<in0> ^1 <o10> + ^2 <o1> +)
    (<in1> ^1 <o11> + ^2 <o2> +)
    (<in2> ^1 <o12> + ^2 <o3> +)
    (<in3> ^1 <o13> + ^2 <o14> +)
    (<in4> ^1 <o14> + ^2 <o15> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in5> +
           ^instance <in6> + ^instance <in7> + ^instance <in8> +
           ^instance <in9> +)
    (<in5> ^1 <o1> + ^2 <o10> +)
    (<in6> ^1 <o2> + ^2 <o11> +)
    (<in7> ^1 <o3> + ^2 <o12> +)
    (<in8> ^1 <o14> + ^2 <o13> +)
    (<in9> ^1 <o15> + ^2 <o14> +)
    (<linear> ^item-type predicate + ^handle linear + ^instance <in10> +
           ^instance <in11> + ^instance <in12> + ^instance <in13> +
           ^instance <in14> + ^instance <in15> + ^instance <in16> +
           ^instance <in17> +)
    (<in10> ^1 <set10> +)
    (<set10> ^object <o1> + ^object <o2> + ^object <o3> +)
    (<in11> ^1 <set11> +)
    (<set11> ^object <o1> + ^object <o5> + ^object <o9> +)
    (<in12> ^1 <set12> +)
    (<set12> ^object <o1> + ^object <o4> + ^object <o7> +)
    (<in13> ^1 <set13> +)
    (<set13> ^object <o4> + ^object <o5> + ^object <o6> +)
    (<in14> ^1 <set14> +)
    (<set14> ^object <o7> + ^object <o8> + ^object <o9> +)
    (<in15> ^1 <set15> +)
    (<set15> ^object <o2> + ^object <o5> + ^object <o8> +)
    (<in16> ^1 <set16> +)
    (<set16> ^object <o3> + ^object <o6> + ^object <o9> +)
    (<in17> ^1 <set17> +)
    (<set17> ^object <o3> + ^object <o5> + ^object <o7> +)
}

sp {dialog-event*apply*game-state-change-respond*init-pushmaze
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-pushmaze)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> + ^object <o17> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <near1> +
           ^predicate <diagonal-with1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^x 1 + ^y 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^x 2 + ^y 1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^x 3 + ^y 1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^x 1 + ^y 2 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^x 2 + ^y 2 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^x 3 + ^y 2 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^x 1 + ^y 3 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^x 2 + ^y 3 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^x 3 + ^y 3 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^x 1 + ^y 4 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location + ^x 2 + ^y 4 + ^color blue1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location + ^x 3 + ^y 4 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block + ^color blue1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category block + ^color black1 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category block + ^color black1 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category block + ^color black1 +)
    (<o17> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category block + ^color black1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> +)
    (<in0> ^1 <o13> + ^2 <o1> +)
    (<in1> ^1 <o14> + ^2 <o4> +)
    (<in2> ^1 <o15> + ^2 <o5> +)
    (<in3> ^1 <o16> + ^2 <o6> +)
    (<in4> ^1 <o17> + ^2 <o9> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in5> +
           ^instance <in6> + ^instance <in7> + ^instance <in8> +
           ^instance <in9> +)
    (<in5> ^1 <o1> + ^2 <o13> +)
    (<in6> ^1 <o4> + ^2 <o14> +)
    (<in7> ^1 <o5> + ^2 <o15> +)
    (<in8> ^1 <o6> + ^2 <o16> +)
    (<in9> ^1 <o9> + ^2 <o17> +)
    (<near1> ^item-type predicate + ^handle near1 + ^instance <in10> +
           ^instance <in11> + ^instance <in12> + ^instance <in13> +
           ^instance <in14> + ^instance <in15> + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> + ^instance <in25> +
           ^instance <in26> + ^instance <in27> + ^instance <in28> +
           ^instance <in29> + ^instance <in30> + ^instance <in31> +
           ^instance <in32> + ^instance <in33> + ^instance <in34> +
           ^instance <in35> + ^instance <in36> + ^instance <in37> +
           ^instance <in38> + ^instance <in39> + ^instance <in40> +
           ^instance <in41> + ^instance <in42> + ^instance <in43> +
           ^instance <in44> + ^instance <in45> + ^instance <in46> +
           ^instance <in47> + ^instance <in48> + ^instance <in49> +
           ^instance <in50> + ^instance <in51> + ^instance <in52> +
           ^instance <in53> + ^instance <in54> + ^instance <in55> +
           ^instance <in56> + ^instance <in57> + ^instance <in58> +
           ^instance <in59> + ^instance <in60> + ^instance <in61> +
           ^instance <in62> + ^instance <in63> + ^instance <in64> +
           ^instance <in65> + ^instance <in66> + ^instance <in67> +)
    (<in10> ^1 <o1> + ^2 <o2> +)
    (<in11> ^1 <o1> + ^2 <o4> +)
    (<in12> ^1 <o1> + ^2 <o5> +)
    (<in13> ^1 <o2> + ^2 <o1> +)
    (<in14> ^1 <o2> + ^2 <o3> +)
    (<in15> ^1 <o2> + ^2 <o4> +)
    (<in16> ^1 <o2> + ^2 <o5> +)
    (<in17> ^1 <o2> + ^2 <o6> +)
    (<in18> ^1 <o3> + ^2 <o2> +)
    (<in19> ^1 <o3> + ^2 <o5> +)
    (<in20> ^1 <o3> + ^2 <o6> +)
    (<in21> ^1 <o4> + ^2 <o1> +)
    (<in22> ^1 <o4> + ^2 <o2> +)
    (<in23> ^1 <o4> + ^2 <o5> +)
    (<in24> ^1 <o4> + ^2 <o7> +)
    (<in25> ^1 <o4> + ^2 <o8> +)
    (<in26> ^1 <o5> + ^2 <o1> +)
    (<in27> ^1 <o5> + ^2 <o2> +)
    (<in28> ^1 <o5> + ^2 <o3> +)
    (<in29> ^1 <o5> + ^2 <o4> +)
    (<in30> ^1 <o5> + ^2 <o6> +)
    (<in31> ^1 <o5> + ^2 <o7> +)
    (<in32> ^1 <o5> + ^2 <o8> +)
    (<in33> ^1 <o5> + ^2 <o9> +)
    (<in34> ^1 <o6> + ^2 <o2> +)
    (<in35> ^1 <o6> + ^2 <o3> +)
    (<in36> ^1 <o6> + ^2 <o5> +)
    (<in37> ^1 <o6> + ^2 <o8> +)
    (<in38> ^1 <o6> + ^2 <o9> +)
    (<in39> ^1 <o7> + ^2 <o4> +)
    (<in40> ^1 <o7> + ^2 <o5> +)
    (<in41> ^1 <o7> + ^2 <o8> +)
    (<in42> ^1 <o8> + ^2 <o7> +)
    (<in43> ^1 <o8> + ^2 <o4> +)
    (<in44> ^1 <o8> + ^2 <o5> +)
    (<in45> ^1 <o8> + ^2 <o6> +)
    (<in46> ^1 <o8> + ^2 <o9> +)
    (<in47> ^1 <o9> + ^2 <o8> +)
    (<in48> ^1 <o9> + ^2 <o5> +)
    (<in49> ^1 <o9> + ^2 <o6> +)
    (<in50> ^1 <o9> + ^2 <o11> +)
    (<in51> ^1 <o9> + ^2 <o12> +)
    (<in52> ^1 <o8> + ^2 <o19> +)
    (<in53> ^1 <o8> + ^2 <o11> +)
    (<in54> ^1 <o8> + ^2 <o12> +)
    (<in55> ^1 <o7> + ^2 <o10> +)
    (<in56> ^1 <o7> + ^2 <o11> +)
    (<in57> ^1 <o10> + ^2 <o7> +)
    (<in58> ^1 <o10> + ^2 <o8> +)
    (<in59> ^1 <o10> + ^2 <o11> +)
    (<in60> ^1 <o11> + ^2 <o10> +)
    (<in61> ^1 <o11> + ^2 <o7> +)
    (<in62> ^1 <o11> + ^2 <o8> +)
    (<in63> ^1 <o11> + ^2 <o9> +)
    (<in64> ^1 <o11> + ^2 <o12> +)
    (<in65> ^1 <o12> + ^2 <o11> +)
    (<in66> ^1 <o12> + ^2 <o8> +)
    (<in67> ^1 <o12> + ^2 <o9> +)
    (<diagonal-with1> ^item-type predicate + ^handle diagonal-with1 +
           ^instance <in68> + ^instance <in69> + ^instance <in70> +
           ^instance <in71> + ^instance <in72> + ^instance <in73> +
           ^instance <in74> + ^instance <in75> + ^instance <in76> +
           ^instance <in77> + ^instance <in78> + ^instance <in79> +
           ^instance <in80> + ^instance <in81> + ^instance <in82> +
           ^instance <in83> + ^instance <in84> + ^instance <in85> +
           ^instance <in86> + ^instance <in87> + ^instance <in88> +
           ^instance <in89> + ^instance <in90> + ^instance <in91> +)
    (<in68> ^1 <o1> + ^2 <o5> +)
    (<in69> ^1 <o2> + ^2 <o4> +)
    (<in70> ^1 <o2> + ^2 <o6> +)
    (<in71> ^1 <o3> + ^2 <o5> +)
    (<in72> ^1 <o4> + ^2 <o2> +)
    (<in73> ^1 <o4> + ^2 <o8> +)
    (<in74> ^1 <o5> + ^2 <o1> +)
    (<in75> ^1 <o5> + ^2 <o3> +)
    (<in76> ^1 <o5> + ^2 <o7> +)
    (<in77> ^1 <o5> + ^2 <o9> +)
    (<in78> ^1 <o6> + ^2 <o2> +)
    (<in79> ^1 <o6> + ^2 <o8> +)
    (<in80> ^1 <o7> + ^2 <o5> +)
    (<in81> ^1 <o8> + ^2 <o4> +)
    (<in82> ^1 <o8> + ^2 <o6> +)
    (<in83> ^1 <o9> + ^2 <o5> +)
    (<in84> ^1 <o9> + ^2 <o11> +)
    (<in85> ^1 <o11> + ^2 <o9> +)
    (<in86> ^1 <o12> + ^2 <o8> +)
    (<in87> ^1 <o8> + ^2 <o12> +)
    (<in88> ^1 <o10> + ^2 <o8> +)
    (<in89> ^1 <o8> + ^2 <o10> +)
    (<in90> ^1 <o11> + ^2 <o7> +)
    (<in91> ^1 <o7> + ^2 <o11> +)
}

sp {dialog-event*apply*game-state-change-respond*second-tower5
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type second-tower5)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +
           ^predicate <larger-than1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color green1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color green1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^color blue1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^size tiny1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^size small1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^size medium1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^size large1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block + ^size giant1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> +)
    (<in0> ^1 <o4> + ^2 <o2> +)
    (<in1> ^1 <o5> + ^2 <o6> +)
    (<in2> ^1 <o6> + ^2 <o7> +)
    (<in3> ^1 <o7> + ^2 <o8> +)
    (<in4> ^1 <o8> + ^2 <o1> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in5> +
           ^instance <in6> + ^instance <in7> + ^instance <in8> +
           ^instance <in9> +)
    (<in5> ^1 <o2> + ^2 <o4> +)
    (<in6> ^1 <o6> + ^2 <o5> +)
    (<in7> ^1 <o7> + ^2 <o6> +)
    (<in8> ^1 <o8> + ^2 <o7> +)
    (<in9> ^1 <o1> + ^2 <o8> +)
    (<larger-than1> ^item-type predicate + ^handle larger-than1 +
           ^instance <in10> + ^instance <in11> + ^instance <in12> +
           ^instance <in13> + ^instance <in14> + ^instance <in15> +
           ^instance <in16> + ^instance <in17> + ^instance <in18> +
           ^instance <in19> + ^instance <in20> + ^instance <in21> +
           ^instance <in22> + ^instance <in23> + ^instance <in24> +
           ^instance <in25> + ^instance <in26> + ^instance <in27> +
           ^instance <in28> + ^instance <in29> + ^instance <in30> +
           ^instance <in31> + ^instance <in32> + ^instance <in33> +
           ^instance <in34> +)
    (<in10> ^1 <o1> + ^2 <o4> +)
    (<in11> ^1 <o2> + ^2 <o4> +)
    (<in12> ^1 <o3> + ^2 <o4> +)
    (<in13> ^1 <o1> + ^2 <o5> +)
    (<in14> ^1 <o2> + ^2 <o5> +)
    (<in15> ^1 <o3> + ^2 <o5> +)
    (<in16> ^1 <o1> + ^2 <o6> +)
    (<in17> ^1 <o2> + ^2 <o6> +)
    (<in18> ^1 <o3> + ^2 <o6> +)
    (<in19> ^1 <o1> + ^2 <o7> +)
    (<in20> ^1 <o2> + ^2 <o7> +)
    (<in21> ^1 <o3> + ^2 <o7> +)
    (<in22> ^1 <o1> + ^2 <o8> +)
    (<in23> ^1 <o2> + ^2 <o8> +)
    (<in24> ^1 <o3> + ^2 <o8> +)
    (<in25> ^1 <o8> + ^2 <o7> +)
    (<in26> ^1 <o8> + ^2 <o6> +)
    (<in27> ^1 <o8> + ^2 <o5> +)
    (<in28> ^1 <o8> + ^2 <o4> +)
    (<in29> ^1 <o7> + ^2 <o6> +)
    (<in30> ^1 <o7> + ^2 <o5> +)
    (<in31> ^1 <o7> + ^2 <o4> +)
    (<in32> ^1 <o6> + ^2 <o5> +)
    (<in33> ^1 <o6> + ^2 <o4> +)
    (<in34> ^1 <o5> + ^2 <o4> +)
}

sp {dialog-event*apply*game-state-change-respond*second-mac
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type second-mac)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^shape bank1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^shape bank1 +
           ^name destination1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category block + ^shape missionary1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^shape missionary1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^shape missionary1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^shape cannibal1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^shape cannibal1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block + ^shape cannibal1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category block + ^shape boat1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +)
    (<in0> ^1 <o3> + ^2 <o1> +)
    (<in1> ^1 <o4> + ^2 <o1> +)
    (<in2> ^1 <o5> + ^2 <o1> +)
    (<in3> ^1 <o6> + ^2 <o9> +)
    (<in4> ^1 <o7> + ^2 <o1> +)
    (<in5> ^1 <o8> + ^2 <o1> +)
    (<in6> ^1 <o9> + ^2 <o1> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in7> +
           ^instance <in8> + ^instance <in9> + ^instance <in10> +
           ^instance <in11> + ^instance <in12> + ^instance <in13> +)
    (<in7> ^1 <o1> + ^2 <o3> +)
    (<in8> ^1 <o1> + ^2 <o4> +)
    (<in9> ^1 <o1> + ^2 <o5> +)
    (<in10> ^1 <o9> + ^2 <o6> +)
    (<in11> ^1 <o1> + ^2 <o7> +)
    (<in12> ^1 <o1> + ^2 <o8> +)
    (<in13> ^1 <o1> + ^2 <o9> +)
}

sp {dialog-event*apply*game-state-change-respond*init-8puzzle5
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-8puzzle5)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> + ^object <o17> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <near1> +
           ^predicate <diagonal-with1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color red1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color orange1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^color yellow1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^color green1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^color blue1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^color purple1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^color gray1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^color brown1 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block + ^color red1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block + ^color orange1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category block + ^color yellow1 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block + ^color green1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category block + ^color blue1 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category block + ^color purple1 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category block + ^color gray1 +)
    (<o17> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category block + ^color brown1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +
           ^instance <in7> +)
    (<in0> ^1 <o10> + ^2 <o2> +)
    (<in1> ^1 <o11> + ^2 <o3> +)
    (<in2> ^1 <o12> + ^2 <o1> +)
    (<in3> ^1 <o13> + ^2 <o4> +)
    (<in4> ^1 <o14> + ^2 <o5> +)
    (<in5> ^1 <o15> + ^2 <o7> +)
    (<in6> ^1 <o16> + ^2 <o8> +)
    (<in7> ^1 <o17> + ^2 <o9> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +
           ^instance <in12> + ^instance <in13> + ^instance <in14> +
           ^instance <in15> +)
    (<in8> ^1 <o2> + ^2 <o10> +)
    (<in9> ^1 <o3> + ^2 <o11> +)
    (<in10> ^1 <o1> + ^2 <o12> +)
    (<in11> ^1 <o4> + ^2 <o13> +)
    (<in12> ^1 <o5> + ^2 <o14> +)
    (<in13> ^1 <o7> + ^2 <o15> +)
    (<in14> ^1 <o8> + ^2 <o16> +)
    (<in15> ^1 <o9> + ^2 <o17> +)
    (<near1> ^item-type predicate + ^handle near1 + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> + ^instance <in25> +
           ^instance <in26> + ^instance <in27> + ^instance <in28> +
           ^instance <in29> + ^instance <in30> + ^instance <in31> +
           ^instance <in32> + ^instance <in33> + ^instance <in34> +
           ^instance <in35> + ^instance <in36> + ^instance <in37> +
           ^instance <in38> + ^instance <in39> + ^instance <in40> +
           ^instance <in41> + ^instance <in42> + ^instance <in43> +
           ^instance <in44> + ^instance <in45> + ^instance <in46> +
           ^instance <in47> + ^instance <in48> + ^instance <in49> +
           ^instance <in50> + ^instance <in51> + ^instance <in52> +
           ^instance <in53> + ^instance <in54> + ^instance <in55> +)
    (<in16> ^1 <o1> + ^2 <o2> +)
    (<in17> ^1 <o1> + ^2 <o4> +)
    (<in18> ^1 <o1> + ^2 <o5> +)
    (<in19> ^1 <o2> + ^2 <o1> +)
    (<in20> ^1 <o2> + ^2 <o3> +)
    (<in21> ^1 <o2> + ^2 <o4> +)
    (<in22> ^1 <o2> + ^2 <o5> +)
    (<in23> ^1 <o2> + ^2 <o6> +)
    (<in24> ^1 <o3> + ^2 <o2> +)
    (<in25> ^1 <o3> + ^2 <o5> +)
    (<in26> ^1 <o3> + ^2 <o6> +)
    (<in27> ^1 <o4> + ^2 <o1> +)
    (<in28> ^1 <o4> + ^2 <o2> +)
    (<in29> ^1 <o4> + ^2 <o5> +)
    (<in30> ^1 <o4> + ^2 <o7> +)
    (<in31> ^1 <o4> + ^2 <o8> +)
    (<in32> ^1 <o5> + ^2 <o1> +)
    (<in33> ^1 <o5> + ^2 <o2> +)
    (<in34> ^1 <o5> + ^2 <o3> +)
    (<in35> ^1 <o5> + ^2 <o4> +)
    (<in36> ^1 <o5> + ^2 <o6> +)
    (<in37> ^1 <o5> + ^2 <o7> +)
    (<in38> ^1 <o5> + ^2 <o8> +)
    (<in39> ^1 <o5> + ^2 <o9> +)
    (<in40> ^1 <o6> + ^2 <o2> +)
    (<in41> ^1 <o6> + ^2 <o3> +)
    (<in42> ^1 <o6> + ^2 <o5> +)
    (<in43> ^1 <o6> + ^2 <o8> +)
    (<in44> ^1 <o6> + ^2 <o9> +)
    (<in45> ^1 <o7> + ^2 <o4> +)
    (<in46> ^1 <o7> + ^2 <o5> +)
    (<in47> ^1 <o7> + ^2 <o8> +)
    (<in48> ^1 <o8> + ^2 <o7> +)
    (<in49> ^1 <o8> + ^2 <o4> +)
    (<in50> ^1 <o8> + ^2 <o5> +)
    (<in51> ^1 <o8> + ^2 <o6> +)
    (<in52> ^1 <o8> + ^2 <o9> +)
    (<in53> ^1 <o9> + ^2 <o8> +)
    (<in54> ^1 <o9> + ^2 <o5> +)
    (<in55> ^1 <o9> + ^2 <o6> +)
    (<diagonal-with1> ^item-type predicate + ^handle diagonal-with1 +
           ^instance <in56> + ^instance <in57> + ^instance <in58> +
           ^instance <in59> + ^instance <in60> + ^instance <in61> +
           ^instance <in62> + ^instance <in63> + ^instance <in64> +
           ^instance <in65> + ^instance <in66> + ^instance <in67> +
           ^instance <in68> + ^instance <in69> + ^instance <in70> +
           ^instance <in71> +)
    (<in56> ^1 <o1> + ^2 <o5> +)
    (<in57> ^1 <o2> + ^2 <o4> +)
    (<in58> ^1 <o2> + ^2 <o6> +)
    (<in59> ^1 <o3> + ^2 <o5> +)
    (<in60> ^1 <o4> + ^2 <o2> +)
    (<in61> ^1 <o4> + ^2 <o8> +)
    (<in62> ^1 <o5> + ^2 <o1> +)
    (<in63> ^1 <o5> + ^2 <o3> +)
    (<in64> ^1 <o5> + ^2 <o7> +)
    (<in65> ^1 <o5> + ^2 <o9> +)
    (<in66> ^1 <o6> + ^2 <o2> +)
    (<in67> ^1 <o6> + ^2 <o8> +)
    (<in68> ^1 <o7> + ^2 <o5> +)
    (<in69> ^1 <o8> + ^2 <o4> +)
    (<in70> ^1 <o8> + ^2 <o6> +)
    (<in71> ^1 <o9> + ^2 <o5> +)
}

sp {dialog-event*apply*game-state-change-respond*final-frog4
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-frog4)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> + ^object <o17> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <left-of1> +
           ^predicate <right-of1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color red1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color red1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^color red1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^color red1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^color blue1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^color blue1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^color blue1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^color blue1 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block + ^color blue1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block + ^color blue1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category block + ^color blue1 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block + ^color blue1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category block + ^color red1 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category block + ^color red1 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category block + ^color red1 +)
    (<o17> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category block + ^color red1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +
           ^instance <in7> +)
    (<in0> ^1 <o10> + ^2 <o6> +)
    (<in1> ^1 <o11> + ^2 <o7> +)
    (<in2> ^1 <o12> + ^2 <o8> +)
    (<in3> ^1 <o13> + ^2 <o9> +)
    (<in4> ^1 <o14> + ^2 <o1> +)
    (<in5> ^1 <o15> + ^2 <o2> +)
    (<in6> ^1 <o16> + ^2 <o3> +)
    (<in7> ^1 <o17> + ^2 <o4> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +
           ^instance <in12> + ^instance <in13> + ^instance <in14> +
           ^instance <in15> +)
    (<in8> ^1 <o6> + ^2 <o10> +)
    (<in9> ^1 <o7> + ^2 <o11> +)
    (<in10> ^1 <o8> + ^2 <o12> +)
    (<in11> ^1 <o9> + ^2 <o13> +)
    (<in12> ^1 <o1> + ^2 <o14> +)
    (<in13> ^1 <o2> + ^2 <o15> +)
    (<in14> ^1 <o3> + ^2 <o16> +)
    (<in15> ^1 <o4> + ^2 <o17> +)
    (<left-of1> ^item-type predicate + ^handle left-of1 + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> +)
    (<in16> ^1 <o1> + ^2 <o2> +)
    (<in17> ^1 <o2> + ^2 <o3> +)
    (<in18> ^1 <o3> + ^2 <o4> +)
    (<in19> ^1 <o4> + ^2 <o5> +)
    (<in20> ^1 <o5> + ^2 <o6> +)
    (<in21> ^1 <o6> + ^2 <o7> +)
    (<in22> ^1 <o7> + ^2 <o8> +)
    (<in23> ^1 <o8> + ^2 <o9> +)
    (<right-of1> ^item-type predicate + ^handle right-of1 + ^instance <in24> +
           ^instance <in25> + ^instance <in26> + ^instance <in27> +
           ^instance <in28> + ^instance <in29> + ^instance <in30> +
           ^instance <in31> +)
    (<in24> ^1 <o2> + ^2 <o1> +)
    (<in25> ^1 <o3> + ^2 <o2> +)
    (<in26> ^1 <o4> + ^2 <o3> +)
    (<in27> ^1 <o5> + ^2 <o4> +)
    (<in28> ^1 <o6> + ^2 <o5> +)
    (<in29> ^1 <o7> + ^2 <o6> +)
    (<in30> ^1 <o8> + ^2 <o7> +)
    (<in31> ^1 <o9> + ^2 <o8> +)
}

sp {dialog-event*apply*game-state-change-respond*final-mahjong
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-mahjong)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category block + ^color green1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category block + ^color red1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category block + ^color yellow1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^name garbage +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^color green1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^color red1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^color yellow1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block + ^color green1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category block + ^color green1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +
           ^instance <in7> +)
    (<in0> ^1 <o1> + ^2 <o4> +)
    (<in1> ^1 <o2> + ^2 <o4> +)
    (<in2> ^1 <o3> + ^2 <o4> +)
    (<in3> ^1 <o5> + ^2 <o4> +)
    (<in4> ^1 <o6> + ^2 <o4> +)
    (<in5> ^1 <o7> + ^2 <o4> +)
    (<in6> ^1 <o8> + ^2 <o4> +)
    (<in7> ^1 <o9> + ^2 <o4> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +
           ^instance <in12> + ^instance <in13> + ^instance <in14> +
           ^instance <in15> +)
    (<in8> ^1 <o4> + ^2 <o1> +)
    (<in9> ^1 <o4> + ^2 <o2> +)
    (<in10> ^1 <o4> + ^2 <o3> +)
    (<in11> ^1 <o4> + ^2 <o5> +)
    (<in12> ^1 <o4> + ^2 <o6> +)
    (<in13> ^1 <o4> + ^2 <o7> +)
    (<in14> ^1 <o4> + ^2 <o8> +)
    (<in15> ^1 <o4> + ^2 <o9> +)
}

sp {dialog-event*apply*game-state-change-respond*fail-logi5
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type fail-logi5)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^row 1 + ^column 1 +
           ^color red1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^row 2 + ^column 1 +
           ^value 1 + ^color red1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^row 3 + ^column 1 +
           ^value 2 + ^color red1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^row 4 + ^column 1 +
           ^color red1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^row 1 + ^column 2 +
           ^value 4 + ^color yellow1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^row 2 + ^column 2 +
           ^value 4 + ^color yellow1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^row 3 + ^column 2 +
           ^color green1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^row 4 + ^column 2 +
           ^color green1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^row 1 + ^column 3 +
           ^color yellow1 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^row 2 + ^column 3 +
           ^color yellow1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location + ^row 3 + ^column 3 +
           ^color green1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location + ^row 4 + ^column 3 +
           ^value 2 + ^color green1 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category location + ^row 1 + ^column 4 +
           ^color blue1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category location + ^row 2 + ^column 4 +
           ^value 4 + ^color blue1 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category location + ^row 3 + ^column 4 +
           ^value 3 + ^color blue1 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category location + ^row 4 + ^column 4 +
           ^color blue1 +)
}

sp {dialog-event*apply*game-state-change-respond*second-breakthrough
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type second-breakthrough)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> + ^object <o17> + ^object <o18> + ^object <o19> +
           ^object <o20> + ^object <o21> + ^object <o22> + ^object <o23> +
           ^object <o24> + ^object <o25> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <above1> +
           ^predicate <under1> + ^predicate <diagonal-with1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color blue1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color blue1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^color blue1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^color blue1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category location + ^color red1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category location + ^color red1 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category location + ^color red1 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category location + ^color red1 +)
    (<o17> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category block + ^color red1 +)
    (<o18> ^item-type object + ^handle object-17 + ^predicates <pr17> +)
    (<pr17> ^visible true + ^category block + ^color red1 +)
    (<o19> ^item-type object + ^handle object-18 + ^predicates <pr18> +)
    (<pr18> ^visible true + ^category block + ^color red1 +)
    (<o20> ^item-type object + ^handle object-19 + ^predicates <pr19> +)
    (<pr19> ^visible true + ^category block + ^color red1 +)
    (<o21> ^item-type object + ^handle object-20 + ^predicates <pr20> +)
    (<pr20> ^visible true + ^category block + ^color blue1 +)
    (<o22> ^item-type object + ^handle object-21 + ^predicates <pr21> +)
    (<pr21> ^visible true + ^category block + ^color blue1 +)
    (<o23> ^item-type object + ^handle object-22 + ^predicates <pr22> +)
    (<pr22> ^visible true + ^category block + ^color blue1 +)
    (<o24> ^item-type object + ^handle object-23 + ^predicates <pr23> +)
    (<pr23> ^visible true + ^category block + ^color blue1 +)
    (<o25> ^item-type object + ^handle object-24 + ^predicates <pr24> +)
    (<pr24> ^visible true + ^category location + ^name garbage +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +
           ^instance <in7> +)
    (<in0> ^1 <o17> + ^2 <o8> +)
    (<in1> ^1 <o18> + ^2 <o2> +)
    (<in2> ^1 <o19> + ^2 <o3> +)
    (<in3> ^1 <o20> + ^2 <o10> +)
    (<in4> ^1 <o21> + ^2 <o13> +)
    (<in5> ^1 <o22> + ^2 <o14> +)
    (<in6> ^1 <o23> + ^2 <o15> +)
    (<in7> ^1 <o24> + ^2 <o16> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +
           ^instance <in12> + ^instance <in13> + ^instance <in14> +
           ^instance <in15> +)
    (<in8> ^1 <o8> + ^2 <o17> +)
    (<in9> ^1 <o2> + ^2 <o18> +)
    (<in10> ^1 <o3> + ^2 <o19> +)
    (<in11> ^1 <o10> + ^2 <o20> +)
    (<in12> ^1 <o13> + ^2 <o21> +)
    (<in13> ^1 <o14> + ^2 <o22> +)
    (<in14> ^1 <o15> + ^2 <o23> +)
    (<in15> ^1 <o16> + ^2 <o24> +)
    (<above1> ^item-type predicate + ^handle above1 + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> + ^instance <in25> +
           ^instance <in26> + ^instance <in27> + ^instance <in28> +
           ^instance <in29> + ^instance <in30> + ^instance <in31> +
           ^instance <in32> + ^instance <in33> + ^instance <in34> +
           ^instance <in35> + ^instance <in36> + ^instance <in37> +
           ^instance <in38> + ^instance <in39> + ^instance <in40> +
           ^instance <in41> + ^instance <in42> + ^instance <in43> +
           ^instance <in44> + ^instance <in45> +)
    (<in16> ^1 <o13> + ^2 <o7> +)
    (<in17> ^1 <o14> + ^2 <o7> +)
    (<in18> ^1 <o13> + ^2 <o8> +)
    (<in19> ^1 <o14> + ^2 <o8> +)
    (<in20> ^1 <o15> + ^2 <o8> +)
    (<in21> ^1 <o14> + ^2 <o9> +)
    (<in22> ^1 <o15> + ^2 <o9> +)
    (<in23> ^1 <o16> + ^2 <o9> +)
    (<in24> ^1 <o15> + ^2 <o12> +)
    (<in25> ^1 <o16> + ^2 <o12> +)
    (<in26> ^1 <o7> + ^2 <o4> +)
    (<in27> ^1 <o8> + ^2 <o4> +)
    (<in28> ^1 <o7> + ^2 <o5> +)
    (<in29> ^1 <o8> + ^2 <o5> +)
    (<in30> ^1 <o9> + ^2 <o5> +)
    (<in31> ^1 <o8> + ^2 <o6> +)
    (<in32> ^1 <o9> + ^2 <o6> +)
    (<in33> ^1 <o12> + ^2 <o6> +)
    (<in34> ^1 <o9> + ^2 <o11> +)
    (<in35> ^1 <o12> + ^2 <o11> +)
    (<in36> ^1 <o4> + ^2 <o1> +)
    (<in37> ^1 <o5> + ^2 <o1> +)
    (<in38> ^1 <o4> + ^2 <o2> +)
    (<in39> ^1 <o5> + ^2 <o2> +)
    (<in40> ^1 <o6> + ^2 <o2> +)
    (<in41> ^1 <o5> + ^2 <o3> +)
    (<in42> ^1 <o6> + ^2 <o3> +)
    (<in43> ^1 <o11> + ^2 <o3> +)
    (<in44> ^1 <o6> + ^2 <o10> +)
    (<in45> ^1 <o11> + ^2 <o10> +)
    (<under1> ^item-type predicate + ^handle under1 + ^instance <in46> +
           ^instance <in47> + ^instance <in48> + ^instance <in49> +
           ^instance <in50> + ^instance <in51> + ^instance <in52> +
           ^instance <in53> + ^instance <in54> + ^instance <in55> +
           ^instance <in56> + ^instance <in57> + ^instance <in58> +
           ^instance <in59> + ^instance <in60> + ^instance <in61> +
           ^instance <in62> + ^instance <in63> + ^instance <in64> +
           ^instance <in65> + ^instance <in66> + ^instance <in67> +
           ^instance <in68> + ^instance <in69> + ^instance <in70> +
           ^instance <in71> + ^instance <in72> + ^instance <in73> +
           ^instance <in74> + ^instance <in75> +)
    (<in46> ^1 <o7> + ^2 <o13> +)
    (<in47> ^1 <o7> + ^2 <o14> +)
    (<in48> ^1 <o8> + ^2 <o13> +)
    (<in49> ^1 <o8> + ^2 <o14> +)
    (<in50> ^1 <o8> + ^2 <o15> +)
    (<in51> ^1 <o9> + ^2 <o14> +)
    (<in52> ^1 <o9> + ^2 <o15> +)
    (<in53> ^1 <o9> + ^2 <o16> +)
    (<in54> ^1 <o12> + ^2 <o15> +)
    (<in55> ^1 <o12> + ^2 <o16> +)
    (<in56> ^1 <o4> + ^2 <o7> +)
    (<in57> ^1 <o4> + ^2 <o8> +)
    (<in58> ^1 <o5> + ^2 <o7> +)
    (<in59> ^1 <o5> + ^2 <o8> +)
    (<in60> ^1 <o5> + ^2 <o9> +)
    (<in61> ^1 <o6> + ^2 <o8> +)
    (<in62> ^1 <o6> + ^2 <o9> +)
    (<in63> ^1 <o6> + ^2 <o12> +)
    (<in64> ^1 <o11> + ^2 <o9> +)
    (<in65> ^1 <o11> + ^2 <o12> +)
    (<in66> ^1 <o1> + ^2 <o4> +)
    (<in67> ^1 <o1> + ^2 <o5> +)
    (<in68> ^1 <o2> + ^2 <o4> +)
    (<in69> ^1 <o2> + ^2 <o5> +)
    (<in70> ^1 <o2> + ^2 <o6> +)
    (<in71> ^1 <o3> + ^2 <o5> +)
    (<in72> ^1 <o3> + ^2 <o6> +)
    (<in73> ^1 <o3> + ^2 <o11> +)
    (<in74> ^1 <o10> + ^2 <o6> +)
    (<in75> ^1 <o10> + ^2 <o11> +)
    (<diagonal-with1> ^item-type predicate + ^handle diagonal-with1 +
           ^instance <in76> + ^instance <in77> + ^instance <in78> +
           ^instance <in79> + ^instance <in80> + ^instance <in81> +
           ^instance <in82> + ^instance <in83> + ^instance <in84> +
           ^instance <in85> + ^instance <in86> + ^instance <in87> +
           ^instance <in88> + ^instance <in89> + ^instance <in90> +
           ^instance <in91> + ^instance <in92> + ^instance <in93> +
           ^instance <in94> + ^instance <in95> + ^instance <in96> +
           ^instance <in97> + ^instance <in98> + ^instance <in99> +
           ^instance <in100> + ^instance <in101> + ^instance <in102> +
           ^instance <in103> + ^instance <in104> + ^instance <in105> +
           ^instance <in106> + ^instance <in107> + ^instance <in108> +
           ^instance <in109> + ^instance <in110> + ^instance <in111> +)
    (<in76> ^1 <o1> + ^2 <o5> +)
    (<in77> ^1 <o2> + ^2 <o4> +)
    (<in78> ^1 <o2> + ^2 <o6> +)
    (<in79> ^1 <o3> + ^2 <o5> +)
    (<in80> ^1 <o4> + ^2 <o2> +)
    (<in81> ^1 <o4> + ^2 <o8> +)
    (<in82> ^1 <o5> + ^2 <o1> +)
    (<in83> ^1 <o5> + ^2 <o3> +)
    (<in84> ^1 <o5> + ^2 <o7> +)
    (<in85> ^1 <o5> + ^2 <o9> +)
    (<in86> ^1 <o6> + ^2 <o2> +)
    (<in87> ^1 <o6> + ^2 <o8> +)
    (<in88> ^1 <o7> + ^2 <o5> +)
    (<in89> ^1 <o8> + ^2 <o4> +)
    (<in90> ^1 <o8> + ^2 <o6> +)
    (<in91> ^1 <o9> + ^2 <o5> +)
    (<in92> ^1 <o3> + ^2 <o11> +)
    (<in93> ^1 <o11> + ^2 <o3> +)
    (<in94> ^1 <o6> + ^2 <o10> +)
    (<in95> ^1 <o10> + ^2 <o6> +)
    (<in96> ^1 <o9> + ^2 <o11> +)
    (<in97> ^1 <o11> + ^2 <o9> +)
    (<in98> ^1 <o12> + ^2 <o6> +)
    (<in99> ^1 <o6> + ^2 <o12> +)
    (<in100> ^1 <o16> + ^2 <o9> +)
    (<in101> ^1 <o9> + ^2 <o16> +)
    (<in102> ^1 <o12> + ^2 <o15> +)
    (<in103> ^1 <o15> + ^2 <o12> +)
    (<in104> ^1 <o14> + ^2 <o9> +)
    (<in105> ^1 <o9> + ^2 <o14> +)
    (<in106> ^1 <o8> + ^2 <o15> +)
    (<in107> ^1 <o15> + ^2 <o8> +)
    (<in108> ^1 <o14> + ^2 <o7> +)
    (<in109> ^1 <o7> + ^2 <o14> +)
    (<in110> ^1 <o13> + ^2 <o8> +)
    (<in111> ^1 <o8> + ^2 <o13> +)
}

sp {dialog-event*apply*game-state-change-respond*init-crazy8
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-crazy8)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category object + ^shape card + ^suit spades +
           ^value 5 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category object + ^shape card + ^suit hearts +
           ^value 8 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category object + ^shape card + ^suit diamonds +
           ^value 9 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category object + ^shape card + ^suit club +
           ^value 10 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category object + ^shape card + ^suit diamonds +
           ^value 5 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category object + ^shape card + ^suit ace +
           ^value 10 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category object + ^name deck +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category object + ^shape hand + ^name player +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category object + ^name dealer +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> +)
    (<in0> ^1 <o1> + ^2 <o8> +)
    (<in1> ^1 <o2> + ^2 <o8> +)
    (<in2> ^1 <o3> + ^2 <o8> +)
    (<in3> ^1 <o4> + ^2 <o8> +)
    (<in4> ^1 <o5> + ^2 <o7> +)
    (<in5> ^1 <o6> + ^2 <o9> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in6> +
           ^instance <in7> + ^instance <in8> + ^instance <in9> +
           ^instance <in10> + ^instance <in11> +)
    (<in6> ^1 <o8> + ^2 <o1> +)
    (<in7> ^1 <o8> + ^2 <o2> +)
    (<in8> ^1 <o8> + ^2 <o3> +)
    (<in9> ^1 <o8> + ^2 <o4> +)
    (<in10> ^1 <o7> + ^2 <o5> +)
    (<in11> ^1 <o9> + ^2 <o6> +)
}

sp {dialog-event*apply*game-state-change-respond*final-frog3
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-frog3)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <left-of1> +
           ^predicate <right-of1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color red1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color red1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^color red1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^color blue1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^color blue1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^color blue1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block + ^color blue1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category block + ^color blue1 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block + ^color blue1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block + ^color red1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category block + ^color red1 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block + ^color red1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> +)
    (<in0> ^1 <o8> + ^2 <o5> +)
    (<in1> ^1 <o9> + ^2 <o6> +)
    (<in2> ^1 <o10> + ^2 <o7> +)
    (<in3> ^1 <o11> + ^2 <o1> +)
    (<in4> ^1 <o12> + ^2 <o2> +)
    (<in5> ^1 <o13> + ^2 <o3> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in6> +
           ^instance <in7> + ^instance <in8> + ^instance <in9> +
           ^instance <in10> + ^instance <in11> +)
    (<in6> ^1 <o5> + ^2 <o8> +)
    (<in7> ^1 <o6> + ^2 <o9> +)
    (<in8> ^1 <o7> + ^2 <o19> +)
    (<in9> ^1 <o1> + ^2 <o11> +)
    (<in10> ^1 <o2> + ^2 <o12> +)
    (<in11> ^1 <o3> + ^2 <o13> +)
    (<left-of1> ^item-type predicate + ^handle left-of1 + ^instance <in12> +
           ^instance <in13> + ^instance <in14> + ^instance <in15> +
           ^instance <in16> + ^instance <in17> +)
    (<in12> ^1 <o1> + ^2 <o2> +)
    (<in13> ^1 <o2> + ^2 <o3> +)
    (<in14> ^1 <o3> + ^2 <o4> +)
    (<in15> ^1 <o4> + ^2 <o5> +)
    (<in16> ^1 <o5> + ^2 <o6> +)
    (<in17> ^1 <o6> + ^2 <o7> +)
    (<right-of1> ^item-type predicate + ^handle right-of1 + ^instance <in18> +
           ^instance <in19> + ^instance <in20> + ^instance <in21> +
           ^instance <in22> + ^instance <in23> +)
    (<in18> ^1 <o2> + ^2 <o1> +)
    (<in19> ^1 <o3> + ^2 <o2> +)
    (<in20> ^1 <o4> + ^2 <o3> +)
    (<in21> ^1 <o5> + ^2 <o4> +)
    (<in22> ^1 <o6> + ^2 <o5> +)
    (<in23> ^1 <o7> + ^2 <o6> +)
}

sp {dialog-event*apply*game-state-change-respond*final-logi5a
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-logi5a)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^row 1 + ^column 1 +
           ^value c + ^color red1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^row 2 + ^column 1 +
           ^value a + ^color red1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^row 3 + ^column 1 +
           ^value b + ^color red1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^row 4 + ^column 1 +
           ^value d + ^color red1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^row 1 + ^column 2 +
           ^value d + ^color yellow1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^row 2 + ^column 2 +
           ^value b + ^color yellow1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^row 3 + ^column 2 +
           ^value a + ^color green1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^row 4 + ^column 2 +
           ^value c + ^color green1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^row 1 + ^column 3 +
           ^value a + ^color yellow1 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^row 2 + ^column 3 +
           ^value c + ^color yellow1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location + ^row 3 + ^column 3 +
           ^value d + ^color green1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location + ^row 4 + ^column 3 +
           ^value b + ^color green1 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category location + ^row 1 + ^column 4 +
           ^value b + ^color blue1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category location + ^row 2 + ^column 4 +
           ^value d + ^color blue1 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category location + ^row 3 + ^column 4 +
           ^value c + ^color blue1 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category location + ^row 4 + ^column 4 +
           ^value a + ^color blue1 +)
}

sp {dialog-event*apply*game-state-change-respond*final-connect-4
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-connect-4)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o21> + ^object <o22> +
           ^object <o23> + ^object <o24> + ^object <o25> + ^object <o26> +
           ^object <o27> + ^object <o28> + ^object <o29> + ^object <o30> +
           ^object <o31> + ^object <o10> + ^object <o11> + ^object <o12> +
           ^object <o13> + ^object <o14> + ^object <o15> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <above1> +
           ^predicate <linear> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location +)
    (<o21> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location +)
    (<o22> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location +)
    (<o23> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location +)
    (<o24> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category location +)
    (<o25> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category location +)
    (<o26> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category location +)
    (<o27> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category location +)
    (<o28> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category location +)
    (<o29> ^item-type object + ^handle object-17 + ^predicates <pr17> +)
    (<pr17> ^visible true + ^category location +)
    (<o30> ^item-type object + ^handle object-18 + ^predicates <pr18> +)
    (<pr18> ^visible true + ^category location +)
    (<o31> ^item-type object + ^handle object-19 + ^predicates <pr19> +)
    (<pr19> ^visible true + ^category location +)
    (<o10> ^item-type object + ^handle object-20 + ^predicates <pr20> +)
    (<pr20> ^visible true + ^category block + ^color red1 +)
    (<o11> ^item-type object + ^handle object-21 + ^predicates <pr21> +)
    (<pr21> ^visible true + ^category block + ^color red1 +)
    (<o12> ^item-type object + ^handle object-22 + ^predicates <pr22> +)
    (<pr22> ^visible true + ^category block + ^color red1 +)
    (<o13> ^item-type object + ^handle object-23 + ^predicates <pr23> +)
    (<pr23> ^visible true + ^category block + ^color red1 +)
    (<o14> ^item-type object + ^handle object-24 + ^predicates <pr24> +)
    (<pr24> ^visible true + ^category block + ^color blue1 +)
    (<o15> ^item-type object + ^handle object-25 + ^predicates <pr25> +)
    (<pr25> ^visible true + ^category block + ^color blue1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> +)
    (<in0> ^1 <o10> + ^2 <o27> +)
    (<in1> ^1 <o11> + ^2 <o28> +)
    (<in2> ^1 <o12> + ^2 <o29> +)
    (<in3> ^1 <o13> + ^2 <o30> +)
    (<in4> ^1 <o14> + ^2 <o15> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in5> +
           ^instance <in6> + ^instance <in7> + ^instance <in8> +
           ^instance <in9> +)
    (<in5> ^1 <o27> + ^2 <o10> +)
    (<in6> ^1 <o28> + ^2 <o11> +)
    (<in7> ^1 <o29> + ^2 <o12> +)
    (<in8> ^1 <o30> + ^2 <o13> +)
    (<in9> ^1 <o15> + ^2 <o14> +)
    (<above1> ^item-type predicate + ^handle above1 + ^instance <in10> +
           ^instance <in11> + ^instance <in12> + ^instance <in13> +
           ^instance <in14> + ^instance <in15> + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> +)
    (<in10> ^1 <o7> + ^2 <o27> +)
    (<in11> ^1 <o4> + ^2 <o7> +)
    (<in12> ^1 <o1> + ^2 <o4> +)
    (<in13> ^1 <o8> + ^2 <o28> +)
    (<in14> ^1 <o5> + ^2 <o8> +)
    (<in15> ^1 <o2> + ^2 <o5> +)
    (<in16> ^1 <o3> + ^2 <o6> +)
    (<in17> ^1 <o6> + ^2 <o9> +)
    (<in18> ^1 <o9> + ^2 <o29> +)
    (<in19> ^1 <o21> + ^2 <o23> +)
    (<in20> ^1 <o23> + ^2 <o25> +)
    (<in21> ^1 <o25> + ^2 <o30> +)
    (<in22> ^1 <o22> + ^2 <o24> +)
    (<in23> ^1 <o24> + ^2 <o26> +)
    (<in24> ^1 <o26> + ^2 <o31> +)
    (<linear> ^item-type predicate + ^handle linear + ^instance <in25> +
           ^instance <in26> + ^instance <in27> + ^instance <in28> +
           ^instance <in29> + ^instance <in30> + ^instance <in31> +
           ^instance <in32> + ^instance <in33> + ^instance <in34> +
           ^instance <in35> + ^instance <in36> + ^instance <in37> +
           ^instance <in38> + ^instance <in39> + ^instance <in40> +
           ^instance <in41> +)
    (<in25> ^1 <set25> +)
    (<set25> ^object <o1> + ^object <o2> + ^object <o3> + ^object <o21> +)
    (<in26> ^1 <set26> +)
    (<set26> ^object <o1> + ^object <o5> + ^object <o9> + ^object <o30> +)
    (<in27> ^1 <set27> +)
    (<set27> ^object <o1> + ^object <o4> + ^object <o7> + ^object <o27> +)
    (<in28> ^1 <set28> +)
    (<set28> ^object <o4> + ^object <o5> + ^object <o6> + ^object <o23> +)
    (<in29> ^1 <set29> +)
    (<set29> ^object <o7> + ^object <o8> + ^object <o9> + ^object <o25> +)
    (<in30> ^1 <set30> +)
    (<set30> ^object <o27> + ^object <o28> + ^object <o29> + ^object <o30> +)
    (<in31> ^1 <set31> +)
    (<set31> ^object <o2> + ^object <o5> + ^object <o8> + ^object <o28> +)
    (<in32> ^1 <set32> +)
    (<set32> ^object <o3> + ^object <o6> + ^object <o9> + ^object <o29> +)
    (<in33> ^1 <set33> +)
    (<set33> ^object <o21> + ^object <o23> + ^object <o25> + ^object <o30> +)
    (<in34> ^1 <set34> +)
    (<set34> ^object <o21> + ^object <o6> + ^object <o8> + ^object <o27> +)
    (<in35> ^1 <set35> +)
    (<set35> ^object <o2> + ^object <o3> + ^object <o21> + ^object <o22> +)
    (<in36> ^1 <set36> +)
    (<set36> ^object <o5> + ^object <o6> + ^object <o23> + ^object <o24> +)
    (<in37> ^1 <set37> +)
    (<set37> ^object <o8> + ^object <o9> + ^object <o25> + ^object <o26> +)
    (<in38> ^1 <set38> +)
    (<set38> ^object <o28> + ^object <o29> + ^object <o30> + ^object <o31> +)
    (<in39> ^1 <set39> +)
    (<set39> ^object <o22> + ^object <o24> + ^object <o26> + ^object <o31> +)
    (<in40> ^1 <set40> +)
    (<set40> ^object <o2> + ^object <o6> + ^object <o25> + ^object <o31> +)
    (<in41> ^1 <set41> +)
    (<set41> ^object <o22> + ^object <o23> + ^object <o9> + ^object <o28> +)
}

sp {dialog-event*apply*game-state-change-respond*init-fox
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-fox)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^shape bank1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^shape bank1 +
           ^name destination1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category block + ^color red1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^color yellow1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^color green1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^shape boat1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +)
    (<in0> ^1 <o4> + ^2 <o1> +)
    (<in1> ^1 <o5> + ^2 <o1> +)
    (<in2> ^1 <o6> + ^2 <o1> +)
    (<in3> ^1 <o3> + ^2 <o1> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in4> +
           ^instance <in5> + ^instance <in6> + ^instance <in7> +)
    (<in4> ^1 <o1> + ^2 <o4> +)
    (<in5> ^1 <o1> + ^2 <o5> +)
    (<in6> ^1 <o1> + ^2 <o6> +)
    (<in7> ^1 <o1> + ^2 <o3> +)
}

sp {dialog-event*apply*game-state-change-respond*init-8puzzle6
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-8puzzle6)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> + ^object <o17> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <near1> +
           ^predicate <diagonal-with1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color red1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color orange1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^color yellow1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^color green1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^color blue1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^color purple1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^color gray1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^color brown1 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block + ^color red1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block + ^color orange1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category block + ^color yellow1 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block + ^color green1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category block + ^color blue1 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category block + ^color purple1 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category block + ^color gray1 +)
    (<o17> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category block + ^color brown1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +
           ^instance <in7> +)
    (<in0> ^1 <o10> + ^2 <o2> +)
    (<in1> ^1 <o11> + ^2 <o6> +)
    (<in2> ^1 <o12> + ^2 <o1> +)
    (<in3> ^1 <o13> + ^2 <o4> +)
    (<in4> ^1 <o14> + ^2 <o5> +)
    (<in5> ^1 <o15> + ^2 <o7> +)
    (<in6> ^1 <o16> + ^2 <o8> +)
    (<in7> ^1 <o17> + ^2 <o9> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +
           ^instance <in12> + ^instance <in13> + ^instance <in14> +
           ^instance <in15> +)
    (<in8> ^1 <o2> + ^2 <o10> +)
    (<in9> ^1 <o6> + ^2 <o11> +)
    (<in10> ^1 <o1> + ^2 <o12> +)
    (<in11> ^1 <o4> + ^2 <o13> +)
    (<in12> ^1 <o5> + ^2 <o14> +)
    (<in13> ^1 <o7> + ^2 <o15> +)
    (<in14> ^1 <o8> + ^2 <o16> +)
    (<in15> ^1 <o9> + ^2 <o17> +)
    (<near1> ^item-type predicate + ^handle near1 + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> + ^instance <in25> +
           ^instance <in26> + ^instance <in27> + ^instance <in28> +
           ^instance <in29> + ^instance <in30> + ^instance <in31> +
           ^instance <in32> + ^instance <in33> + ^instance <in34> +
           ^instance <in35> + ^instance <in36> + ^instance <in37> +
           ^instance <in38> + ^instance <in39> + ^instance <in40> +
           ^instance <in41> + ^instance <in42> + ^instance <in43> +
           ^instance <in44> + ^instance <in45> + ^instance <in46> +
           ^instance <in47> + ^instance <in48> + ^instance <in49> +
           ^instance <in50> + ^instance <in51> + ^instance <in52> +
           ^instance <in53> + ^instance <in54> + ^instance <in55> +)
    (<in16> ^1 <o1> + ^2 <o2> +)
    (<in17> ^1 <o1> + ^2 <o4> +)
    (<in18> ^1 <o1> + ^2 <o5> +)
    (<in19> ^1 <o2> + ^2 <o1> +)
    (<in20> ^1 <o2> + ^2 <o3> +)
    (<in21> ^1 <o2> + ^2 <o4> +)
    (<in22> ^1 <o2> + ^2 <o5> +)
    (<in23> ^1 <o2> + ^2 <o6> +)
    (<in24> ^1 <o3> + ^2 <o2> +)
    (<in25> ^1 <o3> + ^2 <o5> +)
    (<in26> ^1 <o3> + ^2 <o6> +)
    (<in27> ^1 <o4> + ^2 <o1> +)
    (<in28> ^1 <o4> + ^2 <o2> +)
    (<in29> ^1 <o4> + ^2 <o5> +)
    (<in30> ^1 <o4> + ^2 <o7> +)
    (<in31> ^1 <o4> + ^2 <o8> +)
    (<in32> ^1 <o5> + ^2 <o1> +)
    (<in33> ^1 <o5> + ^2 <o2> +)
    (<in34> ^1 <o5> + ^2 <o3> +)
    (<in35> ^1 <o5> + ^2 <o4> +)
    (<in36> ^1 <o5> + ^2 <o6> +)
    (<in37> ^1 <o5> + ^2 <o7> +)
    (<in38> ^1 <o5> + ^2 <o8> +)
    (<in39> ^1 <o5> + ^2 <o9> +)
    (<in40> ^1 <o6> + ^2 <o2> +)
    (<in41> ^1 <o6> + ^2 <o3> +)
    (<in42> ^1 <o6> + ^2 <o5> +)
    (<in43> ^1 <o6> + ^2 <o8> +)
    (<in44> ^1 <o6> + ^2 <o9> +)
    (<in45> ^1 <o7> + ^2 <o4> +)
    (<in46> ^1 <o7> + ^2 <o5> +)
    (<in47> ^1 <o7> + ^2 <o8> +)
    (<in48> ^1 <o8> + ^2 <o7> +)
    (<in49> ^1 <o8> + ^2 <o4> +)
    (<in50> ^1 <o8> + ^2 <o5> +)
    (<in51> ^1 <o8> + ^2 <o6> +)
    (<in52> ^1 <o8> + ^2 <o9> +)
    (<in53> ^1 <o9> + ^2 <o8> +)
    (<in54> ^1 <o9> + ^2 <o5> +)
    (<in55> ^1 <o9> + ^2 <o6> +)
    (<diagonal-with1> ^item-type predicate + ^handle diagonal-with1 +
           ^instance <in56> + ^instance <in57> + ^instance <in58> +
           ^instance <in59> + ^instance <in60> + ^instance <in61> +
           ^instance <in62> + ^instance <in63> + ^instance <in64> +
           ^instance <in65> + ^instance <in66> + ^instance <in67> +
           ^instance <in68> + ^instance <in69> + ^instance <in70> +
           ^instance <in71> +)
    (<in56> ^1 <o1> + ^2 <o5> +)
    (<in57> ^1 <o2> + ^2 <o4> +)
    (<in58> ^1 <o2> + ^2 <o6> +)
    (<in59> ^1 <o3> + ^2 <o5> +)
    (<in60> ^1 <o4> + ^2 <o2> +)
    (<in61> ^1 <o4> + ^2 <o8> +)
    (<in62> ^1 <o5> + ^2 <o1> +)
    (<in63> ^1 <o5> + ^2 <o3> +)
    (<in64> ^1 <o5> + ^2 <o7> +)
    (<in65> ^1 <o5> + ^2 <o9> +)
    (<in66> ^1 <o6> + ^2 <o2> +)
    (<in67> ^1 <o6> + ^2 <o8> +)
    (<in68> ^1 <o7> + ^2 <o5> +)
    (<in69> ^1 <o8> + ^2 <o4> +)
    (<in70> ^1 <o8> + ^2 <o6> +)
    (<in71> ^1 <o9> + ^2 <o5> +)
}

sp {dialog-event*apply*game-state-change-respond*init-i8puzzle
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-i8puzzle)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> + ^object <o17> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <near1> +
           ^predicate <diagonal-with1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^value 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^value 2 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^value 3 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^value 4 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^value 5 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^value 6 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^value 7 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^value 8 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block + ^value 1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block + ^value 2 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category block + ^value 3 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block + ^value 4 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category block + ^value 5 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category block + ^value 6 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category block + ^value 7 +)
    (<o17> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category block + ^value 8 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +
           ^instance <in7> +)
    (<in0> ^1 <o10> + ^2 <o2> +)
    (<in1> ^1 <o11> + ^2 <o3> +)
    (<in2> ^1 <o12> + ^2 <o1> +)
    (<in3> ^1 <o13> + ^2 <o5> +)
    (<in4> ^1 <o14> + ^2 <o6> +)
    (<in5> ^1 <o15> + ^2 <o7> +)
    (<in6> ^1 <o16> + ^2 <o8> +)
    (<in7> ^1 <o17> + ^2 <o9> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +
           ^instance <in12> + ^instance <in13> + ^instance <in14> +
           ^instance <in15> +)
    (<in8> ^1 <o2> + ^2 <o10> +)
    (<in9> ^1 <o3> + ^2 <o11> +)
    (<in10> ^1 <o1> + ^2 <o12> +)
    (<in11> ^1 <o5> + ^2 <o13> +)
    (<in12> ^1 <o6> + ^2 <o14> +)
    (<in13> ^1 <o7> + ^2 <o15> +)
    (<in14> ^1 <o8> + ^2 <o16> +)
    (<in15> ^1 <o9> + ^2 <o17> +)
    (<near1> ^item-type predicate + ^handle near1 + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> + ^instance <in25> +
           ^instance <in26> + ^instance <in27> + ^instance <in28> +
           ^instance <in29> + ^instance <in30> + ^instance <in31> +
           ^instance <in32> + ^instance <in33> + ^instance <in34> +
           ^instance <in35> + ^instance <in36> + ^instance <in37> +
           ^instance <in38> + ^instance <in39> + ^instance <in40> +
           ^instance <in41> + ^instance <in42> + ^instance <in43> +
           ^instance <in44> + ^instance <in45> + ^instance <in46> +
           ^instance <in47> + ^instance <in48> + ^instance <in49> +
           ^instance <in50> + ^instance <in51> + ^instance <in52> +
           ^instance <in53> + ^instance <in54> + ^instance <in55> +)
    (<in16> ^1 <o1> + ^2 <o2> +)
    (<in17> ^1 <o1> + ^2 <o4> +)
    (<in18> ^1 <o1> + ^2 <o5> +)
    (<in19> ^1 <o2> + ^2 <o1> +)
    (<in20> ^1 <o2> + ^2 <o3> +)
    (<in21> ^1 <o2> + ^2 <o4> +)
    (<in22> ^1 <o2> + ^2 <o5> +)
    (<in23> ^1 <o2> + ^2 <o6> +)
    (<in24> ^1 <o3> + ^2 <o2> +)
    (<in25> ^1 <o3> + ^2 <o5> +)
    (<in26> ^1 <o3> + ^2 <o6> +)
    (<in27> ^1 <o4> + ^2 <o1> +)
    (<in28> ^1 <o4> + ^2 <o2> +)
    (<in29> ^1 <o4> + ^2 <o5> +)
    (<in30> ^1 <o4> + ^2 <o7> +)
    (<in31> ^1 <o4> + ^2 <o8> +)
    (<in32> ^1 <o5> + ^2 <o1> +)
    (<in33> ^1 <o5> + ^2 <o2> +)
    (<in34> ^1 <o5> + ^2 <o3> +)
    (<in35> ^1 <o5> + ^2 <o4> +)
    (<in36> ^1 <o5> + ^2 <o6> +)
    (<in37> ^1 <o5> + ^2 <o7> +)
    (<in38> ^1 <o5> + ^2 <o8> +)
    (<in39> ^1 <o5> + ^2 <o9> +)
    (<in40> ^1 <o6> + ^2 <o2> +)
    (<in41> ^1 <o6> + ^2 <o3> +)
    (<in42> ^1 <o6> + ^2 <o5> +)
    (<in43> ^1 <o6> + ^2 <o8> +)
    (<in44> ^1 <o6> + ^2 <o9> +)
    (<in45> ^1 <o7> + ^2 <o4> +)
    (<in46> ^1 <o7> + ^2 <o5> +)
    (<in47> ^1 <o7> + ^2 <o8> +)
    (<in48> ^1 <o8> + ^2 <o7> +)
    (<in49> ^1 <o8> + ^2 <o4> +)
    (<in50> ^1 <o8> + ^2 <o5> +)
    (<in51> ^1 <o8> + ^2 <o6> +)
    (<in52> ^1 <o8> + ^2 <o9> +)
    (<in53> ^1 <o9> + ^2 <o8> +)
    (<in54> ^1 <o9> + ^2 <o5> +)
    (<in55> ^1 <o9> + ^2 <o6> +)
    (<diagonal-with1> ^item-type predicate + ^handle diagonal-with1 +
           ^instance <in56> + ^instance <in57> + ^instance <in58> +
           ^instance <in59> + ^instance <in60> + ^instance <in61> +
           ^instance <in62> + ^instance <in63> + ^instance <in64> +
           ^instance <in65> + ^instance <in66> + ^instance <in67> +
           ^instance <in68> + ^instance <in69> + ^instance <in70> +
           ^instance <in71> +)
    (<in56> ^1 <o1> + ^2 <o5> +)
    (<in57> ^1 <o2> + ^2 <o4> +)
    (<in58> ^1 <o2> + ^2 <o6> +)
    (<in59> ^1 <o3> + ^2 <o5> +)
    (<in60> ^1 <o4> + ^2 <o2> +)
    (<in61> ^1 <o4> + ^2 <o8> +)
    (<in62> ^1 <o5> + ^2 <o1> +)
    (<in63> ^1 <o5> + ^2 <o3> +)
    (<in64> ^1 <o5> + ^2 <o7> +)
    (<in65> ^1 <o5> + ^2 <o9> +)
    (<in66> ^1 <o6> + ^2 <o2> +)
    (<in67> ^1 <o6> + ^2 <o8> +)
    (<in68> ^1 <o7> + ^2 <o5> +)
    (<in69> ^1 <o8> + ^2 <o4> +)
    (<in70> ^1 <o8> + ^2 <o6> +)
    (<in71> ^1 <o9> + ^2 <o5> +)
}

sp {dialog-event*apply*game-state-change-respond*fail-3mens
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type fail-3mens)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <near1> +
           ^predicate <diagonal-with1> + ^predicate <linear> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block + ^color red1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block + ^color red1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category block + ^color red1 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block + ^color blue1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category block + ^color blue1 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category block + ^color blue1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> +)
    (<in0> ^1 <o13> + ^2 <o1> +)
    (<in1> ^1 <o14> + ^2 <o2> +)
    (<in2> ^1 <o15> + ^2 <o3> +)
    (<in3> ^1 <o10> + ^2 <o11> +)
    (<in4> ^1 <o11> + ^2 <o12> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in5> +
           ^instance <in6> + ^instance <in7> + ^instance <in8> +
           ^instance <in9> +)
    (<in5> ^1 <o1> + ^2 <o13> +)
    (<in6> ^1 <o2> + ^2 <o14> +)
    (<in7> ^1 <o3> + ^2 <o15> +)
    (<in8> ^1 <o11> + ^2 <o10> +)
    (<in9> ^1 <o12> + ^2 <o11> +)
    (<near1> ^item-type predicate + ^handle near1 + ^instance <in10> +
           ^instance <in11> + ^instance <in12> + ^instance <in13> +
           ^instance <in14> + ^instance <in15> + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> + ^instance <in25> +
           ^instance <in26> + ^instance <in27> + ^instance <in28> +
           ^instance <in29> + ^instance <in30> + ^instance <in31> +
           ^instance <in32> + ^instance <in33> + ^instance <in34> +
           ^instance <in35> + ^instance <in36> + ^instance <in37> +
           ^instance <in38> + ^instance <in39> + ^instance <in40> +
           ^instance <in41> + ^instance <in42> + ^instance <in43> +
           ^instance <in44> + ^instance <in45> + ^instance <in46> +
           ^instance <in47> + ^instance <in48> + ^instance <in49> +)
    (<in10> ^1 <o1> + ^2 <o2> +)
    (<in11> ^1 <o1> + ^2 <o4> +)
    (<in12> ^1 <o1> + ^2 <o5> +)
    (<in13> ^1 <o2> + ^2 <o1> +)
    (<in14> ^1 <o2> + ^2 <o3> +)
    (<in15> ^1 <o2> + ^2 <o4> +)
    (<in16> ^1 <o2> + ^2 <o5> +)
    (<in17> ^1 <o2> + ^2 <o6> +)
    (<in18> ^1 <o3> + ^2 <o2> +)
    (<in19> ^1 <o3> + ^2 <o5> +)
    (<in20> ^1 <o3> + ^2 <o6> +)
    (<in21> ^1 <o4> + ^2 <o1> +)
    (<in22> ^1 <o4> + ^2 <o2> +)
    (<in23> ^1 <o4> + ^2 <o5> +)
    (<in24> ^1 <o4> + ^2 <o7> +)
    (<in25> ^1 <o4> + ^2 <o8> +)
    (<in26> ^1 <o5> + ^2 <o1> +)
    (<in27> ^1 <o5> + ^2 <o2> +)
    (<in28> ^1 <o5> + ^2 <o3> +)
    (<in29> ^1 <o5> + ^2 <o4> +)
    (<in30> ^1 <o5> + ^2 <o6> +)
    (<in31> ^1 <o5> + ^2 <o7> +)
    (<in32> ^1 <o5> + ^2 <o8> +)
    (<in33> ^1 <o5> + ^2 <o9> +)
    (<in34> ^1 <o6> + ^2 <o2> +)
    (<in35> ^1 <o6> + ^2 <o3> +)
    (<in36> ^1 <o6> + ^2 <o5> +)
    (<in37> ^1 <o6> + ^2 <o8> +)
    (<in38> ^1 <o6> + ^2 <o9> +)
    (<in39> ^1 <o7> + ^2 <o4> +)
    (<in40> ^1 <o7> + ^2 <o5> +)
    (<in41> ^1 <o7> + ^2 <o8> +)
    (<in42> ^1 <o8> + ^2 <o7> +)
    (<in43> ^1 <o8> + ^2 <o4> +)
    (<in44> ^1 <o8> + ^2 <o5> +)
    (<in45> ^1 <o8> + ^2 <o6> +)
    (<in46> ^1 <o8> + ^2 <o9> +)
    (<in47> ^1 <o9> + ^2 <o8> +)
    (<in48> ^1 <o9> + ^2 <o5> +)
    (<in49> ^1 <o9> + ^2 <o6> +)
    (<diagonal-with1> ^item-type predicate + ^handle diagonal-with1 +
           ^instance <in50> + ^instance <in51> + ^instance <in52> +
           ^instance <in53> + ^instance <in54> + ^instance <in55> +
           ^instance <in56> + ^instance <in57> + ^instance <in58> +
           ^instance <in59> + ^instance <in60> + ^instance <in61> +
           ^instance <in62> + ^instance <in63> + ^instance <in64> +
           ^instance <in65> +)
    (<in50> ^1 <o1> + ^2 <o5> +)
    (<in51> ^1 <o2> + ^2 <o4> +)
    (<in52> ^1 <o2> + ^2 <o6> +)
    (<in53> ^1 <o3> + ^2 <o5> +)
    (<in54> ^1 <o4> + ^2 <o2> +)
    (<in55> ^1 <o4> + ^2 <o8> +)
    (<in56> ^1 <o5> + ^2 <o1> +)
    (<in57> ^1 <o5> + ^2 <o3> +)
    (<in58> ^1 <o5> + ^2 <o7> +)
    (<in59> ^1 <o5> + ^2 <o9> +)
    (<in60> ^1 <o6> + ^2 <o2> +)
    (<in61> ^1 <o6> + ^2 <o8> +)
    (<in62> ^1 <o7> + ^2 <o5> +)
    (<in63> ^1 <o8> + ^2 <o4> +)
    (<in64> ^1 <o8> + ^2 <o6> +)
    (<in65> ^1 <o9> + ^2 <o5> +)
    (<linear> ^item-type predicate + ^handle linear + ^instance <in66> +
           ^instance <in67> + ^instance <in68> + ^instance <in69> +
           ^instance <in70> + ^instance <in71> + ^instance <in72> +
           ^instance <in73> +)
    (<in66> ^1 <set66> +)
    (<set66> ^object <o1> + ^object <o2> + ^object <o3> +)
    (<in67> ^1 <set67> +)
    (<set67> ^object <o1> + ^object <o5> + ^object <o9> +)
    (<in68> ^1 <set68> +)
    (<set68> ^object <o1> + ^object <o4> + ^object <o7> +)
    (<in69> ^1 <set69> +)
    (<set69> ^object <o4> + ^object <o5> + ^object <o6> +)
    (<in70> ^1 <set70> +)
    (<set70> ^object <o7> + ^object <o8> + ^object <o9> +)
    (<in71> ^1 <set71> +)
    (<set71> ^object <o2> + ^object <o5> + ^object <o8> +)
    (<in72> ^1 <set72> +)
    (<set72> ^object <o3> + ^object <o6> + ^object <o9> +)
    (<in73> ^1 <set73> +)
    (<set73> ^object <o3> + ^object <o5> + ^object <o7> +)
}

sp {dialog-event*apply*game-state-change-respond*fail-fox
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type fail-fox)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^shape bank1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^shape bank1 +
           ^name destination1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category block + ^color red1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^color yellow1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^color green1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^shape boat1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +)
    (<in0> ^1 <o4> + ^2 <o1> +)
    (<in1> ^1 <o5> + ^2 <o2> +)
    (<in2> ^1 <o6> + ^2 <o2> +)
    (<in3> ^1 <o3> + ^2 <o1> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in4> +
           ^instance <in5> + ^instance <in6> + ^instance <in7> +)
    (<in4> ^1 <o1> + ^2 <o4> +)
    (<in5> ^1 <o2> + ^2 <o5> +)
    (<in6> ^1 <o2> + ^2 <o6> +)
    (<in7> ^1 <o1> + ^2 <o3> +)
}

sp {dialog-event*apply*game-state-change-respond*final-tower3
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-tower3)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color green1 +
           ^volume 4.000000 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color green1 +
           ^volume 4.000000 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^color blue1 +
           ^volume 4.000000 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^size small1 + ^volume 1.000000 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^size medium1 +
           ^volume 2.000000 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^size large1 + ^volume 3.000000 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> +)
    (<in0> ^1 <o4> + ^2 <o5> +)
    (<in1> ^1 <o5> + ^2 <o6> +)
    (<in2> ^1 <o6> + ^2 <o3> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in3> +
           ^instance <in4> + ^instance <in5> +)
    (<in3> ^1 <o5> + ^2 <o4> +)
    (<in4> ^1 <o6> + ^2 <o5> +)
    (<in5> ^1 <o3> + ^2 <o6> +)
}

sp {dialog-event*apply*game-state-change-respond*init-blocksworld
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-blocksworld)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^color red1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^color green1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^color orange1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> +)
    (<in0> ^1 <o4> + ^2 <o5> +)
    (<in1> ^1 <o5> + ^2 <o6> +)
    (<in2> ^1 <o6> + ^2 <o1> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in3> +
           ^instance <in4> + ^instance <in5> +)
    (<in3> ^1 <o5> + ^2 <o4> +)
    (<in4> ^1 <o6> + ^2 <o5> +)
    (<in5> ^1 <o1> + ^2 <o6> +)
}

sp {dialog-event*apply*game-state-change-respond*fail-tower3
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type fail-tower3)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color green1 +
           ^volume 4.000000 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color green1 +
           ^volume 4.000000 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^color blue1 +
           ^volume 4.000000 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^size small1 + ^volume 1.000000 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^size medium1 +
           ^volume 2.000000 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^size large1 + ^volume 3.000000 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> +)
    (<in0> ^1 <o4> + ^2 <o6> +)
    (<in1> ^1 <o5> + ^2 <o4> +)
    (<in2> ^1 <o6> + ^2 <o3> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in3> +
           ^instance <in4> + ^instance <in5> +)
    (<in3> ^1 <o6> + ^2 <o4> +)
    (<in4> ^1 <o4> + ^2 <o5> +)
    (<in5> ^1 <o3> + ^2 <o6> +)
}

sp {dialog-event*apply*game-state-change-respond*final-stacked-frogs2
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-stacked-frogs2)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^x 1 + ^y 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^x 2 + ^y 1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^x 3 + ^y 1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^x 4 + ^y 1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^x 5 + ^y 1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^x 6 + ^y 1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category block +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category block +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> +)
    (<in0> ^1 <o7> + ^2 <o1> +)
    (<in1> ^1 <o8> + ^2 <o1> +)
    (<in2> ^1 <o9> + ^2 <o1> +)
    (<in3> ^1 <o10> + ^2 <o1> +)
    (<in4> ^1 <o11> + ^2 <o1> +)
    (<in5> ^1 <o12> + ^2 <o1> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in6> +
           ^instance <in7> + ^instance <in8> + ^instance <in9> +
           ^instance <in10> + ^instance <in11> +)
    (<in6> ^1 <o1> + ^2 <o7> +)
    (<in7> ^1 <o1> + ^2 <o8> +)
    (<in8> ^1 <o1> + ^2 <o9> +)
    (<in9> ^1 <o1> + ^2 <o10> +)
    (<in10> ^1 <o1> + ^2 <o11> +)
    (<in11> ^1 <o1> + ^2 <o12> +)
}

sp {dialog-event*apply*game-state-change-respond*final-blocksworld
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-blocksworld)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^color red1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^color green1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^color orange1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> +)
    (<in0> ^1 <o6> + ^2 <o4> +)
    (<in1> ^1 <o4> + ^2 <o5> +)
    (<in2> ^1 <o5> + ^2 <o1> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in3> +
           ^instance <in4> + ^instance <in5> +)
    (<in3> ^1 <o4> + ^2 <o6> +)
    (<in4> ^1 <o5> + ^2 <o4> +)
    (<in5> ^1 <o1> + ^2 <o5> +)
}

sp {dialog-event*apply*game-state-change-respond*final-familycross
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-familycross)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^shape bank1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^shape bank1 +
           ^name destination1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category block + ^shape adult1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category block + ^shape adult1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category block + ^shape child1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category block + ^shape child1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^shape boat1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> +)
    (<in0> ^1 <o3> + ^2 <o2> +)
    (<in1> ^1 <o4> + ^2 <o2> +)
    (<in2> ^1 <o5> + ^2 <o2> +)
    (<in3> ^1 <o6> + ^2 <o2> +)
    (<in4> ^1 <o7> + ^2 <o2> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in5> +
           ^instance <in6> + ^instance <in7> + ^instance <in8> +
           ^instance <in9> +)
    (<in5> ^1 <o2> + ^2 <o3> +)
    (<in6> ^1 <o2> + ^2 <o4> +)
    (<in7> ^1 <o2> + ^2 <o5> +)
    (<in8> ^1 <o2> + ^2 <o6> +)
    (<in9> ^1 <o2> + ^2 <o7> +)
}

sp {dialog-event*apply*game-state-change-respond*init-sokoban2
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-sokoban2)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o17> + ^object <o18> + ^object <o19> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <near1> +
           ^predicate <diagonal-with1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^x 1 + ^y 1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^x 2 + ^y 1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^x 3 + ^y 1 + ^color red1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^x 1 + ^y 2 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^x 2 + ^y 2 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^x 3 + ^y 2 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^x 1 + ^y 3 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^x 2 + ^y 3 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^x 3 + ^y 3 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^x 1 + ^y 4 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location + ^x 2 + ^y 4 + ^color green1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location + ^x 3 + ^y 4 +)
    (<o17> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block + ^color blue1 +)
    (<o18> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category block + ^color red1 +)
    (<o19> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category block + ^color green1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> +)
    (<in0> ^1 <o17> + ^2 <o1> +)
    (<in1> ^1 <o18> + ^2 <o2> +)
    (<in2> ^1 <o19> + ^2 <o8> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in3> +
           ^instance <in4> + ^instance <in5> +)
    (<in3> ^1 <o1> + ^2 <o17> +)
    (<in4> ^1 <o2> + ^2 <o18> +)
    (<in5> ^1 <o8> + ^2 <o19> +)
    (<near1> ^item-type predicate + ^handle near1 + ^instance <in6> +
           ^instance <in7> + ^instance <in8> + ^instance <in9> +
           ^instance <in10> + ^instance <in11> + ^instance <in12> +
           ^instance <in13> + ^instance <in14> + ^instance <in15> +
           ^instance <in16> + ^instance <in17> + ^instance <in18> +
           ^instance <in19> + ^instance <in20> + ^instance <in21> +
           ^instance <in22> + ^instance <in23> + ^instance <in24> +
           ^instance <in25> + ^instance <in26> + ^instance <in27> +
           ^instance <in28> + ^instance <in29> + ^instance <in30> +
           ^instance <in31> + ^instance <in32> + ^instance <in33> +
           ^instance <in34> + ^instance <in35> + ^instance <in36> +
           ^instance <in37> + ^instance <in38> + ^instance <in39> +
           ^instance <in40> + ^instance <in41> + ^instance <in42> +
           ^instance <in43> + ^instance <in44> + ^instance <in45> +
           ^instance <in46> + ^instance <in47> + ^instance <in48> +
           ^instance <in49> + ^instance <in50> + ^instance <in51> +
           ^instance <in52> + ^instance <in53> + ^instance <in54> +
           ^instance <in55> + ^instance <in56> + ^instance <in57> +
           ^instance <in58> + ^instance <in59> + ^instance <in60> +
           ^instance <in61> + ^instance <in62> + ^instance <in63> +)
    (<in6> ^1 <o1> + ^2 <o2> +)
    (<in7> ^1 <o1> + ^2 <o4> +)
    (<in8> ^1 <o1> + ^2 <o5> +)
    (<in9> ^1 <o2> + ^2 <o1> +)
    (<in10> ^1 <o2> + ^2 <o3> +)
    (<in11> ^1 <o2> + ^2 <o4> +)
    (<in12> ^1 <o2> + ^2 <o5> +)
    (<in13> ^1 <o2> + ^2 <o6> +)
    (<in14> ^1 <o3> + ^2 <o2> +)
    (<in15> ^1 <o3> + ^2 <o5> +)
    (<in16> ^1 <o3> + ^2 <o6> +)
    (<in17> ^1 <o4> + ^2 <o1> +)
    (<in18> ^1 <o4> + ^2 <o2> +)
    (<in19> ^1 <o4> + ^2 <o5> +)
    (<in20> ^1 <o4> + ^2 <o7> +)
    (<in21> ^1 <o4> + ^2 <o8> +)
    (<in22> ^1 <o5> + ^2 <o1> +)
    (<in23> ^1 <o5> + ^2 <o2> +)
    (<in24> ^1 <o5> + ^2 <o3> +)
    (<in25> ^1 <o5> + ^2 <o4> +)
    (<in26> ^1 <o5> + ^2 <o6> +)
    (<in27> ^1 <o5> + ^2 <o7> +)
    (<in28> ^1 <o5> + ^2 <o8> +)
    (<in29> ^1 <o5> + ^2 <o9> +)
    (<in30> ^1 <o6> + ^2 <o2> +)
    (<in31> ^1 <o6> + ^2 <o3> +)
    (<in32> ^1 <o6> + ^2 <o5> +)
    (<in33> ^1 <o6> + ^2 <o8> +)
    (<in34> ^1 <o6> + ^2 <o9> +)
    (<in35> ^1 <o7> + ^2 <o4> +)
    (<in36> ^1 <o7> + ^2 <o5> +)
    (<in37> ^1 <o7> + ^2 <o8> +)
    (<in38> ^1 <o8> + ^2 <o7> +)
    (<in39> ^1 <o8> + ^2 <o4> +)
    (<in40> ^1 <o8> + ^2 <o5> +)
    (<in41> ^1 <o8> + ^2 <o6> +)
    (<in42> ^1 <o8> + ^2 <o9> +)
    (<in43> ^1 <o9> + ^2 <o8> +)
    (<in44> ^1 <o9> + ^2 <o5> +)
    (<in45> ^1 <o9> + ^2 <o6> +)
    (<in46> ^1 <o9> + ^2 <o11> +)
    (<in47> ^1 <o9> + ^2 <o12> +)
    (<in48> ^1 <o8> + ^2 <o19> +)
    (<in49> ^1 <o8> + ^2 <o11> +)
    (<in50> ^1 <o8> + ^2 <o12> +)
    (<in51> ^1 <o7> + ^2 <o10> +)
    (<in52> ^1 <o7> + ^2 <o11> +)
    (<in53> ^1 <o10> + ^2 <o7> +)
    (<in54> ^1 <o10> + ^2 <o8> +)
    (<in55> ^1 <o10> + ^2 <o11> +)
    (<in56> ^1 <o11> + ^2 <o10> +)
    (<in57> ^1 <o11> + ^2 <o7> +)
    (<in58> ^1 <o11> + ^2 <o8> +)
    (<in59> ^1 <o11> + ^2 <o9> +)
    (<in60> ^1 <o11> + ^2 <o12> +)
    (<in61> ^1 <o12> + ^2 <o11> +)
    (<in62> ^1 <o12> + ^2 <o8> +)
    (<in63> ^1 <o12> + ^2 <o9> +)
    (<diagonal-with1> ^item-type predicate + ^handle diagonal-with1 +
           ^instance <in64> + ^instance <in65> + ^instance <in66> +
           ^instance <in67> + ^instance <in68> + ^instance <in69> +
           ^instance <in70> + ^instance <in71> + ^instance <in72> +
           ^instance <in73> + ^instance <in74> + ^instance <in75> +
           ^instance <in76> + ^instance <in77> + ^instance <in78> +
           ^instance <in79> + ^instance <in80> + ^instance <in81> +
           ^instance <in82> + ^instance <in83> + ^instance <in84> +
           ^instance <in85> + ^instance <in86> + ^instance <in87> +)
    (<in64> ^1 <o1> + ^2 <o5> +)
    (<in65> ^1 <o2> + ^2 <o4> +)
    (<in66> ^1 <o2> + ^2 <o6> +)
    (<in67> ^1 <o3> + ^2 <o5> +)
    (<in68> ^1 <o4> + ^2 <o2> +)
    (<in69> ^1 <o4> + ^2 <o8> +)
    (<in70> ^1 <o5> + ^2 <o1> +)
    (<in71> ^1 <o5> + ^2 <o3> +)
    (<in72> ^1 <o5> + ^2 <o7> +)
    (<in73> ^1 <o5> + ^2 <o9> +)
    (<in74> ^1 <o6> + ^2 <o2> +)
    (<in75> ^1 <o6> + ^2 <o8> +)
    (<in76> ^1 <o7> + ^2 <o5> +)
    (<in77> ^1 <o8> + ^2 <o4> +)
    (<in78> ^1 <o8> + ^2 <o6> +)
    (<in79> ^1 <o9> + ^2 <o5> +)
    (<in80> ^1 <o9> + ^2 <o11> +)
    (<in81> ^1 <o11> + ^2 <o9> +)
    (<in82> ^1 <o12> + ^2 <o8> +)
    (<in83> ^1 <o8> + ^2 <o12> +)
    (<in84> ^1 <o10> + ^2 <o8> +)
    (<in85> ^1 <o8> + ^2 <o10> +)
    (<in86> ^1 <o11> + ^2 <o7> +)
    (<in87> ^1 <o7> + ^2 <o11> +)
}

sp {dialog-event*apply*game-state-change-respond*init-8puzzle4
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-8puzzle4)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> + ^object <o17> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <near1> +
           ^predicate <diagonal-with1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color red1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color orange1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^color yellow1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^color green1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^color blue1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^color purple1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^color gray1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^color brown1 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block + ^color red1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block + ^color orange1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category block + ^color yellow1 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block + ^color green1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category block + ^color blue1 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category block + ^color purple1 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category block + ^color gray1 +)
    (<o17> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category block + ^color brown1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +
           ^instance <in7> +)
    (<in0> ^1 <o10> + ^2 <o2> +)
    (<in1> ^1 <o11> + ^2 <o3> +)
    (<in2> ^1 <o12> + ^2 <o1> +)
    (<in3> ^1 <o13> + ^2 <o4> +)
    (<in4> ^1 <o14> + ^2 <o6> +)
    (<in5> ^1 <o15> + ^2 <o7> +)
    (<in6> ^1 <o16> + ^2 <o8> +)
    (<in7> ^1 <o17> + ^2 <o9> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +
           ^instance <in12> + ^instance <in13> + ^instance <in14> +
           ^instance <in15> +)
    (<in8> ^1 <o2> + ^2 <o10> +)
    (<in9> ^1 <o3> + ^2 <o11> +)
    (<in10> ^1 <o1> + ^2 <o12> +)
    (<in11> ^1 <o4> + ^2 <o13> +)
    (<in12> ^1 <o6> + ^2 <o14> +)
    (<in13> ^1 <o7> + ^2 <o15> +)
    (<in14> ^1 <o8> + ^2 <o16> +)
    (<in15> ^1 <o9> + ^2 <o17> +)
    (<near1> ^item-type predicate + ^handle near1 + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> + ^instance <in25> +
           ^instance <in26> + ^instance <in27> + ^instance <in28> +
           ^instance <in29> + ^instance <in30> + ^instance <in31> +
           ^instance <in32> + ^instance <in33> + ^instance <in34> +
           ^instance <in35> + ^instance <in36> + ^instance <in37> +
           ^instance <in38> + ^instance <in39> + ^instance <in40> +
           ^instance <in41> + ^instance <in42> + ^instance <in43> +
           ^instance <in44> + ^instance <in45> + ^instance <in46> +
           ^instance <in47> + ^instance <in48> + ^instance <in49> +
           ^instance <in50> + ^instance <in51> + ^instance <in52> +
           ^instance <in53> + ^instance <in54> + ^instance <in55> +)
    (<in16> ^1 <o1> + ^2 <o2> +)
    (<in17> ^1 <o1> + ^2 <o4> +)
    (<in18> ^1 <o1> + ^2 <o5> +)
    (<in19> ^1 <o2> + ^2 <o1> +)
    (<in20> ^1 <o2> + ^2 <o3> +)
    (<in21> ^1 <o2> + ^2 <o4> +)
    (<in22> ^1 <o2> + ^2 <o5> +)
    (<in23> ^1 <o2> + ^2 <o6> +)
    (<in24> ^1 <o3> + ^2 <o2> +)
    (<in25> ^1 <o3> + ^2 <o5> +)
    (<in26> ^1 <o3> + ^2 <o6> +)
    (<in27> ^1 <o4> + ^2 <o1> +)
    (<in28> ^1 <o4> + ^2 <o2> +)
    (<in29> ^1 <o4> + ^2 <o5> +)
    (<in30> ^1 <o4> + ^2 <o7> +)
    (<in31> ^1 <o4> + ^2 <o8> +)
    (<in32> ^1 <o5> + ^2 <o1> +)
    (<in33> ^1 <o5> + ^2 <o2> +)
    (<in34> ^1 <o5> + ^2 <o3> +)
    (<in35> ^1 <o5> + ^2 <o4> +)
    (<in36> ^1 <o5> + ^2 <o6> +)
    (<in37> ^1 <o5> + ^2 <o7> +)
    (<in38> ^1 <o5> + ^2 <o8> +)
    (<in39> ^1 <o5> + ^2 <o9> +)
    (<in40> ^1 <o6> + ^2 <o2> +)
    (<in41> ^1 <o6> + ^2 <o3> +)
    (<in42> ^1 <o6> + ^2 <o5> +)
    (<in43> ^1 <o6> + ^2 <o8> +)
    (<in44> ^1 <o6> + ^2 <o9> +)
    (<in45> ^1 <o7> + ^2 <o4> +)
    (<in46> ^1 <o7> + ^2 <o5> +)
    (<in47> ^1 <o7> + ^2 <o8> +)
    (<in48> ^1 <o8> + ^2 <o7> +)
    (<in49> ^1 <o8> + ^2 <o4> +)
    (<in50> ^1 <o8> + ^2 <o5> +)
    (<in51> ^1 <o8> + ^2 <o6> +)
    (<in52> ^1 <o8> + ^2 <o9> +)
    (<in53> ^1 <o9> + ^2 <o8> +)
    (<in54> ^1 <o9> + ^2 <o5> +)
    (<in55> ^1 <o9> + ^2 <o6> +)
    (<diagonal-with1> ^item-type predicate + ^handle diagonal-with1 +
           ^instance <in56> + ^instance <in57> + ^instance <in58> +
           ^instance <in59> + ^instance <in60> + ^instance <in61> +
           ^instance <in62> + ^instance <in63> + ^instance <in64> +
           ^instance <in65> + ^instance <in66> + ^instance <in67> +
           ^instance <in68> + ^instance <in69> + ^instance <in70> +
           ^instance <in71> +)
    (<in56> ^1 <o1> + ^2 <o5> +)
    (<in57> ^1 <o2> + ^2 <o4> +)
    (<in58> ^1 <o2> + ^2 <o6> +)
    (<in59> ^1 <o3> + ^2 <o5> +)
    (<in60> ^1 <o4> + ^2 <o2> +)
    (<in61> ^1 <o4> + ^2 <o8> +)
    (<in62> ^1 <o5> + ^2 <o1> +)
    (<in63> ^1 <o5> + ^2 <o3> +)
    (<in64> ^1 <o5> + ^2 <o7> +)
    (<in65> ^1 <o5> + ^2 <o9> +)
    (<in66> ^1 <o6> + ^2 <o2> +)
    (<in67> ^1 <o6> + ^2 <o8> +)
    (<in68> ^1 <o7> + ^2 <o5> +)
    (<in69> ^1 <o8> + ^2 <o4> +)
    (<in70> ^1 <o8> + ^2 <o6> +)
    (<in71> ^1 <o9> + ^2 <o5> +)
}

sp {dialog-event*apply*game-state-change-respond*init-risk
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-risk)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <near1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category block + ^color red1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category block + ^color red1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category block + ^color red1 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block + ^color red1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block + ^color blue1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category block + ^color blue1 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block + ^color blue1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category block + ^color blue1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +
           ^instance <in7> +)
    (<in0> ^1 <o7> + ^2 <o1> +)
    (<in1> ^1 <o8> + ^2 <o1> +)
    (<in2> ^1 <o9> + ^2 <o2> +)
    (<in3> ^1 <o10> + ^2 <o6> +)
    (<in4> ^1 <o11> + ^2 <o3> +)
    (<in5> ^1 <o12> + ^2 <o3> +)
    (<in6> ^1 <o13> + ^2 <o4> +)
    (<in7> ^1 <o14> + ^2 <o5> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +
           ^instance <in12> + ^instance <in13> + ^instance <in14> +
           ^instance <in15> +)
    (<in8> ^1 <o1> + ^2 <o7> +)
    (<in9> ^1 <o1> + ^2 <o8> +)
    (<in10> ^1 <o2> + ^2 <o9> +)
    (<in11> ^1 <o6> + ^2 <o10> +)
    (<in12> ^1 <o3> + ^2 <o11> +)
    (<in13> ^1 <o3> + ^2 <o12> +)
    (<in14> ^1 <o4> + ^2 <o13> +)
    (<in15> ^1 <o5> + ^2 <o14> +)
    (<near1> ^item-type predicate + ^handle near1 + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> + ^instance <in25> +
           ^instance <in26> + ^instance <in27> + ^instance <in28> +
           ^instance <in29> + ^instance <in30> + ^instance <in31> +
           ^instance <in32> + ^instance <in33> + ^instance <in34> +
           ^instance <in35> + ^instance <in36> + ^instance <in37> +)
    (<in16> ^1 <o1> + ^2 <o2> +)
    (<in17> ^1 <o1> + ^2 <o4> +)
    (<in18> ^1 <o1> + ^2 <o5> +)
    (<in19> ^1 <o2> + ^2 <o1> +)
    (<in20> ^1 <o2> + ^2 <o3> +)
    (<in21> ^1 <o2> + ^2 <o4> +)
    (<in22> ^1 <o2> + ^2 <o5> +)
    (<in23> ^1 <o2> + ^2 <o6> +)
    (<in24> ^1 <o3> + ^2 <o2> +)
    (<in25> ^1 <o3> + ^2 <o5> +)
    (<in26> ^1 <o3> + ^2 <o6> +)
    (<in27> ^1 <o4> + ^2 <o1> +)
    (<in28> ^1 <o4> + ^2 <o2> +)
    (<in29> ^1 <o4> + ^2 <o5> +)
    (<in30> ^1 <o5> + ^2 <o1> +)
    (<in31> ^1 <o5> + ^2 <o2> +)
    (<in32> ^1 <o5> + ^2 <o3> +)
    (<in33> ^1 <o5> + ^2 <o4> +)
    (<in34> ^1 <o5> + ^2 <o6> +)
    (<in35> ^1 <o6> + ^2 <o2> +)
    (<in36> ^1 <o6> + ^2 <o3> +)
    (<in37> ^1 <o6> + ^2 <o5> +)
}

sp {dialog-event*apply*game-state-change-respond*fail-logi5a
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type fail-logi5a)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^row 1 + ^column 1 +
           ^color red1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^row 2 + ^column 1 +
           ^value a + ^color red1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location + ^row 3 + ^column 1 +
           ^value b + ^color red1 +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^row 4 + ^column 1 +
           ^color red1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^row 1 + ^column 2 +
           ^value d + ^color yellow1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^row 2 + ^column 2 +
           ^value d + ^color yellow1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^row 3 + ^column 2 +
           ^color green1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^row 4 + ^column 2 +
           ^color green1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^row 1 + ^column 3 +
           ^color yellow1 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category location + ^row 2 + ^column 3 +
           ^color yellow1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category location + ^row 3 + ^column 3 +
           ^color green1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category location + ^row 4 + ^column 3 +
           ^value b + ^color green1 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category location + ^row 1 + ^column 4 +
           ^color blue1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category location + ^row 2 + ^column 4 +
           ^value d + ^color blue1 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category location + ^row 3 + ^column 4 +
           ^value c + ^color blue1 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category location + ^row 4 + ^column 4 +
           ^color blue1 +)
}

sp {dialog-event*apply*game-state-change-respond
    (state <s> ^name dialog-event ^operator <o> ^top-state <t*2>
          ^top-state <t*1>)
    (<o> ^name game-state-change-respond ^type <type>)
    (<t*2> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^performed <p*1> +)
    (<p*1> ^dialog-event <de> +)
    (<de> ^type game-state-change + ^originator agent +)
    (<changes> ^outgoing-message <msg1> +)
    (<msg1> ^type simple-message + ^message-type ok +)
}

sp {dialog-event*propose*game-state-change-respond
    (state <s> ^name dialog-event ^purpose <p>)
    (<p> ^type game-state-change ^parameters <p*1>)
    (<p*1> ^message <type>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name game-state-change-respond + ^type <type> +)
}

sp {interpret-message*apply*interpret-game-state-change
    (state <s> ^name interpret-message ^operator <o> ^instructor-message <msg>)
    (<o> ^name interpret-game-state-change ^type <type>)
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type game-state-change + ^parameters <p*1> + ^satisfaction <sat> +)
    (<p*1> ^message <type> +)
    (<sat> ^dialog-event <de> +)
    (<de> ^type game-state-change + ^originator agent +)
}

sp {dialog-event*apply*whats-question-respond*time
    (state <s> ^name dialog-event ^operator <o> ^top-state <t*2>
          ^top-state <t*1>)
    (<o> ^name whats-question-respond ^type time)
    (<t*2> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^performed <p*1> +)
    (<p*1> ^dialog-event <de> +)
    (<de> ^type interjection + ^originator agent +)
    (<changes> ^outgoing-message <msg1> +)
    (<msg1> ^type simple-message + ^message-type current-time +)
}

sp {dialog-event*propose*whats-question-respond
    (state <s> ^name dialog-event ^purpose <p>)
    (<p> ^type whats-question ^parameters <p*1>)
    (<p*1> ^message <type>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name whats-question-respond + ^type <type> +)
}

sp {interpret-message*apply*interpret-whats
    (state <s> ^name interpret-message ^operator <o> ^instructor-message <msg>)
    (<o> ^name interpret-whats)
    (<msg> ^arg1 <a*1>)
    (<a*1> ^handle <type>)
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type whats-question + ^parameters <p*1> + ^satisfaction <sat> +)
    (<p*1> ^message <type> +)
    (<sat> ^dialog-event <de> +)
    (<de> ^type interjection + ^originator agent +)
}

sp {interpret-message*propose*interpret-whats2
    (state <s> ^name interpret-message -^action-operator <op>
          ^instructor-message <msg>)
    (<msg> ^message-type command ^action <a*1>)
    (<a*1> ^word-structure <w*1>)
    (<w*1> ^spelling whats)
    -->
    (<s> ^operator <o> + ^operator <o> = ^operator <o> >)
    (<o> ^name interpret-whats + ^command-message <msg> +)
}

sp {interpret-message*propose*interpret-whats
    (state <s> ^name interpret-message -^action-operator <op>
          ^instructor-message <msg>)
    (<msg> ^message-type command ^action <a*1>)
    (<a*1> ^word-structure <w*1>)
    (<w*1> ^spelling |what's|)
    -->
    (<s> ^operator <o> + ^operator <o> = ^operator <o> >)
    (<o> ^name interpret-whats + ^command-message <msg> +)
}

sp {dialog-event*apply*interjection-respond
    (state <s> ^name dialog-event ^operator <o> ^top-state <t*2>
          ^top-state <t*1>)
    (<o> ^name interjection-respond ^type <type>)
    (<t*2> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^performed <p*1> +)
    (<p*1> ^dialog-event <de> +)
    (<de> ^type interjection + ^originator agent +)
    (<changes> ^outgoing-message <msg1> +)
    (<msg1> ^type generic + ^fields <f*1> +)
    (<f*1> ^type <type> +)
}

sp {dialog-event*propose*interjection-respond
    (state <s> ^name dialog-event ^purpose <p>)
    (<p> ^type generic-interjection ^parameters <p*1>)
    (<p*1> ^message <type>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interjection-respond + ^type <type> +)
}

sp {interpret-message*apply*interpret-interjection
    (state <s> ^name interpret-message ^operator <o> ^instructor-message <msg>)
    (<o> ^name interpret-interjection ^type <type>)
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type generic-interjection + ^parameters <p*1> +
           ^satisfaction <sat> +)
    (<p*1> ^message <type> +)
    (<sat> ^dialog-event <de> +)
    (<de> ^type interjection + ^originator agent +)
}

sp {interpret-message*propose*interpret-interjection
    (state <s> ^name interpret-message ^instructor-message <msg>)
    (<msg> -^interpreted true ^message-type { << hello bye >> <type> })
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-interjection + ^type <type> +)
}

sp {interpret-message*apply*interpret-cancel*clarify-argument*pop-action
    (state <s> ^name interpret-message ^current-purpose <c*1> ^operator <o*1>)
    (<c*1> ^type clarify-argument)
    (<o*1> ^name interpret-cancel)
    -->
    (<s> ^pop-action true + ^terminate-segment true +)
}

sp {interpret-message*apply*interpret-cancel*mark
    (state <s> ^name interpret-message ^operator <o>)
    (<o> ^name interpret-cancel ^message <msg>)
    -->
    (<msg> ^interpreted true +)
}

sp {interpret-message*propose*interpret-cancel
    (state <s> ^name interpret-message ^instructor-message <msg>)
    (<msg> -^interpreted true ^message-type cancel)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-cancel + ^message <msg> +)
}

sp {interpret-message*apply*interpret-dont-know*missing-object*mark*stop-asking
    (state <s> ^name interpret-message ^message-context <m*1> ^operator <o*1>
          ^message-context <m*2> ^top-state <t*1>)
    (<m*1> ^type find-missing-object)
    (<o*1> ^name interpret-dont-know)
    (<m*2> ^parameters <params>)
    (<t*1> ^action-stack <a*1>)
    (<a*1> ^top <action>)
    -->
    (<action> ^stop-asking true +)
    (<params> ^stop-asking true +)
    (<s> ^terminate-segment true +)
}

sp {interpret-message*apply*interpret-dont-know*mark*stop-asking
    (state <s> ^name interpret-message ^operator <o*1> ^top-state <t*2>
          ^top-state <t*1>)
    (<o*1> ^name interpret-dont-know)
    (<t*2> ^action-stack <a*1>)
    (<a*1> ^top <action>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <s*2>)
    (<s*2> ^purpose <p*1>)
    (<p*1> ^type get-find-help)
    -->
    (<action> ^stop-asking true +)
}

sp {interpret-message*apply*interpret-dont-know*mark
    (state <s> ^name interpret-message ^operator <o>)
    (<o> ^name interpret-dont-know ^message <msg>)
    -->
    (<msg> ^interpreted true +)
}

sp {interpret-message*propose*interpret-dont-know
    (state <s> ^name interpret-message ^instructor-message <msg>)
    (<msg> -^interpreted true ^message-type dont-know)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-dont-know + ^message <msg> +)
}

sp {interpret-message*apply*interpret-quoted-sentence*find-missing-object*mark*found-as
    (state <s> ^name interpret-message ^operator <o> ^instructor-message <msg>
          ^top-state <t*1>)
    (<o> ^name interpret-quoted-sentence ^object <obj>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <s*2>)
    (<s*2> ^purpose <p>)
    (<p> ^type find-missing-object ^missing-object <missing>)
    -->
    (<s> ^mark-interpreted <msg> +)
    (<missing> ^found-as <obj> +)
}

sp {interpret-message*apply*interpret-quoted-sentence*answer*add*to*ask*action
    (state <s> ^name interpret-message ^operator <o> ^instructor-message <msg>
          ^top-state <t*2> ^top-state <t*1>)
    (<o> ^name interpret-quoted-sentence ^sentence <sent>)
    (<t*2> ^action-stack <a*1>)
    (<a*1> ^top <top>)
    (<top> ^execution-operator <e*1>)
    (<e*1> ^action-handle ask1)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <s*2>)
    (<s*2> ^purpose <p*1>)
    (<p*1> ^type wait-for-answer)
    -->
    (<top> ^answer <sent> +)
    (<s> ^mark-interpreted <msg> +)
}

sp {interpret-message*elaborate*interpret-quoted-sentence*object
    (state <s> ^name interpret-message ^operator <o> +)
    (<o> ^name interpret-quoted-sentence ^message <m*1>)
    (<m*1> ^arg1 <a*1>)
    (<a*1> ^sentence <sent>)
    -->
    (<o> ^sentence <sent> +)
}

sp {interpret-message*propose*interpret-quoted-sentence
    (state <s> ^name interpret-message ^instructor-message <msg>)
    (<msg> -^interpreted true ^message-type quoted-sentence)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-quoted-sentence + ^message <msg> +)
}

sp {interpret-message*apply*interpret-object-definition*find-missing-object*mark*found-as
    (state <s> ^name interpret-message ^operator <o> ^instructor-message <msg>
          ^top-state <t*1>)
    (<o> ^name interpret-object-definition ^object <obj>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <s*2>)
    (<s*2> ^purpose <p>)
    (<p> ^type find-missing-object ^missing-object <missing>)
    -->
    (<s> ^mark-interpreted <msg> +)
    (<missing> ^found-as <obj> +)
}

sp {interpret-message*apply*interpret-object-definition*answer*to*ask*add*answer*predicate
    (state <s> ^name interpret-message ^operator <o> ^instructor-message <msg>
          ^top-state <t*2> ^top-state <t*1>)
    (<o> ^name interpret-object-definition ^object <obj>)
    (<t*2> ^action-stack <a*1>)
    (<a*1> ^top <top>)
    (<top> ^execution-operator <e*1>)
    (<e*1> ^action-handle ask1)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <s*2>)
    (<s*2> ^purpose <p*1>)
    (<p*1> ^type wait-for-answer)
    -->
    (<top> ^answer <obj> +)
    (<s> ^mark-interpreted <msg> +)
}

sp {interpret-message*apply*interpret-object-definition*clarify-argument*remove
    (state <s> ^name interpret-message ^current-purpose <p> ^operator <o>)
    (<p> ^type clarify-argument ^parameters <p*1>)
    (<o> ^name interpret-object-definition ^doesnt-match <arg> ^matches <any>)
    (<p*1> ^action-operator <aop>)
    (<aop> ^<arg-name> <arg>)
    -->
    (<aop> ^<arg-name> <arg> -)
}

sp {interpret-message*apply*interpret-object-definition*clarify-argument*no*matches*reask
    (state <s> ^name interpret-message ^current-purpose <p> ^operator <o>)
    (<p> ^type clarify-argument ^parameters <params>)
    (<o> -^matches <m*1> ^name interpret-object-definition)
    (<params> ^argument-info <arg-info>)
    -->
    (<s> ^new-segment-info <info> + ^outgoing-message <out-msg> +)
    (<info> ^purpose <new-p> + ^originator agent +)
    (<p> ^type clarify-argument + ^parameters <params> + ^satisfaction <s*1> +)
    (<s*1> ^dialog-event <de> +)
    (<de> ^type object-definition + ^originator instructor +)
    (<out-msg> ^type multiple-arguments + ^argument-info <arg-info> +)
}

sp {interpret-message*apply*interpret-object-definition*clarify-argument*mark*interpreted
    (state <s> ^name interpret-message ^operator <o*1>
          ^instructor-message <msg> ^top-state <t*1>)
    (<o*1> ^name interpret-object-definition)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <s*2>)
    (<s*2> ^purpose <p*1>)
    (<p*1> ^type clarify-argument)
    -->
    (<s> ^mark-interpreted <msg> +)
}

sp {interpret-message*elaborate*interpret-object-definition*clarify-argument*elaborate*doesnt-match
    (state <s> ^name interpret-message ^current-purpose <p> ^operator <o> +)
    (<p> ^type clarify-argument ^parameters <params>)
    (<o> ^name interpret-object-definition -^object <obj>)
    (<params> ^arg-name <arg-name> ^action-operator <a*1>)
    (<a*1> ^<arg-name> <arg>)
    (<arg> ^<att> <obj>)
    (<obj> ^item-type object)
    -->
    (<o> ^doesnt-match <arg> +)
}

sp {interpret-message*elaborate*interpret-object-definition*clarify-argument*elaborate*matches
    (state <s> ^name interpret-message ^current-purpose <p> ^operator <o> +)
    (<p> ^type clarify-argument ^parameters <params>)
    (<o> ^name interpret-object-definition ^object <obj>)
    (<params> ^arg-name <arg-name> ^action-operator <a*1>)
    (<a*1> ^<arg-name> <arg>)
    (<arg> ^<att> <obj>)
    (<obj> ^item-type object)
    -->
    (<o> ^matches <arg> +)
}

sp {interpret-message*elaborate*interpret-object-definition*object
    (state <s> ^name interpret-message ^operator <o> +)
    (<o> ^name interpret-object-definition ^message <m*1> -^robot <obj>
          -^goal <obj>)
    (<m*1> ^arg1 <obj>)
    (<obj> ^item-type object)
    -->
    (<o> ^object <obj> +)
}

sp {interpret-message*propose*interpret-object-definition
    (state <s> ^name interpret-message ^instructor-message <msg>)
    (<msg> -^interpreted true ^message-type object-definition)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-object-definition + ^message <msg> +)
}

sp {interpret-message*apply*interpret-ignore-list*create*segment*modify-ignore-list
    (state <s> ^name interpret-message ^operator <o>)
    (<o> ^name interpret-ignore-list ^message <msg>)
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type modify-ignore-list + ^parameters <p*1> + ^satisfaction <sat> +)
    (<p*1> ^message <msg> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type game +)
}

sp {interpret-message*apply*interpret-attend-list*create*segment*modify-attend-list
    (state <s> ^name interpret-message ^operator <o>)
    (<o> ^name interpret-attend-list ^message <msg>)
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type modify-attend-list + ^parameters <p*1> + ^satisfaction <sat> +)
    (<p*1> ^message <msg> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type game +)
}

sp {interpret-message*apply*interpret-done*create*segment*finished-goal-demo
    (state <s> ^name interpret-message ^operator <o> ^instructor-message <msg>
          ^top-state <t*2> ^top-state <t*1>)
    (<o> ^name interpret-done)
    (<t*2> ^dialog-context <dc>)
    (<dc> ^attend <a*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^goal-state <gs>)
    -->
    (<dc> ^modified true +)
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type learn-goal-final-state + ^parameters <p*1> +
           ^satisfaction <sat> +)
    (<p*1> ^message <msg> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type game +)
}

sp {interpret-message*propose*interpret-done
    (state <s> ^name interpret-message ^instructor-message <msg>
          ^top-state <t*2> ^top-state <t*1>)
    (<msg> -^interpreted true ^message-type finished)
    (<t*2> ^dialog-context <d*2>)
    (<d*2> ^attend <a*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learn-link <l*1>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name interpret-done +)
}

sp {interpret-message*apply*interpret-restart*clean*top-state
    (state <s> ^name interpret-message ^operator <o*1> ^top-state <top>)
    (<o*1> ^name interpret-restart)
    (<top> ^current-action <a>)
    -->
    (<top> ^current-action <a> -)
}

sp {interpret-message*apply*interpret-restart*mark*clear-action-stack
    (state <s> ^name interpret-message ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name interpret-restart)
    (<t*1> ^action-stack <a*1>)
    (<a*1> ^changes <chgs>)
    -->
    (<chgs> ^clear-action-stack true +)
}

sp {interpret-message*apply*interpret-restart*mark*clear-interaction-stack
    (state <s> ^name interpret-message ^operator <o*1>)
    (<o*1> ^name interpret-restart)
    -->
    (<s> ^clear-interaction-stack true +)
}

sp {interpret-message*apply*interpret-restart*mark
    (state <s> ^name interpret-message ^operator <o>)
    (<o> ^name interpret-restart ^message <msg>)
    -->
    (<msg> ^interpreted true +)
}

sp {interpret-message*propose*interpret-restart
    (state <s> ^name interpret-message ^instructor-message <msg>)
    (<msg> -^interpreted true ^message-type restart)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-restart + ^message <msg> +)
}

sp {interpret-message*apply*interpret-yes-no-message*no*concept-transfer
    (state <s> ^name interpret-message ^operator <o> ^top-state <ts>)
    (<o> ^message-type no ^name interpret-yes-no-message ^message <msg>)
    (<ts> ^dialog-context <dc> ^interaction <i*1>)
    (<dc> ^transfering <tf> ^learning-predicate <lp>)
    (<tf> ^lti <pred> ^name <name> ^to <game>)
    (<lp> ^name <name>)
    (<i*1> ^changes <changes>)
    -->
    (<msg> ^interpreted true +)
    (<dc> ^transfering <tf> -)
    (<changes> ^outgoing-message <msg2> +)
    (<msg2> ^type unknown-word + ^fields <f*1> +)
    (<f*1> ^word <name> +)
}

sp {interpret-message*apply*interpret-yes-no-message*create*segment*finished-game-learning
    (state <s> ^name interpret-message ^operator <o> ^top-state <t*1>)
    (<o> ^name interpret-yes-no-message ^message-type <yesno> ^message <msg>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^finished-game-teaching true)
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type finished-game-learning + ^parameters <p*1> +
           ^satisfaction <sat> +)
    (<p*1> ^message <yesno> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type game +)
}

sp {interpret-message*apply*interpret-yes-no-message*yes*concept-transfer2
    (state <s> ^name interpret-message ^operator <o> ^top-state <ts>)
    (<o> ^message-type yes ^name interpret-yes-no-message ^message <msg>)
    (<ts> ^dialog-context <dc>)
    (<dc> ^transfering <tf> ^learning-predicate <lp>)
    (<tf> ^lti <pred> ^to <game> ^name <name>)
    (<pred> ^from <game>)
    (<lp> ^name <name>)
    -->
    (<msg> ^interpreted true +)
    (<dc> ^learning-predicate <lp> - ^transfering <tf> -)
}

sp {interpret-message*apply*interpret-yes-no-message*yes*concept-transfer
    (state <s> ^name interpret-message ^operator <o> ^top-state <ts>
          ^smem <s*1>)
    (<o> ^message-type yes ^name interpret-yes-no-message)
    (<ts> ^dialog-context <dc>)
    (<dc> ^transfering <tf> ^learning-predicate <lp>)
    (<tf> ^lti <pred> ^name <name> ^to <game>)
    (<lp> ^name <name>)
    (<s*1> ^command <sc>)
    -->
    (<pred> ^from <game> +)
    (<sc> ^store <pred> +)
}

sp {interpret-message*apply*interpret-yes-no-message*yes**create*segment*learn-failure*predescribed
    (state <s> ^name interpret-message ^operator <o> ^top-state <ts>)
    (<o> ^message-type yes ^name interpret-yes-no-message ^message <msg>)
    (<ts> ^dialog-context <dc>)
    (<dc> ^learning true ^parsed-failure <msg2> ^needs-failure-setup <t>)
    -->
    (<msg> ^interpreted true +)
    (<s> ^new-segment-info <info> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type learn-failure-predicate + ^parameters <p*1> +
           ^satisfaction <sat> +)
    (<p*1> ^message <msg2> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type game +)
}

sp {interpret-message*apply*interpret-yes-no-message*yes**create*segment*learn-goal*predescribed
    (state <s> ^name interpret-message ^operator <o> ^top-state <ts>)
    (<o> ^message-type yes ^name interpret-yes-no-message ^message <msg>)
    (<ts> ^dialog-context <dc>)
    (<dc> ^learning true ^parsed-goal <msg2> ^needs-goal-setup <t>)
    -->
    (<msg> ^interpreted true +)
    (<s> ^new-segment-info <info> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type learn-goal-predicate + ^parameters <p*1> +
           ^satisfaction <sat> +)
    (<p*1> ^message <msg2> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type game +)
}

sp {interpret-message*apply*interpret-yes-no-message*yes**create*segment*learn-failure
    (state <s> ^name interpret-message ^operator <o> ^top-state <ts>)
    (<o> ^message-type yes ^name interpret-yes-no-message ^message <msg>)
    (<ts> ^dialog-context <dc> ^interaction <i*1>)
    (<dc> -^parsed-failure <p*1> ^learning true ^needs-failure-setup <t>)
    (<i*1> ^changes <changes>)
    -->
    (<msg> ^interpreted true +)
    (<dc> ^needs-failure-setup <t> -)
    (<changes> ^outgoing-message <msg2> +)
    (<msg2> ^type simple-message + ^message-type describe-failure +)
}

sp {interpret-message*apply*interpret-yes-no-message*yes**create*segment*learn-goal
    (state <s> ^name interpret-message ^operator <o> ^top-state <ts>)
    (<o> ^message-type yes ^name interpret-yes-no-message ^message <msg>)
    (<ts> ^dialog-context <dc> ^interaction <i*1>)
    (<dc> -^parsed-goal <p*1> ^learning true ^needs-goal-setup <t>)
    (<i*1> ^changes <changes>)
    -->
    (<msg> ^interpreted true +)
    (<dc> ^needs-goal-setup <t> -)
    (<changes> ^outgoing-message <msg2> +)
    (<msg2> ^type simple-message + ^message-type describe-goal +)
}

sp {interpret-message*apply*interpret-yes-no-message*yes**create*segment*learn-goal-initiate-state
    (state <s> ^name interpret-message ^operator <o> ^top-state <t*1>)
    (<o> ^message-type yes ^name interpret-yes-no-message)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^needs-setup true ^learning true)
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type learn-goal-initial-state + ^parameters <p*1> +
           ^satisfaction <sat> +)
    (<p*1> ^message <msg> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type game +)
}

sp {interpret-message*apply*interpret-yes-no-message*reset-state
    (state <s> ^name interpret-message ^operator <o> ^top-state <ts>)
    (<o> ^message-type yes ^name interpret-yes-no-message ^message <msg>)
    (<ts> ^dialog-context <dc> ^interaction <i*1>)
    (<dc> ^learning true ^needs-reset <t>)
    (<i*1> ^status <status>)
    -->
    (<msg> ^interpreted true +)
    (<dc> ^needs-reset <t> -)
    (<status> ^performed <p*1> +)
    (<p*1> ^dialog-event <de> +)
    (<de> ^type single-word-response + ^originator instructor +)
}

sp {interpret-message*apply*interpret-yes-no-message*yes*mark*object*visible
    (state <s> ^name interpret-message ^current-purpose <c*1> ^operator <o>
          ^current-purpose <c*2>)
    (<c*1> ^type ask-about-object)
    (<o> ^message-type yes ^name interpret-yes-no-message)
    (<c*2> ^parameters <p*1>)
    (<p*1> ^object <obj>)
    (<obj> ^predicates <preds>)
    -->
    (<preds> ^visible true + ^visible false -)
}

sp {interpret-message*apply*interpret-yes-no-message*mark*received-yes*start-leading
    (state <s> ^name interpret-message ^operator <o> ^top-state <t*1>)
    (<o> ^message-type yes ^name interpret-yes-no-message)
    (<t*1> ^action-stack <a*1>)
    (<a*1> ^top <top>)
    (<top> ^execution-operator <e*1>)
    (<e*1> ^action-handle { << start-leading1 stop-leading1 >> <a*2> })
    -->
    (<top> ^received-yes true +)
}

sp {interpret-message*apply*interpret-yes-no-message*mark*received-yes*pick-up*put-down
    (state <s> ^name interpret-message ^operator <o> ^top-state <t*1>)
    (<o> ^message-type yes ^name interpret-yes-no-message)
    (<t*1> ^action-stack <a*1>)
    (<a*1> ^top <top>)
    (<top> ^execution-operator <e*1>)
    (<e*1> ^action-handle { << pick-up1 put-down1 give1 >> <a*2> })
    -->
    (<top> ^received-yes true +)
}

sp {interpret-message*apply*interpret-yes-no-message*mark
    (state <s> ^name interpret-message ^operator <o> ^top-state <t*1>)
    (<o> ^name interpret-yes-no-message ^message <msg>)
    (<t*1> ^current-action <c*1>)
    -->
    (<msg> ^interpreted true +)
}

sp {interpret-message*propose*interpret-yes-no-message
    (state <s> ^name interpret-message ^instructor-message <msg>)
    (<msg> -^interpreted true ^message-type { << yes no >> <type> })
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-yes-no-message + ^message <msg> +
           ^message-type <type> +)
}

sp {interpret-message*apply*interpret-what-is-question*create*message
    (state <s> ^name interpret-message ^operator <o>)
    (<o> ^name interpret-what-is-question ^message <in-msg> ^object <obj>)
    -->
    (<in-msg> ^interpreted true +)
    (<s> ^outgoing-message <msg> +)
    (<msg> ^type object-description + ^object <obj> +)
}

sp {interpret-message*elaborate*interpret-what-is-question*object
    (state <s> ^name interpret-message ^operator <o> +)
    (<o> ^name interpret-what-is-question ^message <m*1>)
    (<m*1> ^predicate <obj>)
    -->
    (<o> ^object <obj> +)
}

sp {interpret-message*propose*interpret-what-is-question
    (state <s> ^name interpret-message ^instructor-message <msg>)
    (<msg> -^interpreted true ^message-type what-is-question)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-what-is-question + ^message <msg> +)
}

sp {interpret-message*apply*interpret-ignore*create*segment
    (state <s> ^name interpret-message ^operator <o>)
    (<o> ^name interpret-ignore ^message <msg>)
    -->
    (<s> ^mark-interpreted <msg> + ^outgoing-message <out-msg> +)
    (<out-msg> ^type simple-message + ^message-type ok +)
}

sp {interpret-message*propose*interpret-ignore
    (state <s> ^name interpret-message ^instructor-message <msg>)
    (<msg> -^interpreted true ^message-type ignore)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-ignore + ^message <msg> +)
}

sp {interpret-message*apply*interpret-action-command*pop-segment*existing-action
    (state <s> ^name interpret-message ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name interpret-action-command)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <s*2>)
    (<s*2> ^purpose <p*1>)
    (<p*1> ^type execute-action)
    -->
    (<s> ^terminate-segment true + ^pop-action true +)
}

sp {interpret-message*apply*interpert-action-command*mark*message*learning-action
    (state <s> ^name interpret-message ^operator <o*1>
          ^instructor-message <msg> ^top-state <t*1>)
    (<o*1> ^name interpret-action-command)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <s*2>)
    (<s*2> ^purpose <p*1>)
    (<p*1> ^type get-next-subaction)
    -->
    (<msg> ^task-subaction true +)
}

sp {interpret-message*apply*interpret-action-command
    (state <s> ^name interpret-message ^operator <o*1>
          ^instructor-message <msg>)
    (<o*1> ^name interpret-action-command)
    (<msg> ^action <a*1>)
    (<a*1> ^handle <action-handle>)
    -->
    (<s> ^new-segment-info <info> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type execute-action + ^parameters <p*1> + ^satisfaction <s*1> +)
    (<p*1> ^command-message <msg> +)
    (<s*1> ^action-event <a*2> +)
    (<a*2> ^type <action-handle> +)
    (<msg> ^interpreted true +)
}

sp {interpret-message*propose*interpret-ignore-list
    (state <s> ^name interpret-message ^instructor-message <msg>
          ^top-state <t*1>)
    (<msg> -^interpreted true ^message-type command ^action <a*1>)
    (<a*1> ^handle ignore)
    (<t*1> ^dialog-context <dc>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name interpret-ignore-list + ^message <msg> +)
}

sp {interpret-message*propose*interpret-attend-list
    (state <s> ^name interpret-message ^instructor-message <msg>
          ^top-state <t*1>)
    (<msg> -^interpreted true ^message-type command ^action <a*1>)
    (<a*1> ^handle attend)
    (<t*1> ^dialog-context <dc>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name interpret-attend-list + ^message <msg> +)
}

sp {interpret-message*propose*interpret-conditional-predicate*command
    (state <s> ^name interpret-message ^instructor-message <msg>
          ^top-state <t*1>)
    (<msg> -^interpreted true ^message-type command)
   -{ (<msg> ^action <a*3>)
      (<a*3> ^handle ignore)}
   -{ (<msg> ^interaction-status <i*1>)
      (<i*1> ^failure <f*1>)}
   -{ (<msg> ^action <a*2>)
      (<a*2> ^handle attend)}
   -{ (<msg> ^action <a*1>)
      (<a*1> ^handle load)}
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^type game-learning)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name interpret-conditional-predicate + ^message <msg> +)
}

sp {interpret-message*apply*interpret-stop-following-command
    (state <s> ^name interpret-message ^operator <o*1>
          ^instructor-message <msg> ^top-state <t*1>)
    (<o*1> ^name interpret-stop-following-command)
    (<t*1> ^action-stack <a*1>)
    (<a*1> ^top <top>)
    -->
    (<top> ^told-stop true +)
    (<s> ^interpreted <msg> +)
}

sp {interpret-message*propose*interpret-stop-following-command
    (state <s> ^name interpret-message -^interpreted <i*2>
          ^instructor-message <i*1> ^top-state <t*1>)
    (<i*1> ^action <a*1>)
    (<a*1> ^handle stop1)
    (<t*1> ^action-stack <a*2>)
    (<a*2> ^top <t*2>)
    (<t*2> ^execution-operator <e*1>)
    (<e*1> ^name op_follow-person1)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-stop-following-command +)
}

sp {interpret-message*reject*interpret-action-command*stop-following
    (state <s> ^name interpret-message ^operator <o> +
          ^instructor-message <i*1> ^top-state <t*1>)
    (<o> ^name interpret-action-command)
    (<i*1> ^action <a*1>)
    (<a*1> ^handle stop1)
    (<t*1> ^action-stack <a*2>)
    (<a*2> ^top <t*2>)
    (<t*2> ^execution-operator <e*1>)
    (<e*1> ^name op_follow-person1)
    -->
    (<s> ^operator <o> -)
}

sp {interpret-message*propose*interpret-action-command
    (state <s> ^name interpret-message -^action-operator <op>
          -^new-segment-info <n*1> ^instructor-message <msg>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^dialog-context <d*1>)}
   -{ (<msg> ^action <a*3>)
      (<a*3> ^handle load)}
   -{ (<msg> ^action <a*2>)
      (<a*2> ^word-structure <w*2>)
      (<w*2> ^spelling whats)}
   -{ (<msg> ^action <a*1>)
      (<a*1> ^word-structure <w*1>)
      (<w*1> ^spelling |what's|)}
    (<msg> ^message-type command)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-action-command + ^command-message <msg> +)
}

sp {interpret-message*op-no-chnage*apply*report-failure*remove*message
    (state <s> ^top-state <t*2> ^superstate <s*1> ^operator <o*1>
          ^superstate <s*2>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^dialog-context <d*1>)
      (<d*1> ^learning true)}
    (<s*1> ^name interpret-message)
    (<o*1> ^name report-failure)
    (<t*2> ^interaction <i*1>)
    (<i*1> ^status <status>)
    (<status> ^new-message <msg>)
    (<s*2> ^instructor-message <msg>)
    -->
    (<status> ^new-message <msg> -)
}

sp {interpret-message*op-no-change*apply*report-failure*reject
    (state <s> ^superstate <s*1> ^operator <o*1> ^top-state <t*1>
          ^superstate <ss>)
    (<s*1> ^name interpret-message)
    (<o*1> ^name report-failure)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learning true)
    (<ss> ^operator <o>)
    -->
    (<ss> ^operator <o> -)
}

sp {interpret-message*op-no-change*apply*report-failure
    (state <s> ^top-state <t*2> ^superstate <s*1> ^operator <o*1>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^dialog-context <d*1>)
      (<d*1> ^learning true)}
    (<s*1> ^name interpret-message)
    (<o*1> ^name report-failure)
    (<t*2> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^failure <f*1> +)
    (<f*1> ^type failed-to-interpret-message +)
}

sp {interpret-message*op-no-change*propose*report-failure
    (state <s> ^impasse no-change -^allow-substate true ^attribute operator
          ^superstate <s*1>)
    (<s*1> ^name interpret-message)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name report-failure +)
}

sp {interpret-message*apply*interpret-adjective-definition*create*segment*learn-predicate-info
    (state <s> ^name interpret-message ^operator <o>)
    (<o> ^name interpret-adjective-definition ^property-id <prop-id>
          ^predicate-id <pred-id> ^message <msg>)
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type learn-predicate-info + ^parameters <params> +
           ^satisfaction <sat> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type predicate +)
    (<params> ^predicate-id <pred-id> + ^property-id <prop-id> +)
}

sp {interpret-message*elaborate*interpret-adjective-definition*property
    (state <s> ^name interpret-message ^operator <o> +)
    (<o> ^name interpret-adjective-definition ^message <m*1>)
    (<m*1> ^predicate <p*1>)
    (<p*1> ^id <prop>)
    -->
    (<o> ^property-id <prop> +)
}

sp {interpret-message*elaborate*interpret-adjective-definition*predicate-id*2
    (state <s> ^name interpret-message ^operator <o> +)
    (<o> ^name interpret-adjective-definition ^message <m*1>)
    (<m*1> ^arg1 <a*1>)
    (<a*1> ^id <pred>)
    -->
    (<o> ^predicate-id <pred> +)
}

sp {interpret-message*elaborate*interpret-adjective-definition*predicate-id
    (state <s> ^name interpret-message ^operator <o> +)
    (<o> ^name interpret-adjective-definition ^message <m*1>)
    (<m*1> ^arg1 <pred>)
    (<pred> -^id <i*1>)
    -->
    (<o> ^predicate-id <pred> +)
}

sp {interpret-message*propose*interpret-adjective-definition
    (state <s> ^name interpret-message ^instructor-message <msg>)
    (<msg> -^interpreted true ^message-type adjective-definition)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-adjective-definition + ^message <msg> +)
}

sp {interpret-message*apply*interpret-where-is-question*create*segment*location-question
    (state <s> ^name interpret-message ^operator <o>)
    (<o> ^name interpret-where-is-question ^message <msg> ^object <obj>)
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type location-question + ^parameters <params> +
           ^satisfaction <sat> +)
    (<sat> ^dialog-event <d*1> +)
    (<d*1> ^type explanation +)
    (<params> ^object <obj> +)
}

sp {interpret-message*elaborate*interpret-where-is-question*object
    (state <s> ^name interpret-message ^operator <o> +)
    (<o> ^name interpret-where-is-question ^message <m*1>)
    (<m*1> ^arg1 <obj>)
    -->
    (<o> ^object <obj> +)
}

sp {interpret-message*propose*interpret-where-is-question
    (state <s> ^name interpret-message ^instructor-message <msg>)
    (<msg> -^interpreted true ^message-type where-is-question)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-where-is-question + ^message <msg> +)
}

sp {interpret-message*apply*interpret-conditional-predicate*remove*unknown-word*failure
    (state <s> ^name interpret-message ^operator <o> ^top-state <t*1>)
    (<o> ^name interpret-conditional-predicate ^predicate <p*1>)
    (<p*1> ^spelling <word>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    (<status> ^failure <f>)
    (<f> ^word <word> ^type unknown-word)
    -->
    (<status> ^failure <f> -)
}

sp {interpret-message*apply*interpret-conditional-predicate*learn-goal-definition*terminate*segment
    (state <s> ^name interpret-message ^operator <o> ^current-purpose <c*1>)
    (<o> ^purpose learn-predicate-definition
          ^name interpret-conditional-predicate)
    (<c*1> ^satisfaction <s*1>)
    (<s*1> ^dialog-event <de>)
    (<de> ^originator instructor ^type goal-description)
    -->
    (<s> ^terminate-segment true +)
}

sp {interpret-message*apply*interpret-conditional-predicate*create*context-links*2args*attribute-of
    (state <s> ^name interpret-message ^operator <o> ^top-state <t*1>)
    (<o> ^purpose learn-predicate-definition
          ^name interpret-conditional-predicate ^message <msg>)
    (<msg> ^then-subclause <tc>)
    (<tc> -^arg2 <a*1> ^predicate <pred> ^arg1 <obj>)
    (<pred> ^item-type predicate ^handle of1 ^2 <pred2>)
    (<pred2> ^2 <obj2> ^handle <name>)
    (<t*1> ^dialog-context <dc>)
   -{ (<dc> ^learn-link <l*1>)
      (<l*1> ^handle <name>)}
    (<dc> ^learning-predicate <lp>)
    (<lp> ^name <name>)
    -->
    (<dc> ^learn-link <ll> + ^output-object-1 <obj> + ^input-object-2 <obj2> +)
    (<ll> ^handle <name> + ^item-type predicate +)
}

sp {interpret-message*apply*interpret-conditional-predicate*create*context-links*2args
    (state <s> ^name interpret-message ^operator <o> ^top-state <t*1>)
    (<o> ^purpose learn-predicate-definition
          ^name interpret-conditional-predicate ^message <msg>)
    (<msg> ^then-subclause <tc>)
    (<tc> -^arg2 <a*1> ^predicate <pred> ^arg1 <obj>)
    (<pred> -^handle of1 ^2 <obj2> ^handle <name>)
    (<t*1> ^dialog-context <dc>)
   -{ (<dc> ^learn-link <l*1>)
      (<l*1> ^handle <name>)}
    (<dc> ^learning-predicate <lp>)
    (<lp> ^name <name>)
    -->
    (<dc> ^learn-link <ll> + ^input-object-1 <obj> + ^input-object-2 <obj2> +)
    (<ll> ^handle <name> + ^item-type predicate +)
}

sp {interpret-message*apply*interpret-conditional-predicate*create*context-links*spelling
    (state <s> ^name interpret-message ^operator <o> ^top-state <t*1>)
    (<o> ^purpose learn-predicate-definition
          ^name interpret-conditional-predicate ^message <msg>)
    (<msg> ^then-subclause <tc>)
    (<tc> -^arg2 <a*1> ^predicate <pred> ^arg1 <obj>)
    (<pred> -^2 <v*1> ^handle <name> ^property <p>)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^learning-predicate <lp>)
    (<lp> ^spelling <name> ^name <name2>)
    -->
    (<dc> ^learn-link <ll> + ^input-object-1 <obj> +)
    (<ll> ^handle <name2> + ^item-type predicate + ^property <p> +)
}

sp {interpret-message*apply*interpret-conditional-predicate*create*context-links
    (state <s> ^name interpret-message ^operator <o> ^top-state <t*1>)
    (<o> ^purpose learn-predicate-definition
          ^name interpret-conditional-predicate ^message <msg>)
    (<msg> ^then-subclause <tc>)
    (<tc> -^arg2 <a*1> ^predicate <pred> ^arg1 <obj>)
    (<pred> -^2 <v*1> ^handle <name> ^property <p>)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^learning-predicate <lp>)
    (<lp> ^name <name>)
    -->
    (<dc> ^learn-link <ll> + ^input-object-1 <obj> +)
    (<ll> ^handle <name> + ^item-type predicate + ^property <p> +)
}

sp {interpret-message*apply*interpret-conditional-predicate*copy-old-link
    (state <s> ^name interpret-message ^operator <o> ^top-state <t*1>)
    (<o> ^purpose learn-predicate-definition
          ^name interpret-conditional-predicate ^message <msg>)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^learn-link <ll>)
    (<ll> ^type { << action goal failure >> <t*2> })
    -->
    (<dc> ^store-learn-link <ll> + ^learn-link <ll> -)
}

sp {interpret-message*apply*interpret-conditional-predicate*default-name*goal-demo
    (state <s> ^name interpret-message ^top-state <t*1> ^operator <o>)
    (<t*1> ^dialog-context <dc>)
    (<dc> -^store-learn-link <s*1> -^learn-link <l*1> ^type game-learning
          ^structure <s*2>)
    (<s*2> ^goals <a>)
    (<o> ^message <msg>)
    (<msg> ^arg1 <arg1>)
    (<arg1> ^handle state1 ^predicates <p*1>)
    (<p*1> ^property current)
    -->
    (<dc> ^learn-link <ll> +)
    (<a> ^goal <ll> +)
    (<ll> ^handle (make-constant-symbol goal-default) + ^item-type predicate +
           ^predicate-structure <p> + ^type goal + ^word-structure <n> +)
    (<n> ^referent <ll> + ^spelling default +)
}

sp {interpret-message*apply*interpret-conditional-predicate*default-name*failure
    (state <s> ^name interpret-message ^top-state <t*1> ^operator <o>)
    (<t*1> ^dialog-context <dc>)
    (<dc> -^store-learn-link <s*1> -^learn-link <l*1> ^type game-learning
          ^structure <s*2>)
    (<s*2> ^failures <a>)
    (<o> ^message <msg>)
    (<msg> ^then-subclause <t*2>)
    (<t*2> ^action <a*1>)
    (<a*1> ^handle lose)
    -->
    (<dc> ^learn-link <ll> + ^needs-failure-setup true +)
    (<a> ^failure <ll> +)
    (<ll> ^handle (make-constant-symbol failure-default) +
           ^item-type predicate + ^predicate-structure <p> + ^type failure +
           ^word-structure <n> +)
    (<n> ^referent <ll> + ^spelling default +)
}

sp {interpret-message*apply*interpret-conditional-predicate*default-name*goal
    (state <s> ^name interpret-message ^top-state <t*1> ^operator <o>)
    (<t*1> ^dialog-context <dc>)
    (<dc> -^store-learn-link <s*1> -^learn-link <l*1> ^type game-learning
          ^structure <s*2>)
    (<s*2> ^goals <a>)
    (<o> ^message <msg>)
    (<msg> ^arg1 <a*1>)
    (<a*1> ^handle goal)
    -->
    (<dc> ^learn-link <ll> + ^needs-goal-setup true +)
    (<a> ^goal <ll> +)
    (<ll> ^handle (make-constant-symbol goal-default) + ^item-type predicate +
           ^predicate-structure <p> + ^type goal + ^word-structure <n> +)
    (<n> ^referent <ll> + ^spelling default +)
}

sp {interpret-message*apply*interpret-conditional-predicate*default-name*then-clause*two*action
    (state <s> ^name interpret-message ^top-state <t*1> ^operator <o>)
    (<t*1> ^dialog-context <dc>)
    (<dc> -^store-learn-link <s*1> -^learn-link <l*1> ^type game-learning
          ^structure <s*2>)
    (<s*2> ^actions <a>)
    (<o> ^message <msg>)
   -{ (<msg> ^then-subclause <t*2>)
      (<t*2> ^action <a*2>)
      (<a*2> ^handle { << avoid consider prefer >> <h*2> })}
   -{ (<msg> ^action <a*1>)
      (<a*1> ^handle { << avoid consider prefer >> <h*1> })}
    (<msg> ^then-subclause <ts1>)
    (<ts1> ^subclause <s*4> ^subclause <s*3>)
    (<s*3> ^action <act>)
    (<act> -^handle { << has is1 lose >> <h*3> })
    (<s*4> ^action { > <act> <a*3> } ^action <act2>)
    -->
    (<dc> ^learn-link <ll> +)
    (<a> ^action <ll> +)
    (<ll> ^handle (make-constant-symbol action-default) +
           ^item-type predicate + ^predicate-structure <p> + ^type action +
           ^word-structure <n> +)
    (<n> ^referent <ll> + ^spelling default +)
}

sp {interpret-message*apply*interpret-conditional-predicate*default-name*then-cluase
    (state <s> ^name interpret-message ^top-state <t*1> ^operator <o>)
    (<t*1> ^dialog-context <dc>)
    (<dc> -^store-learn-link <s*1> -^learn-link <l*1> ^type game-learning
          ^structure <s*2>)
    (<s*2> ^actions <a>)
    (<o> ^message <msg>)
   -{ (<msg> ^then-subclause <t*3>)
      (<t*3> ^action <a*2>)
      (<a*2> ^handle { << avoid consider prefer >> <h*2> })}
   -{ (<msg> ^action <a*1>)
      (<a*1> ^handle { << avoid consider prefer >> <h*1> })}
    (<msg> ^then-subclause <t*2>)
    (<t*2> ^action <act>)
    (<act> -^handle { << has is1 lose >> <h*3> })
    -->
    (<dc> ^learn-link <ll> +)
    (<a> ^action <ll> +)
    (<ll> ^handle (make-constant-symbol action-default) +
           ^item-type predicate + ^predicate-structure <p> + ^type action +
           ^word-structure <n> +)
    (<n> ^referent <ll> + ^spelling default +)
}

sp {interpret-message*apply*interpret-conditional-predicate*default-name*heuristic*then
    (state <s> ^name interpret-message ^top-state <t*1> ^operator <o>)
    (<t*1> ^dialog-context <dc>)
    (<dc> -^store-learn-link <s*1> -^learn-link <l*1> ^type game-learning)
    (<o> ^message <msg>)
    (<msg> ^then-subclause <t*2>)
    (<t*2> ^action <a*1>)
    (<a*1> ^handle { << avoid consider prefer >> <h*1> })
    -->
    (<dc> ^learn-link <ll> +)
    (<ll> ^handle (make-constant-symbol heuristic-default) +
           ^item-type predicate + ^ntype heuristic +)
}

sp {interpret-message*apply*interpret-conditional-predicate*default-name*heuristic
    (state <s> ^name interpret-message ^top-state <t*1> ^operator <o>)
    (<t*1> ^dialog-context <dc>)
    (<dc> -^store-learn-link <s*1> -^learn-link <l*1> ^type game-learning)
    (<o> ^message <msg>)
    (<msg> ^action <a*1>)
    (<a*1> ^handle { << avoid consider prefer >> <h*1> })
    -->
    (<dc> ^learn-link <ll> +)
    (<ll> ^handle (make-constant-symbol heuristic-default) +
           ^item-type predicate + ^ntype heuristic +)
}

sp {interpret-message*apply*interpret-conditional-predicate*default-name
    (state <s> ^name interpret-message ^top-state <t*1> ^operator <o>)
    (<t*1> ^dialog-context <dc>)
    (<dc> -^store-learn-link <s*1> -^learn-link <l*1> ^type game-learning
          ^structure <s*2>)
    (<s*2> ^actions <a>)
    (<o> ^message <msg>)
   -{ (<msg> ^then-subclause <t*2>)
      (<t*2> ^action <a*3>)
      (<a*3> ^handle { << avoid consider prefer >> <h*2> })}
   -{ (<msg> ^action <a*2>)
      (<a*2> ^handle { << avoid has consider prefer >> <h*1> })}
    (<msg> ^action <a*1>)
    -->
    (<dc> ^learn-link <ll> +)
    (<a> ^action <ll> +)
    (<ll> ^handle (make-constant-symbol action-default) +
           ^item-type predicate + ^predicate-structure <p> + ^type action +
           ^word-structure <n> +)
    (<n> ^referent <ll> + ^spelling default +)
}

sp {interpret-message*apply*interpret-conditional-predicate*create*segment*learn-action-predicate-definition*setup-failure
    (state <s> ^name interpret-message ^operator <o> ^top-state <t*2>
          ^top-state <t*1>)
    (<o> ^purpose learn-action-predicate-definition
          ^name interpret-conditional-predicate ^message <msg>)
    (<msg> ^then-subclause <t*3>)
    (<t*3> ^action <a*1>)
    (<a*1> ^handle lose)
    (<t*2> ^dialog-context <dc>)
    (<dc> ^type game-learning ^needs-failure-setup <n*1> ^learn-link <l*1>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <changes>)
    -->
    (<dc> ^parsed-failure <msg> +)
    (<msg> ^interpreted true +)
    (<changes> ^outgoing-message <msg2> +)
    (<msg2> ^type simple-message + ^message-type setup-failure +)
}

sp {interpret-message*apply*interpret-conditional-predicate*create*segment*learn-failure-predicate
    (state <s> ^name interpret-message ^operator <o> ^top-state <t*1>)
    (<o> ^purpose learn-action-predicate-definition
          ^name interpret-conditional-predicate ^message <msg>)
    (<msg> ^then-subclause <t*2>)
    (<t*2> ^action <a*1>)
    (<a*1> ^handle lose)
    (<t*1> ^dialog-context <dc>)
    (<dc> -^needs-failure-setup <n*1> ^type game-learning ^learn-link <l*1>)
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type learn-failure-predicate + ^parameters <p*1> +
           ^satisfaction <sat> +)
    (<p*1> ^message <msg> +)
    (<sat> ^learning-event <l*2> +)
    (<l*2> ^type game +)
}

sp {interpret-message*apply*interpret-conditional-predicate*create*segment*learn-heuristic-predicate-definition
    (state <s> ^name interpret-message ^operator <o>)
    (<o> ^purpose learn-action-predicate-definition
          ^name interpret-conditional-predicate ^message <msg>)
   -{ (<msg> ^then-subclause <t*1>)
      (<t*1> ^action <a*1>)
      (<a*1> ^handle lose)}
    (<msg> ^action <a*2>)
    (<a*2> ^handle { << avoid consider prefer >> <h*1> })
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type learn-heuristic-predicate + ^parameters <p*1> +
           ^satisfaction <sat> +)
    (<p*1> ^message <msg> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type game +)
}

sp {interpret-message*apply*interpret-conditional-predicate*create*segment*learn-heuristic-predicate-definition*then
    (state <s> ^name interpret-message ^operator <o>)
    (<o> ^purpose learn-action-predicate-definition
          ^name interpret-conditional-predicate ^message <msg>)
   -{ (<msg> ^then-subclause <t*1>)
      (<t*1> ^action <a*1>)
      (<a*1> ^handle lose)}
    (<msg> ^then-subclause <t*2>)
    (<t*2> ^action <a*2>)
    (<a*2> ^handle { << avoid consider prefer >> <h*1> })
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type learn-heuristic-predicate + ^parameters <p*1> +
           ^satisfaction <sat> +)
    (<p*1> ^message <msg> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type game +)
}

sp {interpret-message*apply*interpret-conditional-predicate*create*segment*learn-start-depth2
    (state <s> ^name interpret-message ^operator <o>)
    (<o> ^purpose learn-action-predicate-definition
          ^name interpret-conditional-predicate ^message <msg>)
   -{ (<msg> ^then-subclause <t*2>)
      (<t*2> ^action <a*4>)
      (<a*4> ^handle { << avoid consider prefer >> <h*1> })}
   -{ (<msg> ^then-subclause <t*1>)
      (<t*1> ^action <a*2>)
      (<a*2> ^handle lose)}
    (<msg> ^action <a*3> ^agent <a*1>)
    (<a*3> ^handle has)
    (<a*1> ^predicates <p*1>)
    (<p*1> ^category solution1)
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type learn-start-depth + ^parameters <p*2> + ^satisfaction <sat> +)
    (<p*2> ^message <msg> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type game +)
}

sp {interpret-message*apply*interpret-conditional-predicate*create*segment*learn-start-depth
    (state <s> ^name interpret-message ^operator <o>)
    (<o> ^purpose learn-action-predicate-definition
          ^name interpret-conditional-predicate ^message <msg>)
   -{ (<msg> ^then-subclause <t*2>)
      (<t*2> ^action <a*4>)
      (<a*4> ^handle { << avoid consider prefer >> <h*1> })}
   -{ (<msg> ^then-subclause <t*1>)
      (<t*1> ^action <a*2>)
      (<a*2> ^handle lose)}
    (<msg> ^agent <a*1> ^action <a*3>)
    (<a*1> ^handle solution1)
    (<a*3> ^handle has)
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type learn-start-depth + ^parameters <p*1> + ^satisfaction <sat> +)
    (<p*1> ^message <msg> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type game +)
}

sp {interpret-message*apply*interpret-conditional-predicate*create*segment*learn-action-predicate-definition
    (state <s> ^name interpret-message ^operator <o>)
    (<o> ^purpose learn-action-predicate-definition
          ^name interpret-conditional-predicate ^message <msg>)
   -{ (<msg> ^then-subclause <t*2>)
      (<t*2> ^action <a*3>)
      (<a*3> ^handle { << avoid consider prefer >> <h*2> })}
   -{ (<msg> ^action <a*2>)
      (<a*2> ^handle { << avoid has consider prefer >> <h*1> })}
   -{ (<msg> ^then-subclause <t*1>)
      (<t*1> ^action <a*1>)
      (<a*1> ^handle lose)}
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type learn-action-predicate + ^parameters <p*1> +
           ^satisfaction <sat> +)
    (<p*1> ^message <msg> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type game +)
}

sp {interpret-message*apply*interpret-conditional-predicate*create*segment*learn-property-predicate
    (state <s> ^name interpret-message ^operator <o> ^top-state <t*1>)
    (<o> ^purpose learn-predicate-definition
          ^name interpret-conditional-predicate ^message <msg>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^performed <p*1> +)
    (<p*1> ^dialog-event <de> +)
    (<de> ^type process-unknown-word + ^originator instructor +)
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type learn-property-predicate + ^parameters <p*2> +
           ^satisfaction <sat> +)
    (<p*2> ^message <msg> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type game +)
}

sp {interpret-message*elaborate*interpret-conditional-predicate*purpose*learn-predicate-definition
    (state <s> ^name interpret-message ^operator <o> + ^top-state <t*1>)
    (<o> ^name interpret-conditional-predicate)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learning-predicate <l*1>)
    -->
    (<o> ^purpose learn-predicate-definition +)
}

sp {interpret-message*elaborate*interpret-conditional-predicate*purpose*learn-action-predicate-definition
    (state <s> ^name interpret-message ^operator <o> + ^top-state <t*1>)
   -{ (<s> ^top-state <t*2>)
      (<t*2> ^dialog-context <d*2>)
      (<d*2> ^learning-predicate <l*1>)}
    (<o> ^name interpret-conditional-predicate)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^type game-learning)
    -->
    (<o> ^purpose learn-action-predicate-definition +)
}

sp {interpret-message*propose*interpret-conditional-predicate
    (state <s> ^name interpret-message ^instructor-message <msg>
          ^top-state <t*1>)
    (<msg> -^interpreted true ^message-type conditional)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^type game-learning)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-conditional-predicate + ^message <msg> +)
}

sp {interpret-message*apply*interpret-done-teaching*create*segment*finished-game-teaching
    (state <s> ^name interpret-message ^operator <o>)
    (<o> ^name interpret-done-teaching ^message <msg>)
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type finished-game-teaching + ^parameters <p*1> +
           ^satisfaction <sat> +)
    (<p*1> ^message <msg> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type game +)
}

sp {interpret-message*propose*interpret-done-teaching
    (state <s> ^name interpret-message ^instructor-message <msg>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^dialog-context <d*1>)
      (<d*1> ^learn-link <l*1>)}
    (<msg> -^interpreted true ^message-type finished)
   -{ (<msg> ^interaction-status <i*1>)
      (<i*1> ^failure <f*1>)}
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-done-teaching + ^message <msg> +)
}

sp {interpret-message*apply*interpret-object-description*remove*unknown-word*failure
    (state <s> ^name interpret-message ^operator <o> ^top-state <t*1>)
    (<o> ^name interpret-object-description ^predicate <p*1>)
    (<p*1> ^spelling <word>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    (<status> ^failure <f>)
    (<f> ^word <word> ^type unknown-word)
    -->
    (<status> ^failure <f> -)
}

sp {interpret-message*apply*interpret-object-description*learn-goal-definition*terminate*segment
    (state <s> ^name interpret-message ^operator <o> ^current-purpose <c*1>)
    (<o> ^purpose learn-goal-definition ^name interpret-object-description)
    (<c*1> ^satisfaction <s*1>)
    (<s*1> ^dialog-event <de>)
    (<de> ^originator instructor ^type goal-description)
    -->
    (<s> ^terminate-segment true +)
}

sp {interpret-message*apply*interpret-object-description*learn-goal-definition*elaborate*goal-predicate*relation*person
    (state <s> ^name interpret-message ^operator <o> ^new-segment-info <n*1>)
    (<o> ^purpose learn-goal-definition ^name interpret-object-description
          ^subclause <sub>)
    (<sub> ^action <a*1> ^agent <obj1> ^arg1 <obj2>)
    (<a*1> ^handle heard)
    (<n*1> ^purpose <p*1>)
    (<p*1> ^parameters <params>)
    -->
    (<params> ^goal-predicate <pred> +)
    (<pred> ^type relation + ^handle heard2 + ^1 <obj1> + ^2 <obj2> +)
}

sp {interpret-message*apply*interpret-object-description*learn-goal-definition*elaborate*goal-predicate*relation
    (state <s> ^name interpret-message ^operator <o> ^new-segment-info <n*1>)
    (<o> ^purpose learn-goal-definition ^name interpret-object-description
          ^subclause <sub>)
    (<sub> ^object1 <obj1> ^{ << arg2 predicate >> <a*1> } <rel>)
    (<n*1> ^purpose <p*1>)
    (<p*1> ^parameters <params>)
    (<rel> ^object2 <obj2> ^handle <pred-handle>)
    -->
    (<params> ^goal-predicate <pred> +)
    (<pred> ^type relation + ^handle <pred-handle> + ^1 <obj1> + ^2 <obj2> +)
}

sp {interpret-message*apply*interpret-object-description*learn-goal-definition*elaborate*goal-predicate*state
    (state <s> ^name interpret-message ^operator <o> ^new-segment-info <n*1>)
    (<o> ^purpose learn-goal-definition ^name interpret-object-description
          ^subclause <sub>)
   -{ (<sub> ^predicate <p*3>)
      (<p*3> ^2 <any>)}
    (<sub> ^object1 <obj> ^predicate <p*2>)
    (<n*1> ^purpose <p*1>)
    (<p*1> ^parameters <params>)
    (<p*2> ^handle <pred-handle>)
    -->
    (<params> ^goal-predicate <pred> +)
    (<pred> ^type state + ^handle <pred-handle> + ^1 <obj> +)
}

sp {interpret-message*interpret-object-description*learn-goal-definition*elaborate*subclause*relation*object2*linked-to
    (state <s> ^name interpret-message ^operator <o> +)
    (<o> ^purpose learn-goal-definition ^name interpret-object-description
          ^subclause <sub>)
    (<sub> ^{ << arg2 predicate >> <a*1> } <rel>)
    (<rel> ^2 <obj2>)
    (<obj2> ^linked-to <link>)
    -->
    (<rel> ^object2 <link> +)
}

sp {interpret-message*interpret-object-description*learn-goal-definition*elaborate*relation*subclause*object2
    (state <s> ^name interpret-message ^operator <o> +)
    (<o> ^purpose learn-goal-definition ^name interpret-object-description
          ^subclause <sub>)
    (<sub> ^{ << arg2 predicate >> <a*1> } <rel>)
    (<rel> ^2 <obj2>)
    (<obj2> -^linked-to <l*1>)
    -->
    (<rel> ^object2 <obj2> +)
}

sp {interpret-message*interpret-object-description*learn-goal-definition*elaborate*subclause*object1*linked-to
    (state <s> ^name interpret-message ^operator <o> +)
    (<o> ^purpose learn-goal-definition ^name interpret-object-description
          ^subclause <sub>)
    (<sub> ^arg1 <obj>)
    (<obj> ^linked-to <link>)
    -->
    (<sub> ^object1 <link> +)
}

sp {interpret-message*interpret-object-description*learn-goal-definition*elaborate*subclause*object1
    (state <s> ^name interpret-message ^operator <o> +)
    (<o> ^purpose learn-goal-definition ^name interpret-object-description
          ^subclause <sub>)
    (<sub> ^arg1 <obj>)
    (<obj> -^linked-to <l*1>)
    -->
    (<sub> ^object1 <obj> +)
}

sp {interpret-message*apply*interpret-object-description*learn-goal-definition*elaborate*action*segment
    (state <s> ^name interpret-message ^operator <o> ^current-purpose <c*1>
          ^new-segment-info <n*1>)
    (<o> ^purpose learn-goal-definition ^name interpret-object-description)
    (<c*1> ^parameters <p*1>)
    (<n*1> ^purpose <p*2>)
    (<p*2> ^parameters <params>)
    (<p*1> ^action <action>)
    -->
    (<params> ^action <action> +)
}

sp {interpret-message*apply*interpret-object-description*create*segment*learn-goal-definition
    (state <s> ^name interpret-message ^operator <o>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^dialog-context <d*1>)
      (<d*1> ^type game-learning)}
    (<o> ^purpose learn-goal-definition ^name interpret-object-description
          ^message <msg>)
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type learn-goal-definition + ^parameters <params> +
           ^satisfaction <sat> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type goal +)
}

sp {interpret-message*apply*interpret-object-description*create*segment*equate-objects
    (state <s> ^name interpret-message ^operator <o>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^dialog-context <d*1>)
      (<d*1> ^type game-learning)}
    (<o> ^purpose equate-objects ^name interpret-object-description
          ^object2 <obj2> ^message <msg> ^object <obj1>)
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type equate-objects + ^parameters <params> + ^satisfaction <sat> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type object +)
    (<params> ^object1 <obj1> + ^object2 <obj2> +)
}

sp {interpret-message*apply*interpret-object-description*create*segment*learn-property-predicate
    (state <s> ^name interpret-message ^operator <o> ^top-state <t*1>)
    (<o> ^name interpret-object-description ^message <msg>)
    (<msg> ^arg1 <a*1>)
    (<a*1> ^predicates <p*1>)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^type game-learning ^learning-predicate <lp>)
    (<lp> ^name <name>)
    (<p*1> ^property <name>)
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type learn-property-predicate + ^parameters <p*2> +
           ^satisfaction <sat> +)
    (<p*2> ^message <msg> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type game +)
}

sp {interpret-message*apply*interpret-object-description*create*segment*learn-goal-predicate*setup
    (state <s> ^name interpret-message ^operator <o> ^top-state <t*2>
          ^top-state <t*1>)
    (<o> ^purpose learn-goal-definition ^name interpret-object-description
          ^message <msg>)
    (<t*2> ^dialog-context <dc>)
    (<dc> ^type game-learning ^learn-link <l*1> ^needs-goal-setup <n*1>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <changes>)
    -->
    (<dc> ^parsed-goal <msg> +)
    (<msg> ^interpreted true +)
    (<changes> ^outgoing-message <msg2> +)
    (<msg2> ^type simple-message + ^message-type setup-goal +)
}

sp {interpret-message*apply*interpret-object-description*create*segment*learn-goal-predicate
    (state <s> ^name interpret-message ^operator <o> ^top-state <t*1>)
    (<o> ^purpose learn-goal-definition ^name interpret-object-description
          ^message <msg>)
    (<t*1> ^dialog-context <dc>)
    (<dc> -^needs-goal-setup <n*1> ^type game-learning ^learn-link <l*1>)
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type learn-goal-predicate + ^parameters <p*1> +
           ^satisfaction <sat> +)
    (<p*1> ^message <msg> +)
    (<sat> ^learning-event <l*2> +)
    (<l*2> ^type game +)
}

sp {interpret-message*apply*interpret-object-description*create*segment*learn-goal-final-state
    (state <s> ^name interpret-message ^operator <o> ^top-state <t*1>)
    (<o> ^name interpret-object-description ^message <msg>)
    (<msg> ^predicate <p*1>)
    (<p*1> ^handle final)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^type game-learning)
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type learn-goal-final-state + ^parameters <p*2> +
           ^satisfaction <sat> +)
    (<p*2> ^message <msg> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type game +)
}

sp {interpret-message*apply*interpret-object-description*create*segment*learn-goal-initiate-state
    (state <s> ^name interpret-message ^operator <o> ^top-state <t*1>)
    (<o> ^name interpret-object-description ^message <msg>)
    (<msg> ^predicate <p*1>)
    (<p*1> ^handle initial)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^type game-learning)
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type learn-goal-initial-state + ^parameters <p*2> +
           ^satisfaction <sat> +)
    (<p*2> ^message <msg> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type game +)
}

sp {interpret-message*apply*interpret-object-description*create*segment*learn-failure-name
    (state <s> ^name interpret-message ^operator <o>)
    (<o> ^name interpret-object-description ^message <msg>)
    (<msg> ^arg1 <a*1>)
    (<a*1> ^2 <q>)
    (<q> ^handle name1 ^2 <v*1>)
    (<v*1> ^{ << failure handle >> <a*2> } failure)
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type learn-failure-name + ^parameters <p*1> + ^satisfaction <sat> +)
    (<p*1> ^message <msg> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type game-name +)
}

sp {interpret-message*apply*interpret-object-description*create*segment*learn-goal-name
    (state <s> ^name interpret-message ^operator <o>)
    (<o> ^name interpret-object-description ^message <msg>)
    (<msg> ^arg1 <a*1>)
    (<a*1> ^2 <q>)
    (<q> ^handle name1 ^2 <v*1>)
    (<v*1> ^{ << goal handle >> <a*2> } goal)
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type learn-goal-name + ^parameters <p*1> + ^satisfaction <sat> +)
    (<p*1> ^message <msg> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type game-name +)
}

sp {interpret-message*apply*interpret-object-description*create*segment*learn-action-name
    (state <s> ^name interpret-message ^operator <o>)
    (<o> ^name interpret-object-description ^message <msg>)
    (<msg> ^arg1 <a*1>)
    (<a*1> ^2 <q>)
    (<q> ^handle name1 ^2 <v*1>)
    (<v*1> ^{ << action handle >> <a*2> } action)
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type learn-action-name + ^parameters <p*1> + ^satisfaction <sat> +)
    (<p*1> ^message <msg> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type game-name +)
}

sp {interpret-message*apply*interpret-object-description*create*segment*learn-puzzle-name
    (state <s> ^name interpret-message ^operator <o>)
    (<o> ^name interpret-object-description ^message <msg>)
    (<msg> ^arg1 <a*1>)
    (<a*1> ^2 <q>)
    (<q> ^handle name1 ^2 <v*1>)
    (<v*1> ^{ << game handle >> <a*2> } puzzle1)
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type learn-puzzle-name + ^parameters <p*1> + ^satisfaction <sat> +)
    (<p*1> ^message <msg> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type game +)
}

sp {interpret-message*apply*interpret-object-description*create*segment*learn-game-name
    (state <s> ^name interpret-message ^operator <o>)
    (<o> ^name interpret-object-description ^message <msg>)
    (<msg> ^arg1 <a*1>)
    (<a*1> ^2 <q>)
    (<q> ^handle name1 ^2 <v*1>)
    (<v*1> ^handle game1)
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type learn-game-name + ^parameters <p*1> + ^satisfaction <sat> +)
    (<p*1> ^message <msg> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type game +)
}

sp {interpret-message*apply*interpret-object-description*create*segment*learn-teacher-name
    (state <s> ^name interpret-message ^operator <o>)
    (<o> ^name interpret-object-description ^message <msg>)
    (<msg> ^arg1 <q> ^predicate <p>)
    (<q> ^handle name1)
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type learn-teacher-name + ^parameters <p*1> + ^satisfaction <sat> +)
    (<p*1> ^message <msg> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type game +)
}

sp {interpret-message*apply*interpret-object-description*teach-location*terminate-segment
    (state <s> ^name interpret-message ^operator <o> ^current-purpose <c*1>)
    (<o> ^purpose teach-location ^name interpret-object-description)
    (<c*1> ^satisfaction <s*1>)
    (<s*1> ^dialog-event <de>)
    (<de> ^originator instructor ^type location-description)
    -->
    (<s> ^terminate-segment true +)
}

sp {interpret-message*apply*interpret-object-description*create*segment*teach-location
    (state <s> ^name interpret-message ^operator <o>)
    (<o> ^purpose teach-location ^name interpret-object-description
          ^message <msg> ^robot <robot> ^relation <r*1>)
    (<r*1> ^2 <loc>)
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type teach-location + ^parameters <params> + ^satisfaction <sat> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type location +)
    (<params> ^location-id <loc> +)
}

sp {interpret-message*apply*interpret-object-description*task-completed*terminate-segment
    (state <s> ^name interpret-message ^operator <o> ^top-state <t*1>)
    (<o> ^purpose task-completed ^name interpret-object-description
          ^message <msg>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <s*2>)
    (<s*2> ^context <c*1>)
    (<c*1> ^parameters <p*1>)
    (<p*1> ^action-operator <a>)
    -->
    (<s> ^terminate-segment true + ^mark-interpreted <msg> +
           ^new-segment-info <info> +)
    (<info> ^purpose <p> + ^originator agent +)
    (<p> ^type retrospective-learning + ^parameters <params> +
           ^satisfaction <s*3> +)
    (<s*3> ^learning-event <l*1> +)
    (<l*1> ^type retrospective +)
    (<params> ^action-operator <a> +)
}

sp {interpret-message*apply*interpret-object-description*create*segment*teach-relation
    (state <s> ^name interpret-message ^operator <o>)
    (<o> ^purpose teach-relation ^name interpret-object-description
          ^message <msg> ^relation <rel> ^object <obj>)
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type teach-relation + ^parameters <params> + ^satisfaction <s*1> +)
    (<s*1> ^learning-event <l*1> +)
    (<l*1> ^type relation +)
    (<params> ^object <obj> + ^relation <rel> +)
}

sp {interpret-message*apply*interpret-object-description*mark*answer
    (state <s> ^name interpret-message ^current-purpose <c*1> ^operator <o>
          ^top-state <t*1>)
    (<c*1> ^type wait-for-answer)
    (<o> ^purpose give-answer ^name interpret-object-description
          ^message <msg>)
    (<msg> ^arg2 <a*2>)
    (<a*2> ^sentence <sentence>)
    (<t*1> ^action-stack <a*1>)
    (<a*1> ^top <top-action>)
    -->
    (<s> ^mark-interpreted <msg> +)
    (<top-action> ^answer <sentence> +)
}

sp {interpret-message*apply*interpret-object-description*copy*predicates
    (state <s> ^name interpret-message ^operator <o> ^new-segment-info <n*1>)
    (<o> ^purpose train-on-object ^name interpret-object-description
          ^predicate <pred>)
    (<n*1> ^purpose <p*1>)
    (<p*1> ^parameters <params>)
    -->
    (<params> ^predicate <pred> +)
}

sp {interpret-message*apply*interpret-object-description*create*segment*train-on-object
    (state <s> ^name interpret-message ^operator <o>)
    (<o> ^purpose train-on-object ^name interpret-object-description
          ^message <msg> ^object <obj>)
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type train-on-object + ^parameters <params> + ^satisfaction <s*1> +)
    (<s*1> ^learning-event <l*1> +)
    (<l*1> ^type object +)
    (<params> ^object <obj> +)
}

sp {interpret-message*elaborate*interpret-object-description*purpose*equate-objects
    (state <s> ^name interpret-message ^operator <o> +)
    (<o> ^name interpret-object-description ^object2 <obj2> ^object <obj>)
    -->
    (<o> ^purpose equate-objects +)
}

sp {interpret-message*elaborate*interpret-object-description*purpose*teach-relation
    (state <s> ^name interpret-message ^operator <o> +)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^dialog-context <d*1>)
      (<d*1> ^type game-learning)}
    (<o> ^name interpret-object-description ^relation <rel> ^object <obj>)
    (<obj> -^handle message1)
    -->
    (<o> ^purpose teach-relation +)
}

sp {interpret-message*elaborate*interpret-object-description*purpose*teach-location
    (state <s> ^name interpret-message ^operator <o> +)
    (<o> ^name interpret-object-description ^robot <rob> ^relation <rel>)
    -->
    (<o> ^purpose teach-location +)
}

sp {interpret-message*elaborate*interpret-object-description*purpose*task-completed
    (state <s> ^name interpret-message ^operator <o> +)
    (<o> ^name interpret-object-description ^predicate <p*1> ^robot <rob>)
    (<p*1> ^handle task-completed)
    -->
    (<o> ^purpose task-completed +)
}

sp {interpret-message*elaborate*interpret-object-description*purpose*learn-goal-definition
    (state <s> ^name interpret-message ^operator <o> +)
    (<o> ^name interpret-object-description ^subclause <sub> ^goal <goal>)
    -->
    (<o> ^purpose learn-goal-definition +)
}

sp {interpret-message*elaborate*interpret-object-description*purpose*give-answer
    (state <s> ^name interpret-message ^operator <o> +)
    (<o> ^name interpret-object-description ^message <m*2> ^message <m*1>)
    (<m*2> ^arg2 <a*2>)
    (<a*2> ^sentence <sent>)
    (<m*1> ^arg1 <a*1>)
    (<a*1> ^predicates <p*1>)
    (<p*1> ^category message)
    -->
    (<o> ^purpose give-answer +)
}

sp {interpret-message*elaborate*interpret-object-description*purpose*train-on-object
    (state <s> ^name interpret-message ^operator <o> +)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^dialog-context <d*1>)
      (<d*1> ^type game-learning)}
    (<o> ^name interpret-object-description ^predicate <pred> ^object <obj>)
    (<obj> -^handle message1)
    -->
    (<o> ^purpose train-on-object +)
}

sp {interpret-message*elaborate*interpret-object-description*subclause*level*2
    (state <s> ^name interpret-message ^operator <o> +)
    (<o> ^name interpret-object-description ^subclause <s*1>)
    (<s*1> ^subclause <sub>)
    -->
    (<o> ^subclause <sub> +)
}

sp {interpret-message*elaborate*interpret-object-description*subclause
    (state <s> ^name interpret-message ^operator <o> +)
    (<o> ^name interpret-object-description ^message <m*1>)
    (<m*1> ^subclause <sub>)
    -->
    (<o> ^subclause <sub> +)
}

sp {interpret-message*elaborate*interpret-object-description*arg2
    (state <s> ^name interpret-message ^operator <o> +)
    (<o> ^name interpret-object-description ^message <m*1>)
    (<m*1> ^arg2 <rel>)
    (<rel> ^item-type predicate)
    -->
    (<o> ^relation <rel> +)
}

sp {interpret-message*elaborate*interpret-object-description*relation
    (state <s> ^name interpret-message ^operator <o> +)
    (<o> ^name interpret-object-description ^message <m*1>)
    (<m*1> ^{ << relation predicate >> <a*1> } <rel>)
   -{ (<rel> ^property <p*1>)
      (<p*1> ^handle { << color shape size >> <h*1> })}
    (<rel> ^2 <other>)
    -->
    (<o> ^relation <rel> +)
}

sp {interpret-message*elaborate*interpret-object-description*predicate
    (state <s> ^name interpret-message ^operator <o> +)
    (<o> ^name interpret-object-description ^message <m*1>)
    (<m*1> ^predicate <pred>)
    -->
    (<o> ^predicate <pred> +)
}

sp {interpret-message*elaborate*interpret-object-description*object2
    (state <s> ^name interpret-message ^operator <o> +)
    (<o> ^name interpret-object-description ^message <m*1>)
    (<m*1> ^arg2 <obj>)
    (<obj> ^item-type object)
    -->
    (<o> ^object2 <obj> +)
}

sp {interpret-message*elaborate*interpret-object-description*object
    (state <s> ^name interpret-message ^operator <o> +)
    (<o> ^name interpret-object-description ^message <m*1> -^robot <obj>
          -^goal <obj>)
    (<m*1> ^arg1 <obj>)
    (<obj> ^item-type object)
    -->
    (<o> ^object <obj> +)
}

sp {interpret-message*elaborate*interpret-object-description*robot
    (state <s> ^name interpret-message ^operator <o> +)
    (<o> ^name interpret-object-description ^message <m*1>)
    (<m*1> ^arg1 <obj>)
    (<obj> ^handle rosie)
    -->
    (<o> ^robot <obj> +)
}

sp {interpret-message*elaborate*interpret-object-description*goal
    (state <s> ^name interpret-message ^operator <o> +)
    (<o> ^name interpret-object-description ^message <m*1>)
    (<m*1> ^arg1 <obj>)
    (<obj> ^handle goal)
    -->
    (<o> ^goal <obj> +)
}

sp {interpret-message*propose*interpret-object-description
    (state <s> ^name interpret-message ^instructor-message <msg>)
    (<msg> -^interpreted true ^message-type object-description)
   -{ (<msg> ^interaction-status <i*1>)
      (<i*1> ^failure <f*1>)}
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-object-description + ^message <msg> +)
}

sp {interpret-message*apply*complete-interpret-message*pop-action
    (state <s> ^pop-action true ^name interpret-message ^operator <o*1>
          ^top-state <t*1>)
    (<o*1> ^name complete-interpret-message)
    (<t*1> ^action-stack <stack>)
    (<stack> ^top { <> none <top> } ^changes <c>)
    -->
    (<c> ^pop <top> +)
}

sp {interpret-message*apply*complete-interpret-message*copy*outgoing-message
    (state <s> ^name interpret-message ^operator <o*1> ^outgoing-message <msg>
          ^top-state <t*1>)
    (<o*1> ^name complete-interpret-message)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <c>)
    -->
    (<c> ^outgoing-message <msg> +)
}

sp {interpret-message*apply*complete-interpret-message*clear-interaction-stack
    (state <s> ^clear-interaction-stack true ^name interpret-message
          ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name complete-interpret-message)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <c>)
    -->
    (<c> ^clear-interaction-stack true +)
}

sp {interpret-message*apply*complete-interpret-message*terminate-segment
    (state <s> ^terminate-segment true ^name interpret-message ^operator <o*1>
          ^top-state <t*1>)
    (<o*1> ^name complete-interpret-message)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <c>)
    -->
    (<c> ^terminate-segment true +)
}

sp {interpret-message*apply*complete-interpret-message*ANY*type*terminate
    (state <s> ^name interpret-message ^operator <o*1> ^message-context <m*1>
          ^instructor-message <i*1> ^top-state <t*1>)
    (<o*1> ^name complete-interpret-message)
    (<i*1> ^message-type <type>)
    (<m*1> ^satisfaction <s*1>)
    (<s*1> ^dialog-event <de>)
    (<de> ^originator instructor ^type ANY)
    (<t*1> ^interaction <i*2>)
    (<i*2> ^changes <c>)
    -->
    (<c> ^terminate-segment true +)
}

sp {interpret-message*apply*complete-interpret-message*expected*message*terminate
    (state <s> ^name interpret-message ^operator <o*1> ^message-context <m*1>
          ^instructor-message <i*1> ^top-state <t*1>)
    (<o*1> ^name complete-interpret-message)
    (<i*1> ^message-type <type>)
    (<m*1> ^satisfaction <s*1>)
    (<s*1> ^dialog-event <de>)
    (<de> ^originator instructor ^type <type>)
    (<t*1> ^interaction <i*2>)
    (<i*2> ^changes <c>)
    -->
    (<c> ^terminate-segment true +)
}

sp {interpret-message*apply*complete-interpret-message*copy*new-segment-info
    (state <s> ^name interpret-message ^operator <o*1>
          ^new-segment-info <info> ^top-state <t*1>)
    (<o*1> ^name complete-interpret-message)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <c>)
    -->
    (<c> ^new-segment-info <info> +)
}

sp {interpret-message*apply*complete-interpret-message*delete*nl-il
    (state <s> ^name interpret-message ^operator <o*1>
          ^instructor-message <msg> ^top-state <t*1>)
    (<o*1> ^name complete-interpret-message)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    (<status> ^new-message <msg>)
    -->
    (<status> ^new-message <msg> -)
}

sp {interpret-message*propose*complete-interpret-message
    (state <s> ^name interpret-message)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete-interpret-message +)
}

sp {interpret-message*elaborate*current-purpose
    (state <s> ^name interpret-message ^top-state <t*1>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <s*2>)
    (<s*2> ^purpose <p>)
    -->
    (<s> ^current-purpose <p> +)
}

sp {interpret-message*elaborate*message-context
    (state <s> ^name interpret-message ^top-state <t*1>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <s*2>)
    (<s*2> ^context <context>)
    -->
    (<s> ^message-context <context> +)
}

sp {interpret-message*apply*any-op*mark*message*interpreted
    (state <s> ^name interpret-message ^mark-interpreted <msg> ^operator <o>)
    -->
    (<msg> ^interpreted true +)
}

sp {interpret-message*elaborate*instructor-message*yes-message
    (state <s> ^name interpret-message ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^message <msg>)
    (<msg> ^message-type yes)
    -->
    (<s> ^instructor-message <msg> +)
}

sp {interpret-message*elaborate*instructor-message
    (state <s> ^name interpret-message ^agent-params <a*1> ^superstate <s*1>)
    (<a*1> ^debug-interaction <flag>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^message <msg>)
    (<msg> -^message-type yes)
    -->
    (<s> ^instructor-message <msg> +)
    (write (ifeq <flag> true (concat |Interpreting Instructor Message: | (crlf) (cmd print <msg> |-d| 10)) ||))
}

sp {interaction*apply*pop-segment*pop*action-stack
    (state <s> ^name interaction ^operator <o> ^top-state <t*1>)
    (<o> ^name pop-segment ^segment <s*1>)
    (<s*1> ^purpose <p>)
    (<p> ^type execute-action ^satisfaction <s*2>)
    (<s*2> ^action-event <a*1>)
    (<t*1> ^action-stack <stack>)
    (<stack> ^changes <changes> ^next <action>)
    (<action> ^execution-operator <e*1>)
    (<e*1> ^action-handle <handle>)
    (<a*1> ^type <handle>)
    -->
    (<changes> ^pop <action> +)
}

sp {interaction*apply*pop-segment*remove*clear-interaction-stack
    (state <s> ^name interaction ^operator <o> ^top-state <t*1>)
    (<o> ^name pop-segment ^segment <s*1>)
    (<s*1> ^next <n*1>)
    (<n*1> ^purpose none)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <c>)
    (<c> ^clear-interaction-stack true)
    -->
    (<c> ^clear-interaction-stack true -)
}

sp {interaction*apply*pop-segment*remove*terminate-segment
    (state <s> ^change-type terminate-segment ^name interaction
          ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name pop-segment)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <c>)
    (<c> ^terminate-segment <any>)
    -->
    (<c> ^terminate-segment <any> -)
}

sp {interaction*apply*pop-segment
    (state <s> ^name interaction ^operator <o> ^top-state <t*1>)
    (<o> ^name pop-segment ^segment <top-seg>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <stack>)
    (<stack> ^segment <top-seg>)
    (<top-seg> ^next <next-seg>)
    -->
    (<stack> ^segment <top-seg> - ^segment <next-seg> +)
    (<next-seg> ^prev <top-seg> -)
}

sp {push-segment*apply*create-segment*copy*context
    (state <s> ^name push-segment ^operator <o*1> ^segment <seg>)
    (<o*1> ^name create-segment)
    (<seg> ^next <n*1>)
    (<n*1> ^purpose <p>)
    -->
    (<seg> ^context <p> +)
}

sp {push-segment*apply*create-segment*originator
    (state <s> ^name push-segment ^operator <o*1> ^new-segment-info <n*1>
          ^segment <seg>)
    (<o*1> ^name create-segment)
    (<n*1> ^originator <orig>)
    -->
    (<seg> ^originator <orig> +)
}

sp {push-segment*apply*create-segment*purpose*parameters
    (state <s> ^name push-segment ^operator <o*1> ^new-segment-info <n*1>)
    (<o*1> ^name create-segment)
    (<n*1> ^purpose <p>)
    (<p> -^parameters <p*1>)
    -->
    (<p> ^parameters <params> +)
}

sp {push-segment*apply*create-segment*purpose
    (state <s> ^name push-segment ^operator <o*1> ^new-segment-info <n*1>
          ^segment <seg>)
    (<o*1> ^name create-segment)
    (<n*1> ^purpose <p>)
    -->
    (<seg> ^purpose <p> +)
}

sp {push-segment*apply*create-segment*create*root
    (state <s> ^name push-segment ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name create-segment)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <prev-seg>)
    (<prev-seg> ^counter <count> ^id <id>)
    -->
    (<s> ^segment <seg> +)
    (<seg> ^id (+ (* <id> 100) <count>) + ^counter 1 + ^next <prev-seg> +
           ^info <info> +)
}

sp {push-segment*propose*create-segment
    (state <s> ^name push-segment ^new-segment-info <n*1>)
   -{ (<s> ^segment <s*1>)
      (<s*1> ^purpose <p*2>)}
    (<n*1> ^purpose <p*1>)
    (<p*1> ^type <t*1>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-segment +)
}

sp {push-segment*increment*counter
    (state <s> ^name push-segment ^operator <o*1> ^segment <seg>
          ^top-state <t*1>)
    (<o*1> ^name complete-push-segment)
    (<seg> ^purpose <p*1>)
    (<p*1> ^type action-command)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <prev>)
    (<prev> ^counter <count>)
    -->
    (<prev> ^counter <count> - ^counter (+ <count> 1) +)
}

sp {push-segment*apply*complete-push-segment*remove*new-segment-info
    (state <s> ^name push-segment ^operator <o*1> ^new-segment-info <info>
          ^top-state <t*1>)
    (<o*1> ^name complete-push-segment)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <c>)
    (<c> ^new-segment-info <info>)
    -->
    (<c> ^new-segment-info <info> -)
}

sp {push-segment*apply*complete-push-segment*push-segment
    (state <s> ^name push-segment ^operator <o*1> ^segment <seg>
          ^top-state <t*1> ^epmem <e*1>)
    (<o*1> ^name complete-push-segment)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <stack>)
    (<stack> ^segment <prev-seg>)
    (<e*1> ^present-id <epmem-id>)
    -->
    (<stack> ^segment <prev-seg> - ^segment <seg> +)
    (<seg> ^epmem-id <epmem-id> +)
    (<prev-seg> ^prev <seg> +)
}

sp {push-segment*propose*complete-push-segment
    (state <s> ^name push-segment)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete-push-segment +)
}

sp {push-segment*elaborate*new-segment-info
    (state <s> ^name push-segment ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^new-segment-info <info>)
    (<info> ^purpose <p>)
    -->
    (<s> ^new-segment-info <info> +)
}

sp {interaction*apply*complete-interaction*clear*changes
    (state <s> ^name interaction ^operator <o*1> ^change-type <type>
          ^change-info <info> ^top-state <t*1>)
    (<o*1> ^name complete-interaction)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <changes>)
    (<changes> ^<type> <info>)
    -->
    (<changes> ^<type> <info> -)
}

sp {interaction*apply*complete-interaction*clear*status
    (state <s> ^name interaction ^operator <o*1> ^status-type <type>
          ^status-info <info> ^top-state <t*1>)
    (<o*1> ^name complete-interaction)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    (<status> ^<type> <info>)
    -->
    (<status> ^<type> <info> -)
}

sp {interaction*propose*complete-interaction
    (state <s> ^name interaction)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete-interaction +)
}

sp {interaction*elaborate*current-segment
    (state <s> ^name interaction ^top-state <t*1>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <seg>)
    -->
    (<s> ^current-segment <seg> +)
}

sp {interaction*elaborate*change*info
    (state <s> ^name interaction ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^change-type <type> ^change-info <change>)
    -->
    (<s> ^change-info <change> + ^change-type <type> +)
}

sp {interaction*elaborate*status*info
    (state <s> ^name interaction ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^status-type <type> ^status-info <info>)
    -->
    (<s> ^status-info <info> + ^status-type <type> +)
}

sp {interaction*propose*performed-event
    (state <s> ^status-type performed ^name interaction ^status-info <event>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name performed-event + ^event <event> +)
}

sp {interaction*propose*pop-segment*clear-stack
    (state <s> ^change-type clear-interaction-stack ^name interaction
          ^top-state <t*1>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <seg>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name pop-segment + ^segment <seg> +)
}

sp {interaction*propose*pop-segment
    (state <s> ^change-type terminate-segment ^name interaction
          ^top-state <t*1>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <seg>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name pop-segment + ^segment <seg> +)
}

sp {interaction*propose*push-segment
    (state <s> ^change-type new-segment-info ^name interaction
          ^change-info <info>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name push-segment + ^new-segment-info <info> +)
}

sp {interaction*propose*send-message
    (state <s> ^change-type outgoing-message ^name interaction
          ^change-info <msg>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name send-message + ^message <msg> +)
}

sp {interaction*propose*interpret-failure
    (state <s> ^status-type failure ^name interaction ^status-info <failure>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-failure + ^failure <failure> +)
}

sp {interaction*apply*interpret-message*interrupt
    (state <s> ^name interaction ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name interpret-message)
    (<t*1> ^agent-params <a*1>)
    (<a*1> ^enable-interrupts true)
    -->
    (interrupt)
}

sp {interaction*propose*interpret-message
    (state <s> ^status-type new-message ^name interaction ^status-info <msg>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name interpret-message + ^message <msg> +)
}

sp {interaction*better-preferences*clear-interaction-stack
    (state <s> ^top-state <s> ^operator <o2> + ^operator <o1> +)
    (<o2> ^name interaction ^<type> { << new-segment-info >> <t*1> })
    (<o1> ^change-type clear-interaction-stack ^name interaction)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {interaction*better-preferences*performed*process-sentence
    (state <s> ^top-state <s> ^operator <o2> + ^operator <o1> +)
   -{ (<o2> ^status-info <s*2>)
      (<s*2> ^dialog-event <d*2>)
      (<d*2> ^type process-sentence)}
    (<o2> ^status-type performed ^name interaction)
    (<o1> ^status-type performed ^name interaction ^status-info <s*1>)
    (<s*1> ^dialog-event <d*1>)
    (<d*1> ^type process-sentence)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {interaction*better-preferences*performed
    (state <s> ^top-state <s> ^operator <o2> + ^operator <o1> +)
    (<o2> ^name interaction
          ^<type> { << clear-interaction-stack new-segment-info >> <t*1> })
    (<o1> ^status-type performed ^name interaction)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {interaction*better-preferences*terminate-segment
    (state <s> ^top-state <s> ^operator <o2> + ^operator <o1> +)
    (<o2> ^name interaction
          ^<type> { << performed clear-interaction-stack new-segment-info >> <t*1> })
    (<o1> ^change-type terminate-segment ^name interaction)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {interaction*better-preferences*outgoing-message
    (state <s> ^top-state <s> ^operator <o2> + ^operator <o1> +)
    (<o2> ^name interaction
          ^<type> { << performed clear-interaction-stack terminate-segment new-segment-info >> <t*1> })
    (<o1> ^change-type outgoing-message ^name interaction)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {interaction*better-preferences*new-message
    (state <s> ^top-state <s> ^operator <o2> + ^operator <o1> +)
    (<o2> ^name interaction
          ^<type> { << outgoing-message performed clear-interaction-stack terminate-segment new-segment-info >> <t*1> })
    (<o1> ^status-type new-message ^name interaction)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {interaction*better-preferences*failure
    (state <s> ^top-state <s> ^operator <o2> + ^operator <o1> +)
    (<o2> ^name interaction
          ^<type> { << new-message outgoing-message performed clear-interaction-stack terminate-segment new-segment-info >> <t*1> })
    (<o1> ^status-type failure ^name interaction)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {anystate*prefer*others*over*wait
    (state <s> ^operator <o2> + ^operator <o1> +)
    (<o2> ^name wait)
    (<o1> ^name { <> wait <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {state-no-change*propose*wait
    (state <s> ^choices none ^attribute state)
   -{ (<s> ^operator <o*1>)
      (<o*1> ^name wait)}
    -->
    (<s> ^operator <o> +)
    (<o> ^name wait +)
}

sp {non-atomic*propose*wait
    (state <s> ^allow-wait true ^choices none)
   -{ (<s> ^operator <o*1>)
      (<o*1> ^name wait)}
    -->
    (<s> ^operator <q> +)
    (<q> ^name wait +)
}

sp {top-state*apply*init-agent*create*perception-monitor*internal
    (state <s> ^world-usage internal ^top-state <s> ^operator <o*1>)
    (<o*1> ^name init-agent)
    -->
    (<s> ^perception-monitor <mon> +)
    (<mon> ^object-monitor <obj-mon> + ^predicate-monitor <pred-mon> +)
}

sp {top-state*apply*init-agent*create*perception-monitor
    (state <s> ^world-usage external ^top-state <s> ^operator <o*1>)
    (<o*1> ^name init-agent)
    -->
    (<s> ^perception-monitor <mon> +)
    (<mon> ^change-info <info> + ^changes <changes> +
           ^object-monitor <obj-mon> + ^predicate-monitor <pred-mon> +)
}

sp {top-state*apply*init-agent*create*interaction-stack
    (state <s> ^top-state <s> ^operator <o*1>)
    (<o*1> ^name init-agent)
    -->
    (<s> ^interaction <int> +)
    (<int> ^stack <stack> + ^status <status> + ^changes <changes> +)
    (<stack> ^segment <seg> + ^segments <s*1> +)
    (<s*1> ^segment <seg> +)
    (<seg> ^id 10 + ^purpose none + ^counter 1 +)
}

sp {top-state*apply*init-agent*create*name
    (state <s> ^top-state <s> ^operator <o*1>)
    (<o*1> ^name init-agent)
    -->
    (<s> ^name rosie +)
}

sp {anystate*apply*smem-retrieve-lti*clear*smem*command
    (state <s> ^operator <o> ^smem <s*2> ^smem <s*1>)
    (<o> ^name smem-retrieve-lti ^retrieve-info <r*2>)
    (<r*2> ^identifier <lti>)
    (<s*1> ^result <r*1>)
    (<s*2> ^command <cmd>)
    (<r*1> ^{ << success failure >> <a*1> } <lti>)
    (<cmd> ^<att> <val>)
    -->
    (<cmd> ^<att> <val> -)
}

sp {anystate*apply*smem-retrieve-lti*mark*retrieved
    (state <s> ^operator <o> ^smem <s*1>)
    (<o> ^name smem-retrieve-lti ^retrieve-info <ret>)
    (<ret> ^identifier <lti>)
    (<s*1> ^result <r*1>)
    (<r*1> ^{ << success failure >> <a*1> } <lti>)
    -->
    (<ret> ^retrieved true +)
}

sp {anystate*apply*smem-retrieve-lti*copy*retrieve*params
    (state <s> ^operator <o> ^smem <s*1>)
    (<o> ^name smem-retrieve-lti ^retrieve-info <info>)
    (<s*1> ^command <cmd>)
    (<info> ^{ <> identifier <> retrieved <att> } <val>)
    -->
    (<cmd> ^<att> <val> +)
}

sp {anystate*apply*smem-retrieve-lti*create*retrieve*command
    (state <s> ^operator <o> ^smem <s*1>)
    (<o> ^name smem-retrieve-lti ^retrieve-info <r*1>)
    (<r*1> ^identifier <lti>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^retrieve <lti> +)
}

sp {anystate*propose*smem-retrieve-lti
    (state <s> ^smem-retrieve <ret>)
    (<ret> -^retrieved true ^identifier <lti>)
    -->
    (<s> ^operator <o> + ^operator <o> > ^operator <o> =)
    (<o> ^name smem-retrieve-lti + ^retrieve-info <ret> +)
}

sp {new*anystate*apply*smem-store*copy-result*copy
    (state <s> ^operator <o> ^store-concept <lti> ^smem <s*1>)
    (<o> ^name smem-store)
    (<s*1> ^result <r*1>)
    (<r*1> ^{ << success failure >> <a*1> } <lti>)
    -->
    (<s> ^stored <lti> +)
}

sp {new*anystate*apply*smem-store*create-cue*clear
    (state <s> ^operator <op> ^smem <s*1>)
    (<op> ^name smem-store)
    (<s*1> ^command <cmd>)
    (<cmd> ^{ << retrieve query >> <command> } <olti>)
    -->
    (<cmd> ^<command> <olti> -)
}

sp {new*anystate*apply*smem-store*create-cue
    (state <s> ^operator <op> ^store-concept <lti> ^smem <s*1>)
    (<op> ^name smem-store)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^store <lti> +)
}

sp {new*anystate*propose*smem-store*create-cue
    (state <s> ^store-concept <lti> -^stored <lti>)
    -->
    (<s> ^operator <o> + ^operator <o> = ^operator <o> >)
    (<o> ^name smem-store +)
}

sp {anystate*apply*smem-query*clear*smem*command
    (state <s> ^operator <o> ^smem <s*2> ^smem <s*1>)
    (<o> ^name smem-query ^query-info <q*1>)
    (<q*1> ^cue <cue>)
    (<s*1> ^result <r*1>)
    (<s*2> ^command <cmd>)
    (<r*1> ^{ << success failure >> <a*1> } <cue>)
    (<cmd> ^<att> <val>)
    -->
    (<cmd> ^<att> <val> -)
}

sp {anystate*apply*smem-query*create*result*failure
    (state <s> ^operator <o> ^smem <s*1>)
    (<o> ^name smem-query ^query-info <info>)
    (<info> ^cue <cue>)
    (<s*1> ^result <r*1>)
    (<r*1> ^failure <cue>)
    -->
    (<info> ^result failure +)
}

sp {anystate*apply*smem-query*create*result*success
    (state <s> ^operator <o> ^smem <s*2> ^smem <s*1>)
    (<o> ^name smem-query ^query-info <info>)
    (<info> ^cue <cue>)
    (<s*2> ^result <r*1>)
    (<r*1> ^success <cue>)
    (<s*1> ^result <res>)
    (<res> ^success <cue> ^retrieved <top-lti>)
   -{ (<res> ^retrieved <r*2>)
      (<r*2> ^<att> <top-lti>)}
    -->
    (<info> ^result <top-lti> +)
}

sp {anystate*apply*smem-query*copy*params
    (state <s> ^operator <o> ^smem <s*1>)
    (<o> ^name smem-query ^query-info <info>)
    (<s*1> ^command <cmd>)
    (<info> ^{ <> cue <> result <att> } <val>)
    -->
    (<cmd> ^<att> <val> +)
}

sp {anystate*apply*smem-query*create*query*command
    (state <s> ^operator <o> ^smem <s*1>)
    (<o> ^name smem-query ^query-info <q*1>)
    (<q*1> ^cue <cue>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^query <cue> +)
}

sp {anystate*propose*smem-query
    (state <s> ^smem-query <query>)
    (<query> -^result <r*1> ^cue <cue>)
    -->
    (<s> ^operator <o> + ^operator <o> > ^operator <o> =)
    (<o> ^name smem-query + ^query-info <query> +)
}

sp {top-state*perception-monitor*predicate-monitor*elaborate*default*predicates*mobile
    (state <s> ^world-usage external ^superstate nil ^perception-monitor <p*1>)
    (<p*1> ^predicate-monitor <mon>)
    -->
    (<mon> ^predicate-info <on-info> + ^predicate-info <in-info2> +
           ^predicate-info <in-info3> + ^predicate-info <in-info4> +)
    (<on-info> ^predicate-handle on1 +)
    (<in-info2> ^predicate-handle below1 +)
    (<in-info3> ^predicate-handle near1 +)
    (<in-info4> ^predicate-handle diagonal-with1 +)
}

sp {top-state*elaborate*agent-info
    (state <s> ^superstate nil)
    -->
    (<s> ^agent-info <info> +)
}

sp {top-state*elaborate*problem-space
    (state <s> ^superstate nil)
    -->
    (<s> ^problem-space <ps> +)
    (<ps> ^perception <perc> +)
    (<perc> ^attend-to-all-perception yes +)
}

sp {rosie*elaborate*edge*to*further*edge
    :o-support
    (state <s> ^name rosie ^maps <m*1>)
    (<m*1> ^map <m*2>)
    (<m*2> ^waypoint <wp>)
    (<wp> ^edge <edge> ^handle { <> <wp-handle> <h*1> })
    (<edge> ^end <e*2>)
    (<e*2> ^edge <e*3>)
    (<e*3> ^to <wp-handle>)
   -{ (<wp> ^edge <e*1>)
      (<e*1> ^to <wp-handle>)}
    -->
    (<edge> ^to <wp-handle> +)
}

sp {rosie*elaborate*edge*to*end
    :o-support
    (state <s> ^name rosie ^maps <m*1>)
    (<m*1> ^map <m*2>)
    (<m*2> ^waypoint <wp>)
    (<wp> ^edge <edge>)
    (<edge> ^end <e*1>)
    (<e*1> ^handle <wp-handle>)
    -->
    (<edge> ^to <wp-handle> +)
}

sp {rosie*elaborate*next*waypoint
    (state <s> ^name rosie ^maps <m*1>)
    (<m*1> ^map <m*2>)
    (<m*2> ^waypoint <wp>)
    (<wp> ^edge <e*1>)
    (<e*1> ^end <next-wp>)
    -->
    (<wp> ^next <next-wp> +)
}

sp {svs*apply*any-op*property-command*object-source*belief
    (state <s> ^top-state <t*1> ^svs <s*1> ^operator <o>)
    (<t*1> ^perception-monitor <p*1>)
    (<p*1> ^object-monitor <o*1>)
    (<o*1> ^object-info <o*2>)
    (<o*2> ^belief-obj <bel-obj>)
    (<bel-obj> -^object-source belief ^id <bel-id>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^set_tag <prop> +)
    (<prop> ^id <bel-id> + ^tag_name object-source + ^tag_value belief +)
}

sp {svs*elaborate*svs*objects*type*node
    (state <s> ^svs <s*1>)
    (<s*1> ^spatial-scene <sc>)
    (<sc> ^child <C>)
    (<C> ^object-source belief)
    -->
    (<C> ^type node +)
}

sp {all*elaborate*agent-params
    (state <s> ^superstate <s*1>)
    (<s*1> ^agent-params <ap>)
    -->
    (<s> ^agent-params <ap> +)
}

sp {all*elaborate*io
    (state <s> ^superstate <s*1> -^name action-policy -^name setup-search
          -^name learn-param -^name selection)
   -{ (<s> ^problem-space <p*1>)
      (<p*1> ^state <s*2>)
      (<s*2> ^dont-copy io)}
    (<s*1> ^io <io>)
    -->
    (<s> ^io <io> +)
}

sp {top-state*elaborate*top-state
    (state <s> ^superstate nil)
    -->
    (<s> ^top-state <s> +)
}

sp {all*elaborate*name
    (state <s> ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^name <name>)
    -->
    (<s> ^name <name> +)
}

sp {interaction-stack*elaborate*ask-property-name*info*word
    (state <s> ^top-state <s> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segments <s*2>)
    (<s*2> ^segment <seg>)
    (<seg> ^purpose <purp> ^info <info>)
    (<purp> ^type ask-property-name ^word <word>)
    -->
    (<info> ^word <word> +)
}

sp {interaction-stack*elaborate*teaching-request*info*object
    (state <s> ^top-state <s> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segments <s*2>)
    (<s*2> ^segment <seg>)
    (<seg> ^info <info> ^purpose <purp>)
    (<purp> ^target-object <out>
          ^type { << teaching-request which-question >> <t*1> })
    -->
    (<info> ^object <out> +)
}

sp {interaction-stack*elaborate*segments*all*segments
    (state <s> ^top-state <s> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segments <segs>)
    (<segs> ^segment <s*2>)
    (<s*2> ^prev <seg>)
    -->
    (<segs> ^segment <seg> +)
}

sp {apply*interaction*update-dialog-object-list-saved
    (state <s> ^operator <o*1> ^dialog-object-list <dol>
          ^dialog-object-list-saved { <> <dol> <dols> })
    (<o*1> ^name interaction)
    -->
    (<s> ^dialog-object-list-saved <dols> - ^dialog-object-list-saved <dol> +)
}

sp {top-state*better-preferences*attend-to-scene-change
    (state <s> ^operator <o1> + ^operator <o2> +)
    (<o1> ^name attend-to-scene-change)
    (<o2> ^name { << wait >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {top-state*better-preferences*execute-action
    (state <s> ^operator <o2> + ^operator <o1> +)
    (<o2> ^name satisfy-purpose)
    (<o1> ^name execute-action)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {top-state*better-preferences*satisfy-purpose
    (state <s> ^operator <o2> + ^operator <o1> +)
    (<o2> ^name { << attend-to-scene-change wait >> <n*2> })
    (<o1> ^name { << satisfy-purpose execute-action action-learning >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {top-state*manage-action-stack*prefer*push-action*higher*first
    (state <s> ^superstate nil ^operator <o2> + ^operator <o1> +)
    (<o2> ^change-name push ^name manage-action-stack ^change-info <c*2>)
    (<o1> ^change-name push ^name manage-action-stack ^change-info <c*1>)
    (<c*2> ^order <i2>)
    (<c*1> ^order { > <i2> <i1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {top-state*better-preferences*manage-action-stack
    (state <s> ^operator <o1> + ^operator <o2> +)
    (<o1> ^name manage-action-stack)
    (<o2>
          ^name { << satisfy-purpose action-learning execute-action attend-to-scene-change wait >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {top-state*better-preferences*generate-action-operator
    (state <s> ^operator <o1> + ^operator <o2> +)
    (<o1> ^name generate-action-operator)
    (<o2>
          ^name { << manage-action-stack satisfy-purpose action-learning execute-action attend-to-scene-change wait >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {top-state*better-preferences*comprehension
    (state <s> ^operator <o1> + ^operator <o2> +)
    (<o1> ^name comprehension)
    (<o2>
          ^name { << generate-action-operator manage-action-stack satisfy-purpose action-learning execute-action attend-to-scene-change wait >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {top-state*better-preferences*interaction
    (state <s> ^operator <o1> + ^operator <o2> +)
    (<o1> ^name interaction)
    (<o2>
          ^name { << generate-action-operator comprehension manage-action-stack satisfy-purpose action-learning execute-action attend-to-scene-change wait >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {top-state*better-preferences*lookup-preposition
    (state <s> ^operator <o1> + ^operator <o2> +)
    (<o1> ^name lookup-preposition)
    (<o2>
          ^name { << interaction generate-action-operator comprehension manage-action-stack satisfy-purpose action-learning execute-action attend-to-scene-change wait >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {top-state*propose*manage-action-stack
    (state <s> ^superstate nil ^action-stack <a*1>)
    (<a*1> ^changes <c*1>)
    (<c*1> ^<change-name> <any>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name manage-action-stack + ^change-name <change-name> +
           ^change-info <any> +)
}

sp {top-state*propose*generate-action-operator
    (state <s> ^superstate nil ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <s*2>)
    (<s*2> ^purpose <p>)
    (<p> ^type execute-action ^parameters <params>)
    (<params> -^action-operator <op> ^command-message <msg>)
    (<msg> -^pushed <p*1>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name generate-action-operator + ^command-message <msg> +)
}

sp {top-state*apply*execute-action
    (state <s> ^superstate nil ^agent-params <a*1> ^operator <o*1>)
    (<a*1> ^enable-interrupts true)
    (<o*1> ^name execute-action)
    -->
    (interrupt)
}

sp {top-state*propose*execute-action
    (state <s> ^superstate nil ^top-state <t*1> ^action-stack <a*1>)
    (<t*1> ^world-usage external)
    (<a*1> ^bottom { <> none <action> })
    -->
    (<s> ^operator <o> +)
    (<o> ^name execute-action + ^action <action> +)
}

sp {top-state*propose*satisfy-purpose
    (<s> -^parser-testing true ^interaction <i*1>)
    (state <s> ^top-state <s>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <s*2>)
    (<s*2> ^purpose { <> none <p> })
    (<p> -^category goal
          -^type { << action-command execute-action goal-description >> <t*1> })
    -->
    (<s> ^operator <o> +)
    (<o> ^name satisfy-purpose + ^purpose <p> +)
}

sp {top-state*propose*interaction*interaction-change
    (<s> -^parser-testing true ^interaction <i*1>)
    (state <s> ^top-state <s>)
    (<i*1> ^changes <c*1>)
    (<c*1> ^<type> <change>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name interaction + ^type interaction-change +
           ^change-info <change> + ^change-type <type> +)
}

sp {top-state*propose*interaction*status-change
    (<s> -^parser-testing true ^interaction <i*1>)
    (state <s> ^top-state <s>)
    (<i*1> ^status <s*1>)
    (<s*1> ^<any> <status>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name interaction + ^type status-change + ^status-info <status> +
           ^status-type <any> +)
}

sp {top-state*propose*init-agent
    (<s> -^name rosie)
    (state <s> ^top-state <s>)
    -->
    (<s> ^operator <o> + ^operator <o> !)
    (<o> ^name init-agent +)
}

sp {top-state*elaborate*debug-ids*world
    (state <s> ^superstate nil ^agent-params <a*1> ^world <w>)
    (<a*1> ^debug-ids true)
    (<w> ^robot <rob> ^objects <objs> ^predicates <preds>)
    -->
    (<w> ^debug-id world +)
    (<objs> ^debug-id objs +)
    (<rob> ^debug-id rob +)
    (<preds> ^debug-id preds +)
}

sp {top-state*elaborate*debug-ids*perception-monitor
    (state <s> ^superstate nil ^agent-params <a*1> ^perception-monitor <pmon>)
    (<a*1> ^debug-ids true)
    (<pmon> ^changes <chgs> ^predicate-monitor <prmon> ^object-monitor <omon>)
    -->
    (<pmon> ^debug-id percmon +)
    (<omon> ^debug-id objmon +)
    (<prmon> ^debug-id predmon +)
    (<chgs> ^debug-id perc-changes +)
}

sp {top-state*apply*any-op*report*svs*command*errors
    (state <s> ^top-state <s> ^agent-params <a*1> ^svs <s*1>)
    (<a*1> ^debug-perception true)
    (<s*1> ^command <cmd>)
    (<cmd> ^{ <> extract <> extract_once <type> } <val>)
    (<val> ^status { <> success <status> })
    -->
    (write |Command Error (| <type> |): | <status> (crlf))
}

sp {top-state*apply*any-op*report*svs*filter*errors
    (state <s> ^top-state <s> ^agent-params <a*1> ^svs <s*1>)
    (<a*1> ^debug-perception true)
    (<s*1> ^command <cmd>)
    (<cmd> ^{ << extract extract_once >> <a*2> } <val>)
    (<val> ^status { <> success <status> } ^type <type>)
    -->
    (write |Filter Error (| <type> |): | <status> (crlf))
}

sp {anystate*operator-tie*print*operators
    (state <s> ^type state ^impasse tie ^top-state <top> ^item <i*1>)
    (<top> ^agent-params <a*1>)
    (<a*1> ^debug-op-ties true)
    (<i*1> ^name <name>)
    -->
    (write |Operator tie on | <s> |: '| <name> |'| (crlf))
}

sp {anystate*operator-tie*action*interrupt
    (state <s> ^problemspace action ^impasse tie ^top-state <top>)
    (<top> ^agent-params <a*1>)
    (<a*1> ^debug-op-ties true)
    -->
    (interrupt)
}

sp {top-state*elaborate*agent-params*debug
    (state <s> ^top-state <s> ^agent-params <params>)
    -->
    (<params> ^debug-op-ties false + ^debug-ids true +
           ^enable-interrupts false + ^debug-perception true +
           ^debug-actions true + ^debug-arm false +
           ^debug-path-planning false + ^debug-interaction true +)
}

sp {top-state*elaborate*agent-params*perception
    (state <s> ^top-state <s> ^agent-params <params>)
    -->
    (<params> ^stability-check-duration 0 + ^pos-diff-threshold 0.020000 +
           ^vol-low-diff-threshold 0.800000 +
           ^vol-high-diff-threshold 1.200000 + ^max-stability-checks 5 +
           ^occlusion-threshold 0.150000 + ^occlusion-check-period 3 +
           ^contained-threshold 0.330000 + ^contained-by-threshold 0.500000 +
           ^recheck-growth-delay 5 +)
}

sp {top-state*elaborate*agent-params*task
    (state <s> ^superstate nil ^agent-params <params>)
    -->
    (<params> ^use-default-values true + ^use-object-variablization true +
           ^use-intra-task-transfer true + ^action-search-depth 3 +
           ^confirm-arm-actions no +)
}

sp {top-state*elaborate*agent-params*object-rep-info
    (state <s> ^superstate nil ^agent-params <params>)
    -->
    (<params> ^object-rep-info <rep> +)
    (<rep> ^copy-level1 waypoint + ^ignore-level1 handle +
           ^ignore-level1 item-type + ^ignore-level1 object-instance +
           ^ignore-level1 predicates + ^ignore-level1 in-smem +
           ^ignore-level1 room1 + ^ignore-level1 storage1 +
           ^ignore-level2 arm-status + ^ignore-level2 object-status +
           ^ignore-level2 visible + ^ignore-level2 dialog-object +
           ^ignore-level2 handle +)
}

sp {top-state*elaborate*agent-params*domain
    (state <s> ^superstate nil ^agent-params <params>)
    -->
    (<params> ^domain tabletop +)
}

sp {top-state*elaborate*agent-params
    (state <s> ^top-state <s>)
    -->
    (<s> ^agent-params <params> +)
}



# Semantic Memory

smem --add {
(@90 ^type aligned ^count 0 ^sum 0.000000 ^bottom 0.000000 ^top 0.000000 ^axis x ^avg 0.000000 ^squaredsum 0.000000)
(@1 ^arg1 @2 ^op_name op_pick-up1)
(@4 ^arg1 @5 ^op_name op_put-down1)
(@7 ^arg1 @8 ^op_name op_open1)
(@8 ^id @9 ^arg-type object)
(@5 ^id @6 ^arg-type object ^arg-status real ^importance required)
(@2 ^id @3 ^arg-type object ^arg-status real ^importance required)
(@20 ^predicate @26)
(@29 ^id @33 ^2 @32 ^arg-type predicate ^arg-status desired ^importance required)
(@10 ^arg1 @11 ^op_name op_close1)
(@34 ^type relation ^id @33 ^1 @31 ^2 @32)
(@35 ^arg1 @36 ^op_name op_turn1)
(@36 ^id @37 ^arg-type concept ^arg-status abstract ^importance required)
(@21 ^id @23 ^arg-type object ^arg-status real ^importance required)
(@11 ^id @12 ^arg-type object)
(@13 ^arg1 @14 ^op_name op_turn-on1)
(@14 ^id @15 ^arg-type object)
(@16 ^arg1 @17 ^op_name op_turn-off1)
(@17 ^id @18 ^arg-type object)
(@19 ^arg1 @21 ^arg2 @22 ^op_name op_move1)
(@26 ^type relation ^id @25 ^1 @23 ^2 @24)
(@22 ^id @25 ^2 @24 ^arg-type predicate ^arg-status desired ^importance required)
(@27 ^arg1 @30 ^arg2 @29 ^op_name op_write1)
(@28 ^predicate @34)
(@38 ^arg1 @39 ^op_name op_follow-wall1)
(@30 ^id @31 ^arg-type object ^arg-status real ^importance required)
(@42 ^id @43 ^arg-type concept ^arg-status abstract ^importance required)
(@51 ^arg2 @52 ^op_name op_go-to-waypoint1)
(@52 ^id @53 ^arg-type concept ^arg-status abstract)
(@58 ^op_name op_scan1)
(@39 ^id @40 ^arg-type object ^arg-status abstract ^importance required)
(@41 ^arg1 @42 ^op_name op_orient1)
(@44 ^arg1 @45 ^op_name op_face1)
(@48 ^id @49 ^2 @50 ^arg-type predicate ^arg-status desired ^importance required)
(@45 ^id @46 ^arg-type object ^arg-status real ^importance required)
(@47 ^arg2 @48 ^op_name op_go-to-location1)
(@59 ^op_name op_sense1)
(@60 ^op_name initiate-attend1)
(@64 ^op_name initiate-win1)
(@65 ^op_name initiate-lose1)
(@66 ^op_name initiate-prefer1)
(@67 ^op_name initiate-avoid1)
(@54 ^arg2 @55 ^op_name op_go-to-next-waypoint1)
(@55 ^id @56 ^arg-type concept ^arg-status abstract)
(@57 ^op_name op_stop1)
(@61 ^op_name initiate-ignore1)
(@62 ^op_name initiate-has1)
(@63 ^op_name initiate-play1)
(@68 ^op_name initiate-think1)
(@69 ^op_name initiate-attack)
(@74 ^type aligned ^count 0 ^sum 0.000000 ^bottom 0.000000 ^top 0.000000 ^axis z ^avg 0.000000 ^squaredsum 0.000000)
(@20999 ^structure-type G ^converts-to GP ^assigners @1000060 @1000061 @1000062 ^number singular ^semantic-structure action ^tense present)
(@70 ^op_name initiate-load)
(@71 ^op_name initiate-consider1)
(@72 ^type aligned ^count 0 ^sum 0.000000 ^bottom 0.000000 ^top 0.000000 ^axis x ^avg 0.000000 ^squaredsum 0.000000)
(@73 ^type aligned ^count 0 ^sum 0.000000 ^bottom 0.000000 ^top 0.000000 ^axis y ^avg 0.000000 ^squaredsum 0.000000)
(@75 ^type less ^count 1 ^sum 0.800000 ^bottom 0.000100 ^top 4.000000 ^axis y ^avg 0.800000 ^squaredsum 0.640000)
(@76 ^type aligned ^count 0 ^sum 0.000000 ^bottom 0.000000 ^top 0.000000 ^axis z ^avg 0.000000 ^squaredsum 0.000000)
(@77 ^type aligned ^count 0 ^sum 0.000000 ^bottom 0.000000 ^top 0.000000 ^axis x ^avg 0.000000 ^squaredsum 0.000000)
(@78 ^type aligned ^count 0 ^sum 0.000000 ^bottom 0.000000 ^top 0.000000 ^axis x ^avg 0.000000 ^squaredsum 0.000000)
(@79 ^type greater ^count 1 ^sum 0.800000 ^bottom 0.000100 ^top 4.000000 ^axis y ^avg 0.800000 ^squaredsum 0.640000)
(@80 ^type aligned ^count 0 ^sum 0.000000 ^bottom 0.000000 ^top 0.000000 ^axis z ^avg 0.000000 ^squaredsum 0.000000)
(@81 ^type greater ^count 1 ^sum 0.800000 ^bottom 0.000100 ^top 4.000000 ^axis x ^avg 0.800000 ^squaredsum 0.640000)
(@82 ^type aligned ^count 0 ^sum 0.000000 ^bottom 0.000000 ^top 0.000000 ^axis y ^avg 0.000000 ^squaredsum 0.000000)
(@83 ^type aligned ^count 0 ^sum 0.000000 ^bottom 0.000000 ^top 0.000000 ^axis z ^avg 0.000000 ^squaredsum 0.000000)
(@84 ^type less ^count 1 ^sum 0.100000 ^bottom 0.000100 ^top 4.000000 ^axis x ^avg 0.800000 ^squaredsum 0.640000)
(@85 ^type aligned ^count 0 ^sum 0.000000 ^bottom 0.000000 ^top 0.000000 ^axis y ^avg 0.000000 ^squaredsum 0.000000)
(@86 ^type aligned ^count 0 ^sum 0.000000 ^bottom 0.000000 ^top 0.000000 ^axis z ^avg 0.000000 ^squaredsum 0.000000)
(@87 ^type aligned ^count 0 ^sum 0.000000 ^bottom 0.000000 ^top 0.000000 ^axis x ^avg 0.000000 ^squaredsum 0.000000)
(@88 ^type aligned ^count 0 ^sum 0.000000 ^bottom 0.000000 ^top 0.000000 ^axis y ^avg 0.000000 ^squaredsum 0.000000)
(@89 ^type greater ^count 3 ^sum 0.000000 ^bottom 0.000010 ^top 0.040000 ^axis z ^avg 0.005000 ^squaredsum 0.000000)
(@91 ^type aligned ^count 0 ^sum 0.000000 ^bottom 0.000000 ^top 0.000000 ^axis y ^avg 0.000000 ^squaredsum 0.000000)
(@94 ^type aligned less greater ^count 1 ^sum 0.000000 ^bottom 0.000100 ^top 0.100000 ^axis y ^avg 0.100000 ^squaredsum 0.000000)
(@95 ^type aligned ^count 1 ^sum 0.000000 ^bottom 0.000100 ^top 0.000000 ^axis z ^avg 0.100000 ^squaredsum 0.000000)
(@92 ^type less ^count 3 ^sum 0.000000 ^bottom 0.000001 ^top 0.040000 ^axis z ^avg 0.005000 ^squaredsum 0.000000)
(@93 ^type aligned less greater ^count 1 ^sum 0.000000 ^bottom 0.000100 ^top 0.100000 ^axis x ^avg 0.100000 ^squaredsum 0.000000)
(@96 ^type aligned ^count 1 ^sum 0.000000 ^bottom 0.000100 ^top 0.000000 ^axis z ^avg 0.100000 ^squaredsum 0.000000)
(@99 ^name kitchen1 ^waypoint wp03 ^handle loc-kitchen1 ^item-type object ^object-instance true ^category location ^spatial-shape room1)
(@97 ^type less greater ^count 1 ^sum 0.000000 ^bottom 0.000100 ^top 0.100000 ^axis y ^avg 0.100000 ^squaredsum 0.000000)
(@98 ^type less greater ^count 1 ^sum 0.000000 ^bottom 0.000100 ^top 0.100000 ^axis x ^avg 0.100000 ^squaredsum 0.000000)
(@100 ^name soar1 ^waypoint wp01 ^handle loc-soar1 ^item-type object ^object-instance true ^category location ^spatial-shape room1)
(@102 ^name conference1 ^waypoint wp04 ^handle loc-conf1 ^item-type object ^object-instance true ^category location ^spatial-shape room1)
(@101 ^name main1 ^waypoint wp02 ^handle loc-main1 ^item-type object ^object-instance true ^category location ^spatial-shape room1)
(@103 ^waypoint wp07 ^handle loc-north-hall1 ^item-type object ^object-instance true ^category location ^spatial-shape hall1 ^cardinal-direction1 north1)
(@104 ^waypoint wp05 ^handle loc-south-hall1 ^item-type object ^object-instance true ^category location ^spatial-shape hall1 ^cardinal-direction1 south1)
(@105 ^name alice1 ^handle person-alice1 ^item-type object ^object-instance true ^room1 @99 ^category person)
(@106 ^name bob1 ^handle person-bob1 ^item-type object ^object-instance true ^room1 @100 ^category person)
(@107 ^name charlie1 ^handle person-charlie1 ^item-type object ^object-instance true ^room1 @102 ^category person)
(@901 ^spelling turn ^referent @101005 ^structure-type V ^converts-to VP ^assigners @999601 @999602 @999603 ^number singular ^semantic-structure action ^tense present)
(@905 ^relation @501000 ^spelling on ^structure-type P ^converts-to PP ^assigners @999435 ^relation-type binary)
(@902 ^spelling the ^specifier definite ^number singular ^super-type @991001)
(@903 ^relation @501031 ^spelling to ^super-type @609000 ^directional maybe)
(@9010 ^spelling is ^structure-type IS-V ^number singular ^tense present)
(@101002 ^handle put-down1 ^item-type action ^procedural @4)
(@60985 ^structure-type V ^converts-to VP ^assigners @999682 @999683 @999684 @999685 @999686 @999687 @999688 ^number singular ^semantic-structure action ^tense present)
(@60986 ^structure-type V ^converts-to VP ^assigners @999678 @999679 @999680 @999681 ^number singular ^semantic-structure action ^tense present)
(@60987 ^structure-type V ^converts-to VP ^assigners @999670 @999671 @999672 @999673 @999674 @999675 @999676 @999677 ^number singular ^semantic-structure action ^tense present)
(@60988 ^structure-type V ^converts-to VP ^assigners @999665 @999666 @999667 @999668 @999669 ^number singular ^semantic-structure action ^tense present)
(@60989 ^structure-type V ^converts-to VP ^assigners @999660 @999661 @999662 @999663 @999664 ^number singular ^semantic-structure action ^tense present)
(@60990 ^structure-type V ^converts-to VP ^assigners @999657 @999658 @999659 ^number singular ^semantic-structure action ^tense present)
(@60991 ^structure-type V ^converts-to VP ^assigners @999653 @999654 @999655 @999656 ^number singular ^semantic-structure action ^tense present)
(@60992 ^structure-type V ^converts-to VP ^assigners @999647 @999648 @999649 @999650 @999651 ^number singular ^semantic-structure action ^tense present)
(@60993 ^structure-type V ^converts-to VP ^assigners @999641 @999642 @999643 @999644 @999645 @999646 ^number singular ^semantic-structure action ^tense present)
(@60994 ^structure-type V ^converts-to VP ^assigners @999638 @999639 @999640 ^number singular ^semantic-structure action ^tense present)
(@60995 ^structure-type V ^converts-to VP ^assigners @999632 @999633 @999634 @999635 @999636 @999637 ^number singular ^semantic-structure action ^tense present)
(@60996 ^structure-type V ^converts-to VP ^assigners @999626 @999627 @999628 @999629 @999630 @999631 ^number singular ^semantic-structure action ^tense present)
(@60997 ^structure-type V ^converts-to VP ^assigners @999619 @999620 @999621 @999622 @999623 @999624 @999625 ^number singular ^semantic-structure action ^tense present)
(@60998 ^structure-type V ^converts-to VP ^assigners @999614 @999615 @999616 @999617 @999618 ^number singular ^semantic-structure action ^tense present)
(@60999 ^structure-type V ^converts-to VP ^assigners @999606 @999607 @999608 @999609 @999610 @999611 @999612 @999613 ^number singular ^semantic-structure action ^tense present)
(@101001 ^handle pick-up1 ^item-type action ^procedural @1)
(@101003 ^handle open1 ^item-type action ^procedural @7)
(@101004 ^handle close1 ^item-type action ^procedural @10)
(@101005 ^handle turn-on1 ^item-type action ^procedural @13)
(@101006 ^handle turn-off1 ^item-type action ^procedural @16)
(@101101 ^goal @20 ^handle move1 ^item-type action ^procedural @19)
(@101111 ^handle sense1 ^item-type action ^procedural @59)
(@101117 ^type action ^handle attend ^procedural @60)
(@101118 ^type action ^handle ignore ^procedural @61)
(@101131 ^handle scan1 ^item-type action ^procedural @58 ^learn-proposal true)
(@101144 ^type action ^handle attack ^procedural @69)
(@101119 ^type action ^handle has ^procedural @62)
(@101120 ^type action ^handle play ^procedural @63)
(@101121 ^type action ^handle win ^procedural @64)
(@101122 ^type action ^handle lose ^procedural @65)
(@101123 ^type action ^handle prefer ^procedural @66)
(@101124 ^type action ^handle avoid ^procedural @67)
(@101146 ^type action ^handle consider ^procedural @71)
(@101145 ^type action ^handle load ^procedural @70)
(@101143 ^type action ^handle think ^procedural @68)
(@101201 ^handle turn1 ^item-type action ^procedural @35)
(@101202 ^handle follow-wall1 ^item-type action ^procedural @38)
(@402002 ^property @402000 ^handle arch1 ^item-type predicate)
(@101147 ^handle matches1)
(@101148 ^handle is1)
(@101149 ^handle covers1 ^tense past)
(@402013 ^property @402000 ^handle lights1 ^item-type predicate)
(@403001 ^property @403000 ^handle small1 ^item-type predicate)
(@402010 ^property @402000 ^handle soda1 ^item-type predicate)
(@101203 ^handle orient1 ^item-type action ^procedural @41)
(@101204 ^handle face1 ^item-type action ^procedural @44)
(@101206 ^handle go-to-location1 ^item-type action ^procedural @47)
(@101207 ^handle go-to-waypoint1 ^item-type action ^procedural @51)
(@101208 ^handle go-to-next-waypoint1 ^item-type action ^procedural @54)
(@101209 ^handle stop1 ^item-type action ^procedural @57)
(@101901 ^goal @28 ^handle write1 ^item-type action ^procedural @27)
(@108009 ^handle organize)
(@202000 ^type visual ^handle property1 ^item-type property)
(@401002 ^property @401000 ^handle orange1 ^item-type predicate)
(@401000 ^type visual ^handle color ^item-type property)
(@401001 ^property @401000 ^handle red1 ^item-type predicate)
(@401003 ^property @401000 ^handle yellow1 ^item-type predicate)
(@401004 ^property @401000 ^handle green1 ^item-type predicate)
(@401005 ^property @401000 ^handle blue1 ^item-type predicate)
(@401006 ^property @401000 ^handle purple1 ^item-type predicate)
(@401007 ^property @401000 ^handle white1 ^item-type predicate)
(@401008 ^property @401000 ^handle black1 ^item-type predicate)
(@401009 ^property @401000 ^handle brown1 ^item-type predicate)
(@401010 ^property @401000 ^handle gray1 ^item-type predicate)
(@402000 ^type visual ^handle shape ^item-type property)
(@402008 ^property @402000 ^handle rectangle1 ^item-type predicate)
(@402001 ^property @402000 ^handle triangle1 ^item-type predicate)
(@402003 ^property @402000 ^handle square1 ^item-type predicate)
(@402004 ^property @402000 ^handle l-block1 ^item-type predicate)
(@402005 ^property @402000 ^handle t-block1 ^item-type predicate)
(@402006 ^property @402000 ^handle sphere1 ^item-type predicate)
(@402007 ^property @402000 ^handle chicken1 ^item-type predicate)
(@403003 ^property @403000 ^handle large1 ^item-type predicate)
(@404001 ^property @404000 ^handle pantry ^item-type predicate)
(@403002 ^property @403000 ^handle medium1 ^item-type predicate)
(@402011 ^property @402000 ^handle box1 ^item-type predicate)
(@402012 ^property @402000 ^handle steak1 ^item-type predicate)
(@402014 ^property @402000 ^handle package1 ^item-type predicate)
(@402015 ^property @402000 ^handle papers1 ^item-type predicate)
(@402016 ^property @402000 ^handle kinect1 ^item-type predicate)
(@402017 ^property @404000 ^handle trash1 ^item-type predicate)
(@402018 ^property @402000 ^handle line1 ^item-type predicate)
(@402019 ^multiple true ^property @402000 ^handle triangle1 ^item-type predicate)
(@402020 ^property @402000 ^handle stapler1 ^item-type predicate)
(@402021 ^property @402000 ^handle book1 ^item-type predicate)
(@402022 ^property @402000 ^handle water1 ^item-type predicate)
(@402023 ^property @402000 ^handle juice1 ^item-type predicate)
(@402024 ^property @402000 ^handle milk1 ^item-type predicate)
(@402025 ^property @402000 ^handle cupboard1 ^item-type predicate)
(@402026 ^property @402000 ^handle table1 ^item-type predicate)
(@402027 ^property @402000 ^handle bread1 ^item-type predicate)
(@402028 ^property @402000 ^handle tissues1 ^item-type predicate)
(@403000 ^type visual ^handle size ^item-type property)
(@404002 ^property @404000 ^handle garbage ^item-type predicate)
(@404003 ^property @404000 ^handle table ^item-type predicate)
(@404009 ^property @404000 ^handle grid-orange)
(@403004 ^property @403000 ^handle tiny1 ^item-type predicate)
(@403005 ^property @403000 ^handle giant1 ^item-type predicate)
(@404000 ^type visual ^handle name ^item-type property)
(@404010 ^property @404000 ^handle grid-yellow)
(@404011 ^property @404000 ^handle grid-green)
(@404012 ^property @404000 ^handle grid-blue)
(@404005 ^property @404000 ^handle dishwasher ^item-type predicate)
(@404006 ^property @404000 ^handle scale ^item-type predicate)
(@404007 ^property @404000 ^handle thermometer ^item-type predicate)
(@404008 ^property @404000 ^handle grid-red)
(@404013 ^property @404000 ^handle goal ^item-type predicate)
(@404014 ^property @404000 ^handle home ^item-type predicate)
(@404015 ^property @404000 ^handle bin-1)
(@404016 ^property @404000 ^handle bin-2)
(@406005 ^property @406000 ^handle hottest1)
(@406006 ^property @406000 ^handle coldest1)
(@404017 ^property @404000 ^handle bin-3)
(@405001 ^property @405000 ^handle heavy1 ^item-type predicate)
(@404018 ^property @404000 ^handle bin-4)
(@404019 ^property @404000 ^handle bin-5)
(@404020 ^property @404000 ^handle bin-6)
(@404023 ^property @404000 ^handle stove)
(@404024 ^property @404000 ^handle answer ^item-type predicate)
(@404025 ^property @404000 ^handle soar1 ^item-type predicate)
(@404026 ^property @404000 ^handle april1 ^item-type predicate)
(@404027 ^property @404000 ^handle main1 ^item-type predicate)
(@404028 ^property @404000 ^handle conference1 ^item-type predicate)
(@404029 ^property @404000 ^handle kitchen1 ^item-type predicate)
(@404030 ^property @404000 ^handle copy1 ^item-type predicate)
(@404032 ^property @404000 ^handle corner1 ^item-type predicate)
(@404033 ^property @404000 ^handle atrium1 ^item-type predicate)
(@404040 ^property @404000 ^handle alice1 ^item-type predicate)
(@404041 ^property @404000 ^handle bob1 ^item-type predicate)
(@404042 ^property @404000 ^handle charlie1 ^item-type predicate)
(@404043 ^property @404000 ^handle fridge1 ^item-type predicate)
(@404044 ^property @404000 ^handle faucet1 ^item-type predicate)
(@404045 ^property @404000 ^handle water1 ^item-type predicate)
(@404046 ^property @404000 ^handle cup1 ^item-type predicate)
(@404047 ^property @404000 ^handle dealer ^item-type predicate)
(@404048 ^property @404000 ^handle player ^item-type predicate)
(@404049 ^property @404000 ^handle deck ^item-type predicate)
(@405000 ^type measurable ^handle weight ^item-type property)
(@405002 ^property @405000 ^handle light1 ^item-type predicate)
(@406001 ^property @406000 ^handle hot1)
(@405003 ^property @405000 ^handle heaviest1 ^item-type predicate)
(@405004 ^property @405000 ^handle lightest1 ^item-type predicate)
(@406000 ^type measurable ^handle temperature ^item-type property)
(@406002 ^property @406000 ^handle warm1)
(@406004 ^property @406000 ^handle cold1)
(@406003 ^property @406000 ^handle cool1)
(@407000 ^type visual ^handle category ^item-type property)
(@407002 ^property @407000 ^handle location)
(@407003 ^property @407000 ^handle object ^subcategory @407001 @407002 @407006 @407008)
(@408002 ^property @408000 ^handle east1 ^item-type concept ^yaw 0.000000)
(@408003 ^property @408000 ^handle south1 ^item-type concept ^yaw -1.507000)
(@409001 ^property @409000 ^handle right1 ^item-type concept ^side -1 ^yaw -1.570000)
(@409002 ^property @409000 ^handle left1 ^item-type concept ^side 1 ^yaw 1.570000)
(@407001 ^property @407000 ^handle block)
(@407004 ^multiple true ^property @407000 ^handle block)
(@407014 ^property @407000 ^handle person)
(@407005 ^multiple true ^property @407000 ^handle location)
(@407006 ^property @407000 ^handle piece)
(@407007 ^multiple true ^property @407000 ^handle piece)
(@407010 ^property @407000 ^handle tile)
(@407011 ^multiple true ^property @407000 ^handle tile)
(@407012 ^property @407000 ^handle message)
(@407015 ^property @407000 ^handle question)
(@408001 ^property @408000 ^handle north1 ^item-type concept ^yaw 1.507000)
(@408000 ^handle cardinal-direction1 ^item-type property)
(@409003 ^property @409000 ^handle around1 ^item-type concept ^side -1 ^yaw 3.140000)
(@501005 ^relation @90 @91 @92 ^handle below1 ^item-type relation ^relation-type existing)
(@501035 ^handle linear ^item-type relation ^relation-type existing)
(@408004 ^property @408000 ^handle west1 ^item-type concept ^yaw 3.140000)
(@409000 ^handle relative-direction1 ^item-type property)
(@501009 ^handle aligned-with1 ^item-type relation ^relation-type existing)
(@501010 ^handle under1 ^item-type relation ^relation-type existing)
(@501011 ^relation @93 @94 @95 ^handle near1 ^item-type relation ^relation-type existing)
(@501000 ^relation @87 @88 @89 ^handle on1 ^item-type relation ^relation-type existing)
(@501001 ^relation @72 @73 @74 ^handle in1 ^item-type relation ^reference-frame global ^relation-type existing)
(@501008 ^handle next-to1 ^item-type relation ^relation-type existing)
(@501002 ^relation @75 @76 @77 ^handle right-of1 ^item-type relation ^reference-frame local ^relation-type existing)
(@501003 ^relation @78 @79 @80 ^handle left-of1 ^item-type relation ^reference-frame local ^relation-type existing)
(@501004 ^handle above1 ^item-type relation ^relation-type existing)
(@501007 ^handle linear-with1 ^item-type relation ^relation-type existing)
(@501012 ^relation @96 @97 @98 ^handle diagonal-with1 ^item-type relation ^relation-type existing)
(@501014 ^relation @81 @82 @83 ^handle behind1 ^item-type relation ^reference-frame local ^relation-type existing)
(@501024 ^handle greater-than1)
(@501025 ^handle more-than1)
(@501028 ^handle worse)
(@501027 ^handle owned-by-you1)
(@501026 ^handle less-than1)
(@501013 ^handle diagonal-from1 ^item-type relation ^relation-type existing)
(@501018 ^handle adjacent ^item-type relation ^relation-type existing)
(@501021 ^handle named)
(@501019 ^handle equal)
(@501016 ^relation @84 @85 @86 ^handle infront1 ^item-type relation ^reference-frame local ^relation-type existing)
(@501017 ^handle holding1 ^item-type relation ^relation-type desired)
(@501022 ^handle between ^item-type relation ^relation-type existing)
(@501023 ^handle as)
(@501029 ^handle better)
(@501030 ^handle over)
(@501031 ^handle to1 ^item-type relation ^relation-type desired ^spatial-relation @501001)
(@999025 ^spelling full ^referent @999026 ^structure-type ADJ)
(@999026 ^property @999027 ^handle full)
(@999027 ^type visual ^handle property)
(@999028 ^spelling enemy ^referent @999029 ^structure-type ADJ)
(@501032 ^handle from1 ^item-type relation ^relation-type existing ^spatial-relation @501001)
(@999003 ^spelling former ^referent @999004 ^structure-type ADJ ^attachment immediate)
(@501033 ^handle by1)
(@501034 ^handle heard2 ^item-type relation ^relation-type desired)
(@501038 ^type temporal-relation ^handle during1)
(@609000 ^structure-type P ^converts-to PP ^assigners @999402 ^relation-type binary)
(@609001 ^structure-type P ^converts-to PP ^assigners @999403 @999404 @999405 ^relation-type ternary)
(@609002 ^structure-type P ^converts-to PP ^assigners @999406 @999407 ^relation-type binary)
(@991001 ^structure-type D ^converts-to DP ^assigners @999188 @999189 @999190 @999191 ^super-converts-to CP)
(@999002 ^type grammatical ^handle grammatical-property)
(@991050 ^structure-type POS ^converts-to DP ^assigners @1000113 @1000114 @1000115 @1000116 ^super-converts-to CP)
(@999000 ^spelling latter ^referent @999001 ^structure-type ADJ ^attachment immediate)
(@999001 ^property @999002 ^handle latter)
(@999005 ^spelling red ^referent @401001 ^structure-type ADJ ^attachment immediate)
(@999006 ^spelling orange ^referent @401002 ^structure-type ADJ ^attachment immediate)
(@999004 ^property @999002 ^handle former)
(@999024 ^property @999022 ^handle absent)
(@999007 ^spelling yellow ^referent @401003 ^structure-type ADJ ^attachment immediate)
(@999013 ^spelling brown ^referent @401009 ^structure-type ADJ)
(@999008 ^spelling green ^referent @401004 ^structure-type ADJ ^attachment immediate)
(@999009 ^spelling blue ^referent @401005 ^structure-type ADJ ^attachment immediate)
(@999010 ^spelling purple ^referent @401006 ^structure-type ADJ ^attachment immediate)
(@999011 ^spelling white ^referent @401007 ^structure-type ADJ ^attachment immediate)
(@999012 ^spelling black ^referent @401008 ^structure-type ADJ)
(@999014 ^spelling gray ^referent @401010 ^structure-type ADJ)
(@999015 ^spelling small ^referent @403001 ^structure-type ADJ ^attachment immediate)
(@999019 ^spelling large ^referent @403003 ^structure-type ADJ ^attachment immediate)
(@999016 ^spelling tiny ^referent @403004 ^structure-type ADJ ^attachment immediate)
(@999017 ^spelling little ^referent @403001 ^structure-type ADJ ^attachment immediate)
(@999018 ^spelling medium ^referent @403002 ^structure-type ADJ ^attachment immediate)
(@999023 ^spelling absent ^referent @999024 ^structure-type ADJ)
(@999020 ^spelling giant ^referent @403005 ^structure-type ADJ ^attachment immediate)
(@999021 ^spelling big ^referent @403003 ^structure-type ADJ ^attachment immediate)
(@999022 ^type visual ^handle property)
(@999029 ^property @999022 ^handle enemy)
(@999030 ^spelling destination ^referent @999031 ^structure-type ADJ ^attachment immediate)
(@999032 ^spelling linear ^referent @999033 ^structure-type ADJ ^attachment immediate)
(@999044 ^spelling initial ^referent @999043 ^structure-type ADJ ^attachment immediate)
(@999101 ^handle upwards)
(@999103 ^handle down1)
(@999104 ^spelling forward ^referent @999105 ^structure-type ADV)
(@999102 ^spelling down ^referent @999103 ^structure-type ADV)
(@999031 ^property @404000 ^handle destination1 ^item-type predicate)
(@999034 ^spelling moved ^referent @999035 ^structure-type ADJ)
(@999033 ^property @999022 ^handle linear)
(@999035 ^property @999022 ^handle moved)
(@999036 ^spelling visible ^referent @999037 ^structure-type ADJ ^attachment immediate)
(@999038 ^spelling storage ^referent @999058 @4015006 ^structure-type ADJ ^attachment immediate)
(@999037 ^property @999022 ^handle visible)
(@999041 ^spelling other ^referent @999042 ^structure-type ADJ ^attachment immediate)
(@999039 ^spelling usual ^referent @999040 ^structure-type ADJ ^attachment immediate)
(@999040 ^property @999022 ^handle usual)
(@999043 ^property @999022 ^handle initial)
(@999042 ^property @999022 ^handle other)
(@999047 ^spelling last last-moved ^referent @999048 @4014302 ^structure-type ADJ ^attachment immediate)
(@999059 ^spelling starting ^referent @4015001 ^structure-type ADJ ^attachment immediate)
(@999045 ^spelling final ^referent @999046 ^structure-type ADJ ^attachment immediate)
(@999046 ^property @999022 ^handle final)
(@999051 ^spelling same ^referent @999052 ^structure-type ADJ ^attachment immediate)
(@999048 ^property @999022 ^handle last)
(@999049 ^spelling original ^referent @999050 ^structure-type ADJ ^attachment immediate)
(@999050 ^property @999002 ^handle original)
(@999053 ^spelling no ^referent @999054 ^structure-type ADJ ^attachment immediate)
(@999052 ^property @999022 ^handle same)
(@999055 ^spelling closed ^referent @4014202 ^structure-type ADJ)
(@999054 ^property @999022 ^handle same)
(@999056 ^spelling closed ^referent @999057 ^structure-type ADJ ^attachment immediate)
(@999058 ^property @999022 ^handle storage1)
(@999057 ^property @999022 ^handle closed)
(@999063 ^spelling open ^referent @4014201 ^structure-type ADJ)
(@999064 ^spelling wild ^referent @999065 ^structure-type ADJ ^attachment immediate)
(@999060 ^spelling desired ^referent @4015004 ^structure-type ADJ ^attachment immediate)
(@999061 ^spelling cooked ^referent @4014101 ^structure-type ADJ ^attachment immediate)
(@999062 ^spelling raw ^referent @4014102 ^structure-type ADJ)
(@999066 ^spelling conference ^referent @4013012 ^structure-type ADJ ^attachment immediate)
(@999075 ^spelling turned-on ^referent @4014001 ^structure-type ADJ ^prior-word turned ^current-word on ^attachment immediate ^consumes-prior-word true)
(@999065 ^property @404000 ^handle wild)
(@999070 ^spelling main ^referent @4013009 ^structure-type ADJ ^attachment immediate)
(@999067 ^spelling soar ^referent @4013007 ^structure-type ADJ ^attachment immediate)
(@999068 ^spelling robotics ^referent @4013014 ^structure-type ADJ ^attachment immediate)
(@999069 ^spelling april ^referent @4013008 ^structure-type ADJ ^attachment immediate)
(@999074 ^spelling off ^referent @4014002 ^structure-type ADJ ^attachment immediate)
(@999071 ^spelling copy ^referent @4013010 ^structure-type ADJ ^attachment immediate)
(@999072 ^spelling turned ^structure-type V ^can-be-part-of turned-on ^tense past)
(@999073 ^spelling turned-off ^referent @4014002 ^structure-type ADJ ^prior-word turned ^current-word off ^attachment immediate ^consumes-prior-word true)
(@999076 ^referent @4014001 ^structure-type ADJ ^alternative-structure P ^attachment immediate)
(@999077 ^spelling lit ^referent @4014001 ^structure-type ADJ ^attachment immediate)
(@999080 ^spelling hot ^referent @406001 ^structure-type ADJ ^attachment immediate)
(@999100 ^spelling up ^referent @999101 ^structure-type ADV)
(@999078 ^spelling next ^referent @999079 ^structure-type ADJ ^prior-word D ^attachment immediate)
(@999079 ^handle next1)
(@999125 ^structure-type VP ^syntactic-structure predicate ^required true ^semantic-structure *copy*)
(@999088 ^spelling heaviest ^referent @405003 ^structure-type ADJ ^attachment immediate)
(@999081 ^spelling warm ^referent @406002 ^structure-type ADJ ^attachment immediate)
(@999082 ^spelling cool ^referent @406003 ^structure-type ADJ ^attachment immediate)
(@999083 ^spelling cold ^referent @406004 ^structure-type ADJ ^attachment immediate)
(@999084 ^spelling hottest ^referent @406005 ^structure-type ADJ ^attachment immediate)
(@999085 ^spelling coldest ^referent @406006 ^structure-type ADJ ^attachment immediate)
(@999086 ^spelling heavy ^referent @405001 ^structure-type ADJ ^attachment immediate)
(@999087 ^spelling light ^referent @405002 ^structure-type ADJ ^attachment immediate)
(@999091 ^spelling southern ^referent @408003 ^structure-type ADJ)
(@999089 ^spelling lightest ^referent @405004 ^structure-type ADJ ^attachment immediate)
(@999090 ^spelling northern ^referent @408001 ^structure-type ADJ)
(@999092 ^spelling eastern ^referent @408002 ^structure-type ADJ)
(@999093 ^spelling western ^referent @408004 ^structure-type ADJ)
(@999094 ^spelling done ^referent @4015001 ^structure-type ADJ)
(@999096 ^spelling won ^referent @4015002 ^structure-type ADJ)
(@999095 ^spelling finished ^referent @4015001 ^structure-type ADJ)
(@999097 ^spelling lost ^referent @4015003 ^structure-type ADJ)
(@999098 ^spelling not ^referent @999099 ^structure-type ADV)
(@999099 ^handle negation ^modifier true)
(@999105 ^handle forward)
(@999107 ^handle backward)
(@999109 ^handle around)
(@999110 ^spelling carefully ^referent @999111 ^structure-type ADV)
(@999111 ^handle careful1)
(@999112 ^spelling slowly ^referent @999113 ^structure-type ADV)
(@999108 ^spelling around ^referent @999109 ^structure-type ADV)
(@999106 ^spelling backward ^referent @999107 ^structure-type ADV)
(@999113 ^handle slow1)
(@999114 ^spelling away ^referent @999115 ^structure-type ADV)
(@999115 ^handle away1)
(@999116 ^spelling previously ^referent @999117 ^structure-type ADV)
(@999117 ^handle previously ^modifier true)
(@999118 ^structure-type S ^prior-word CP ^current-word T ^assigners @999119 @999120 ^construction CP-T ^prior-word-first true false)
(@999129 ^message-type object-definition ^structure-type S ^prior-word DP ^current-word T ^assigners @999130 @999131 ^construction *-DP-T ^prior-word-first true)
(@999194 ^spelling were ^structure-type IS-V ^number plural ^tense past)
(@999196 ^spelling game ^referent @999197 ^structure-type N ^syntactic-referent-type DP ^number singular ^object-feature handle)
(@999198 ^spelling time ^referent @999199 ^structure-type N ^syntactic-referent-type DP ^number singular ^object-feature handle)
(@999213 ^property @999195 ^handle goal)
(@999120 ^after @999119 ^structure-type T ^syntactic-structure terminator ^required true)
(@999119 ^structure-type CP ^syntactic-structure sentence ^required true ^semantic-structure *copy*)
(@999131 ^after @999130 ^structure-type T ^syntactic-structure terminator ^required true)
(@999121 ^message-type command ^structure-type S ^prior-word VP ^current-word T ^assigners @999122 @999123 ^construction *-VP-T ^prior-word-first true)
(@999122 ^structure-type VP ^syntactic-structure predicate ^required true ^semantic-structure *copy*)
(@999123 ^after @999122 ^structure-type T ^syntactic-structure terminator ^required true)
(@999124 ^message-type command ^structure-type C ^converts-to CP ^prior-word VP ^current-word T ^assigners @999125 ^construction VP-T ^prior-word-first false)
(@999126 ^message-type command ^structure-type CP ^prior-word ROSIE ^current-word V ^assigners @999127 @999128 ^construction *-Rosie-VP ^prior-word-first true)
(@999127 ^before @999128 ^structure-type ROSIE ^syntactic-structure head ^required true ^semantic-structure agent)
(@999128 ^structure-type VP ^syntactic-structure predicate ^required true ^semantic-structure *copy*)
(@999134 ^after @999133 ^structure-type VP ^syntactic-structure predicate ^required true ^semantic-structure action)
(@999130 ^structure-type DP ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999132 ^message-type object-action ^structure-type CP ^prior-word DP ^current-word V ^assigners @999133 @999134 ^construction *-DP-VP ^prior-word-first true)
(@999133 ^before @999134 ^structure-type DP ^relative-position before ^syntactic-structure head ^required true ^semantic-structure agent)
(@999135 ^message-type object-action ^structure-type CP ^prior-word PN ^current-word V ^assigners @999136 @999137 ^construction *-PN-VP ^prior-word-first true)
(@999136 ^before @999137 ^structure-type NP ^relative-position after ^syntactic-structure head ^required true ^semantic-structure agent)
(@999137 ^after @999136 ^structure-type VP ^syntactic-structure predicate ^required true ^semantic-structure action)
(@999138 ^structure-type C ^converts-to CP ^prior-word DP ^current-word V ^assigners @999139 @999140 ^construction DP-VP ^prior-word-first false)
(@999141 ^message-type command ^structure-type S ^prior-word VPING ^current-word T ^assigners @999142 @999143 @999144 ^construction *-MV-VPING-T ^prior-word-first false)
(@999139 ^before @999140 ^structure-type DP ^syntactic-structure head ^required true ^semantic-structure agent)
(@999140 ^structure-type VP ^syntactic-structure predicate ^required true ^semantic-structure *copy*)
(@999144 ^after @999142 @999143 ^structure-type T ^syntactic-structure terminator ^required true)
(@999150 ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier ^optional true)
(@999142 ^structure-type MV ^syntactic-structure action ^required true ^semantic-structure *copy*)
(@999143 ^after @999142 ^structure-type VPING ^syntactic-structure nil ^required true ^semantic-structure *embed* ^embed-structure vping-clause)
(@999145 ^spelling stop ^referent @101209 ^structure-type MV ^number singular ^semantic-structure action ^tense present)
(@999148 ^op_name initiate-start1)
(@999149 ^op_name follow)
(@999146 ^handle start1 ^item-type action ^procedural @999148)
(@999147 ^spelling start ^referent @999146 ^structure-type MV ^number singular ^semantic-structure action ^tense present)
(@999152 ^after @999151 ^structure-type CONJP ^syntactic-structure predicate ^copy-structure arg1 ^semantic-structure *copy* ^optional true ^repeatable true)
(@999156 ^spelling following ^referent @999149 ^structure-type VING ^converts-to VPING ^assigners @999150 @999151 @999152 @999153 @999154 @999155 ^number singular ^semantic-structure action ^tense present)
(@999151 ^before @999152 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999155 ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier ^optional true)
(@999153 ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier ^optional true)
(@999154 ^structure-type PP ^relative-position after ^syntactic-structure complement2 ^semantic-structure arg2 ^optional true)
(@999159 ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier ^optional true)
(@999160 ^before @999161 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999157 ^spelling leading ^referent @999158 ^structure-type VING ^converts-to VPING ^assigners @999159 @999160 @999161 @999162 @999163 @999164 ^number singular ^semantic-structure action ^tense present)
(@999221 ^spelling relationship ^referent @999219 ^structure-type N ^syntactic-referent-type P ^number singular)
(@999162 ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier ^optional true)
(@999158 ^op_name lead)
(@999161 ^after @999160 ^structure-type CONJP ^syntactic-structure predicate ^copy-structure arg1 ^semantic-structure *copy* ^optional true ^repeatable true)
(@999193 ^spelling was ^structure-type IS-V ^number singular ^tense past)
(@999165 ^message-type for-construct ^structure-type CP ^prior-word * ^current-word for ^assigners @999166 @999167 @999168 @999169 ^construction *-for-DP-semicolon-VP)
(@999163 ^structure-type PP ^relative-position after ^syntactic-structure complement2 ^semantic-structure arg2 ^optional true)
(@999164 ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier ^optional true)
(@999167 ^before @999168 @999169 ^structure-type SEMICOLON ^syntactic-structure nil ^required true)
(@999166 ^before @999167 @999168 @999169 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true ^semantic-structure for-condition)
(@999168 ^before @999169 ^structure-type VP ^syntactic-structure predicate ^required true ^semantic-structure *embed* ^embed-structure for-action-subclause)
(@999169 ^before @999170 ^structure-type THEN ^syntactic-structure nil ^optional true)
(@999170 ^structure-type CP ^syntactic-structure nil ^semantic-structure *embed* ^optional true ^embed-structure for-action-then-subclause)
(@999173 ^before @999174 ^structure-type SEMICOLON ^syntactic-structure nil ^required true)
(@999171 ^message-type while-construct ^structure-type CP ^prior-word * ^current-word while ^assigners @999172 @999173 @999174 ^construction *-while-CP-semicolon-VP)
(@999172 ^before @999173 @999174 ^structure-type CP ^relative-position after ^syntactic-structure head ^required true ^semantic-structure *embed* ^embed-structure while-condition-subclause)
(@999175 ^message-type otherwise-construct ^structure-type CP ^prior-word * ^current-word otherwise ^assigners @999176 @999177 ^construction *-otherwise-colon-VP)
(@999174 ^structure-type VP ^syntactic-structure predicate ^required true ^semantic-structure *embed* ^embed-structure while-action-subclause)
(@999179 ^spelling my ^specifier definite ^number singular ^super-type @991001 ^possessive true)
(@999176 ^before @999177 ^structure-type SEMICOLON ^syntactic-structure nil ^required true)
(@999177 ^structure-type VP ^syntactic-structure predicate ^required true ^semantic-structure *embed* ^embed-structure otherwise-action-subclause)
(@999178 ^spelling your ^referent @501027 ^specifier definite ^number singular ^super-type @991001 ^possessive true)
(@999181 ^spelling |and that| ^specifier definite ^prior-word and ^current-word that ^number singular ^super-type @991001 ^attachment immediate ^consumes-prior-word false ^demonstrative true)
(@999180 ^spelling these ^specifier definite ^number plural ^super-type @991001)
(@999182 ^spelling those ^specifier definite ^number plural ^super-type @991001)
(@999183 ^spelling their ^specifier definite ^number plural ^super-type @991001 ^possessive true)
(@999184 ^spelling a ^specifier indefinite ^number singular ^super-type @991001)
(@999185 ^spelling an ^specifier indefinite ^number singular ^super-type @991001)
(@999186 ^spelling any ^specifier indefinite ^number singular ^super-type @991001)
(@999187 ^spelling another ^specifier indefinite distinct ^number singular ^super-type @991001)
(@999188 ^before @999189 ^structure-type PP ^relative-position after ^syntactic-structure complement ^optional true)
(@999192 ^spelling are ^structure-type IS-V ^number plural ^tense present)
(@999189 ^structure-type RCP ^relative-position after ^syntactic-structure complement ^optional true)
(@999190 ^before @999188 @999189 @999191 ^structure-type ADJ ^relative-position after ^syntactic-structure adjoin ^optional true ^repeatable true)
(@999191 ^before @999188 @999189 ^structure-type N ^relative-position after ^syntactic-structure head ^required true)
(@999203 ^spelling task ^referent @999202 ^structure-type N ^syntactic-referent-type DP ^number singular ^object-feature handle)
(@999205 ^spelling tour ^referent @999204 ^structure-type N ^syntactic-referent-type DP ^number singular ^object-feature handle)
(@999202 ^property @999195 ^handle task1)
(@999195 ^type conceptual ^handle concept)
(@999200 ^property @999195 ^handle puzzle1)
(@999197 ^property @999195 ^handle game1)
(@999201 ^spelling puzzle ^referent @999200 ^structure-type N ^syntactic-referent-type DP ^number singular ^object-feature handle)
(@999199 ^property @999195 ^handle time)
(@999210 ^property @999195 ^handle letter1)
(@999211 ^spelling letter ^referent @999210 ^structure-type N ^syntactic-referent-type CN ^number singular)
(@999219 ^property @999195 ^handle relation)
(@999220 ^spelling relation ^referent @999219 ^structure-type N ^syntactic-referent-type P ^number singular)
(@999209 ^spelling number ^referent @999208 ^structure-type N ^syntactic-referent-type CN ^number singular ^object-feature number)
(@999204 ^property @999195 ^handle tour1)
(@999208 ^property @999195 ^handle number1)
(@999206 ^spelling name ^referent @999207 ^structure-type N ^syntactic-referent-type N ^number singular ^object-feature handle)
(@999207 ^property @999195 ^handle name1)
(@999223 ^spelling color ^referent @999222 ^structure-type N ^syntactic-referent-type ADJ ^number singular)
(@999214 ^spelling failure ^referent @999215 ^structure-type N ^syntactic-referent-type DP ^number singular ^object-feature handle)
(@999212 ^spelling goal ^referent @999213 ^structure-type N ^syntactic-referent-type DP ^number singular ^object-feature handle)
(@999216 ^spelling action ^referent @999217 ^structure-type N ^syntactic-referent-type V ^number singular ^object-feature handle)
(@999215 ^property @999195 ^handle failure)
(@999218 ^type action ^handle action)
(@999217 ^property @999218 ^handle action)
(@999233 ^spelling column ^referent @999232 ^structure-type N ^syntactic-referent-type N ^number singular)
(@999403 ^before @999404 @999405 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true)
(@999407 ^structure-type ANY ^relative-position after ^syntactic-structure head ^exclusive @999406 ^optional true ^strip-assigners true)
(@999411 ^handle during1)
(@999222 ^property @999195 ^handle color)
(@999226 ^spelling volume ^referent @999227 ^structure-type N ^syntactic-referent-type ADJ ^number singular)
(@999224 ^spelling last-name ^referent @999225 ^structure-type N ^syntactic-referent-type ADJ ^number singular)
(@999225 ^property @999195 ^handle last-name)
(@999230 ^spelling sum ^referent @999231 ^structure-type N ^syntactic-referent-type N ^number singular)
(@999227 ^property @999195 ^handle volume)
(@999228 ^property @999195 ^handle value)
(@999229 ^spelling value ^referent @999228 ^structure-type N ^syntactic-referent-type N ^number singular)
(@999232 ^property @999195 ^handle column)
(@999231 ^property @999195 ^handle sum)
(@999236 ^property @999195 ^handle section)
(@999234 ^property @999195 ^handle row)
(@999235 ^spelling row ^referent @999234 ^structure-type N ^syntactic-referent-type N ^number singular)
(@999237 ^spelling section ^referent @999236 ^structure-type N ^syntactic-referent-type N ^number singular)
(@999241 ^spelling shape ^referent @999240 ^structure-type N ^syntactic-referent-type N ^number singular)
(@999238 ^spelling location ^referent @407002 ^structure-type N ^syntactic-referent-type DP ^number singular)
(@999239 ^spelling locations ^referent @407005 ^structure-type N ^syntactic-referent-type DP ^number plural)
(@999240 ^property @999195 ^handle shape)
(@999243 ^spelling size ^referent @999242 ^structure-type N ^syntactic-referent-type ADJ ^number singular)
(@999242 ^property @999195 ^handle size)
(@999245 ^spelling question ^referent @407015 ^structure-type N ^number singular)
(@999244 ^spelling answer ^referent @4015003 ^structure-type N ^number singular)
(@999246 ^spelling response ^referent @999247 ^structure-type N ^syntactic-referent-type N ^number singular ^object-feature handle)
(@999248 ^spelling message ^referent @407012 ^structure-type N ^number singular)
(@999247 ^property @999195 ^handle response)
(@999249 ^spelling steps ^referent @999250 ^structure-type N ^syntactic-referent-type N ^number plural ^object-feature handle)
(@999252 ^spelling state ^referent @999251 ^structure-type N ^number singular)
(@999250 ^multiple true ^property @402000 ^handle steps1 ^item-type object)
(@999251 ^property @404000 ^handle state1 ^item-type object)
(@999253 ^spelling drink ^referent @407003 ^structure-type N ^number singular)
(@999321 ^spelling table ^referent @404003 ^structure-type N ^number singular)
(@999254 ^property @402000 ^handle soldier1 ^item-type object)
(@999255 ^spelling soldier ^referent @999254 ^structure-type N ^number singular)
(@999257 ^property @402000 ^handle man1 ^item-type object)
(@999256 ^spelling man ^referent @999257 ^structure-type N ^number singular)
(@999258 ^spelling woman ^referent @999259 ^structure-type N ^number singular)
(@999260 ^property @402000 ^handle adult1 ^item-type object)
(@999259 ^property @402000 ^handle woman1 ^item-type object)
(@999261 ^spelling adult ^referent @999260 ^structure-type N ^number singular)
(@999262 ^spelling solution ^referent @999263 ^structure-type N ^number singular)
(@999263 ^property @407000 ^handle solution1 ^item-type object)
(@999264 ^spelling child ^referent @999265 ^structure-type N ^number singular)
(@999265 ^property @402000 ^handle child1 ^item-type object)
(@999266 ^multiple true ^spelling missionaries ^referent @999267 ^structure-type N ^number plural)
(@999267 ^multiple true ^property @402000 ^handle missionary1 ^item-type object)
(@999269 ^spelling missionary ^referent @999268 ^structure-type N ^number singular)
(@999268 ^property @402000 ^handle missionary1 ^item-type object ^number singular)
(@999270 ^spelling cannibals ^referent @999271 ^structure-type N ^number plural)
(@999271 ^multiple true ^property @402000 ^handle cannibal1 ^item-type object)
(@999272 ^spelling cannibal ^referent @999273 ^structure-type N ^number singular)
(@999273 ^property @402000 ^handle cannibal1 ^item-type object ^number singular)
(@999274 ^spelling boat ^referent @999275 ^structure-type N ^number singular)
(@999275 ^property @402000 ^handle boat1 ^item-type object)
(@999276 ^spelling river ^referent @999277 ^structure-type N ^number singular)
(@999278 ^spelling side ^referent @999279 ^structure-type N ^number singular)
(@999277 ^property @402000 ^handle river1 ^item-type object)
(@999279 ^property @402000 ^handle side1 ^item-type object)
(@999280 ^spelling bank ^referent @999281 ^structure-type N ^number singular)
(@999282 ^spelling rank ^referent @999283 ^structure-type N ^number singular)
(@999281 ^property @402000 ^handle bank1 ^item-type object)
(@999284 ^spelling suit ^referent @999285 ^structure-type N ^number singular)
(@999283 ^property @999195 ^handle rank1)
(@999285 ^property @999195 ^handle suit)
(@999286 ^spelling opponent ^referent @999287 ^structure-type N ^number singular)
(@999287 ^property @402000 ^handle opponent1 ^item-type object)
(@999288 ^property @402000 ^handle people1 ^item-type object)
(@999289 ^spelling people ^referent @999288 ^structure-type N ^number singular)
(@999290 ^spelling person ^referent @999291 ^structure-type N ^number singular)
(@999291 ^property @402000 ^handle person1 ^item-type object)
(@999292 ^spelling dealer ^referent @404047 ^structure-type N ^number singular)
(@999293 ^spelling player ^referent @404048 ^structure-type N ^number singular)
(@999294 ^spelling deck ^referent @404049 ^structure-type N ^number singular)
(@999295 ^spelling rectangle ^referent @402008 ^structure-type N ^number signular)
(@999296 ^spelling triangle ^referent @402001 ^structure-type N ^number singular)
(@999297 ^spelling triangles ^referent @402019 ^structure-type N ^number plural)
(@999298 ^spelling arch ^referent @402002 ^structure-type N ^number signular)
(@999299 ^spelling square ^referent @402003 ^structure-type N ^number signular)
(@999300 ^spelling line ^referent @402018 ^structure-type N ^number singular)
(@999301 ^spelling block ^referent @407001 ^structure-type N ^number singular)
(@999302 ^spelling object ^referent @407003 ^structure-type N ^number singular)
(@999303 ^spelling blocks ^referent @407004 ^structure-type N ^number plural)
(@999304 ^spelling l-block ^referent @402004 ^structure-type N ^number singular)
(@999305 ^property P2000 ^spelling t-block ^referent @402005 ^structure-type N ^number singular)
(@999306 ^spelling sphere ^referent @402006 ^structure-type N ^number singular)
(@999307 ^spelling tile ^referent @407010 ^structure-type N ^number singular)
(@999308 ^spelling tiles ^referent @407011 ^structure-type N ^number plural)
(@999309 ^spelling piece ^referent @407006 ^structure-type N ^number singular)
(@999310 ^spelling pieces ^referent @407007 ^structure-type N ^number plural)
(@999311 ^spelling card ^referent @999312 ^structure-type N ^number singular)
(@999312 ^property @402000 ^handle card ^item-type object)
(@999313 ^spelling hand ^referent @999314 ^structure-type N ^number singular)
(@999314 ^property @402000 ^handle hand ^item-type object)
(@999315 ^spelling fridge ^referent @404043 ^structure-type N ^number singular)
(@999316 ^spelling stove ^referent @404023 ^structure-type N ^number singular ^on-off-state-change true)
(@999317 ^spelling faucet ^referent @404044 ^structure-type N ^number singular ^on-off-state-change true)
(@999318 ^spelling cup ^referent @404046 ^structure-type N ^number singular ^on-off-state-change true)
(@999319 ^spelling pantry ^referent @404001 ^structure-type N ^number singular)
(@999320 ^spelling garbage ^referent @404002 ^structure-type N ^number singular)
(@999323 ^spelling kitchen ^referent @4013001 ^structure-type N ^number singular)
(@999345 ^spelling sodas ^referent @402010 ^structure-type N ^number plural)
(@999322 ^spelling cupboard ^referent @402025 ^structure-type N ^number singular)
(@999324 ^spelling office ^referent @4012011 ^structure-type N ^number singular)
(@999325 ^spelling lab ^referent @4013013 ^structure-type N ^number singular)
(@999326 ^spelling bedroom ^referent @4013003 ^structure-type N ^number singular)
(@999327 ^spelling bathroom ^referent @4013004 ^structure-type N ^number singular)
(@999328 ^spelling atrium ^referent @404033 ^structure-type N ^number singular)
(@999329 ^spelling laundry ^referent @4013005 ^structure-type N ^number singular)
(@999330 ^spelling wp47 ^referent @4013047 ^structure-type N ^number singular)
(@999331 ^spelling wp48 ^referent @4013048 ^structure-type N ^number singular)
(@999332 ^spelling wp49 ^referent @4013049 ^structure-type N ^number singular)
(@999333 ^spelling wp50 ^referent @4013050 ^structure-type N ^number singular)
(@999334 ^spelling wp51 ^referent @4013051 ^structure-type N ^number singular)
(@999335 ^spelling wp52 ^referent @4013052 ^structure-type N ^number singular)
(@999336 ^spelling wp53 ^referent @4013053 ^structure-type N ^number singular)
(@999337 ^spelling chicken ^referent @402007 ^structure-type N ^number singular)
(@999339 ^spelling lights ^referent @402013 ^structure-type N ^number singular ^on-off-state-change true)
(@999338 ^spelling steak ^referent @402012 ^structure-type N ^number singular)
(@999342 ^spelling water ^referent @402022 @404045 ^structure-type N ^syntactic-referent-type DP ^number singular)
(@999340 ^spelling light ^referent @402013 ^structure-type N ^number singular ^on-off-state-change true)
(@999341 ^spelling soda ^referent @402010 ^structure-type N ^number singular)
(@999343 ^spelling juice ^referent @402023 ^structure-type N ^number singular)
(@999344 ^spelling milk ^referent @402024 ^structure-type N ^number singular)
(@999346 ^spelling trash ^referent @402017 ^structure-type N ^number singular)
(@999371 ^spelling minutes ^referent @999370 ^structure-type N ^number plural)
(@999347 ^spelling stapler ^referent @402020 ^structure-type N ^number singular)
(@999348 ^spelling box ^referent @402011 ^structure-type N ^number singular)
(@999349 ^spelling book ^referent @402021 ^structure-type N ^number singular)
(@999350 ^spelling package ^referent @402014 ^structure-type N ^number singular)
(@999351 ^spelling papers ^referent @402015 ^structure-type N ^number plural)
(@999352 ^spelling kinect ^referent @402016 ^structure-type N ^number singular)
(@999353 ^spelling bread ^referent @402027 ^structure-type N ^number singular)
(@999354 ^spelling tissues ^referent @402028 ^structure-type N ^number singular)
(@999355 ^spelling book ^referent @402021 ^structure-type N ^number singular)
(@999357 ^spelling meters ^referent @4010001 ^structure-type N ^number plural)
(@999356 ^spelling meter ^referent @4010001 ^structure-type N ^number singular)
(@999358 ^spelling foot ^referent @4010002 ^structure-type N ^number singular)
(@999359 ^spelling feet ^referent @4010002 ^structure-type N ^number plural)
(@999360 ^spelling inch ^referent @4010003 ^structure-type N ^number singular)
(@999361 ^spelling inches ^referent @4010003 ^structure-type N ^number plural)
(@999363 ^spelling centimeters ^referent @4010004 ^structure-type N ^number plural)
(@999362 ^spelling centimeter ^referent @4010004 ^structure-type N ^number singular)
(@999364 ^relation @999365 ^spelling middle-noun ^structure-type N ^prior-word D ^current-word middle ^number singular ^semantic-structure predicate ^consumes-prior-word false ^semantic-entity-type relation)
(@999366 ^relation @999367 ^spelling front-noun ^structure-type DP ^prior-word P ^current-word front ^number singular ^semantic-structure predicate ^consumes-prior-word false ^semantic-entity-type relation)
(@999365 ^handle middle-of1)
(@999367 ^handle front-of1)
(@999368 ^relation @999369 ^spelling back-noun ^structure-type DP ^prior-word P ^current-word back ^number singular ^semantic-structure predicate ^consumes-prior-word false ^semantic-entity-type relation)
(@999370 ^property @4010000 ^handle minute)
(@999374 ^spelling end ^referent @4012001 ^structure-type N ^number singular)
(@999369 ^handle back-of1)
(@999372 ^spelling minute ^referent @999370 ^structure-type N ^number singular)
(@999385 ^spelling hallway ^referent @4012003 ^structure-type N ^number singular)
(@999373 ^spelling wall ^referent @4012002 ^structure-type N ^number singular)
(@999376 ^spelling south ^referent @408003 ^structure-type CARDINAL ^number singular)
(@999375 ^spelling north ^referent @408001 ^structure-type CARDINAL ^number singular)
(@999377 ^spelling east ^referent @408002 ^structure-type CARDINAL ^number singular)
(@999378 ^spelling west ^referent @408004 ^structure-type CARDINAL ^number singular)
(@999379 ^spelling n ^referent @408001 ^structure-type CARDINAL ^number singular)
(@999380 ^spelling s ^referent @408003 ^structure-type CARDINAL ^number singular)
(@999381 ^spelling e ^referent @408002 ^structure-type CARDINAL ^number singular)
(@999382 ^spelling w ^referent @408004 ^structure-type CARDINAL ^number singular)
(@999383 ^spelling waypoint ^referent @4012009 ^structure-type N ^number singular)
(@999384 ^spelling hall ^referent @4012003 ^structure-type N ^number singular)
(@999402 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true)
(@999386 ^spelling intersection ^referent @4012005 ^structure-type N ^number singular)
(@999387 ^spelling intersections ^referent @4012005 ^structure-type N ^number plural)
(@999388 ^spelling junction ^referent @4012005 ^structure-type N ^number singular)
(@999389 ^spelling door ^referent @4012004 ^structure-type N ^number singular)
(@999390 ^spelling doors ^referent @4012014 ^structure-type N ^number plural)
(@999391 ^spelling building ^referent @4013011 ^structure-type N ^number singular)
(@999392 ^spelling doorway ^referent @4012004 ^structure-type N ^number singular)
(@999394 ^spelling opening ^referent @4012006 ^structure-type N ^number singular)
(@999393 ^spelling doorways ^referent @4012014 ^structure-type N ^number plural)
(@999395 ^spelling t-intersection ^referent @4012007 ^structure-type N ^number singular)
(@999396 ^spelling room ^referent @4012008 ^structure-type N ^number singular)
(@999397 ^spelling where ^structure-type QP ^number singular ^question true)
(@999400 ^property @999401 ^handle there)
(@999398 ^spelling what ^structure-type QP ^number singular ^question true)
(@999399 ^spelling there ^referent @999400 ^structure-type DPX ^number singular)
(@999401 ^type visual ^handle handle)
(@999412 ^relation @999413 ^spelling by ^super-type @609000 ^attachment immediate)
(@999413 ^handle by1)
(@999414 ^relation @999415 ^spelling of ^super-type @609000 ^attachment immediate)
(@999404 ^before @999405 ^structure-type CONJ ^syntactic-structure CONJ ^required true)
(@999405 ^structure-type DP ^relative-position after ^syntactic-structure complement ^required true)
(@999406 ^structure-type U ^relative-position after ^syntactic-structure head ^exclusive @999407 ^optional true ^strip-assigners true)
(@999408 ^relation @999409 ^spelling matched-by ^super-type @609000 ^attachment immediate)
(@999410 ^relation @999411 ^spelling during ^super-type @609000 ^attachment immediate)
(@999409 ^handle matched-by1)
(@999420 ^handle for1)
(@999421 ^relation @999420 ^spelling for ^super-type @609000)
(@999422 ^relation @999423 ^spelling flank flanks ^super-type @609000 ^attachment immediate)
(@999416 ^relation @999417 ^spelling with ^super-type @609000 ^attachment immediate)
(@999415 ^handle of1)
(@999418 ^handle about1)
(@999419 ^relation @999418 ^spelling about ^super-type @609000)
(@999417 ^handle with1)
(@999428 ^relation @501002 ^spelling right-of ^structure-type P ^converts-to PP ^assigners @999429 ^relation-type binary)
(@999433 ^relation @501032 ^spelling from ^super-type @609000 ^directional true)
(@999424 ^relation @999425 ^spelling hold ^super-type @609000 ^attachment immediate)
(@999423 ^handle flank1)
(@999426 ^handle heard1)
(@999427 ^relation @501034 @999426 ^spelling heard ^super-type @609000 ^attachment immediate ^directional false)
(@999425 ^handle hold1)
(@999430 ^relation @501003 ^spelling left-of ^structure-type P ^converts-to PP ^assigners @999431 ^relation-type binary)
(@999431 ^structure-type DP ^relative-position after ^syntactic-structure head ^optional true)
(@999432 ^relation @501001 ^spelling at ^super-type @609000)
(@999429 ^structure-type DP ^relative-position after ^syntactic-structure head ^optional true)
(@999477 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true)
(@999436 ^relation @999437 ^alternative-structure ADJ ^super-type @609000)
(@999437 ^handle off1)
(@999438 ^relation @501001 ^spelling in ^super-type @609000)
(@999434 ^relation @501000 ^spelling ontop ^super-type @609000)
(@999435 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true)
(@999447 ^relation @501017 ^spelling holding ^super-type @609000 ^directional false)
(@999448 ^relation @501023 ^spelling as ^super-type @609000)
(@999439 ^relation @501001 ^spelling inside ^super-type @609000)
(@999440 ^relation @501005 ^spelling below ^super-type @609000)
(@999441 ^relation @501010 ^spelling under ^super-type @609000 ^directional true)
(@999442 ^relation @501014 ^spelling behind ^super-type @609000)
(@999443 ^relation @501004 ^spelling above ^super-type @609000)
(@999444 ^relation @501001 ^spelling into ^super-type @609000 ^directional true)
(@999445 ^relation @501000 ^spelling onto ^super-type @609000 ^directional true)
(@999446 ^relation @501030 ^spelling over ^structure-type P)
(@999455 ^relation @501024 ^spelling greater ^structure-type C-ADJ ^converts-to C-ADJ-P)
(@999460 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true)
(@999458 ^relation @501029 ^spelling better ^structure-type C-ADJ ^converts-to C-ADJ-P)
(@999449 ^relation @501021 ^spelling named ^super-type @609002 ^directional false)
(@999450 ^relation @501021 ^spelling called ^super-type @609002 ^directional false)
(@999451 ^relation @999452 ^spelling until ^structure-type P ^converts-to UNTIL-PP ^assigners @999453 ^attachment immediate)
(@999452 ^handle until1)
(@999453 ^structure-type CP ^relative-position after ^syntactic-structure head ^required true ^semantic-structure *embed* ^embed-structure until-clause)
(@999454 ^relation @501026 ^spelling less ^structure-type C-ADJ ^converts-to C-ADJ-P)
(@999461 ^relation @501028 ^spelling worse-than ^structure-type C-ADJ ^converts-to C-ADJ-P ^prior-word worse ^current-word than ^assigners @999462)
(@999462 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true)
(@999456 ^relation @501025 ^spelling more ^structure-type C-ADJ ^converts-to C-ADJ-P)
(@999457 ^relation @501028 ^spelling worse ^structure-type C-ADJ ^converts-to C-ADJ-P)
(@999459 ^relation @501026 ^spelling less-than ^structure-type C-ADJ ^converts-to C-ADJ-P ^prior-word less ^current-word than ^assigners @999460)
(@999463 ^relation @501024 ^spelling greater-than ^structure-type C-ADJ ^converts-to C-ADJ-P ^prior-word greater ^current-word than ^assigners @999464)
(@999464 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true)
(@999465 ^relation @501025 ^spelling more-than ^structure-type C-ADJ ^converts-to C-ADJ-P ^prior-word more ^current-word than ^assigners @999466)
(@999466 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true)
(@999467 ^relation @501029 ^spelling better-than ^structure-type C-ADJ ^converts-to C-ADJ-P ^prior-word better ^current-word than ^assigners @999468)
(@999468 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true)
(@999469 ^relation @501011 ^spelling next ^structure-type P ^converts-to PP)
(@999470 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true)
(@999484 ^relation @501016 ^spelling in-front-of ^structure-type P ^converts-to PP ^prior-word in-front ^current-word of ^assigners @999483)
(@999485 ^relation @501022 ^spelling between ^super-type @609001 ^attachment immediate)
(@999471 ^relation @501011 ^spelling next-to ^structure-type P ^converts-to PP ^prior-word next ^current-word to ^assigners @999470)
(@999472 ^relation @501011 ^spelling near ^structure-type P ^converts-to PP)
(@999474 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true)
(@999475 ^relation @501012 ^spelling diagonal ^structure-type P ^converts-to PP)
(@999473 ^relation @501011 ^spelling near ^structure-type P ^converts-to PP ^prior-word near ^assigners @999474)
(@999478 ^relation @501019 ^spelling equal ^structure-type P ^converts-to PP)
(@999480 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true)
(@999476 ^relation @501012 ^spelling diagonal ^structure-type P ^converts-to PP ^prior-word diagonal ^current-word with ^assigners @999477)
(@999481 ^relation @501016 ^spelling front ^structure-type FRONT ^converts-to PP)
(@999483 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true)
(@999496 ^structure-type GP ^syntactic-structure complement2 ^semantic-structure *embed* ^optional true ^embed-structure subclause2)
(@999479 ^relation @501019 ^spelling equal-to ^structure-type P ^converts-to PP ^prior-word equal ^current-word to ^assigners @999480)
(@999567 ^structure-type DP ^relative-position after ^syntactic-structure complement ^required true ^semantic-structure arg2)
(@999568 ^spelling remember-if ^referent @101112 ^structure-type V ^converts-to VP ^prior-word remember ^current-word if ^assigners @999569 @999570 @999571 ^number singular ^semantic-structure action ^tense present)
(@999482 ^spelling in-front ^structure-type in-front ^converts-to PP ^prior-word in ^current-word front ^can-be-part-of in-front-of)
(@999488 ^spelling |!| ^structure-type T ^delay-retry true)
(@999489 ^spelling prefer ^referent @101123 ^structure-type V ^converts-to VP ^assigners @999490 @999491 @999492 ^number singular ^semantic-structure action ^tense present)
(@999487 ^spelling |?| ^structure-type QT ^delay-retry true)
(@999486 ^spelling |.| ^structure-type T ^delay-retry true)
(@999572 ^spelling heard ^referent @101115 ^structure-type V ^converts-to VP ^assigners @999573 @999574 ^number singular ^semantic-structure action ^tense present)
(@999502 ^spelling throw ^referent @101032 ^super-type @60998 ^directional true)
(@999490 ^before @999491 @999492 ^structure-type GP ^relative-position after ^syntactic-structure complement ^required true ^semantic-structure *embed* ^embed-structure subclause1)
(@999491 ^before @999492 ^structure-type P ^syntactic-structure adjunct ^referent-type literal ^optional true ^lexical-item-spelling over)
(@999492 ^structure-type GP ^syntactic-structure complement2 ^semantic-structure *embed* ^optional true ^embed-structure subclause2)
(@999493 ^spelling consider ^referent @101146 ^structure-type V ^converts-to VP ^assigners @999494 @999495 @999496 ^number singular ^semantic-structure action ^tense present)
(@999500 ^structure-type GP ^semantic-structure *embed* ^optional true ^embed-structure subclause2)
(@999494 ^before @999495 @999496 ^structure-type GP ^relative-position after ^syntactic-structure complement ^required true ^semantic-structure *embed* ^embed-structure subclause1)
(@999495 ^before @999496 ^structure-type P ^syntactic-structure adjunct ^referent-type literal ^optional true ^lexical-item-spelling over)
(@999497 ^spelling avoid ^referent @101124 ^structure-type V ^converts-to VP ^assigners @999498 @999499 @999500 ^number singular ^semantic-structure action ^tense present)
(@999498 ^before @999499 @999500 ^structure-type GP ^relative-position after ^syntactic-structure complement ^required true ^semantic-structure *embed* ^embed-structure subclause1)
(@999499 ^before @999500 ^structure-type P ^syntactic-structure adjunct ^semantic-structure on-off-state ^referent-type literal ^optional true ^lexical-item-spelling over)
(@999501 ^spelling tell ^referent @101031 ^super-type @60991)
(@999503 ^spelling move ^referent @101101 ^super-type @60987 ^directional true ^tense present)
(@999504 ^spelling write ^referent @101901 ^super-type @60987 ^directional true ^tense present)
(@999505 ^spelling set ^referent @101013 ^super-type @60997 ^directional true)
(@999506 ^spelling place ^referent @101002 ^super-type @60999 ^directional true)
(@999507 ^spelling attack ^referent @101144 ^super-type @60999 ^directional true)
(@999508 ^spelling fill ^referent @101244 ^super-type @60999 ^directional true)
(@999509 ^spelling put ^referent @101002 ^super-type @60985 ^directional true)
(@999510 ^spelling said ^referent @101116 ^super-type @60999 ^tense past)
(@999511 ^spelling discard ^referent @101010 ^super-type @60998)
(@999512 ^spelling pick ^referent @101001 ^super-type @60998 ^can-be-part-of pick-up)
(@999513 ^spelling find ^referent @101020 ^super-type @60998)
(@999514 ^spelling cook ^referent @101012 ^super-type @60998)
(@999515 ^spelling open ^referent @101003 ^super-type @60997 ^can-be-part-of open-up)
(@999516 ^spelling close ^referent @101004 ^converts-to VP ^super-type @60997)
(@999517 ^spelling organize ^referent @108009 ^super-type @60997)
(@999518 ^spelling clean ^referent @101014 ^super-type @60997)
(@999519 ^spelling activate ^referent @101005 ^super-type @60997)
(@999520 ^spelling store ^referent @101009 ^super-type @60996)
(@999521 ^spelling matches ^referent @101147 ^super-type @60987 ^directional true ^tense present)
(@999522 ^spelling point ^referent @101002 ^super-type @60995)
(@999523 ^spelling check ^referent @101113 ^super-type @60990)
(@999524 ^spelling test ^referent @101113 ^super-type @60990)
(@999525 ^spelling fetch ^referent @101019 ^super-type @60999 ^directional true)
(@999526 ^spelling has ^referent @101119 ^super-type @60989)
(@999527 ^spelling have ^referent @101119 ^super-type @60989)
(@999528 ^spelling play ^referent @101120 ^super-type @60999)
(@999529 ^spelling wins ^referent @101121 ^super-type @60993)
(@999530 ^spelling win ^referent @101121 ^super-type @60993)
(@999531 ^spelling lose ^referent @101122 ^super-type @60993)
(@999532 ^spelling ignore ^referent @101118 ^super-type @60988)
(@999533 ^spelling attend ^referent @101117 ^super-type @60988)
(@999534 ^spelling attend-to ^referent @101117 ^prior-word attend ^current-word to ^super-type @60998 ^consumes-prior-word true)
(@999535 ^spelling stop ^referent @101209 ^super-type @60995)
(@999536 ^message-type command ^referent @101209 ^structure-type CP ^semantic-structure action ^spelling-single-word stop)
(@999538 ^spelling scan ^referent @101125 ^super-type @60992)
(@999537 ^spelling deliver ^referent @101018 ^super-type @60999 ^directional true)
(@999539 ^spelling give ^referent @101126 ^super-type @60999 ^directional true)
(@999540 ^spelling take ^referent @101127 ^super-type @60999)
(@999541 ^spelling guide ^referent @101128 ^super-type @60999)
(@999542 ^spelling serve ^referent @101129 ^super-type @60999)
(@999543 ^spelling perform ^referent @101131 ^super-type @60998)
(@999544 ^spelling bring ^referent @101130 ^super-type @60999)
(@999545 ^message-type command ^referent @101131 ^structure-type CP ^semantic-structure action ^spelling-single-word scan)
(@999547 ^spelling face ^referent @101204 ^super-type @60998)
(@999546 ^spelling scan ^referent @101131 ^super-type @60995)
(@999548 ^message-type command ^spelling turn-left ^referent @101201 ^structure-type CP ^prior-word turn ^current-word left ^prior-word-first true ^referent2 @409002 ^semantic-structure action ^semantic-structure2 arg1)
(@999550 ^message-type command ^spelling turn-around ^referent @101201 ^structure-type CP ^prior-word turn ^current-word around ^prior-word-first true ^referent2 @409003 ^semantic-structure action ^semantic-structure2 arg1)
(@999549 ^message-type command ^spelling turn-right ^referent @101201 ^structure-type CP ^prior-word turn ^current-word right ^prior-word-first true ^referent2 @409001 ^semantic-structure action ^semantic-structure2 arg1)
(@999552 ^spelling detect ^referent @101111 ^super-type @60997)
(@999551 ^spelling see ^referent @101111 ^super-type @60997)
(@999553 ^spelling sense ^referent @101111 ^super-type @60997)
(@999554 ^spelling encounter ^referent @101111 ^super-type @60997)
(@999555 ^spelling reach ^referent @101111 ^super-type @60997)
(@999556 ^spelling explore ^referent @101110 ^super-type @60992)
(@999557 ^spelling go ^referent @101206 ^super-type @60992)
(@999558 ^message-type command ^referent @101206 ^structure-type CP ^semantic-structure action ^spelling-single-word go)
(@999559 ^message-type command ^referent @101206 ^structure-type CP ^semantic-structure action ^spelling-single-word forward)
(@999560 ^spelling go-down ^referent @101206 ^prior-word go ^current-word down ^prior-word-first true ^super-type @60993)
(@999561 ^spelling drive ^referent @101206 ^super-type @60992)
(@999562 ^message-type command ^referent @101206 ^structure-type CP ^semantic-structure action ^spelling-single-word drive)
(@999563 ^spelling drive-down ^referent @101206 ^prior-word drive ^current-word down ^prior-word-first true ^super-type @60993)
(@999564 ^spelling remember ^referent @101112 ^structure-type V ^converts-to VP ^assigners @999565 @999566 @999567 ^number singular ^semantic-structure action ^tense present)
(@999566 ^structure-type P ^syntactic-structure nil ^required true ^lexical-item-spelling as)
(@999565 ^before @999567 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999601 ^before @999602 @999603 ^structure-type DP ^relative-position after ^syntactic-structure complement ^semantic-structure arg1 ^optional true)
(@999606 ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier ^optional true)
(@999607 ^structure-type DP ^relative-position before ^syntactic-structure head ^semantic-structure agent ^optional true)
(@999569 ^before @999570 @999571 ^structure-type CP ^relative-position after ^syntactic-structure nil ^required true ^semantic-structure *embed* ^embed-structure if-subclause)
(@999570 ^before @999571 ^structure-type P ^syntactic-structure nil ^required true ^lexical-item-spelling as)
(@999571 ^structure-type DP ^relative-position after ^syntactic-structure complement ^required true ^semantic-structure arg2)
(@999575 ^spelling recall ^referent @101114 ^structure-type V ^converts-to VP ^assigners @999576 @999577 ^number singular ^semantic-structure action ^tense present)
(@999573 ^before @999574 ^structure-type PN ^relative-position before ^syntactic-structure head ^required true ^semantic-structure agent)
(@999574 ^structure-type DP ^relative-position after ^syntactic-structure complement ^semantic-structure arg1 ^optional true)
(@999579 ^spelling think ^referent @101143 ^structure-type V ^converts-to VP ^assigners @999580 ^semantic-structure action ^tense present)
(@999576 ^structure-type DP ^relative-position after ^syntactic-structure head ^exclusive @999578 ^semantic-structure arg1 ^optional true)
(@999577 ^structure-type PP ^relative-position after ^syntactic-structure complement ^required true ^semantic-structure predicate)
(@999600 ^structure-type DP ^syntactic-structure head ^semantic-structure arg3 ^optional true)
(@999580 ^structure-type PP ^relative-position after ^syntactic-structure complement ^required true ^semantic-structure arg2)
(@999581 ^spelling ask ^referent @101030 ^structure-type V ^converts-to VP ^assigners @999582 @999583 @999584 ^number singular ^semantic-structure action ^tense present)
(@999582 ^before @999583 @999584 ^structure-type PN ^relative-position after ^syntactic-structure head ^semantic-structure agent ^optional true)
(@999595 ^spelling stack ^referent @101011 ^structure-type V ^converts-to VP ^assigners @999596 @999597 @999598 @999599 @999600 ^number singular ^semantic-structure action ^tense present)
(@999583 ^structure-type U ^relative-position after ^syntactic-structure complement ^exclusive @999584 ^semantic-structure arg1 ^optional true)
(@999584 ^structure-type DP ^relative-position after ^syntactic-structure complement ^exclusive @999583 ^semantic-structure arg1 ^optional true)
(@999585 ^spelling say ^referent @101116 ^structure-type V ^converts-to VP ^assigners @999586 @999587 ^number singular ^semantic-structure action ^tense present)
(@999586 ^structure-type U ^relative-position after ^syntactic-structure complement ^exclusive @999587 ^semantic-structure arg1 ^optional true)
(@999587 ^structure-type DP ^relative-position after ^syntactic-structure complement ^exclusive @999586 ^semantic-structure arg1 ^optional true)
(@999589 ^spelling orient ^referent @101203 ^structure-type V ^converts-to VP ^assigners @999590 ^number singular ^semantic-structure action ^tense present)
(@999588 ^spelling follow ^referent @101202 ^super-type @60993)
(@999597 ^before @999599 ^structure-type CONJ ^syntactic-structure nil ^optional true)
(@999590 ^structure-type CARDINAL ^syntactic-structure head ^required true ^semantic-structure arg1 ^referent-type literal)
(@999591 ^spelling face ^referent @101203 ^structure-type V ^converts-to VP ^assigners @999592 ^number singular ^semantic-structure action ^tense present)
(@999592 ^structure-type CARDINAL ^syntactic-structure head ^required true ^semantic-structure arg1 ^referent-type literal)
(@999593 ^spelling load ^referent @101145 ^structure-type V ^converts-to VP ^assigners @999594 ^number singular ^semantic-structure action ^tense present)
(@999594 ^structure-type U ^syntactic-structure head ^required true ^semantic-structure arg1 ^referent-type literal)
(@999596 ^before @999598 @999600 ^structure-type DP ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999598 ^before @999600 ^structure-type DP ^syntactic-structure head ^semantic-structure arg2 ^optional true)
(@999599 ^structure-type CONJ ^syntactic-structure nil ^optional true)
(@999627 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999608 ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier ^optional true)
(@999602 ^after @999601 ^structure-type ADJ ^relative-position after ^syntactic-structure adjunct ^required true ^exclusive @999603 ^semantic-structure on-off-state ^referent-type literal ^lexical-item-spelling on)
(@999603 ^after @999601 ^structure-type ADJ ^relative-position after ^syntactic-structure adjunct ^required true ^exclusive @999602 ^semantic-structure on-off-state ^referent-type literal ^lexical-item-spelling off)
(@999604 ^message-type wait ^structure-type CP ^spelling-single-word wait)
(@999605 ^spelling wait ^referent @101007 ^super-type @60993)
(@999633 ^structure-type PP ^relative-position after ^syntactic-structure complement ^semantic-structure arg1 ^optional true)
(@999634 ^after @999633 ^structure-type CONJP ^syntactic-structure predicate ^copy-structure arg1 ^semantic-structure *copy* ^optional true ^repeatable true)
(@999610 ^after @999609 ^structure-type CONJP ^syntactic-structure predicate ^copy-structure arg1 ^exclusive @999613 ^semantic-structure *copy* ^optional true ^repeatable true)
(@999609 ^before @999611 @999613 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999616 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999611 ^structure-type PP ^relative-position after ^syntactic-structure complement2 ^exclusive @999613 ^semantic-structure arg2 ^optional true)
(@999613 ^structure-type DP ^relative-position after ^syntactic-structure head ^exclusive @999610 @999611 ^semantic-structure arg2 ^optional true)
(@999612 ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier ^optional true)
(@999614 ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier ^optional true)
(@999618 ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier ^optional true)
(@999615 ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier ^optional true)
(@999617 ^after @999616 ^structure-type CONJP ^syntactic-structure predicate ^copy-structure arg1 ^semantic-structure *copy* ^optional true ^repeatable true)
(@999619 ^structure-type DP ^relative-position before ^syntactic-structure nil ^semantic-structure agent ^optional true)
(@999622 ^after @999621 ^structure-type CONJP ^syntactic-structure predicate ^copy-structure arg1 ^semantic-structure *copy* ^optional true ^repeatable true)
(@999620 ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier ^optional true)
(@999621 ^before @999622 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999625 ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier ^optional true)
(@999626 ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier ^optional true)
(@999623 ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier ^optional true)
(@999624 ^structure-type PP ^relative-position after ^syntactic-structure complement2 ^semantic-structure arg2 ^optional true)
(@999635 ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier ^optional true)
(@999636 ^structure-type UNTIL-PP ^relative-position after ^syntactic-structure complement2 ^semantic-structure arg2 ^optional true)
(@999628 ^after @999627 ^structure-type CONJP ^syntactic-structure predicate ^copy-structure arg1 ^semantic-structure *copy* ^optional true ^repeatable true)
(@999632 ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier ^optional true)
(@999629 ^structure-type PP ^relative-position after ^syntactic-structure complement2 ^semantic-structure arg2 ^optional true)
(@999630 ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier ^optional true)
(@999631 ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier ^optional true)
(@999640 ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier ^optional true)
(@999641 ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier ^optional true)
(@999642 ^before @999643 ^structure-type DP ^relative-position after ^syntactic-structure head ^semantic-structure arg1 ^optional true)
(@999645 ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier ^optional true)
(@999646 ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier ^optional true)
(@999637 ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier ^optional true)
(@999639 ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier ^optional true)
(@999638 ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier ^optional true)
(@999657 ^structure-type IF-CLAUSE ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999658 ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier ^optional true)
(@999643 ^structure-type UNTIL-PP ^relative-position after ^syntactic-structure complement ^semantic-structure arg2 ^optional true)
(@999644 ^structure-type PP ^relative-position after ^syntactic-structure complement ^semantic-structure arg1 ^optional true)
(@999647 ^before @999648 @999650 ^structure-type DP ^relative-position after ^syntactic-structure head ^semantic-structure arg1 ^referent-type literal ^optional true)
(@999649 ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier ^optional true)
(@999650 ^structure-type PP ^relative-position after ^syntactic-structure complement2 ^semantic-structure relation ^optional true)
(@999651 ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier ^optional true)
(@999648 ^structure-type UNTIL-PP ^relative-position after ^syntactic-structure complement ^semantic-structure arg2 ^optional true)
(@999659 ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier ^optional true)
(@999661 ^structure-type C-ADJ-P ^relative-position after ^syntactic-structure predicate ^exclusive @999660 @999663 ^semantic-structure predicate ^optional true)
(@999652 ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier ^optional true)
(@999653 ^before @999654 ^structure-type PN ^relative-position after ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999654 ^structure-type DP ^relative-position after ^syntactic-structure complement ^semantic-structure arg2 ^referent-type literal ^optional true)
(@999656 ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier ^optional true)
(@999655 ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier ^optional true)
(@999663 ^structure-type ADJ ^relative-position after ^syntactic-structure predicate ^exclusive @999660 @999661 ^semantic-structure predicate ^referent-type literal ^optional true)
(@999703 ^message-type no ^structure-type CP ^spelling-single-word nope)
(@999704 ^message-type finished ^structure-type CP ^spelling-single-word go)
(@999705 ^message-type finished ^structure-type CP ^spelling-single-word done)
(@999660 ^structure-type DP ^relative-position after ^syntactic-structure head ^exclusive @999661 @999663 ^semantic-structure arg1 ^optional true)
(@999662 ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier ^optional true)
(@999664 ^structure-type DP ^relative-position before ^syntactic-structure head ^semantic-structure agent ^optional true)
(@999665 ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier ^optional true)
(@999669 ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier ^optional true)
(@999684 ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier ^optional true)
(@999666 ^structure-type DP ^relative-position after ^syntactic-structure head ^exclusive @999667 ^semantic-structure arg1 ^optional true)
(@999667 ^structure-type P ^relative-position after ^syntactic-structure head ^exclusive @999666 ^semantic-structure arg1 ^referent-type literal ^optional true ^strip-assigners true)
(@999668 ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier ^optional true)
(@999672 ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier ^optional true)
(@999681 ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier ^optional true)
(@999670 ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier ^optional true)
(@999671 ^structure-type DP ^relative-position before ^syntactic-structure head ^semantic-structure agent ^optional true)
(@999680 ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier ^optional true)
(@999673 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999674 ^after @999673 ^structure-type CONJP ^syntactic-structure predicate ^copy-structure arg1 ^semantic-structure *copy* ^optional true ^repeatable true)
(@999675 ^before @999677 ^structure-type PP ^relative-position after ^syntactic-structure complement ^semantic-structure arg2 ^optional true)
(@999676 ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier ^optional true)
(@999677 ^after @999673 @999675 ^structure-type PP ^relative-position after ^syntactic-structure complement2 ^semantic-structure arg3 ^optional true)
(@999678 ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier ^optional true)
(@999679 ^structure-type PP ^relative-position after ^syntactic-structure complement ^semantic-structure arg1 ^optional true)
(@999682 ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier ^optional true)
(@999686 ^after @999685 ^structure-type CONJP ^syntactic-structure predicate ^copy-structure arg1 ^semantic-structure *copy* ^optional true ^repeatable true)
(@999688 ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier ^optional true)
(@999689 ^spelling turn-on ^referent @101005 ^prior-word turn ^current-word on ^prior-word-first true ^super-type @60997)
(@999683 ^structure-type DP ^relative-position before ^syntactic-structure head ^semantic-structure agent ^optional true)
(@999685 ^before @999687 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999690 ^spelling turn-off ^referent @101006 ^prior-word turn ^current-word off ^prior-word-first true ^super-type @60997 ^prior-word-lti @60001)
(@999687 ^structure-type PP ^relative-position after ^syntactic-structure complement2 ^semantic-structure arg2 ^optional true)
(@999699 ^message-type yes ^structure-type CP ^spelling-single-word yeah)
(@999700 ^message-type yes ^structure-type CP ^spelling-single-word ok)
(@999691 ^spelling clean-up ^referent @1010014 ^prior-word clean ^current-word up ^prior-word-first true ^super-type @60997 ^prior-word-lti @60001)
(@999692 ^spelling open-up ^referent @101003 ^prior-word open ^current-word up ^prior-word-first true ^super-type @60997)
(@999693 ^spelling start-leading ^referent @101150 ^prior-word start ^current-word leading ^prior-word-first true ^super-type @60998)
(@999694 ^spelling stop-leading ^referent @101151 ^prior-word stop ^current-word leading ^prior-word-first true ^super-type @60998)
(@999695 ^spelling start-following ^referent @101152 ^prior-word start ^current-word following ^prior-word-first true ^super-type @60998)
(@999696 ^spelling stop-following ^referent @101209 ^prior-word stop ^current-word following ^prior-word-first true ^super-type @60998)
(@999697 ^relation @501000 ^spelling on-to ^structure-type P ^converts-to PP ^prior-word on ^current-word to ^assigners @999698 ^directional true)
(@999698 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true)
(@999701 ^message-type yes ^structure-type CP ^spelling-single-word yes)
(@999702 ^message-type no ^structure-type CP ^spelling-single-word no)
(@999706 ^message-type finished ^structure-type CP ^spelling-single-word finished)
(@999707 ^message-type restart ^structure-type CP ^spelling-single-word restart)
(@999713 ^message-type cancel ^structure-type CP ^spelling-single-word cancel)
(@999714 ^spelling Rosie ^referent @999715 ^structure-type ROSIE ^number singular)
(@999712 ^message-type dont-know ^structure-type CP ^spelling-single-word unknown)
(@999710 ^message-type bye ^structure-type CP ^spelling-single-word bye)
(@999711 ^message-type bye ^structure-type CP ^spelling-single-word goodbye)
(@999708 ^message-type hello ^structure-type CP ^spelling-single-word hi)
(@999709 ^message-type hello ^structure-type CP ^spelling-single-word hello)
(@999716 ^spelling rosie ^referent @999717 ^structure-type ROSIE ^number singular)
(@999756 ^message-type unknown-word ^structure-type S ^prior-word U ^current-word T ^assigners @999757 @999758 ^construction *-U-T ^prior-word-first true)
(@999873 ^before @999869 @999870 @999874 @999875 ^structure-type IS-V ^syntactic-structure predicate ^required true)
(@999874 ^before @999869 @999870 @999871 ^specifier definite ^structure-type DP ^syntactic-structure head ^required true ^semantic-structure arg1 ^demonstrative true)
(@999715 ^handle rosie)
(@999717 ^handle rosie)
(@999718 ^spelling |rosie,| ^structure-type ROSIE ^prior-word ROSIE ^current-word |,| ^assigners @999719 ^consumes-prior-word true)
(@999719 ^structure-type ROSIE ^syntactic-structure complement ^required true ^semantic-structure agent)
(@999720 ^spelling me ^referent @999721 ^structure-type PN ^number singular)
(@999721 ^property @999722 ^handle me ^item-type object)
(@999723 ^spelling alice ^referent @404040 ^specifier definite ^structure-type PN ^converts-to DP ^number singular ^singleton-DP true)
(@999722 ^type person ^handle person1 ^item-type property)
(@999724 ^spelling bob ^referent @404041 ^specifier definite ^structure-type PN ^converts-to DP ^number singular ^singleton-DP true)
(@999729 ^structure-type *-V-ADJ ^converts-to DP ^prior-word V ^current-word ADJ ^assigners @999726 @999727 @999728 ^number singular ^construction *-V-ADJ ^prior-word-first true)
(@999728 ^structure-type PP ^relative-position after ^syntactic-structure complement ^optional true)
(@999725 ^spelling charlie ^referent @404042 ^specifier definite ^structure-type PN ^converts-to DP ^number singular ^singleton-DP true)
(@999726 ^before @999727 ^structure-type ADJ ^syntactic-structure adjoin ^optional true ^repeatable true)
(@999727 ^before @999728 ^structure-type N ^syntactic-structure head ^required true)
(@999733 ^structure-type V-ADJ ^converts-to DP ^prior-word V ^current-word ADJ ^assigners @999730 @999731 @999732 ^number singular ^construction V-ADJ ^prior-word-first false)
(@999731 ^before @999732 ^structure-type N ^syntactic-structure head ^required true)
(@999730 ^before @999731 ^structure-type ADJ ^syntactic-structure adjoin ^required true ^repeatable true)
(@999732 ^structure-type PP ^relative-position after ^syntactic-structure complement ^optional true)
(@999736 ^structure-type |N-X| ^converts-to DP ^prior-word V ^current-word N ^assigners @999734 @999735 ^number singular ^construction *-V-N ^prior-word-first true)
(@999734 ^before @999735 ^structure-type N ^syntactic-structure head ^required true)
(@999735 ^structure-type PP ^relative-position after ^syntactic-structure complement ^optional true)
(@999742 ^structure-type P-N-X ^converts-to DP ^prior-word P ^current-word N ^assigners @999740 @999741 ^number singular ^construction |P-N| ^prior-word-first false)
(@999737 ^before @999738 ^structure-type N ^syntactic-structure head ^required true)
(@999738 ^structure-type PP ^relative-position after ^syntactic-structure complement ^optional true)
(@999739 ^structure-type |N-X| ^converts-to DP ^prior-word V ^current-word N ^assigners @999737 @999738 ^number singular ^construction |V-N| ^prior-word-first false)
(@999740 ^before @999741 ^structure-type N ^syntactic-structure head ^required true)
(@999741 ^structure-type PP ^relative-position after ^syntactic-structure complement ^optional true)
(@999744 ^before @999745 ^structure-type N ^syntactic-structure head ^required true)
(@999746 ^structure-type P-ADJ-X ^converts-to DP ^prior-word P ^current-word ADJ ^assigners @999743 @999744 @999745 ^number singular ^construction P-ADJ ^prior-word-first false)
(@999743 ^before @999744 ^structure-type ADJ ^syntactic-structure adjoin ^repeatable true)
(@999745 ^structure-type PP ^relative-position after ^syntactic-structure complement ^optional true)
(@999748 ^structure-type CP ^relative-position after ^syntactic-structure head ^required true ^delay-merge true ^semantic-structure *copy*)
(@999751 ^structure-type PP ^syntactic-structure complement2 ^semantic-structure arg2 ^optional true)
(@999752 ^structure-type U ^syntactic-structure action ^required true ^semantic-structure action ^referent-type literal ^predicted-structure-type V)
(@999747 ^spelling is-that ^structure-type RPN ^converts-to RC ^prior-word is ^current-word that ^assigners @999748 ^attachment immediate ^consumes-prior-word false)
(@999750 ^structure-type DP ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999749 ^message-type new-verb ^structure-type UV ^converts-to VP ^prior-word U ^current-word D ^assigners @999750 @999751 @999752 ^construction *-U-D ^prior-word-first true)
(@999824 ^structure-type PP ^relative-position after ^syntactic-structure complement ^exclusive @999823 ^semantic-structure relation ^optional true)
(@999825 ^structure-type C-ADJ-P ^relative-position before ^syntactic-structure head ^required true ^semantic-structure *embed* ^embed-structure arg1)
(@999753 ^message-type new-verb ^structure-type UV ^converts-to VP ^prior-word U ^current-word P ^assigners @999754 @999755 ^construction *-U-P ^prior-word-first true)
(@999754 ^structure-type PP ^syntactic-structure complement2 ^semantic-structure arg2 ^optional true)
(@999755 ^structure-type U ^syntactic-structure action ^required true ^semantic-structure action ^referent-type literal ^predicted-structure-type V)
(@999759 ^message-type new-verb ^structure-type UV ^converts-to VP ^prior-word U ^current-word PN ^assigners @999760 @999761 ^construction *-U-PN ^prior-word-first true)
(@999757 ^structure-type U ^syntactic-structure head ^required true)
(@999758 ^structure-type T ^syntactic-structure terminator ^required true)
(@999766 ^structure-type N ^relative-position after ^syntactic-structure predicate ^exclusive @999765 ^semantic-structure property ^referent-type literal ^optional true)
(@999760 ^structure-type PN ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999761 ^structure-type U ^syntactic-structure action ^required true ^semantic-structure action ^referent-type literal ^predicted-structure-type V)
(@999762 ^message-type adjective-definition ^structure-type CP ^prior-word U ^current-word IS-V ^assigners @999763 @999764 @999765 @999766 ^construction *-U-is-DP ^prior-word-first true)
(@999763 ^before @999764 ^structure-type U ^syntactic-structure head ^required true ^semantic-structure arg1 ^referent-type literal ^predicted-structure-type ADJ N)
(@999764 ^before @999765 ^after @999763 ^structure-type IS-V ^syntactic-structure predicate ^required true ^lexical-item-spelling is)
(@999765 ^structure-type DP ^relative-position after ^syntactic-structure predicate ^exclusive @999766 ^semantic-structure property ^referent-type literal ^optional true)
(@999767 ^structure-type PP ^relative-position after ^syntactic-structure complement ^exclusive @999768 @999769 @999770 @999772 @999778 @999779 @999780 ^semantic-structure relation ^optional true)
(@999768 ^structure-type U ^relative-position after ^syntactic-structure predicate ^exclusive @999767 @999769 @999770 @999772 @999778 @999779 @999780 ^semantic-structure predicate ^referent-type literal ^optional true ^predicted-structure-type ADJ)
(@999770 ^structure-type RC ^relative-position after ^syntactic-structure predicate ^exclusive @999767 @999768 @999769 @999772 @999778 @999779 @999780 ^semantic-structure *embed* ^optional true ^embed-structure subclause)
(@999774 ^structure-type V-AUX ^relative-position after ^syntactic-structure nil ^semantic-structure modifier ^optional true)
(@999769 ^structure-type C-ADJ-P ^relative-position after ^syntactic-structure predicate ^exclusive @999767 @999768 @999770 @999772 @999778 @999779 @999780 ^semantic-structure predicate ^optional true)
(@999771 ^structure-type CONJP ^syntactic-structure predicate ^copy-structure predicate ^semantic-structure *copy* ^optional true ^repeatable true)
(@999772 ^structure-type V ^relative-position after ^syntactic-structure predicate ^exclusive @999767 @999769 @999770 @999778 @999779 @999780 ^semantic-structure predicate ^referent-type literal ^optional true ^strip-assigners true)
(@999773 ^structure-type DP ^relative-position before ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999775 ^before @999776 ^after @999773 ^structure-type CONJP ^relative-position before ^syntactic-structure head ^copy-structure arg1 ^semantic-structure *copy* ^optional true ^repeatable true)
(@999776 ^before @999770 ^structure-type IS-V ^syntactic-structure predicate ^required true ^semantic-structure action)
(@999777 ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier ^referent-type literal ^optional true)
(@999779 ^structure-type DP ^relative-position after ^syntactic-structure complement ^exclusive @999767 @999768 @999769 @999770 @999772 @999778 @999780 ^semantic-structure arg2 ^referent-type literal ^optional true)
(@999778 ^structure-type ADJ ^relative-position after ^syntactic-structure predicate ^exclusive @999767 @999768 @999769 @999770 @999772 @999779 @999780 ^semantic-structure predicate ^referent-type literal ^optional true)
(@999780 ^structure-type N ^relative-position after ^syntactic-structure predicate ^exclusive @999767 @999768 @999769 @999770 @999772 @999778 @999779 ^semantic-structure predicate ^referent-type literal ^optional true)
(@999782 ^structure-type N ^relative-position after ^syntactic-structure predicate ^exclusive @999783 @999784 @999785 @999786 @999788 @999791 @999792 ^semantic-structure predicate ^referent-type literal ^optional true)
(@999781 ^message-type object-description ^structure-type C ^converts-to CP ^prior-word DP ^current-word IS-V ^assigners @999767 @999768 @999769 @999770 @999771 @999772 @999773 @999774 @999775 @999776 @999777 @999778 @999779 @999780 ^construction *-DP-is-ADJ/DP/PP/CONJP/RC ^prior-word-first true)
(@999788 ^structure-type V ^relative-position after ^syntactic-structure predicate ^exclusive @999782 @999783 @999785 @999786 @999791 @999792 ^semantic-structure predicate ^referent-type literal ^optional true ^strip-assigners true)
(@999783 ^structure-type PP ^relative-position after ^syntactic-structure complement ^exclusive @999782 @999784 @999785 @999786 @999788 @999791 @999792 ^semantic-structure relation ^optional true)
(@999784 ^structure-type U ^relative-position after ^syntactic-structure predicate ^exclusive @999782 @999783 @999785 @999786 @999788 @999791 @999792 ^semantic-structure predicate ^referent-type literal ^optional true ^predicted-structure-type ADJ)
(@999786 ^structure-type RC ^relative-position after ^syntactic-structure predicate ^exclusive @999782 @999783 @999784 @999785 @999788 @999791 @999792 ^semantic-structure *embed* ^optional true ^embed-structure subclause)
(@999785 ^structure-type C-ADJ-P ^relative-position after ^syntactic-structure predicate ^exclusive @999782 @999783 @999784 @999786 @999788 @999791 @999792 ^semantic-structure predicate ^optional true)
(@999787 ^structure-type CONJP ^syntactic-structure predicate ^copy-structure predicate ^semantic-structure *copy* ^optional true ^repeatable true)
(@999789 ^before @999786 ^structure-type IS-V ^syntactic-structure predicate ^required true ^semantic-structure action)
(@999790 ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier ^referent-type literal ^optional true)
(@999791 ^structure-type ADJ ^relative-position after ^syntactic-structure predicate ^exclusive @999782 @999783 @999784 @999785 @999786 @999788 @999792 ^semantic-structure predicate ^referent-type literal ^optional true)
(@999792 ^structure-type DP ^relative-position after ^syntactic-structure predicate ^exclusive @999782 @999783 @999784 @999785 @999786 @999788 @999791 ^semantic-structure predicate ^referent-type literal ^optional true)
(@999793 ^structure-type PN ^relative-position before ^syntactic-structure head ^required true ^exclusive @999793 ^semantic-structure arg1)
(@999795 ^before @999789 ^after @999793 ^structure-type CONJP ^relative-position before ^syntactic-structure head ^copy-structure arg1 ^semantic-structure *copy* ^optional true ^repeatable true)
(@999798 ^structure-type U ^relative-position after ^syntactic-structure predicate ^exclusive @999797 @999799 @999800 @999802 @999807 @999808 @999809 ^semantic-structure predicate ^referent-type literal ^optional true ^predicted-structure-type ADJ)
(@999794 ^structure-type V-AUX ^relative-position after ^syntactic-structure nil ^semantic-structure modifier ^optional true)
(@999807 ^structure-type ADJ ^relative-position after ^syntactic-structure predicate ^exclusive @999797 @999798 @999799 @999800 @999802 @999808 @999809 ^semantic-structure predicate ^referent-type literal ^optional true)
(@999796 ^message-type object-description ^structure-type C ^converts-to CP ^prior-word PN ^current-word IS-V ^assigners @999782 @999783 @999784 @999785 @999786 @999787 @999788 @999789 @999790 @999791 @999792 @999793 @999794 @999795 ^construction *-PN-is-ADJ/DP/PP/CONJP/RC ^prior-word-first true)
(@999797 ^structure-type PP ^relative-position after ^syntactic-structure complement ^exclusive @999798 @999799 @999800 @999802 @999807 @999808 @999809 ^semantic-structure relation ^optional true)
(@999800 ^structure-type RC ^relative-position after ^syntactic-structure predicate ^exclusive @999797 @999798 @999799 @999802 @999807 @999808 @999809 ^semantic-structure *embed* ^optional true ^embed-structure subclause)
(@999799 ^structure-type C-ADJ-P ^relative-position after ^syntactic-structure predicate ^exclusive @999797 @999798 @999800 @999802 @999807 @999808 @999809 ^semantic-structure predicate ^optional true)
(@999801 ^structure-type CONJP ^syntactic-structure predicate ^copy-structure predicate ^semantic-structure *copy* ^optional true ^repeatable true)
(@999802 ^structure-type V ^relative-position after ^syntactic-structure predicate ^exclusive @999797 @999799 @999800 @999807 @999808 @999809 ^semantic-structure predicate ^referent-type literal ^optional true ^strip-assigners true)
(@999803 ^structure-type DP ^relative-position before ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999804 ^before @999805 ^after @999803 ^structure-type CONJP ^relative-position before ^syntactic-structure head ^copy-structure arg1 ^semantic-structure *copy* ^optional true ^repeatable true)
(@999805 ^before @999800 ^structure-type IS-V ^syntactic-structure predicate ^required true ^semantic-structure action)
(@999806 ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier ^referent-type literal ^optional true)
(@999822 ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier ^referent-type literal ^optional true)
(@999808 ^structure-type DP ^relative-position after ^syntactic-structure predicate ^exclusive @999797 @999798 @999799 @999800 @999802 @999807 @999809 ^semantic-structure predicate ^referent-type literal ^optional true)
(@999809 ^structure-type N ^relative-position after ^syntactic-structure predicate ^exclusive @999797 @999798 @999799 @999800 @999802 @999807 @999808 ^semantic-structure predicate ^referent-type literal ^optional true)
(@999810 ^message-type object-description ^structure-type C ^converts-to CP ^prior-word CONJP ^current-word IS-V ^assigners @999797 @999798 @999799 @999800 @999801 @999802 @999803 @999804 @999805 @999806 @999807 @999808 @999809 ^construction CONJP-is-ADJ/DP/PP/CONJP/RC ^prior-word-first true false)
(@999812 ^structure-type PP ^relative-position after ^syntactic-structure complement ^exclusive @999811 @999813 @999816 @999817 ^semantic-structure relation ^optional true)
(@999815 ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier ^referent-type literal ^optional true)
(@999819 ^message-type object-description ^referent @101148 ^structure-type C ^converts-to CP ^prior-word DP ^current-word IS-V ^assigners @999811 @999812 @999813 @999814 @999815 @999816 @999817 @999818 ^construction DP-is-ADJ/DP/PP/CONJP/RP ^prior-word-first false ^semantic-structure action)
(@999811 ^structure-type N ^relative-position after ^syntactic-structure predicate ^exclusive @999812 @999813 @999816 @999817 ^semantic-structure predicate ^referent-type literal ^optional true)
(@999813 ^structure-type C-ADJ-P ^relative-position after ^syntactic-structure complement ^exclusive @999811 @999812 @999816 @999817 ^semantic-structure relation ^referent-type literal ^optional true)
(@999814 ^structure-type IS-V ^syntactic-structure predicate ^required true)
(@999816 ^structure-type ADJ ^relative-position after ^syntactic-structure predicate ^exclusive @999811 @999812 @999813 @999817 ^semantic-structure predicate ^referent-type literal ^optional true)
(@999817 ^structure-type DP ^relative-position after ^syntactic-structure predicate ^exclusive @999811 @999812 @999816 ^semantic-structure predicate ^referent-type literal ^optional true)
(@999818 ^structure-type DP ^relative-position before ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999820 ^referent @101148 ^structure-type C ^converts-to CP ^prior-word C-ADJ-P ^current-word IS-V ^assigners @999821 @999822 @999823 @999824 @999825 ^construction |C-ADJ-P IS /DP/PP/C-ADJP-CONJP/RP| ^prior-word-first false ^semantic-structure action)
(@999821 ^structure-type IS-V ^syntactic-structure predicate ^required true ^semantic-structure action)
(@999842 ^before @999841 ^structure-type IS-V ^syntactic-structure nil ^required true ^semantic-structure nil)
(@999823 ^structure-type ADJ ^relative-position after ^syntactic-structure predicate ^exclusive @999824 ^semantic-structure predicate ^referent-type literal ^optional true)
(@999830 ^message-type adjective-definition ^structure-type CP ^prior-word N ^current-word IS-V ^assigners @999831 @999832 @999833 ^construction *-N-is-DP ^prior-word-first true)
(@999828 ^before @999829 ^after @999827 ^structure-type IS-V ^syntactic-structure predicate ^required true ^semantic-structure action)
(@999826 ^message-type adjective-definition ^structure-type CP ^prior-word ADJ ^current-word IS-V ^assigners @999827 @999828 @999829 ^construction *-ADJ-is-DP ^prior-word-first true)
(@999827 ^before @999828 ^structure-type ADJ ^syntactic-structure head ^required true ^semantic-structure arg1 ^referent-type literal)
(@999829 ^structure-type DP ^relative-position after ^syntactic-structure predicate ^required true ^semantic-structure property ^referent-type literal)
(@999844 ^specifier definite ^structure-type THIS ^relative-position after ^syntactic-structure head ^exclusive @999843 ^semantic-structure arg1 ^demonstrative true ^optional true)
(@999833 ^after @999832 ^structure-type DP ^syntactic-structure predicate ^required true ^semantic-structure property ^referent-type literal)
(@999831 ^before @999832 ^structure-type N ^syntactic-structure head ^required true ^semantic-structure arg1 ^referent-type literal)
(@999832 ^before @999833 ^after @999831 ^structure-type IS-V ^syntactic-structure predicate ^required true ^semantic-structure action)
(@999836 ^structure-type IS-V ^syntactic-structure predicate ^required true ^semantic-structure action)
(@999834 ^message-type what-is-question ^structure-type S ^prior-word what ^current-word IS-V ^assigners @999835 @999836 @999837 @999838 ^construction *-What-is-PP/DP-QT ^prior-word-first true)
(@999839 ^message-type predicate-question ^structure-type S ^prior-word what ^current-word N ^assigners @999840 @999841 @999842 @999843 @999844 ^construction *-What-N-is-DP-QT ^prior-word-first true)
(@999835 ^structure-type QT ^syntactic-structure terminator ^required true)
(@999837 ^structure-type PP ^relative-position after ^syntactic-structure complement2 ^exclusive @999838 ^semantic-structure relation ^optional true)
(@999838 ^structure-type DP ^relative-position after ^syntactic-structure head ^exclusive @999837 ^semantic-structure arg1 ^optional true)
(@999840 ^before @999841 @999842 ^structure-type N ^syntactic-structure predicate ^required true ^semantic-structure property ^referent-type literal)
(@999841 ^structure-type QT ^syntactic-structure terminator ^required true)
(@999856 ^structure-type DP ^syntactic-structure predicate ^exclusive @999857 @999858 @999861 ^semantic-structure predicate ^optional true)
(@999843 ^structure-type DP ^relative-position after ^syntactic-structure head ^exclusive @999844 ^semantic-structure arg1 ^optional true)
(@999845 ^message-type where-is-question ^structure-type S ^prior-word where ^current-word IS-V ^assigners @999846 @999847 @999848 ^construction *-Where-is-DP-QT ^prior-word-first true)
(@999846 ^before @999847 @999848 ^structure-type IS-V ^syntactic-structure predicate ^required true ^semantic-structure where-question)
(@999847 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999854 ^structure-type DP ^relative-position after ^syntactic-structure predicate ^exclusive @999850 @999851 ^semantic-structure predicate ^optional true)
(@999849 ^message-type object-description ^structure-type CP ^prior-word there ^current-word IS-V ^assigners @999850 @999851 @999852 @999853 @999854 ^construction *-There-is-DP/ADJ/PP ^prior-word-first true)
(@999848 ^structure-type QT ^syntactic-structure terminator ^required true)
(@999851 ^syntactic-structure complement ^exclusive @999850 @999854 ^semantic-structure arg2 ^optional true ^structrure P)
(@999850 ^structure-type ADJ ^syntactic-structure predicate ^exclusive @999851 @999854 ^semantic-structure predicate ^referent-type literal ^optional true)
(@999852 ^before @999850 @999851 @999854 ^structure-type IS-V ^syntactic-structure predicate ^required true ^semantic-structure action)
(@999853 ^structure-type ADV ^syntactic-structure adverb-modifier ^semantic-structure modifier ^referent-type literal)
(@999861 ^structure-type ADJ ^syntactic-structure predicate ^exclusive @999856 @999857 @999858 ^semantic-structure predicate ^referent-type literal ^optional true)
(@999862 ^message-type object-question ^structure-type S ^prior-word * ^current-word is ^assigners @999863 @999864 @999865 @999866 @999867 ^construction *-Is-DP-DP/ADJ/PP?)
(@999855 ^message-type object-description ^structure-type C ^converts-to CP ^prior-word there ^current-word IS-V ^assigners @999856 @999857 @999858 @999859 @999860 @999861 ^construction There-is-ADJ/DP/PP ^prior-word-first false)
(@999865 ^before @999863 @999866 @999867 ^specifier definite ^structure-type DP ^syntactic-structure head ^required true ^semantic-structure arg1 ^demonstrative true)
(@999857 ^structure-type PP ^syntactic-structure complement ^exclusive @999856 @999858 @999861 ^semantic-structure arg2 ^optional true)
(@999858 ^structure-type C-ADJ-P ^syntactic-structure predicate ^exclusive @999856 @999857 @999861 ^semantic-structure predicate ^optional true)
(@999859 ^before @999856 @999857 @999858 @999860 @999861 ^structure-type IS-V ^syntactic-structure predicate ^required true ^semantic-structure action)
(@999860 ^structure-type ADV ^syntactic-structure adverb-modifier ^semantic-structure modifier ^referent-type literal)
(@999961 ^structure-type QUANT ^syntactic-structure quantifier ^optional true)
(@999963 ^before @999964 @999965 ^structure-type ADJ ^relative-position after ^syntactic-structure adjoin ^optional true ^repeatable true)
(@999962 ^specifier universal ^structure-type D ^converts-to DP ^prior-word QUANT ^current-word the ^assigners @999961 @999963 @999964 @999965 ^number plural ^construction quant-the ^prior-word-first true false ^consumes-prior-word true ^super-converts-to CP)
(@999864 ^structure-type QT ^syntactic-structure terminator ^required true)
(@999863 ^structure-type PP ^syntactic-structure complement ^exclusive @999866 @999867 ^semantic-structure relation ^optional true)
(@999867 ^structure-type ADJ ^syntactic-structure predicate ^exclusive @999863 @999866 ^semantic-structure predicate ^referent-type literal ^optional true)
(@999866 ^structure-type DP ^syntactic-structure predicate ^exclusive @999863 @999867 ^semantic-structure predicate ^referent-type literal ^optional true)
(@999868 ^message-type object-question ^structure-type S ^prior-word IS-V ^current-word D ^assigners @999869 @999870 @999871 @999872 @999873 @999874 ^construction *-Is-DP-DP/ADJ/PP? ^prior-word-first true)
(@999870 ^after @999874 ^structure-type ADJ ^syntactic-structure predicate ^exclusive @999869 @999871 ^semantic-structure predicate ^referent-type literal ^optional true)
(@999869 ^structure-type DP ^syntactic-structure predicate ^exclusive @999870 @999871 ^semantic-structure predicate ^referent-type literal ^optional true)
(@999871 ^structure-type PP ^syntactic-structure complement ^exclusive @999869 @999870 ^semantic-structure relation ^optional true)
(@999872 ^structure-type QT ^syntactic-structure terminator ^required true)
(@999966 ^specifier universal ^structure-type D ^converts-to DP ^prior-word QUANT ^current-word your ^assigners @999967 @999968 @999969 @999970 ^number plural ^construction quant-your ^prior-word-first true false ^consumes-prior-word true)
(@999877 ^spelling |1| ^specifier indefinite ^structure-type DP ^number singular ^constraint @4011201)
(@999876 ^spelling |0| ^specifier indefinite ^structure-type DP ^number singular ^constraint @4011200)
(@999878 ^spelling |2| ^specifier indefinite ^structure-type DP ^number singular ^constraint @4011202)
(@999879 ^spelling |3| ^specifier indefinite ^structure-type DP ^number singular ^constraint @4011203)
(@999880 ^spelling |4| ^specifier indefinite ^structure-type DP ^number singular ^constraint @4011204)
(@999881 ^spelling |5| ^specifier indefinite ^structure-type DP ^number singular ^constraint @4011205)
(@999883 ^spelling |7| ^specifier indefinite ^structure-type DP ^number singular ^constraint @4011207)
(@999882 ^spelling |6| ^specifier indefinite ^structure-type DP ^number singular ^constraint @4011206)
(@999884 ^spelling |8| ^specifier indefinite ^structure-type DP ^number singular ^constraint @4011208)
(@999885 ^spelling |9| ^specifier indefinite ^structure-type DP ^number singular ^constraint @4011209)
(@999886 ^spelling |10| ^specifier indefinite ^structure-type DP ^number singular ^constraint @4011210)
(@999887 ^spelling |11| ^specifier indefinite ^structure-type DP ^number singular ^constraint @4011211)
(@999889 ^spelling |13| ^specifier indefinite ^structure-type DP ^number singular ^constraint @4011213)
(@999888 ^spelling |12| ^specifier indefinite ^structure-type DP ^number singular ^constraint @4011212)
(@999890 ^spelling |14| ^specifier indefinite ^structure-type DP ^number singular ^constraint @4011214)
(@999891 ^spelling |15| ^specifier indefinite ^structure-type DP ^number singular ^constraint @4011215)
(@999892 ^spelling |16| ^specifier indefinite ^structure-type DP ^number singular ^constraint @4011216)
(@999894 ^spelling |18| ^specifier indefinite ^structure-type DP ^number singular ^constraint @4011218)
(@999893 ^spelling |17| ^specifier indefinite ^structure-type DP ^number singular ^constraint @4011217)
(@999895 ^spelling |19| ^specifier indefinite ^structure-type DP ^number singular ^constraint @4011219)
(@999896 ^spelling |20| ^specifier indefinite ^structure-type DP ^number singular ^constraint @4011220)
(@999897 ^spelling |30| ^specifier indefinite ^structure-type DP ^number singular ^constraint @4011230)
(@999898 ^spelling |31| ^specifier indefinite ^structure-type DP ^number singular ^constraint @4011231)
(@999900 ^before @999901 ^structure-type N ^relative-position after ^syntactic-structure head ^optional true)
(@999899 ^before @999900 ^structure-type ADJ ^relative-position after ^syntactic-structure adjoin ^optional true ^repeatable true)
(@999903 ^spelling zero ^number plural ^super-type @6010000 ^constraint @4011200)
(@999901 ^structure-type PP ^relative-position after ^syntactic-structure complement ^optional true)
(@999902 ^spelling no ^number plural ^super-type @6010000 ^constraint @4011200)
(@999904 ^spelling one ^number singular ^super-type @6010000 ^constraint @4011201)
(@999905 ^spelling two ^number plural ^super-type @6010000 ^constraint @4011202)
(@999906 ^spelling three ^number singular ^super-type @6010000 ^constraint @4011203)
(@999907 ^spelling four ^number singular ^super-type @6010000 ^constraint @4011204)
(@999908 ^spelling five ^number singular ^super-type @6010000 ^constraint @4011205)
(@999909 ^spelling six ^number singular ^super-type @6010000 ^constraint @4011206)
(@999910 ^spelling seven ^number singular ^super-type @6010000 ^constraint @4011207)
(@999911 ^spelling eight ^number singular ^super-type @6010000 ^constraint @4011208)
(@999912 ^spelling nine ^number singular ^super-type @6010000 ^constraint @4011209)
(@999913 ^spelling ten ^number singular ^super-type @6010000 ^constraint @4011210)
(@999914 ^spelling eleven ^number singular ^super-type @6010000 ^constraint @4011211)
(@999915 ^spelling twelve ^number plural ^super-type @6010000 ^constraint @4011212)
(@999916 ^spelling thirteen ^number singular ^super-type @6010000 ^constraint @4011213)
(@999917 ^spelling fourteen ^number singular ^super-type @6010000 ^constraint @4011214)
(@999918 ^spelling fifteen ^number singular ^super-type @6010000 ^constraint @4011215)
(@999919 ^spelling sixteen ^number singular ^super-type @6010000 ^constraint @4011216)
(@999920 ^spelling seventeen ^number singular ^super-type @6010000 ^constraint @4011217)
(@999921 ^spelling eighteen ^number singular ^super-type @6010000 ^constraint @4011218)
(@999922 ^spelling nineteen ^number singular ^super-type @6010000 ^constraint @4011219)
(@999923 ^spelling twenty ^number singular ^super-type @6010000 ^constraint @4011220)
(@999924 ^spelling thirty ^number singular ^super-type @6010000 ^constraint @4011230)
(@999925 ^spelling thirty-one ^number singular ^super-type @6010000 ^constraint @4011231)
(@999926 ^spelling D-zero ^referent @4011200 ^structure-type ADJ ^prior-word D ^current-word zero)
(@999942 ^spelling D-sixteen ^referent @4011216 ^structure-type ADJ ^prior-word D ^current-word sixteen)
(@999927 ^spelling D-one ^referent @4011201 ^structure-type ADJ ^prior-word D ^current-word one)
(@999928 ^spelling D-two ^referent @4011202 ^structure-type ADJ ^prior-word D ^current-word two)
(@999929 ^spelling D-three ^referent @4011203 ^structure-type ADJ ^prior-word D ^current-word three)
(@999930 ^spelling D-four ^referent @4011204 ^structure-type ADJ ^prior-word D ^current-word four)
(@999931 ^spelling D-five ^referent @4011205 ^structure-type ADJ ^prior-word D ^current-word five)
(@999932 ^spelling D-six ^referent @4011206 ^structure-type ADJ ^prior-word D ^current-word six)
(@999933 ^spelling D-seven ^referent @4011207 ^structure-type ADJ ^prior-word D ^current-word seven)
(@999934 ^spelling D-eight ^referent @4011208 ^structure-type ADJ ^prior-word D ^current-word eight)
(@999935 ^spelling D-nine ^referent @4011209 ^structure-type ADJ ^prior-word D ^current-word nine)
(@999936 ^spelling D-ten ^referent @4011210 ^structure-type ADJ ^prior-word D ^current-word ten)
(@999937 ^spelling D-eleven ^referent @4011211 ^structure-type ADJ ^prior-word D ^current-word eleven)
(@999938 ^spelling D-twelve ^referent @4011212 ^structure-type ADJ ^prior-word D ^current-word twelve)
(@999939 ^spelling D-thirteen ^referent @4011213 ^structure-type ADJ ^prior-word D ^current-word thirteen)
(@999940 ^spelling D-fourteen ^referent @4011214 ^structure-type ADJ ^prior-word D ^current-word fourteen)
(@999941 ^spelling D-five ^referent @4011215 ^structure-type ADJ ^prior-word D ^current-word five)
(@999948 ^spelling first ^structure-type ADJ ^attachment immediate ^constraint @4011101)
(@999943 ^spelling D-seventeen ^referent @4011217 ^structure-type ADJ ^prior-word D ^current-word seventeen)
(@999944 ^spelling D-eighteen ^referent @4011218 ^structure-type ADJ ^prior-word D ^current-word eighteen)
(@999945 ^spelling D-nineteen ^referent @4011219 ^structure-type ADJ ^prior-word D ^current-word nineteen)
(@999946 ^spelling D-twenty ^referent @4011210 ^structure-type ADJ ^prior-word D ^current-word twenty)
(@999947 ^spelling zeroth ^number plural ^super-type @6010000 ^constraint @4011100)
(@999949 ^spelling second ^structure-type ADJ ^attachment immediate ^constraint @4011102)
(@999950 ^spelling third ^number singular ^super-type @6010000 ^constraint @4011103)
(@999951 ^spelling fourth ^number singular ^super-type @6010000 ^constraint @4011104)
(@999952 ^spelling fifth ^number singular ^super-type @6010000 ^constraint @4011105)
(@999953 ^spelling sixth ^number singular ^super-type @6010000 ^constraint @4011106)
(@999954 ^spelling seventh ^number singular ^super-type @6010000 ^constraint @4011107)
(@999955 ^spelling eighth ^number singular ^super-type @6010000 ^constraint @4011108)
(@999956 ^spelling ninth ^number singular ^super-type @6010000 ^constraint @4011109)
(@999957 ^spelling all ^referent @999958 ^specifier universal ^structure-type QUANT ^number plural ^super-converts-to CP)
(@999959 ^spelling quant-of ^specifier universal ^structure-type QUANT ^prior-word QUANT ^current-word of ^assigners @999960 ^number plural ^consumes-prior-word true ^super-converts-to CP)
(@999958 ^handle all)
(@999960 ^structure-type QUANT ^syntactic-structure quantifier ^required true)
(@999970 ^structure-type QUANT ^syntactic-structure quantifier ^optional true)
(@999971 ^specifier universal ^structure-type D ^converts-to DP ^prior-word QUANT ^current-word ADJ ^assigners @999972 @999973 @999974 @999975 ^number plural ^construction quant-ADJ ^prior-word-first true false)
(@999978 ^before @999979 ^structure-type N ^syntactic-structure head ^required true)
(@999964 ^before @999965 ^structure-type N ^relative-position after ^syntactic-structure head ^required true)
(@999965 ^structure-type PP ^relative-position after ^syntactic-structure complement ^optional true)
(@999973 ^before @999974 ^structure-type N ^relative-position after ^syntactic-structure head ^required true)
(@999975 ^structure-type QUANT ^syntactic-structure quantifier ^optional true)
(@999967 ^before @999968 @999969 ^structure-type ADJ ^relative-position after ^syntactic-structure adjoin ^optional true ^repeatable true)
(@999968 ^before @999969 ^structure-type N ^relative-position after ^syntactic-structure head ^required true)
(@999969 ^structure-type PP ^relative-position after ^syntactic-structure complement ^optional true)
(@999976 ^specifier universal ^structure-type D ^converts-to DP ^prior-word QUANT ^current-word N ^assigners @999977 @999978 @999979 ^number plural ^construction quant-N ^prior-word-first true false)
(@999979 ^structure-type PP ^relative-position after ^syntactic-structure complement ^optional true)
(@999980 ^spelling some ^referent @999981 ^specifier indefinite ^structure-type QUANT ^number plural ^super-converts-to DP)
(@999972 ^before @999973 @999974 ^structure-type ADJ ^syntactic-structure adjoin ^optional true ^repeatable true)
(@999974 ^structure-type PP ^relative-position after ^syntactic-structure complement ^optional true)
(@999981 ^handle some)
(@999982 ^handle each ^spelling each ^referent @999982 ^specifier definite ^structure-type QUANT ^number singular ^super-converts-to DP)
(@999977 ^structure-type QUANT ^syntactic-structure quantifier ^optional true)
(@999987 ^handle few)
(@1000000 ^property @999998 ^handle anyone)
(@1000001 ^spelling anyone ^referent @1000000 ^specifier indefinite ^structure-type DP ^number singular ^super-converts-to CP)
(@1000003 ^spelling someone ^referent @1000002 ^specifier indefinite ^structure-type DP ^number singular ^super-converts-to CP)
(@999988 ^spelling few ^referent @999987 ^specifier indefinite ^structure-type QUANT ^number plural ^super-converts-to DP)
(@999983 ^handle none)
(@999984 ^spelling none ^referent @999983 ^specifier indefinite ^structure-type QUANT ^number plural)
(@999985 ^spelling many ^referent @999986 ^specifier indefinite ^structure-type QUANT ^number plural ^super-converts-to DP)
(@999986 ^handle many)
(@999989 ^spelling this ^specifier definite ^structure-type DP ^number singular ^demonstrative true)
(@999993 ^structure-type DP ^prior-word this ^current-word one ^number singular ^construction adj-one ^demonstrative true)
(@999990 ^spelling that ^specifier definite ^structure-type DP ^number singular ^demonstrative true)
(@999991 ^structure-type N ^prior-word D ^current-word one ^number singular ^construction D-one ^demonstrative true)
(@999992 ^structure-type N ^prior-word ADJ ^current-word one ^number singular ^construction adj-one ^demonstrative true)
(@999995 ^spelling it ^specifier it ^structure-type DP ^number singular ^super-converts-to CP)
(@999999 ^spelling they ^specifier it ^structure-type DP ^number plural ^super-converts-to CP)
(@999994 ^spelling |;| ^structure-type SEMICOLON)
(@999998 ^type visual ^handle handle)
(@999996 ^spelling you ^referent @999997 ^specifier personal ^structure-type DP ^number singular)
(@999997 ^property @999998 ^handle rosie)
(@1000013 ^spelling righty ^referent @1000012 ^structure-type ADJ)
(@1000014 ^spelling lefty ^referent @1000015 ^structure-type ADJ)
(@1000020 ^structure-type DP ^relative-position after ^syntactic-structure predicate ^exclusive @1000019 @1000021 @1000022 @1000023 ^referent-type literal ^optional true)
(@1000011 ^referent @409001 ^structure-type ADJ)
(@1000002 ^property @999998 ^handle anyone)
(@1000006 ^relation @501003 ^spelling left ^structure-type P ^converts-to PP ^semantic-entity-type relation)
(@1000004 ^structure-type VP ^syntactic-structure predicate ^required true ^semantic-structure *copy*)
(@1000005 ^structure-type CP ^prior-word you ^current-word VP ^assigners @1000004 ^construction You-VP ^prior-word-first true false)
(@1000007 ^relation @501002 ^spelling right ^structure-type P ^converts-to PP ^semantic-entity-type relation)
(@1000008 ^relation @501002 ^spelling right-noun ^structure-type N ^prior-word the ^current-word right ^number singular ^semantic-structure relation ^consumes-prior-word false ^semantic-entity-type relation)
(@1000009 ^relation @501003 ^spelling left-noun ^structure-type N ^prior-word the ^current-word left ^number singular ^semantic-structure relation ^consumes-prior-word false ^semantic-entity-type relation)
(@1000010 ^referent @409002 ^structure-type ADJ)
(@1000046 ^spelling might ^referent @1000047 ^structure-type V-AUX)
(@1000049 ^spelling must ^referent @1000048 ^structure-type V-AUX)
(@1000016 ^structure-type RC ^converts-to RCP ^prior-word D ^current-word that ^assigners @1000017 @1000018 @1000019 @1000020 @1000021 @1000022 @1000023 @1000024 ^construction that-is-ADJ/DP/PP/VP//C-ADJP-CONJP/RP/CP ^prior-word-first false ^attachment immediate)
(@1000026 ^spelling then ^structure-type THEN)
(@1000027 ^before @1000030 @1000031 ^structure-type VP ^relative-position after ^syntactic-structure nil ^required true ^exclusive @1000029 ^delay-merge true ^semantic-structure *embed* ^embed-structure if-subclause)
(@1000017 ^structure-type IS-V ^syntactic-structure predicate ^required true)
(@1000018 ^structure-type ADV ^relative-position after ^syntactic-structure predicate ^referent-type literal ^optional true ^repeatable true)
(@1000019 ^structure-type ADJ ^relative-position after ^syntactic-structure predicate ^exclusive @1000020 @1000021 @1000022 @1000023 ^referent-type literal ^optional true)
(@1000021 ^structure-type PP ^relative-position after ^syntactic-structure predicate ^exclusive @1000019 @1000020 @1000022 @1000023 ^attachment immediately-follow ^optional true)
(@1000022 ^structure-type C-ADJ-P ^relative-position after ^syntactic-structure predicate ^exclusive @1000019 @1000020 @1000021 @1000023 ^optional true)
(@1000023 ^after @1000019 @1000020 @1000021 @1000022 ^structure-type VP ^relative-position after ^syntactic-structure complement ^exclusive @1000019 @1000020 @1000021 @1000022 ^optional true)
(@1000024 ^after @1000019 @1000020 @1000021 @1000022 @1000025 ^structure-type CONJ-C-ADJ-P ^relative-position after ^syntactic-structure conj-predicate ^optional true)
(@1000030 ^before @1000031 ^structure-type THEN ^syntactic-structure nil ^required true)
(@1000028 ^message-type conditional ^spelling if ^structure-type C ^converts-to CP ^assigners @1000027 @1000029 @1000030 @1000031 ^current-word-first true)
(@1000032 ^message-type conditional ^spelling when ^structure-type C ^converts-to CP ^assigners @1000033 @1000034 @1000035 ^current-word-first true)
(@1000029 ^before @1000030 @1000031 ^structure-type CP ^relative-position after ^syntactic-structure nil ^required true ^exclusive @1000027 ^delay-merge true ^semantic-structure *embed* ^embed-structure if-subclause)
(@1000031 ^structure-type CP ^syntactic-structure nil ^required true ^semantic-structure *embed* ^embed-structure then-subclause)
(@1000040 ^spelling V-if ^structure-type IF ^converts-to IF-CLAUSE ^prior-word V ^current-word if whether ^assigners @1000041 ^hypothetical true ^current-word-first false)
(@1000042 ^spelling can ^referent @1000043 ^structure-type V-AUX)
(@1000036 ^message-type conditional ^spelling while ^structure-type C ^converts-to CP ^assigners @1000037 @1000038 @1000039 ^current-word-first true)
(@1000033 ^before @1000034 @1000035 ^structure-type CP ^relative-position after ^syntactic-structure nil ^required true ^delay-merge true ^semantic-structure *embed* ^embed-structure when-subclause)
(@1000034 ^before @1000035 ^structure-type SEMICOLON ^syntactic-structure nil ^required true)
(@1000035 ^structure-type CP ^syntactic-structure nil ^required true ^semantic-structure *embed* ^embed-structure then-subclause)
(@1000043 ^handle can)
(@1000044 ^handle may)
(@1000037 ^before @1000038 @1000039 ^structure-type CP ^relative-position after ^syntactic-structure nil ^required true ^delay-merge true ^semantic-structure *embed* ^embed-structure while-subclause)
(@1000056 ^spelling would ^referent @1000057 ^structure-type V-AUX)
(@1000038 ^before @1000039 ^structure-type SEMICOLON ^syntactic-structure nil ^required true)
(@1000039 ^structure-type CP ^syntactic-structure nil ^required true ^semantic-structure *embed* ^embed-structure then-subclause)
(@1000045 ^spelling may ^referent @1000044 ^structure-type V-AUX)
(@1000041 ^structure-type CP ^relative-position after ^syntactic-structure nil ^required true ^semantic-structure *embed* ^embed-structure if-subclause)
(@1000053 ^handle should)
(@1000055 ^handle will)
(@1000058 ^spelling usually ^referent @1000059 ^structure-type V-AUX)
(@1000059 ^handle usually)
(@1000060 ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier ^optional true)
(@1000054 ^spelling will ^referent @1000055 ^structure-type V-AUX)
(@1000047 ^handle might)
(@1000048 ^handle must)
(@1000050 ^spelling could ^referent @1000051 ^structure-type V-AUX)
(@1000051 ^handle could)
(@1000052 ^spelling should ^referent @1000053 ^structure-type V-AUX)
(@1000061 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true ^semantic-structure arg1)
(@1000057 ^handle would)
(@1000062 ^structure-type PP ^relative-position after ^syntactic-structure complement2 ^semantic-structure arg2 ^optional true)
(@1000064 ^spelling placing ^referent @101120 ^super-type @20999)
(@1000075 ^spelling and ^structure-type CONJ ^alternative-structure CP-CONJ ^semantic-structure conjunction ^super-converts-to CONJP ^merge-delay true)
(@4011210 ^property @4011000 ^handle 10 ^item-type predicate)
(@4011211 ^property @4011000 ^handle 11 ^item-type predicate)
(@4011231 ^property @4011000 ^handle 31 ^item-type predicate)
(@1000063 ^spelling playing ^referent @101120 ^super-type @20999)
(@1000065 ^spelling moving ^referent @101101 ^super-type @20999)
(@1000066 ^before @1000067 @1000069 ^structure-type N ^relative-position after ^syntactic-structure head ^required true ^semantic-structure arg1)
(@1000071 ^spelling fewer ^referent @501025 ^structure-type C-ADJ ^converts-to C-ADJ-P ^assigners @1000070 @1000072 @1000073 ^semantic-structure relation)
(@1000067 ^before @1000069 ^structure-type THAN ^syntactic-structure nil ^required true)
(@1000068 ^spelling more ^referent @501025 ^structure-type C-ADJ ^converts-to C-ADJ-P ^assigners @1000066 @1000067 @1000069 ^semantic-structure relation)
(@1000069 ^structure-type N ^relative-position after ^syntactic-structure complement ^required true ^semantic-structure arg2)
(@1000070 ^structure-type N ^relative-position after ^syntactic-structure complement ^required true ^semantic-structure arg2)
(@1000073 ^before @1000070 ^structure-type THAN ^syntactic-structure nil ^required true)
(@1000072 ^before @1000070 @1000073 ^structure-type N ^relative-position after ^syntactic-structure head ^required true ^semantic-structure arg1)
(@1000074 ^spelling than ^structure-type THAN)
(@1000084 ^before @1000085 ^structure-type CONJ ^syntactic-structure CONJ ^required true)
(@1000076 ^spelling and ^structure-type CP-CONJ ^alternative-structure CONJ ^semantic-structure conjunction)
(@1000077 ^spelling andx ^structure-type CONJ ^semantic-structure conjunction ^super-converts-to CONJP CONJ-C-ADJ-P ^merge-delay true)
(@1000078 ^spelling andc ^structure-type CP-CONJ ^semantic-structure conjunction)
(@1000079 ^spelling plus ^structure-type CP-CONJ ^semantic-structure conjunction)
(@1000080 ^spelling but ^structure-type CONJ ^alternative-structure CP-CONJ ^semantic-structure conjunction ^super-converts-to CONJP ^merge-delay true)
(@1000081 ^spelling but ^structure-type CP-CONJ ^alternative-structure CONJ ^semantic-structure conjunction)
(@1000082 ^spelling |, and| ^structure-type CONJ ^prior-word |,| ^current-word and ^semantic-structure conjunction ^converts-to-any true ^merge-delay true)
(@1000083 ^spelling |,| ^structure-type CONJ ^semantic-structure conjunction ^converts-to-any true ^merge-delay true)
(@1000089 ^spelling CONJ-N ^structure-type CONJ-N ^converts-to CONJP ^prior-word CONJ ^current-word N ^assigners @1000087 @1000088 ^prior-word-first true false)
(@1000085 ^structure-type ADJ ^syntactic-structure predicate ^required true ^semantic-structure predicate)
(@1000086 ^spelling CONJ-ADJ ^structure-type CONJ-ADJ ^converts-to CONJP ^prior-word CONJ ^current-word ADJ ^assigners @1000084 @1000085 ^prior-word-first true false)
(@1000087 ^before @1000088 ^structure-type CONJ ^syntactic-structure CONJ ^required true)
(@1000088 ^structure-type N ^syntactic-structure head ^required true ^semantic-structure predicate)
(@1000092 ^spelling CONJ-DP ^structure-type CONJ-DP ^converts-to CONJP ^prior-word CONJ ^current-word D ^assigners @1000090 @1000091 ^prior-word-first true false)
(@1000090 ^before @1000091 ^structure-type CONJ ^syntactic-structure CONJ ^required true)
(@1000091 ^structure-type DP ^syntactic-structure head ^required true ^semantic-structure predicate)
(@1000095 ^structure-type PP ^syntactic-structure complement ^required true ^semantic-structure predicate)
(@1000096 ^structure-type C ^converts-to CP ^prior-word CP ^current-word CP-CONJ ^assigners @1000097 @1000098 @1000099 @1000100 ^construction CP-CONJ-CP ^prior-word-first true false)
(@1000093 ^spelling CONJ-PP ^structure-type CONJ-PP ^converts-to CONJP ^prior-word CONJ ^current-word P ^assigners @1000094 @1000095 ^prior-word-first true false)
(@1000094 ^before @1000095 ^structure-type CONJ ^syntactic-structure CONJ ^required true)
(@1000098 ^before @1000099 @1000100 ^structure-type CP-CONJ ^syntactic-structure CONJ ^required true)
(@1000113 ^before @1000114 @1000115 ^structure-type N ^relative-position after ^syntactic-structure head ^required true)
(@1000097 ^before @1000098 @1000099 @1000100 ^structure-type CP ^syntactic-structure sentence ^required true ^semantic-structure *embed* ^embed-structure subclause)
(@1000099 ^structure-type CP ^syntactic-structure sentence ^exclusive @1000100 ^semantic-structure *embed* ^optional true ^embed-structure subclause)
(@1000101 ^structure-type C ^converts-to CP ^prior-word CP ^current-word CONJ ^assigners @1000102 @1000103 @1000104 ^construction CP-AND-CP ^prior-word-first true false)
(@1000100 ^structure-type VP ^syntactic-structure sentence ^exclusive @1000099 ^semantic-structure *embed* ^optional true ^embed-structure subclause)
(@1000103 ^before @1000104 ^structure-type CONJ ^syntactic-structure CONJ ^required true)
(@1000102 ^before @1000103 @1000104 ^structure-type CP ^syntactic-structure sentence ^required true ^semantic-structure *embed* ^embed-structure subclause)
(@1000104 ^structure-type CP ^syntactic-structure sentence ^required true ^semantic-structure *embed* ^embed-structure subclause)
(@1000107 ^before @1000108 @1000109 ^structure-type CP-CONJ ^syntactic-structure CONJ ^required true)
(@1000105 ^structure-type C ^converts-to CP ^prior-word VP ^current-word CP-CONJ ^assigners @1000106 @1000107 @1000108 @1000109 ^construction VP-CONJ-CP ^prior-word-first true false)
(@1000106 ^before @1000107 @1000108 @1000109 ^structure-type VP ^syntactic-structure sentence ^required true ^semantic-structure *embed* ^embed-structure subclause)
(@1000108 ^structure-type CP ^syntactic-structure sentence ^exclusive @1000109 ^semantic-structure *embed* ^optional true ^embed-structure subclause)
(@1000110 ^spelling CONJ-C-ADJ-P ^structure-type CONJ-C-ADJ ^converts-to CONJ-C-ADJ-P ^prior-word CONJ ^current-word C-ADJ ^assigners @1000111 @1000112 ^prior-word-first true false)
(@1000109 ^structure-type VP ^syntactic-structure sentence ^exclusive @1000108 ^semantic-structure *embed* ^optional true ^embed-structure subclause)
(@1000112 ^structure-type C-ADJ-P ^syntactic-structure head ^required true)
(@1000111 ^before @1000112 ^structure-type CONJ ^syntactic-structure CONJ ^required true)
(@1000118 ^spelling |bob's| ^referent @4016002 ^specifier definite ^number singular ^super-type @991050)
(@4010003 ^property @4010000 ^handle inches ^item-type concept)
(@4011207 ^property @4011000 ^handle 7 ^item-type predicate)
(@1000114 ^before @1000115 ^structure-type PP ^relative-position after ^syntactic-structure complement ^optional true)
(@1000115 ^structure-type RCP ^relative-position after ^syntactic-structure complement ^optional true)
(@1000116 ^before @1000113 @1000114 @1000115 ^structure-type ADJ ^relative-position after ^syntactic-structure adjoin ^optional true ^repeatable true)
(@1000117 ^spelling |alice's| ^referent @4016001 ^specifier definite ^number singular ^super-type @991050)
(@4010000 ^type unit ^handle unit ^item-type property)
(@1000119 ^spelling |charlie's| ^referent @4016003 ^specifier definite ^number singular ^super-type @991050)
(@4010002 ^property @4010000 ^handle feet ^item-type concept)
(@4010001 ^property @4010000 ^handle meters ^item-type concept)
(@4010004 ^property @4010000 ^handle centimeters ^item-type concept)
(@4011100 ^property @4011000 ^handle zeroth1 ^item-type predicate)
(@4011000 ^type number ^handle number ^item-type property)
(@4011101 ^property @4011000 ^handle first1 ^item-type predicate)
(@4011104 ^property @4011000 ^handle fourth1 ^item-type predicate)
(@4011102 ^property @4011000 ^handle second1 ^item-type predicate)
(@4011103 ^property @4011000 ^handle third1 ^item-type predicate)
(@4011105 ^property @4011000 ^handle fifth1 ^item-type predicate)
(@4011106 ^property @4011000 ^handle sixth1 ^item-type predicate)
(@4011107 ^property @4011000 ^handle seventh1 ^item-type predicate)
(@4011108 ^property @4011000 ^handle eighth1 ^item-type predicate)
(@4011109 ^property @4011000 ^handle ninth1 ^item-type predicate)
(@4011200 ^property @4011000 ^handle 0 ^item-type predicate)
(@4011201 ^property @4011000 ^handle 1 ^item-type predicate)
(@4011202 ^property @4011000 ^handle 2 ^item-type predicate)
(@4011203 ^property @4011000 ^handle 3 ^item-type predicate)
(@4011204 ^property @4011000 ^handle 4 ^item-type predicate)
(@4011205 ^property @4011000 ^handle 5 ^item-type predicate)
(@4011206 ^property @4011000 ^handle 6 ^item-type predicate)
(@4011208 ^property @4011000 ^handle 8 ^item-type predicate)
(@4011209 ^property @4011000 ^handle 9 ^item-type predicate)
(@4011233 ^property @4011000 ^handle 33 ^item-type predicate)
(@4012001 ^property @4012000 ^handle end1 ^item-type predicate)
(@4011232 ^property @4011000 ^handle 32 ^item-type predicate)
(@4011212 ^property @4011000 ^handle 12 ^item-type predicate)
(@4011213 ^property @4011000 ^handle 13 ^item-type predicate)
(@4011214 ^property @4011000 ^handle 14 ^item-type predicate)
(@4011215 ^property @4011000 ^handle 15 ^item-type predicate)
(@4011216 ^property @4011000 ^handle 16 ^item-type predicate)
(@4011217 ^property @4011000 ^handle 17 ^item-type predicate)
(@4011218 ^property @4011000 ^handle 18 ^item-type predicate)
(@4011219 ^property @4011000 ^handle 19 ^item-type predicate)
(@4011220 ^property @4011000 ^handle 20 ^item-type predicate)
(@4011221 ^property @4011000 ^handle 21 ^item-type predicate)
(@4011222 ^property @4011000 ^handle 22 ^item-type predicate)
(@4011223 ^property @4011000 ^handle 23 ^item-type predicate)
(@4011224 ^property @4011000 ^handle 24 ^item-type predicate)
(@4011225 ^property @4011000 ^handle 25 ^item-type predicate)
(@4011226 ^property @4011000 ^handle 26 ^item-type predicate)
(@4011227 ^property @4011000 ^handle 27 ^item-type predicate)
(@4011228 ^property @4011000 ^handle 28 ^item-type predicate)
(@4011229 ^property @4011000 ^handle 29 ^item-type predicate)
(@4011230 ^property @4011000 ^handle 30 40 ^item-type predicate)
(@4012003 ^property @4012000 ^handle hall1 ^item-type predicate)
(@4012007 ^property @4012000 ^handle t-intersection1 ^item-type predicate)
(@4012002 ^property @4012000 ^handle wall1 ^item-type predicate)
(@4011234 ^property @4011000 ^handle 34 ^item-type predicate)
(@4011235 ^property @4011000 ^handle 35 ^item-type predicate)
(@4011236 ^property @4011000 ^handle 36 ^item-type predicate)
(@4011237 ^property @4011000 ^handle 37 ^item-type predicate)
(@4011238 ^property @4011000 ^handle 38 ^item-type predicate)
(@4011239 ^property @4011000 ^handle 39 ^item-type predicate)
(@4012000 ^type visual ^handle spatial-shape ^item-type property)
(@4012004 ^property @4012000 ^handle door ^item-type predicate ^output-word door)
(@4012005 ^property @4012000 ^handle intersection ^item-type predicate ^output-word intersection)
(@4012006 ^property @4012000 ^handle opening1 ^item-type predicate)
(@4012008 ^property @4012000 ^handle room1 ^item-type predicate)
(@4012009 ^property @4012000 ^handle waypoint ^item-type predicate)
(@4012010 ^multiple true ^property @4012000 ^handle door ^item-type predicate ^output-word door)
(@4012011 ^property @4012000 ^handle office1 ^item-type predicate ^style office)
(@4014000 ^type visual ^handle property ^item-type property)
(@4014100 ^type state ^handle meat1 ^item-type property)
(@4014302 ^property @4014300 ^handle last-moved1 ^item-type predicate)
(@4014001 ^property @4014000 ^handle task-completed ^item-type predicate)
(@4014202 ^property @4014200 ^handle closed2 ^item-type concept)
(@4014101 ^property @4014100 ^handle cooked1 ^item-type concept)
(@4014102 ^property @4014100 ^handle raw1 ^item-type concept)
(@4014200 ^type state ^handle door1 ^item-type property)
(@4014201 ^property @4014200 ^handle open2 ^item-type concept)
(@4014300 ^type state ^handle action1 ^item-type property)
(@4015000 ^type visual ^handle property ^item-type property)
(@4015001 ^property @4015000 ^handle task-completed ^item-type predicate)
(@4015002 ^property @4015000 ^handle won ^item-type predicate)
(@4016000 ^handle possessive ^item-type property)
(@4016001 ^property @4016000 ^handle alices1 ^item-type predicate ^person-name alice1)
(@4015003 ^property @4015000 ^handle lost ^item-type predicate)
(@4016002 ^property @4016000 ^handle bobs1 ^item-type predicate ^person-name bob1)
(@6010000 ^specifier indefinite ^structure-type CN ^converts-to DP ^assigners @999899 @999900 @999901)
(@4016003 ^property @4016000 ^handle charlies1 ^item-type predicate ^person-name charlie1)
(@4017000 ^type visual ^handle gender ^item-type property)
}

